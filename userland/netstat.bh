# netstat - Display network connections, routing tables, interface statistics
# Reads from /proc/net/tcp and /proc/net/udp

from lib.syscalls import *

def hexchar_to_int(c: uint8) -> int32:
  if c >= cast[uint8](48):
    if c <= cast[uint8](57):
      return cast[int32](c) - 48
  if c >= cast[uint8](65):
    if c <= cast[uint8](70):
      return cast[int32](c) - 65 + 10
  if c >= cast[uint8](97):
    if c <= cast[uint8](102):
      return cast[int32](c) - 97 + 10
  return 0

def int_to_char(val: int32) -> uint8:
  if val < 10:
    return cast[uint8](val + 48)
  return cast[uint8](0)

def print_hex_as_ip(hex_str: *uint8, out: *uint8):
  # Convert hex IP address (little endian) to dotted decimal
  # Example: 0100007F -> 127.0.0.1
  i: int32 = 0
  j: int32 = 0
  byte_val: int32 = 0
  octet: int32 = 0

  # Process 4 octets (8 hex chars, 2 per byte)
  while i < 8:
    byte_val = hexchar_to_int(hex_str[i]) * 16 + hexchar_to_int(hex_str[i + 1])

    # Convert byte to decimal string
    d1: int32 = byte_val / 100
    d2: int32 = (byte_val % 100) / 10
    d3: int32 = byte_val % 10

    if d1 > 0:
      out[j] = int_to_char(d1)
      j = j + 1
      out[j] = int_to_char(d2)
      j = j + 1
      out[j] = int_to_char(d3)
      j = j + 1
    if d1 == 0:
      if d2 > 0:
        out[j] = int_to_char(d2)
        j = j + 1
        out[j] = int_to_char(d3)
        j = j + 1
      if d2 == 0:
        out[j] = int_to_char(d3)
        j = j + 1

    octet = octet + 1
    if octet < 4:
      out[j] = cast[uint8](46)  # .
      j = j + 1

    i = i + 2

  out[j] = cast[uint8](0)

def print_hex_as_port(hex_str: *uint8, out: *uint8):
  # Convert hex port (4 chars) to decimal
  port: int32 = 0
  i: int32 = 0

  while i < 4:
    port = port * 16 + hexchar_to_int(hex_str[i])
    i = i + 1

  # Convert to string
  j: int32 = 0
  if port == 0:
    out[j] = cast[uint8](48)  # 0
    j = j + 1
  if port > 0:
    temp: int32 = port
    digits: int32 = 0

    # Count digits
    while temp > 0:
      digits = digits + 1
      temp = temp / 10

    # Fill from end
    j = digits
    temp = port
    while temp > 0:
      j = j - 1
      out[j] = int_to_char(temp % 10)
      temp = temp / 10

    j = digits

  out[j] = cast[uint8](0)

def parse_line(line: *uint8, local: *uint8, remote: *uint8, state: *uint8):
  # Parse format: "  sl  local_address rem_address   st tx_queue rx_queue..."
  # Skip to local address (after spaces and sl)
  i: int32 = 0
  field: int32 = 0

  # Skip initial spaces and sl field
  while line[i] == cast[uint8](32):
    i = i + 1
  while line[i] != cast[uint8](32):
    if line[i] == cast[uint8](0):
      return
    i = i + 1

  # Skip spaces to local address
  while line[i] == cast[uint8](32):
    i = i + 1

  # Parse local address (format: HEXIP:HEXPORT)
  local_start: int32 = i
  while line[i] != cast[uint8](58):  # :
    if line[i] == cast[uint8](0):
      return
    i = i + 1

  # Extract IP
  ip_buf: *uint8 = cast[*uint8](cast[int32](local) + 100)
  k: int32 = 0
  j: int32 = local_start
  while j < i:
    ip_buf[k] = line[j]
    k = k + 1
    j = j + 1
  ip_buf[k] = cast[uint8](0)

  print_hex_as_ip(ip_buf, local)

  # Add colon
  k = 0
  while local[k] != cast[uint8](0):
    k = k + 1
  local[k] = cast[uint8](58)  # :
  k = k + 1

  # Skip colon
  i = i + 1

  # Extract port
  port_buf: *uint8 = cast[*uint8](cast[int32](local) + 150)
  j = 0
  while line[i] != cast[uint8](32):
    if line[i] == cast[uint8](0):
      return
    port_buf[j] = line[i]
    j = j + 1
    i = i + 1
  port_buf[j] = cast[uint8](0)

  print_hex_as_port(port_buf, cast[*uint8](cast[int32](local) + k))

  # Skip spaces to remote address
  while line[i] == cast[uint8](32):
    i = i + 1

  # Parse remote address (same format)
  local_start = i
  while line[i] != cast[uint8](58):
    if line[i] == cast[uint8](0):
      return
    i = i + 1

  # Extract remote IP
  k = 0
  j = local_start
  while j < i:
    ip_buf[k] = line[j]
    k = k + 1
    j = j + 1
  ip_buf[k] = cast[uint8](0)

  print_hex_as_ip(ip_buf, remote)

  # Add colon
  k = 0
  while remote[k] != cast[uint8](0):
    k = k + 1
  remote[k] = cast[uint8](58)
  k = k + 1

  # Skip colon
  i = i + 1

  # Extract remote port
  j = 0
  while line[i] != cast[uint8](32):
    if line[i] == cast[uint8](0):
      return
    port_buf[j] = line[i]
    j = j + 1
    i = i + 1
  port_buf[j] = cast[uint8](0)

  print_hex_as_port(port_buf, cast[*uint8](cast[int32](remote) + k))

  # Skip spaces to state
  while line[i] == cast[uint8](32):
    i = i + 1

  # Copy state (2 hex digits)
  state[0] = line[i]
  i = i + 1
  state[1] = line[i]
  state[2] = cast[uint8](0)

def process_file(path: *uint8, proto: *uint8):
  fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return

  # Allocate buffer
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16384
  _ = syscall1(SYS_brk, new_brk)

  buffer: *uint8 = cast[*uint8](old_brk)
  line_buf: *uint8 = cast[*uint8](old_brk + 8192)
  local_buf: *uint8 = cast[*uint8](old_brk + 8192 + 512)
  remote_buf: *uint8 = cast[*uint8](old_brk + 8192 + 512 + 200)
  state_buf: *uint8 = cast[*uint8](old_brk + 8192 + 512 + 400)

  nread: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 8192)
  _ = syscall1(SYS_close, fd)

  if nread <= 0:
    return

  # Process line by line
  line_start: int32 = 0
  i: int32 = 0
  first_line: int32 = 1

  while i < nread:
    if buffer[i] == cast[uint8](10):  # newline
      # Skip first line (header)
      if first_line == 1:
        first_line = 0
        line_start = i + 1
        i = i + 1
        if i >= nread:
          return
      if first_line == 0:
        # Copy line
        j: int32 = 0
        k: int32 = line_start
        while k < i:
          line_buf[j] = buffer[k]
          j = j + 1
          k = k + 1
        line_buf[j] = cast[uint8](0)

        # Parse and print
        parse_line(line_buf, local_buf, remote_buf, state_buf)

        print(proto)
        print(cast[*uint8]("  "))
        print(local_buf)

        # Pad to 24 chars
        len: int32 = strlen(local_buf)
        while len < 24:
          print(cast[*uint8](" "))
          len = len + 1

        print(remote_buf)

        # Pad to 24 chars
        len = strlen(remote_buf)
        while len < 24:
          print(cast[*uint8](" "))
          len = len + 1

        print(state_buf)
        print(cast[*uint8]("\n"))

        line_start = i + 1

    i = i + 1

def main():
  # Allocate memory for paths
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 1024
  _ = syscall1(SYS_brk, new_brk)

  tcp_path: *uint8 = cast[*uint8](old_brk)
  udp_path: *uint8 = cast[*uint8](old_brk + 256)
  tcp_label: *uint8 = cast[*uint8](old_brk + 512)
  udp_label: *uint8 = cast[*uint8](old_brk + 520)

  # Build /proc/net/tcp
  tcp_path[0] = cast[uint8](47)   # /
  tcp_path[1] = cast[uint8](112)  # p
  tcp_path[2] = cast[uint8](114)  # r
  tcp_path[3] = cast[uint8](111)  # o
  tcp_path[4] = cast[uint8](99)   # c
  tcp_path[5] = cast[uint8](47)   # /
  tcp_path[6] = cast[uint8](110)  # n
  tcp_path[7] = cast[uint8](101)  # e
  tcp_path[8] = cast[uint8](116)  # t
  tcp_path[9] = cast[uint8](47)   # /
  tcp_path[10] = cast[uint8](116) # t
  tcp_path[11] = cast[uint8](99)  # c
  tcp_path[12] = cast[uint8](112) # p
  tcp_path[13] = cast[uint8](0)

  # Build /proc/net/udp
  udp_path[0] = cast[uint8](47)   # /
  udp_path[1] = cast[uint8](112)  # p
  udp_path[2] = cast[uint8](114)  # r
  udp_path[3] = cast[uint8](111)  # o
  udp_path[4] = cast[uint8](99)   # c
  udp_path[5] = cast[uint8](47)   # /
  udp_path[6] = cast[uint8](110)  # n
  udp_path[7] = cast[uint8](101)  # e
  udp_path[8] = cast[uint8](116)  # t
  udp_path[9] = cast[uint8](47)   # /
  udp_path[10] = cast[uint8](117) # u
  udp_path[11] = cast[uint8](100) # d
  udp_path[12] = cast[uint8](112) # p
  udp_path[13] = cast[uint8](0)

  # Build labels
  tcp_label[0] = cast[uint8](116) # t
  tcp_label[1] = cast[uint8](99)  # c
  tcp_label[2] = cast[uint8](112) # p
  tcp_label[3] = cast[uint8](0)

  udp_label[0] = cast[uint8](117) # u
  udp_label[1] = cast[uint8](100) # d
  udp_label[2] = cast[uint8](112) # p
  udp_label[3] = cast[uint8](0)

  # Print header
  print(cast[*uint8]("Proto Local Address          Foreign Address        State\n"))

  # Process TCP connections
  process_file(tcp_path, tcp_label)

  # Process UDP connections
  process_file(udp_path, udp_label)

  _ = syscall1(SYS_exit, 0)
