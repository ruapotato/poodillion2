# watch.bh - Execute a program periodically
# Usage: watch [-n seconds] command [args...]
#
# Options:
#   -n SEC   Refresh interval in seconds (default: 2)
#   -t       Turn off header
#   -h       Show help
#
# Examples:
#   watch ls             Run 'ls' every 2 seconds
#   watch -n 5 ps        Run 'ps' every 5 seconds
#   watch df -h          Run 'df -h' every 2 seconds

from lib.syscalls import *

opt_interval: int32 = 2
opt_no_header: int32 = 0

def show_usage():
  println(cast[*uint8]("Usage: watch [-n sec] [-t] command [args...]"))
  println(cast[*uint8](""))
  println(cast[*uint8]("Execute a program periodically, showing output."))
  println(cast[*uint8](""))
  println(cast[*uint8]("Options:"))
  println(cast[*uint8]("  -n SEC   Refresh interval in seconds (default: 2)"))
  println(cast[*uint8]("  -t       Turn off the header"))
  println(cast[*uint8]("  -h       Display this help"))

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= 48 and s[i] <= 57:
    result = result * 10 + (cast[int32](s[i]) - 48)
    i = i + 1
  return result

def clear_screen():
  # ANSI escape sequence to clear screen and move cursor to top-left
  print(cast[*uint8]("\x1B[2J\x1B[H"))

def print_header(cmd: *uint8):
  if opt_no_header == 1:
    return

  print(cast[*uint8]("Every "))
  print_int(opt_interval)
  print(cast[*uint8]("s: "))
  println(cmd)
  println(cast[*uint8](""))

def run_command(argc: int32, argv: Ptr[Ptr[uint8]], cmd_start: int32):
  # Build command string
  cmd: array[1024, uint8]
  pos: int32 = 0
  i: int32 = cmd_start

  while i < argc:
    arg: *uint8 = argv[i]
    j: int32 = 0
    while arg[j] != 0 and pos < 1020:
      cmd[pos] = arg[j]
      pos = pos + 1
      j = j + 1

    if i + 1 < argc and pos < 1020:
      cmd[pos] = 32  # space
      pos = pos + 1
    i = i + 1

  cmd[pos] = 0

  # Fork and exec
  pid: int32 = fork_proc()

  if pid == 0:
    # Child process - execute the command via shell
    shell_argv: array[4, *uint8]
    shell_argv[0] = cast[*uint8]("/bin/bsh")
    shell_argv[1] = cast[*uint8]("-c")
    shell_argv[2] = addr(cmd[0])
    shell_argv[3] = cast[*uint8](0)

    execve(cast[*uint8]("/bin/bsh"), addr(shell_argv[0]), cast[Ptr[Ptr[uint8]]](0))
    exit(1)
  elif pid > 0:
    # Parent - wait for child
    status: int32 = 0
    waitpid(pid, addr(status), 0)

  clear_screen()
  print_header(addr(cmd[0]))

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
  cmd_start: int32 = 1
  i: int32 = 1

  # Parse options
  while i < argc:
    arg: *uint8 = argv[i]

    if arg[0] == 45:  # '-'
      if arg[1] == 110 and arg[2] == 0:  # -n
        i = i + 1
        if i >= argc:
          println(cast[*uint8]("watch: -n requires argument"))
          return 1
        opt_interval = parse_int(argv[i])
        if opt_interval < 1:
          opt_interval = 1
        cmd_start = i + 1
      elif arg[1] == 116 and arg[2] == 0:  # -t
        opt_no_header = 1
        cmd_start = i + 1
      elif arg[1] == 104 and arg[2] == 0:  # -h
        show_usage()
        return 0
      else:
        # Unknown option - might be part of command
        break
    else:
      break

    i = i + 1

  if cmd_start >= argc:
    println(cast[*uint8]("watch: no command specified"))
    show_usage()
    return 1

  # Build initial command string for header
  cmd_str: array[1024, uint8]
  pos: int32 = 0
  i = cmd_start
  while i < argc:
    arg: *uint8 = argv[i]
    j: int32 = 0
    while arg[j] != 0 and pos < 1020:
      cmd_str[pos] = arg[j]
      pos = pos + 1
      j = j + 1
    if i + 1 < argc and pos < 1020:
      cmd_str[pos] = 32
      pos = pos + 1
    i = i + 1
  cmd_str[pos] = 0

  # Main loop
  while 1:
    clear_screen()
    print_header(addr(cmd_str[0]))

    # Fork and exec
    pid: int32 = fork_proc()

    if pid == 0:
      # Child process
      shell_argv: array[4, *uint8]
      shell_argv[0] = cast[*uint8]("/bin/bsh")
      shell_argv[1] = cast[*uint8]("-c")
      shell_argv[2] = addr(cmd_str[0])
      shell_argv[3] = cast[*uint8](0)

      execve(cast[*uint8]("/bin/bsh"), addr(shell_argv[0]), cast[Ptr[Ptr[uint8]]](0))
      exit(1)
    elif pid > 0:
      # Parent - wait for child
      status: int32 = 0
      waitpid(pid, addr(status), 0)

    # Sleep for interval using nanosleep syscall
    timespec: array[2, int32]
    timespec[0] = opt_interval  # seconds
    timespec[1] = 0             # nanoseconds
    syscall2(SYS_nanosleep, cast[int32](addr(timespec[0])), 0)

  return 0
