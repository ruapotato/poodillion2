# logger.bh - Log messages to system log
# Usage: logger [options] [message]
#
# Write messages to the system log file (/var/log/messages).
#
# Options:
#   -t TAG     Use TAG as the log tag
#   -p PRI     Specify priority (default: info)
#   -f FILE    Log to FILE instead of /var/log/messages
#   -s         Also output to standard error
#   -h         Show help
#
# Priorities: emerg, alert, crit, err, warning, notice, info, debug
#
# Examples:
#   logger "System started"
#   logger -t myapp "Application started"
#   logger -p warning "Low disk space"

from lib.syscalls import *

tag: array[64, uint8]
priority: array[16, uint8]
log_file: array[256, uint8]
also_stderr: int32 = 0

def init_defaults():
    # Default tag is "user"
    tag[0] = 117  # u
    tag[1] = 115  # s
    tag[2] = 101  # e
    tag[3] = 114  # r
    tag[4] = 0

    # Default priority is "info"
    priority[0] = 105  # i
    priority[1] = 110  # n
    priority[2] = 102  # f
    priority[3] = 111  # o
    priority[4] = 0

    # Default log file
    logpath: *uint8 = cast[*uint8]("/var/log/messages")
    i: int32 = 0
    while logpath[i] != 0 and i < 255:
        log_file[i] = logpath[i]
        i = i + 1
    log_file[i] = 0

def copy_string(src: *uint8, dst: *uint8, max_len: int32):
    i: int32 = 0
    while src[i] != 0 and i < max_len - 1:
        dst[i] = src[i]
        i = i + 1
    dst[i] = 0

def show_usage():
    println(cast[*uint8]("Usage: logger [OPTIONS] [MESSAGE]"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Write messages to the system log."))
    println(cast[*uint8](""))
    println(cast[*uint8]("Options:"))
    println(cast[*uint8]("  -t TAG     Use TAG as the log tag"))
    println(cast[*uint8]("  -p PRI     Specify priority (info, warning, error, etc.)"))
    println(cast[*uint8]("  -f FILE    Log to FILE instead of /var/log/messages"))
    println(cast[*uint8]("  -s         Also output to standard error"))
    println(cast[*uint8]("  -h         Display this help"))

def write_log(message: *uint8):
    # Build log line: [timestamp] TAG: MESSAGE\n
    line: array[1024, uint8]
    pos: int32 = 0

    # Add timestamp placeholder [TIMESTAMP]
    ts: *uint8 = cast[*uint8]("[")
    i: int32 = 0
    while ts[i] != 0 and pos < 1000:
        line[pos] = ts[i]
        pos = pos + 1
        i = i + 1

    # Get time if available
    time_buf: array[2, int32]
    result: int32 = syscall2(SYS_gettimeofday, cast[int32](addr(time_buf[0])), 0)
    if result >= 0:
        # Print seconds since epoch (simple)
        secs: int32 = time_buf[0]
        tmp: array[16, uint8]
        ti: int32 = 0

        if secs == 0:
            tmp[ti] = 48
            ti = ti + 1
        else:
            while secs > 0:
                tmp[ti] = cast[uint8](48 + secs % 10)
                secs = secs / 10
                ti = ti + 1

        while ti > 0:
            ti = ti - 1
            line[pos] = tmp[ti]
            pos = pos + 1
    else:
        # Fallback
        unk: *uint8 = cast[*uint8]("unknown")
        i = 0
        while unk[i] != 0:
            line[pos] = unk[i]
            pos = pos + 1
            i = i + 1

    line[pos] = 93  # ']'
    pos = pos + 1
    line[pos] = 32  # space
    pos = pos + 1

    # Add priority
    i = 0
    while priority[i] != 0 and pos < 1000:
        line[pos] = priority[i]
        pos = pos + 1
        i = i + 1

    line[pos] = 32  # space
    pos = pos + 1

    # Add tag
    i = 0
    while tag[i] != 0 and pos < 1000:
        line[pos] = tag[i]
        pos = pos + 1
        i = i + 1

    line[pos] = 58  # ':'
    pos = pos + 1
    line[pos] = 32  # space
    pos = pos + 1

    # Add message
    i = 0
    while message[i] != 0 and pos < 1020:
        line[pos] = message[i]
        pos = pos + 1
        i = i + 1

    line[pos] = 10  # newline
    pos = pos + 1
    line[pos] = 0

    # Write to log file (append mode)
    fd: int32 = open(addr(log_file[0]), O_WRONLY or O_CREAT or O_APPEND)
    if fd >= 0:
        _ = write(fd, addr(line[0]), pos)
        close(fd)
    else:
        # Try creating parent directory
        print(cast[*uint8]("logger: cannot open "))
        println(addr(log_file[0]))

    # Also write to stderr if requested
    if also_stderr != 0:
        _ = write(STDERR, addr(line[0]), pos)

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
    init_defaults()

    msg_start: int32 = 0
    i: int32 = 1

    while i < argc:
        arg: *uint8 = argv[i]

        if arg[0] == 45:  # '-'
            if arg[1] == 116 and arg[2] == 0:  # -t
                i = i + 1
                if i < argc:
                    copy_string(argv[i], addr(tag[0]), 64)
            elif arg[1] == 112 and arg[2] == 0:  # -p
                i = i + 1
                if i < argc:
                    copy_string(argv[i], addr(priority[0]), 16)
            elif arg[1] == 102 and arg[2] == 0:  # -f
                i = i + 1
                if i < argc:
                    copy_string(argv[i], addr(log_file[0]), 256)
            elif arg[1] == 115 and arg[2] == 0:  # -s
                also_stderr = 1
            elif arg[1] == 104 and arg[2] == 0:  # -h
                show_usage()
                return 0
            else:
                # Unknown option
                if msg_start == 0:
                    msg_start = i
        else:
            if msg_start == 0:
                msg_start = i

        i = i + 1

    if msg_start == 0:
        # No message provided, read from stdin
        buf: array[1024, uint8]
        n: int32 = read(STDIN, addr(buf[0]), 1023)
        if n > 0:
            # Remove trailing newline
            if buf[n - 1] == 10:
                n = n - 1
            buf[n] = 0
            write_log(addr(buf[0]))
    else:
        # Concatenate remaining arguments as message
        msg: array[1024, uint8]
        pos: int32 = 0

        i = msg_start
        while i < argc:
            arg: *uint8 = argv[i]

            # Skip options that might be in the middle
            if arg[0] != 45 or (arg[0] == 45 and arg[1] == 0):
                j: int32 = 0
                while arg[j] != 0 and pos < 1020:
                    msg[pos] = arg[j]
                    pos = pos + 1
                    j = j + 1

                if i + 1 < argc and pos < 1020:
                    msg[pos] = 32  # space
                    pos = pos + 1

            i = i + 1

        msg[pos] = 0
        write_log(addr(msg[0]))

    return 0
