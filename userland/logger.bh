# logger.bh - Log messages to system log
# Usage: logger [options] [message]
#
# Write messages to the system log file (/var/log/messages).
#
# Options:
#   -t TAG     Use TAG as the log tag
#   -p PRI     Specify priority (default: info)
#   -f FILE    Log to FILE instead of /var/log/messages
#   -s         Also output to standard error
#   -h         Show help
#
# Priorities: emerg, alert, crit, err, warning, notice, info, debug
#
# Examples:
#   logger "System started"
#   logger -t myapp "Application started"
#   logger -p warning "Low disk space"

import "lib/syscalls"

var tag: array[64, uint8]
var priority: array[16, uint8]
var log_file: array[256, uint8]
var also_stderr: int32 = 0

proc init_defaults() =
  # Default tag is "user"
  tag[0] = 117  # u
  tag[1] = 115  # s
  tag[2] = 101  # e
  tag[3] = 114  # r
  tag[4] = 0

  # Default priority is "info"
  priority[0] = 105  # i
  priority[1] = 110  # n
  priority[2] = 102  # f
  priority[3] = 111  # o
  priority[4] = 0

  # Default log file
  var logpath: ptr uint8 = cast[ptr uint8]("/var/log/messages")
  var i: int32 = 0
  while logpath[i] != 0 and i < 255:
    log_file[i] = logpath[i]
    i = i + 1
  log_file[i] = 0

proc copy_string(src: ptr uint8, dst: ptr uint8, max_len: int32) =
  var i: int32 = 0
  while src[i] != 0 and i < max_len - 1:
    dst[i] = src[i]
    i = i + 1
  dst[i] = 0

proc show_usage() =
  println(cast[ptr uint8]("Usage: logger [OPTIONS] [MESSAGE]"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Write messages to the system log."))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Options:"))
  println(cast[ptr uint8]("  -t TAG     Use TAG as the log tag"))
  println(cast[ptr uint8]("  -p PRI     Specify priority (info, warning, error, etc.)"))
  println(cast[ptr uint8]("  -f FILE    Log to FILE instead of /var/log/messages"))
  println(cast[ptr uint8]("  -s         Also output to standard error"))
  println(cast[ptr uint8]("  -h         Display this help"))

proc write_log(message: ptr uint8) =
  # Build log line: [timestamp] TAG: MESSAGE\n
  var line: array[1024, uint8]
  var pos: int32 = 0

  # Add timestamp placeholder [TIMESTAMP]
  var ts: ptr uint8 = cast[ptr uint8]("[")
  var i: int32 = 0
  while ts[i] != 0 and pos < 1000:
    line[pos] = ts[i]
    pos = pos + 1
    i = i + 1

  # Get time if available
  var time_buf: array[2, int32]
  var result: int32 = syscall2(SYS_gettimeofday, cast[int32](addr(time_buf[0])), 0)
  if result >= 0:
    # Print seconds since epoch (simple)
    var secs: int32 = time_buf[0]
    var tmp: array[16, uint8]
    var ti: int32 = 0

    if secs == 0:
      tmp[ti] = 48
      ti = ti + 1
    else:
      while secs > 0:
        tmp[ti] = cast[uint8](48 + secs % 10)
        secs = secs / 10
        ti = ti + 1

    while ti > 0:
      ti = ti - 1
      line[pos] = tmp[ti]
      pos = pos + 1
  else:
    # Fallback
    var unk: ptr uint8 = cast[ptr uint8]("unknown")
    i = 0
    while unk[i] != 0:
      line[pos] = unk[i]
      pos = pos + 1
      i = i + 1

  line[pos] = 93  # ']'
  pos = pos + 1
  line[pos] = 32  # space
  pos = pos + 1

  # Add priority
  i = 0
  while priority[i] != 0 and pos < 1000:
    line[pos] = priority[i]
    pos = pos + 1
    i = i + 1

  line[pos] = 32  # space
  pos = pos + 1

  # Add tag
  i = 0
  while tag[i] != 0 and pos < 1000:
    line[pos] = tag[i]
    pos = pos + 1
    i = i + 1

  line[pos] = 58  # ':'
  pos = pos + 1
  line[pos] = 32  # space
  pos = pos + 1

  # Add message
  i = 0
  while message[i] != 0 and pos < 1020:
    line[pos] = message[i]
    pos = pos + 1
    i = i + 1

  line[pos] = 10  # newline
  pos = pos + 1
  line[pos] = 0

  # Write to log file (append mode)
  var fd: int32 = open(addr(log_file[0]), O_WRONLY or O_CREAT or O_APPEND)
  if fd >= 0:
    discard write(fd, addr(line[0]), pos)
    close(fd)
  else:
    # Try creating parent directory
    print(cast[ptr uint8]("logger: cannot open "))
    println(addr(log_file[0]))

  # Also write to stderr if requested
  if also_stderr != 0:
    discard write(STDERR, addr(line[0]), pos)

proc main(argc: int32, argv: ptr ptr uint8): int32 =
  init_defaults()

  var msg_start: int32 = 0
  var i: int32 = 1

  while i < argc:
    var arg: ptr uint8 = argv[i]

    if arg[0] == 45:  # '-'
      if arg[1] == 116 and arg[2] == 0:  # -t
        i = i + 1
        if i < argc:
          copy_string(argv[i], addr(tag[0]), 64)
      elif arg[1] == 112 and arg[2] == 0:  # -p
        i = i + 1
        if i < argc:
          copy_string(argv[i], addr(priority[0]), 16)
      elif arg[1] == 102 and arg[2] == 0:  # -f
        i = i + 1
        if i < argc:
          copy_string(argv[i], addr(log_file[0]), 256)
      elif arg[1] == 115 and arg[2] == 0:  # -s
        also_stderr = 1
      elif arg[1] == 104 and arg[2] == 0:  # -h
        show_usage()
        return 0
      else:
        # Unknown option
        if msg_start == 0:
          msg_start = i
    else:
      if msg_start == 0:
        msg_start = i

    i = i + 1

  if msg_start == 0:
    # No message provided, read from stdin
    var buf: array[1024, uint8]
    var n: int32 = read(STDIN, addr(buf[0]), 1023)
    if n > 0:
      # Remove trailing newline
      if buf[n - 1] == 10:
        n = n - 1
      buf[n] = 0
      write_log(addr(buf[0]))
  else:
    # Concatenate remaining arguments as message
    var msg: array[1024, uint8]
    var pos: int32 = 0

    i = msg_start
    while i < argc:
      var arg: ptr uint8 = argv[i]

      # Skip options that might be in the middle
      if arg[0] != 45 or (arg[0] == 45 and arg[1] == 0):
        var j: int32 = 0
        while arg[j] != 0 and pos < 1020:
          msg[pos] = arg[j]
          pos = pos + 1
          j = j + 1

        if i + 1 < argc and pos < 1020:
          msg[pos] = 32  # space
          pos = pos + 1

      i = i + 1

    msg[pos] = 0
    write_log(addr(msg[0]))

  return 0
