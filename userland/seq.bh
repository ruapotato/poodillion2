# seq - print sequence of numbers
# Usage: seq END          -> print 1 to END
#        seq START END    -> print START to END
# Part of BrainhairOS text utilities

const SYS_write: int32 = 4
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45

const STDOUT: int32 = 1
const STDERR: int32 = 2

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

proc strlen(s: ptr uint8): int32 =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    i = i + 1
  return i

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Parse integer from string
proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  var is_negative: int32 = 0

  # Check for negative sign
  if s[0] == cast[uint8](45):  # '-'
    is_negative = 1
    i = 1

  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1

  if is_negative != 0:
    result = 0 - result

  return result

# Convert int to string and print
proc print_int(n: int32) =
  # Handle negative
  var num: int32 = n
  if num < 0:
    discard syscall3(SYS_write, STDOUT, cast[int32]("-"), 1)
    num = 0 - num

  # Handle 0 case
  if num == 0:
    discard syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
    return

  # Allocate small buffer for digits
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 32
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)

  var i: int32 = 0

  # Build string in reverse
  while num > 0:
    var digit: int32 = num % 10
    buffer[i] = cast[uint8](48 + digit)
    num = num / 10
    i = i + 1

  # Print in reverse order (correct direction)
  var j: int32 = i - 1
  while j >= 0:
    discard syscall3(SYS_write, STDOUT, cast[int32](buffer + j), 1)
    j = j - 1

proc main() =
  var argc: int32 = get_argc()
  var start: int32
  var end: int32

  if argc < 2:
    print_err(cast[ptr uint8]("seq: missing operand\n"))
    discard syscall1(SYS_exit, 1)

  # Parse arguments
  if argc == 2:
    # seq END -> print 1 to END
    start = 1
    end = parse_int(get_argv(1))
  else:
    # seq START END
    start = parse_int(get_argv(1))
    end = parse_int(get_argv(2))

  # Print sequence
  if start <= end:
    # Ascending sequence
    var i: int32 = start
    while i <= end:
      print_int(i)
      discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      i = i + 1
  else:
    # Descending sequence
    var i: int32 = start
    while i >= end:
      print_int(i)
      discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      i = i - 1

  discard syscall1(SYS_exit, 0)
