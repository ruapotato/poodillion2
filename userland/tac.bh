# tac.bh - Concatenate and print files in reverse
# Usage: tac [file...]
#
# Print files in reverse line order (last line first).
# With no FILE, or when FILE is -, read standard input.
#
# Examples:
#   tac file.txt           Print file.txt in reverse
#   tac file1.txt file2.txt
#   cat file.txt | tac

from lib.syscalls import *

const MAX_LINES: int32 = 8192
const MAX_FILE_SIZE: int32 = 262144  # 256KB

line_starts: array[8192, int32]
line_count: int32 = 0
file_buf: *uint8 = cast[*uint8](0)
file_size: int32 = 0

def allocate_buffer():
  if file_buf == cast[*uint8](0):
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + MAX_FILE_SIZE
    syscall1(SYS_brk, new_brk)
    file_buf = cast[*uint8](old_brk)

def find_lines():
  line_count = 0

  if file_size == 0:
    return

  # First line starts at 0
  line_starts[line_count] = 0
  line_count = 1

  i: int32 = 0
  while i < file_size:
    if file_buf[i] == 10:  # newline
      # Next line starts after this newline
      if i + 1 < file_size and line_count < MAX_LINES:
        line_starts[line_count] = i + 1
        line_count = line_count + 1
    i = i + 1

def print_lines_reverse():
  i: int32 = line_count - 1
  while i >= 0:
    start: int32 = line_starts[i]
    end_pos: int32 = file_size

    # Find end of this line
    if i + 1 < line_count:
      end_pos = line_starts[i + 1] - 1  # Exclude the newline
    else:
      # Last line - check if ends with newline
      if file_size > 0 and file_buf[file_size - 1] == 10:
        end_pos = file_size - 1

    # Print line content
    len: int32 = end_pos - start
    if len > 0:
      write(STDOUT, addr(file_buf[start]), len)
    println(cast[*uint8](""))

    i = i - 1

def process_fd(fd: int32) -> int32:
  allocate_buffer()
  file_size = 0

  # Read file into buffer
  while file_size < MAX_FILE_SIZE:
    n: int32 = read(fd, addr(file_buf[file_size]), MAX_FILE_SIZE - file_size)
    if n <= 0:
      break
    file_size = file_size + n

  # Find line boundaries
  find_lines()

  # Print in reverse
  print_lines_reverse()

  return 0

def process_file(filename: *uint8) -> int32:
  # Check for stdin marker
  if filename[0] == 45 and filename[1] == 0:  # "-"
    return process_fd(STDIN)

  fd: int32 = open(filename, O_RDONLY)
  if fd < 0:
    print(cast[*uint8]("tac: "))
    print(filename)
    println(cast[*uint8](": No such file or directory"))
    return 1

  result: int32 = process_fd(fd)
  close(fd)
  return result

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
  if argc == 1:
    # No args - read stdin
    return process_fd(STDIN)

  result: int32 = 0
  i: int32 = 1

  while i < argc:
    r: int32 = process_file(argv[i])
    if r != 0:
      result = r
    i = i + 1

  return result
