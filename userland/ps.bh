# ps - List processes
# Default: human-readable text output
# -b flag: binary PSCH format for pipelines
# Schema: pid(4) + ppid(4) + state(1) + pad(3) + rss(4) + name(32) = 48 bytes/record

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# Print number with padding
def print_num_pad(n: int32, width: int32):
  # First calculate number of digits
  temp: int32 = n
  digits: int32 = 0
  if n == 0:
    digits = 1
  else:
    if n < 0:
      temp = 0 - n
    while temp > 0:
      digits = digits + 1
      temp = temp / 10

  # Print padding spaces
  pad: int32 = width - digits
  if n < 0:
    pad = pad - 1
  while pad > 0:
    print(" ")
    pad = pad - 1

  # Print the number
  print_int(n)

def is_numeric(s: *uint8) -> int32:
  i: int32 = 0
  if s[0] == cast[uint8](0):
    return 0
  while s[i] != cast[uint8](0):
    if s[i] < cast[uint8](48):
      return 0
    if s[i] > cast[uint8](57):
      return 0
    i = i + 1
  return 1

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] == cast[uint8](32):
    i = i + 1
  neg: int32 = 0
  if s[i] == cast[uint8](45):
    neg = 1
    i = i + 1
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  if neg == 1:
    result = 0 - result
  return result

def build_stat_path(path: *uint8, pid_str: *uint8):
  # Build "/proc/{pid}/stat"
  path[0] = cast[uint8](47)   # /
  path[1] = cast[uint8](112)  # p
  path[2] = cast[uint8](114)  # r
  path[3] = cast[uint8](111)  # o
  path[4] = cast[uint8](99)   # c
  path[5] = cast[uint8](47)   # /
  pos: int32 = 6
  i: int32 = 0
  while pid_str[i] != cast[uint8](0):
    path[pos] = pid_str[i]
    pos = pos + 1
    i = i + 1
  path[pos] = cast[uint8](47)      # /
  path[pos + 1] = cast[uint8](115) # s
  path[pos + 2] = cast[uint8](116) # t
  path[pos + 3] = cast[uint8](97)  # a
  path[pos + 4] = cast[uint8](116) # t
  path[pos + 5] = cast[uint8](0)

const RECORD_SIZE: int32 = 48
const NAME_SIZE: int32 = 32

def main() -> int32:
  argc: int32 = get_argc()
  binary_mode: int32 = 0

  i: int32 = 1
  while i < argc:
    arg: *uint8 = get_argv(i)
    if arg[0] == cast[uint8](45):
      j: int32 = 1
      while arg[j] != cast[uint8](0):
        if arg[j] == cast[uint8](98):
          binary_mode = 1
        j = j + 1
    i = i + 1

  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 131072
  _ = syscall1(SYS_brk, new_brk)

  dent_buf: *uint8 = cast[*uint8](old_brk)
  out_buf: *uint8 = cast[*uint8](old_brk + 8192)
  stat_buf: *uint8 = cast[*uint8](old_brk + 73728)
  path_buf: *uint8 = cast[*uint8](old_brk + 77824)

  # For text mode, store process info
  pids: *int32 = cast[*int32](old_brk + 78080)
  ppids: *int32 = cast[*int32](old_brk + 82176)
  states: *uint8 = cast[*uint8](old_brk + 86272)
  rsss: *int32 = cast[*int32](old_brk + 90368)
  names: *uint8 = cast[*uint8](old_brk + 94464)

  # Build "/proc"
  path_buf[0] = cast[uint8](47)
  path_buf[1] = cast[uint8](112)
  path_buf[2] = cast[uint8](114)
  path_buf[3] = cast[uint8](111)
  path_buf[4] = cast[uint8](99)
  path_buf[5] = cast[uint8](0)

  proc_fd: int32 = open(path_buf, O_RDONLY | O_DIRECTORY, 0)
  if proc_fd < 0:
    perror("ps: cannot open /proc")
    return 1

  record_count: int32 = 0
  out_pos: int32 = 0
  names_pos: int32 = 0

  nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  while nread > 0:
    pos: int32 = 0
    while pos < nread:
      reclen_ptr: *uint16 = cast[*uint16](cast[int32](dent_buf) + pos + 16)
      reclen: int32 = cast[int32](reclen_ptr[0])
      d_name: *uint8 = cast[*uint8](cast[int32](dent_buf) + pos + 19)

      if is_numeric(d_name) == 1:
        build_stat_path(path_buf, d_name)

        stat_fd: int32 = open(path_buf, O_RDONLY, 0)
        if stat_fd >= 0:
          stat_len: int32 = read(stat_fd, stat_buf, 4095)
          _ = close(stat_fd)

          if stat_len > 0:
            stat_buf[stat_len] = cast[uint8](0)

            pid: int32 = parse_int(stat_buf)

            comm_start: int32 = 0
            i = 0
            while stat_buf[i] != cast[uint8](0):
              if stat_buf[i] == cast[uint8](40):
                comm_start = i + 1
                break
              i = i + 1

            comm_end: int32 = comm_start
            last_paren: int32 = comm_start
            while stat_buf[comm_end] != cast[uint8](0):
              if stat_buf[comm_end] == cast[uint8](41):
                last_paren = comm_end
              comm_end = comm_end + 1
            comm_end = last_paren

            state_pos: int32 = comm_end + 2
            state: uint8 = stat_buf[state_pos]

            field_pos: int32 = state_pos + 2
            ppid: int32 = parse_int(cast[*uint8](cast[int32](stat_buf) + field_pos))

            field_num: int32 = 4
            i = field_pos
            while field_num < 24:
              if stat_buf[i] == cast[uint8](32):
                field_num = field_num + 1
              i = i + 1
              if stat_buf[i] == cast[uint8](0):
                break
            rss: int32 = parse_int(cast[*uint8](cast[int32](stat_buf) + i))
            rss = rss * 4

            if binary_mode != 0:
              rec: *uint8 = cast[*uint8](cast[int32](out_buf) + out_pos)
              j: int32 = 0
              while j < RECORD_SIZE:
                rec[j] = cast[uint8](0)
                j = j + 1
              pid_ptr: *int32 = cast[*int32](rec)
              pid_ptr[0] = pid
              ppid_ptr: *int32 = cast[*int32](cast[int32](rec) + 4)
              ppid_ptr[0] = ppid
              rec[8] = state
              rss_ptr: *int32 = cast[*int32](cast[int32](rec) + 12)
              rss_ptr[0] = rss
              name_len: int32 = comm_end - comm_start
              if name_len > NAME_SIZE - 1:
                name_len = NAME_SIZE - 1
              j = 0
              while j < name_len:
                rec[16 + j] = stat_buf[comm_start + j]
                j = j + 1
              out_pos = out_pos + RECORD_SIZE
            else:
              # Text mode - store info
              pids[record_count] = pid
              ppids[record_count] = ppid
              states[record_count] = state
              rsss[record_count] = rss

              # Copy name
              name_len: int32 = comm_end - comm_start
              if name_len > NAME_SIZE - 1:
                name_len = NAME_SIZE - 1
              j: int32 = 0
              while j < name_len:
                names[names_pos + j] = stat_buf[comm_start + j]
                j = j + 1
              names[names_pos + name_len] = cast[uint8](0)
              names_pos = names_pos + NAME_SIZE

            record_count = record_count + 1

      pos = pos + reclen

    nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  _ = close(proc_fd)

  if binary_mode != 0:
    _ = write(STDOUT, "PSCH", 4)
    version: uint8 = 1
    _ = write(STDOUT, cast[*uint8](addr(version)), 1)
    fields: uint8 = 5
    _ = write(STDOUT, cast[*uint8](addr(fields)), 1)
    rec_size: uint16 = 48
    _ = write(STDOUT, cast[*uint8](addr(rec_size)), 2)
    _ = write(STDOUT, cast[*uint8](addr(record_count)), 4)
    _ = write(STDOUT, out_buf, out_pos)
  else:
    # Text mode output - header
    println("  PID  PPID S   RSS COMMAND")

    i = 0
    while i < record_count:
      print_num_pad(pids[i], 5)
      print(" ")
      print_num_pad(ppids[i], 5)
      print(" ")
      _ = write(STDOUT, cast[*uint8](addr(states[i])), 1)
      print(" ")
      print_num_pad(rsss[i], 5)
      print(" ")
      print(cast[*uint8](cast[int32](names) + i * NAME_SIZE))
      newline()
      i = i + 1

  return 0
