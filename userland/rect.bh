# rect - Draw a rectangle on framebuffer
# Usage: rect <x> <y> <width> <height> <color> [fill]
# Color is 24-bit RGB (e.g., 0xFF0000 for red)

const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_write: int32 = 4
const SYS_lseek: int32 = 19
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45

const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const FBIOGET_VSCREENINFO: int32 = 0x4600
const SEEK_SET: int32 = 0

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

proc print(msg: ptr uint8, len: int32) =
  discard syscall3(SYS_write, STDOUT, cast[int32](msg), len)

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc atoi(s: ptr uint8): int32 =
  var n: int32 = 0
  var i: int32 = 0
  var neg: int32 = 0

  # Handle hex prefix
  if s[0] == cast[uint8](48) and s[1] == cast[uint8](120):  # "0x"
    i = 2
    while s[i] != cast[uint8](0):
      var c: uint8 = s[i]
      n = n * 16
      if c >= cast[uint8](48) and c <= cast[uint8](57):
        n = n + cast[int32](c) - 48
      if c >= cast[uint8](97) and c <= cast[uint8](102):  # a-f
        n = n + cast[int32](c) - 87
      if c >= cast[uint8](65) and c <= cast[uint8](70):  # A-F
        n = n + cast[int32](c) - 55
      i = i + 1
    return n

  # Handle negative
  if s[0] == cast[uint8](45):  # '-'
    neg = 1
    i = 1

  # Parse decimal
  while s[i] != cast[uint8](0):
    if s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
      n = n * 10 + cast[int32](s[i]) - 48
    i = i + 1

  if neg != 0:
    return 0 - n
  return n

proc draw_hline(fd: int32, x: int32, y: int32, width: int32, xres: int32, yres: int32, color: int32, line_buf: ptr uint32) =
  if y < 0 or y >= yres:
    return

  var start_x: int32 = x
  var end_x: int32 = x + width
  if start_x < 0:
    start_x = 0
  if end_x > xres:
    end_x = xres
  if start_x >= end_x:
    return

  var actual_width: int32 = end_x - start_x

  # Fill line buffer with color
  var i: int32 = 0
  while i < actual_width:
    line_buf[i] = cast[uint32](color)
    i = i + 1

  # Write to framebuffer
  var offset: int32 = (y * xres + start_x) * 4
  discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
  discard syscall3(SYS_write, fd, cast[int32](line_buf), actual_width * 4)

proc draw_vline(fd: int32, x: int32, y: int32, height: int32, xres: int32, yres: int32, color: int32, pixel_buf: ptr uint32) =
  if x < 0 or x >= xres:
    return

  var start_y: int32 = y
  var end_y: int32 = y + height
  if start_y < 0:
    start_y = 0
  if end_y > yres:
    end_y = yres

  pixel_buf[0] = cast[uint32](color)

  var cy: int32 = start_y
  while cy < end_y:
    var offset: int32 = (cy * xres + x) * 4
    discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)
    cy = cy + 1

proc main() =
  var argc: int32 = get_argc()

  if argc < 6:
    print_str(cast[ptr uint8]("Usage: rect <x> <y> <width> <height> <color> [fill]\n"))
    print_str(cast[ptr uint8]("  color: 0xRRGGBB (e.g., 0xFF0000 for red)\n"))
    print_str(cast[ptr uint8]("  fill: 1 to fill, 0 or omit for outline\n"))
    discard syscall1(SYS_exit, 1)

  var x: int32 = atoi(get_argv(1))
  var y: int32 = atoi(get_argv(2))
  var width: int32 = atoi(get_argv(3))
  var height: int32 = atoi(get_argv(4))
  var color: int32 = atoi(get_argv(5))

  var fill: int32 = 0
  if argc > 6:
    fill = atoi(get_argv(6))

  # Open framebuffer
  var fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192  # Space for vinfo + line buffer
  discard syscall1(SYS_brk, new_brk)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var line_buf: ptr uint32 = cast[ptr uint32](old_brk + 256)
  var pixel_buf: ptr uint32 = cast[ptr uint32](old_brk + 200)

  var result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if result < 0:
    print_str(cast[ptr uint8]("Error: Cannot get screen info\n"))
    discard syscall1(SYS_close, fd)
    discard syscall1(SYS_exit, 1)

  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  if fill != 0:
    # Draw filled rectangle
    var cy: int32 = y
    while cy < y + height:
      draw_hline(fd, x, cy, width, xres, yres, color, line_buf)
      cy = cy + 1
  else:
    # Draw outline
    draw_hline(fd, x, y, width, xres, yres, color, line_buf)  # Top
    draw_hline(fd, x, y + height - 1, width, xres, yres, color, line_buf)  # Bottom
    draw_vline(fd, x, y, height, xres, yres, color, pixel_buf)  # Left
    draw_vline(fd, x + width - 1, y, height, xres, yres, color, pixel_buf)  # Right

  discard syscall1(SYS_close, fd)
  discard syscall1(SYS_exit, 0)

main()
