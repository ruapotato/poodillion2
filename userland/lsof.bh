# lsof - List open files (simplified)
# Shows open file descriptors for all processes
# Format: COMMAND PID USER FD TYPE NAME

from lib.syscalls import *

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if string is all digits
def is_numeric(s: *uint8) -> int32:
    i: int32 = 0
    if s[0] == cast[uint8](0):
        return 0
    while s[i] != cast[uint8](0):
        if s[i] < cast[uint8](48):  # '0'
            return 0
        if s[i] > cast[uint8](57):  # '9'
            return 0
        i = i + 1
    return 1

# Parse integer from string
def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    while s[i] >= cast[uint8](48):
        if s[i] > cast[uint8](57):
            break
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
    return result

# Print integer
# Print string with padding
def print_str_padded(s: *uint8, width: int32):
    len: int32 = strlen(s)

    # Print string
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

    # Print padding spaces
    spaces: int32 = width - len
    while spaces > 0:
        _ = syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
        spaces = spaces - 1

# Build path: /proc/PID/comm
def build_comm_path(path: *uint8, pid_str: *uint8):
    path[0] = cast[uint8](47)   # /
    path[1] = cast[uint8](112)  # p
    path[2] = cast[uint8](114)  # r
    path[3] = cast[uint8](111)  # o
    path[4] = cast[uint8](99)   # c
    path[5] = cast[uint8](47)   # /
    pos: int32 = 6
    # Copy PID
    i: int32 = 0
    while pid_str[i] != cast[uint8](0):
        path[pos] = pid_str[i]
        pos = pos + 1
        i = i + 1
    # /comm
    path[pos] = cast[uint8](47)      # /
    path[pos + 1] = cast[uint8](99)  # c
    path[pos + 2] = cast[uint8](111) # o
    path[pos + 3] = cast[uint8](109) # m
    path[pos + 4] = cast[uint8](109) # m
    path[pos + 5] = cast[uint8](0)

# Build path: /proc/PID/fd
def build_fd_path(path: *uint8, pid_str: *uint8):
    path[0] = cast[uint8](47)   # /
    path[1] = cast[uint8](112)  # p
    path[2] = cast[uint8](114)  # r
    path[3] = cast[uint8](111)  # o
    path[4] = cast[uint8](99)   # c
    path[5] = cast[uint8](47)   # /
    pos: int32 = 6
    # Copy PID
    i: int32 = 0
    while pid_str[i] != cast[uint8](0):
        path[pos] = pid_str[i]
        pos = pos + 1
        i = i + 1
    # /fd
    path[pos] = cast[uint8](47)     # /
    path[pos + 1] = cast[uint8](102) # f
    path[pos + 2] = cast[uint8](100) # d
    path[pos + 3] = cast[uint8](0)

# Build path: /proc/PID/fd/FD
def build_fd_link_path(path: *uint8, pid_str: *uint8, fd_str: *uint8):
    path[0] = cast[uint8](47)   # /
    path[1] = cast[uint8](112)  # p
    path[2] = cast[uint8](114)  # r
    path[3] = cast[uint8](111)  # o
    path[4] = cast[uint8](99)   # c
    path[5] = cast[uint8](47)   # /
    pos: int32 = 6
    # Copy PID
    i: int32 = 0
    while pid_str[i] != cast[uint8](0):
        path[pos] = pid_str[i]
        pos = pos + 1
        i = i + 1
    # /fd/
    path[pos] = cast[uint8](47)     # /
    path[pos + 1] = cast[uint8](102) # f
    path[pos + 2] = cast[uint8](100) # d
    path[pos + 3] = cast[uint8](47)  # /
    pos = pos + 4
    # Copy FD
    i = 0
    while fd_str[i] != cast[uint8](0):
        path[pos] = fd_str[i]
        pos = pos + 1
        i = i + 1
    path[pos] = cast[uint8](0)

def main():
    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 65536
    _ = syscall1(SYS_brk, new_brk)

    # Memory layout:
    # +0: proc dent buffer (8KB)
    # +8192: fd dent buffer (8KB)
    # +16384: comm buffer (256 bytes)
    # +16640: path buffer (512 bytes)
    # +17152: link target buffer (512 bytes)
    proc_dent_buf: *uint8 = cast[*uint8](old_brk)
    fd_dent_buf: *uint8 = cast[*uint8](old_brk + 8192)
    comm_buf: *uint8 = cast[*uint8](old_brk + 16384)
    path_buf: *uint8 = cast[*uint8](old_brk + 16640)
    link_buf: *uint8 = cast[*uint8](old_brk + 17152)

    # Print header
    print(cast[*uint8]("COMMAND          PID    FD   TYPE   NAME\n"))

    # Open /proc
    path_buf[0] = cast[uint8](47)   # /
    path_buf[1] = cast[uint8](112)  # p
    path_buf[2] = cast[uint8](114)  # r
    path_buf[3] = cast[uint8](111)  # o
    path_buf[4] = cast[uint8](99)   # c
    path_buf[5] = cast[uint8](0)

    proc_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY | O_DIRECTORY, 0)
    if proc_fd < 0:
        print_err(cast[*uint8]("lsof: cannot open /proc\n"))
        _ = syscall1(SYS_exit, 1)

    # Read /proc directory
    nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](proc_dent_buf), 8192)

    while nread > 0:
        pos: int32 = 0
        while pos < nread:
            # Parse dirent64
            reclen_ptr: *uint16 = cast[*uint16](cast[int32](proc_dent_buf) + pos + 16)
            reclen: int32 = cast[int32](reclen_ptr[0])
            d_name: *uint8 = cast[*uint8](cast[int32](proc_dent_buf) + pos + 19)

            # Check if this is a PID directory (all numeric)
            if is_numeric(d_name) == 1:
                pid: int32 = parse_int(d_name)

                # Get process command name
                build_comm_path(path_buf, d_name)
                comm_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
                comm_len: int32 = 0
                if comm_fd >= 0:
                    comm_len = syscall3(SYS_read, comm_fd, cast[int32](comm_buf), 255)
                    _ = syscall1(SYS_close, comm_fd)
                    if comm_len > 0:
                        # Remove trailing newline
                        if comm_buf[comm_len - 1] == cast[uint8](10):
                            comm_len = comm_len - 1
                        comm_buf[comm_len] = cast[uint8](0)
                    else:
                        comm_buf[0] = cast[uint8](63)  # '?'
                        comm_buf[1] = cast[uint8](0)
                else:
                    comm_buf[0] = cast[uint8](63)  # '?'
                    comm_buf[1] = cast[uint8](0)

                # Open /proc/PID/fd directory
                build_fd_path(path_buf, d_name)
                fd_dir: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY | O_DIRECTORY, 0)

                if fd_dir >= 0:
                    # Read fd directory
                    fd_nread: int32 = syscall3(SYS_getdents64, fd_dir, cast[int32](fd_dent_buf), 8192)

                    while fd_nread > 0:
                        fd_pos: int32 = 0
                        while fd_pos < fd_nread:
                            fd_reclen_ptr: *uint16 = cast[*uint16](cast[int32](fd_dent_buf) + fd_pos + 16)
                            fd_reclen: int32 = cast[int32](fd_reclen_ptr[0])
                            fd_name: *uint8 = cast[*uint8](cast[int32](fd_dent_buf) + fd_pos + 19)

                            # Check if this is a numeric fd entry
                            if is_numeric(fd_name) == 1:
                                # Build path to /proc/PID/fd/FD
                                build_fd_link_path(path_buf, d_name, fd_name)

                                # Read the symlink target
                                link_len: int32 = syscall3(SYS_readlink, cast[int32](path_buf), cast[int32](link_buf), 511)
                                if link_len > 0:
                                    link_buf[link_len] = cast[uint8](0)
                                else:
                                    link_buf[0] = cast[uint8](63)  # '?'
                                    link_buf[1] = cast[uint8](0)

                                # Print: COMMAND PID FD TYPE NAME
                                print_str_padded(comm_buf, 16)
                                print(cast[*uint8](" "))
                                print_int(pid)
                                print(cast[*uint8]("    "))
                                print(fd_name)
                                print(cast[*uint8]("    REG    "))
                                print(link_buf)
                                print(cast[*uint8]("\n"))

                            fd_pos = fd_pos + fd_reclen

                        fd_nread = syscall3(SYS_getdents64, fd_dir, cast[int32](fd_dent_buf), 8192)

                    _ = syscall1(SYS_close, fd_dir)

            pos = pos + reclen

        nread = syscall3(SYS_getdents64, proc_fd, cast[int32](proc_dent_buf), 8192)

    _ = syscall1(SYS_close, proc_fd)

    _ = syscall1(SYS_exit, 0)
