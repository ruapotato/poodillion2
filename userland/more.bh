# more - simple pager (display one screenful at a time)
# Usage: more [FILE]
# Space = next page, Enter = next line, q = quit

from lib.syscalls import *

# Terminal control (ioctl)
const TCGETS: int32 = 0x5401
const TCSETS: int32 = 0x5402
const ICANON: int32 = 2
const ECHO: int32 = 8

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

def main():
    argc: int32 = get_argc()
    fd: int32 = STDIN

    # Open file if provided
    if argc >= 2:
        filename: *uint8 = get_argv(1)
        fd = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
        if fd < 0:
            print_err(cast[*uint8]("more: cannot open file\n"))
            _ = syscall1(SYS_exit, 1)

    # Allocate buffers
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 8192
    _ = syscall1(SYS_brk, new_brk)
    buffer: *uint8 = cast[*uint8](old_brk)
    line_buffer: *uint8 = cast[*uint8](old_brk + 4096)

    # Save terminal settings (for stdin)
    termios_old: *uint8 = cast[*uint8](old_brk + 4096 + 1024)
    termios_new: *uint8 = cast[*uint8](old_brk + 4096 + 1024 + 64)

    # Get current terminal settings
    _ = syscall3(SYS_ioctl, STDIN, TCGETS, cast[int32](termios_old))

    # Copy to new settings
    k: int32 = 0
    while k < 64:
        termios_new[k] = termios_old[k]
        k = k + 1

    # Disable canonical mode and echo (raw mode)
    lflag_ptr: *int32 = cast[*int32](termios_new + 12)
    lflag: int32 = lflag_ptr[0]
    lflag = lflag - (lflag % (ICANON * 2) - lflag % ICANON)  # Clear ICANON
    lflag = lflag - (lflag % (ECHO * 2) - lflag % ECHO)      # Clear ECHO
    lflag_ptr[0] = lflag

    # Set raw mode
    _ = syscall3(SYS_ioctl, STDIN, TCSETS, cast[int32](termios_new))

    line_count: int32 = 0
    buf_pos: int32 = 0
    buf_size: int32 = 0
    running: int32 = 1
    line_start: int32 = 0

    while running != 0:
        # Display lines
        while line_count < 24:
            # Build a line
            line_start = 0
            line_done: int32 = 0

            while line_done == 0:
                # Need more data?
                if buf_pos >= buf_size:
                    buf_size = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
                    buf_pos = 0
                    if buf_size <= 0:
                        running = 0
                        line_done = 1
                        break

                if buf_pos < buf_size:
                    c: uint8 = buffer[buf_pos]
                    buf_pos = buf_pos + 1

                    line_buffer[line_start] = c
                    line_start = line_start + 1

                    if c == cast[uint8](10):  # newline
                        line_done = 1

            # Display the line
            if line_start > 0:
                _ = syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_start)
                line_count = line_count + 1

            if running == 0:
                break

        # Check if we're done
        if running == 0:
            break

        # Show prompt
        print(cast[*uint8]("--More--"))

        # Wait for key
        key_buf: *uint8 = cast[*uint8](old_brk + 4096 + 1024 + 128)
        key_read: int32 = syscall3(SYS_read, STDIN, cast[int32](key_buf), 1)

        # Clear prompt
        print(cast[*uint8]("\r        \r"))

        if key_read <= 0:
            running = 0
            break

        key: uint8 = key_buf[0]

        # q = quit
        if key == cast[uint8](113):  # 'q'
            running = 0

        # Enter = one more line
        if key == cast[uint8](10):   # '\n'
            line_count = 23

        # Space = next page
        if key == cast[uint8](32):   # ' '
            line_count = 0

    # Restore terminal settings
    _ = syscall3(SYS_ioctl, STDIN, TCSETS, cast[int32](termios_old))

    # Close file if opened
    if fd != STDIN:
        _ = syscall1(SYS_close, fd)

    _ = syscall1(SYS_exit, 0)
