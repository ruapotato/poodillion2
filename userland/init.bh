# init - PID 1 system initializer for BrainhairOS
# This is THE most critical program - the first userspace process
#
# Responsibilities:
# - Mount essential filesystems (/proc, /sys, /dev)
# - Spawn getty on console
# - Reap zombie processes (wait loop)
# - Handle shutdown signals
#
# Usage: Run as PID 1 (kernel starts this)

from lib.syscalls import *

# Mount flags (from linux/fs.h)
MS_RDONLY: Final[uint32] = 1
MS_NOSUID: Final[uint32] = 2
MS_NODEV: Final[uint32] = 4
MS_NOEXEC: Final[uint32] = 8

# Open flags
O_NOCTTY: Final[int32] = 256

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Mount a filesystem
# mount(source, target, filesystemtype, mountflags, data)
def do_mount(source: *uint8, target: *uint8, fstype: *uint8, flags: uint32):
    result: int32 = syscall5(SYS_mount, cast[int32](source), cast[int32](target), cast[int32](fstype), cast[int32](flags), 0)

    if result < 0:
        print_err(cast[*uint8]("init: mount failed: "))
        print_err(target)
        print_err(cast[*uint8]("\n"))
    else:
        print(cast[*uint8]("init: mounted "))
        print(fstype)
        print(cast[*uint8](" at "))
        print(target)
        print(cast[*uint8]("\n"))

# Spawn getty on a tty device
def spawn_getty(tty_path: *uint8) -> int32:
    pid: int32 = syscall1(SYS_fork, 0)

    if pid < 0:
        print_err(cast[*uint8]("init: fork failed for getty\n"))
        return -1

    if pid == 0:
        # Child process - exec getty

        # Allocate memory for argv
        old_brk: int32 = syscall1(SYS_brk, 0)
        new_brk: int32 = old_brk + 512
        _ = syscall1(SYS_brk, new_brk)
        argv: *int32 = cast[*int32](old_brk)
        getty_path: *uint8 = cast[*uint8](old_brk + 64)

        # Build argv for getty
        # argv[0] = "/bin/getty" or "./bin/getty"
        # argv[1] = tty_path (e.g., "/dev/tty1")
        # argv[2] = NULL
        strcpy(getty_path, cast[*uint8]("/bin/getty"))
        argv[0] = cast[int32](getty_path)
        argv[1] = cast[int32](tty_path)
        argv[2] = 0

        # Try to exec getty
        _ = syscall3(SYS_execve, cast[int32](getty_path), cast[int32](argv), 0)

        # If that fails, try ./bin/getty
        strcpy(getty_path, cast[*uint8]("./bin/getty"))
        argv[0] = cast[int32](getty_path)
        _ = syscall3(SYS_execve, cast[int32](getty_path), cast[int32](argv), 0)

        # If exec fails, just run a shell directly
        strcpy(getty_path, cast[*uint8]("/bin/psh"))
        argv[0] = cast[int32](getty_path)
        argv[1] = 0
        _ = syscall3(SYS_execve, cast[int32](getty_path), cast[int32](argv), 0)

        # Try ./bin/psh
        strcpy(getty_path, cast[*uint8]("./bin/psh"))
        argv[0] = cast[int32](getty_path)
        _ = syscall3(SYS_execve, cast[int32](getty_path), cast[int32](argv), 0)

        # If everything fails
        print_err(cast[*uint8]("init: failed to exec getty or shell\n"))
        _ = syscall1(SYS_exit, 1)

    # Parent - return the child pid
    return pid

def main():
    # Check if we're actually PID 1
    pid: int32 = syscall1(SYS_getpid, 0)

    if pid == 1:
        print(cast[*uint8]("init: BrainhairOS init starting (PID 1)\n"))
    else:
        print(cast[*uint8]("init: running as PID "))
        # Note: would print pid here with print_int, but keeping it simple
        print(cast[*uint8]("(not PID 1, testing mode)\n"))

    # Allocate working memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    _ = syscall1(SYS_brk, new_brk)

    # Create string buffers for mount operations
    proc_src: *uint8 = cast[*uint8](old_brk)
    proc_tgt: *uint8 = cast[*uint8](old_brk + 64)
    proc_type: *uint8 = cast[*uint8](old_brk + 128)

    sys_src: *uint8 = cast[*uint8](old_brk + 192)
    sys_tgt: *uint8 = cast[*uint8](old_brk + 256)
    sys_type: *uint8 = cast[*uint8](old_brk + 320)

    dev_src: *uint8 = cast[*uint8](old_brk + 384)
    dev_tgt: *uint8 = cast[*uint8](old_brk + 448)
    dev_type: *uint8 = cast[*uint8](old_brk + 512)

    tty_path: *uint8 = cast[*uint8](old_brk + 576)

    # Mount /proc
    strcpy(proc_src, cast[*uint8]("proc"))
    strcpy(proc_tgt, cast[*uint8]("/proc"))
    strcpy(proc_type, cast[*uint8]("proc"))
    do_mount(proc_src, proc_tgt, proc_type, 0)

    # Mount /sys
    strcpy(sys_src, cast[*uint8]("sysfs"))
    strcpy(sys_tgt, cast[*uint8]("/sys"))
    strcpy(sys_type, cast[*uint8]("sysfs"))
    do_mount(sys_src, sys_tgt, sys_type, 0)

    # Mount /dev (devtmpfs - automatic device nodes)
    strcpy(dev_src, cast[*uint8]("devtmpfs"))
    strcpy(dev_tgt, cast[*uint8]("/dev"))
    strcpy(dev_type, cast[*uint8]("devtmpfs"))
    do_mount(dev_src, dev_tgt, dev_type, 0)

    print(cast[*uint8]("init: essential filesystems mounted\n"))

    # Storage for console path
    console_path: *uint8 = cast[*uint8](old_brk + 700)

    # Spawn getty on /dev/tty1 (for graphical console)
    strcpy(tty_path, cast[*uint8]("/dev/tty1"))
    print(cast[*uint8]("init: spawning getty on /dev/tty1\n"))
    getty_pid: int32 = spawn_getty(tty_path)

    if getty_pid > 0:
        print(cast[*uint8]("init: getty spawned on tty1\n"))

    # Also spawn getty on /dev/console (for serial console mode)
    strcpy(console_path, cast[*uint8]("/dev/console"))
    print(cast[*uint8]("init: spawning getty on /dev/console\n"))
    console_getty_pid: int32 = spawn_getty(console_path)

    if console_getty_pid > 0:
        print(cast[*uint8]("init: getty spawned on console\n"))

    # Main loop: reap zombie processes
    print(cast[*uint8]("init: entering main loop (reaping zombies)\n"))

    # Allocate space for status
    status_ptr: *int32 = cast[*int32](old_brk + 640)

    while 1 == 1:
        # Wait for any child process to exit
        # waitpid(-1, &status, 0) - wait for any child
        status_ptr[0] = 0
        child_pid: int32 = syscall3(SYS_waitpid, -1, cast[int32](status_ptr), 0)

        if child_pid > 0:
            # A child exited
            print(cast[*uint8]("init: reaped process "))
            # Would print child_pid here
            print(cast[*uint8]("(zombie cleaned)\n"))

            # If it was a getty, respawn it
            if child_pid == getty_pid:
                print(cast[*uint8]("init: tty1 getty died, respawning...\n"))
                getty_pid = spawn_getty(tty_path)
            if child_pid == console_getty_pid:
                print(cast[*uint8]("init: console getty died, respawning...\n"))
                console_getty_pid = spawn_getty(console_path)
        else:
            # No children or error - just loop
            # In a real init, we'd handle SIGCHLD here
            # For now, just continue
            _ = 0

    # Should never reach here
    _ = syscall1(SYS_exit, 0)
