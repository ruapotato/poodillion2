# uptime - Show how long the system has been running
# Uses SYS_uptime syscall to get system uptime
# Shows uptime in human-readable format with process count

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# Uptime structure
uptime_data: int32[2]

# Parse integer from string
def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  # Skip leading whitespace
  while s[i] == cast[uint8](32):
    i = i + 1
  # Parse digits
  while s[i] >= cast[uint8](48):
    if s[i] <= cast[uint8](57):
      result = result * 10 + cast[int32](s[i]) - 48
      i = i + 1
    else:
      break
  return result

# Print integer with padding
def print_int_pad(n: int32):
  if n < 10:
    _ = write(STDOUT, cast[*uint8]("0"), 1)
  print_int(n)

# Count processes from /proc
def count_processes() -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16384
  syscall1(SYS_brk, new_brk)

  dent_buf: *uint8 = cast[*uint8](old_brk)
  path_buf: *uint8 = cast[*uint8](old_brk + 8192)

  # Build "/proc"
  path_buf[0] = cast[uint8](47)
  path_buf[1] = cast[uint8](112)
  path_buf[2] = cast[uint8](114)
  path_buf[3] = cast[uint8](111)
  path_buf[4] = cast[uint8](99)
  path_buf[5] = cast[uint8](0)

  proc_fd: int32 = open(path_buf, O_RDONLY | O_DIRECTORY, 0)
  if proc_fd < 0:
    return 0

  count: int32 = 0
  nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  while nread > 0:
    pos: int32 = 0
    while pos < nread:
      reclen_ptr: *uint16 = cast[*uint16](cast[int32](dent_buf) + pos + 16)
      reclen: int32 = cast[int32](reclen_ptr[0])
      d_name: *uint8 = cast[*uint8](cast[int32](dent_buf) + pos + 19)

      # Check if it's a numeric directory (PID)
      if d_name[0] >= cast[uint8](48) and d_name[0] <= cast[uint8](57):
        count = count + 1

      pos = pos + reclen

    nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  _ = close(proc_fd)
  return count

def main() -> int32:
  # Get uptime using syscall
  result: int32 = syscall1(SYS_uptime, cast[int32](addr(uptime_data[0])))

  uptime_seconds: int32 = uptime_data[0]
  uptime_millis: int32 = uptime_data[1]

  # Convert to days, hours, minutes
  days: int32 = uptime_seconds / 86400
  remainder: int32 = uptime_seconds % 86400
  hours: int32 = remainder / 3600
  minutes: int32 = (remainder % 3600) / 60
  seconds: int32 = remainder % 60

  # Count processes
  proc_count: int32 = count_processes()

  # Print uptime in format similar to Unix uptime command
  # Format: " HH:MM:SS up X days, Y hours, Z minutes, N processes"

  # Print current time (using uptime as fake time)
  print(cast[*uint8](" "))
  print_int_pad(hours)
  print(cast[*uint8](":"))
  print_int_pad(minutes)
  print(cast[*uint8](":"))
  print_int_pad(seconds)

  print(cast[*uint8](" up "))

  # Print uptime in human-readable format
  if days > 0:
    print_int(days)
    if days == 1:
      print(cast[*uint8](" day, "))
    else:
      print(cast[*uint8](" days, "))

  if hours > 0 or days > 0:
    print_int(hours)
    if hours == 1:
      print(cast[*uint8](" hour, "))
    else:
      print(cast[*uint8](" hours, "))

  print_int(minutes)
  if minutes == 1:
    print(cast[*uint8](" minute"))
  else:
    print(cast[*uint8](" minutes"))

  # Print process count
  print(cast[*uint8](", "))
  print_int(proc_count)
  if proc_count == 1:
    print(cast[*uint8](" process"))
  else:
    print(cast[*uint8](" processes"))

  newline()

  return 0
