# bhasm - Brainhair Assembler Wrapper
# Assembles .asm files using NASM
#
# Usage: bhasm <source.asm> <output> [format]
# Formats: bin (default), elf32

const SYS_write: int32 = 4
const SYS_exit: int32 = 1
const SYS_fork: int32 = 2
const SYS_execve: int32 = 11
const SYS_waitpid: int32 = 7
const SYS_brk: int32 = 45

const STDOUT: int32 = 1
const STDERR: int32 = 2

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc get_argc(): int32
extern proc get_argv(idx: int32): ptr uint8

proc print(msg: ptr uint8) =
  var len: int32 = 0
  while msg[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](msg), len)

proc println(msg: ptr uint8) =
  print(msg)
  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

proc print_err(msg: ptr uint8) =
  var len: int32 = 0
  while msg[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

proc strlen(s: ptr uint8): int32 =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  return len

proc strcpy(dest: ptr uint8, src: ptr uint8) =
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dest[i] = src[i]
    i = i + 1
  dest[i] = cast[uint8](0)

proc strcmp(s1: ptr uint8, s2: ptr uint8): int32 =
  var i: int32 = 0
  while s1[i] != cast[uint8](0) and s2[i] != cast[uint8](0):
    if s1[i] != s2[i]:
      return cast[int32](s1[i]) - cast[int32](s2[i])
    i = i + 1
  return cast[int32](s1[i]) - cast[int32](s2[i])

proc run_cmd(argv: ptr int32): int32 =
  var pid: int32 = syscall1(SYS_fork, 0)

  if pid == 0:
    var envp: array[1, int32]
    envp[0] = 0
    discard syscall3(SYS_execve, argv[0], cast[int32](argv), cast[int32](addr(envp)))
    print_err(cast[ptr uint8]("bhasm: exec failed\n"))
    discard syscall1(SYS_exit, 127)

  if pid < 0:
    return 1

  var status: int32 = 0
  discard syscall3(SYS_waitpid, pid, cast[int32](addr(status)), 0)
  var exit_code: int32 = (status >> 8) & 255
  return exit_code

proc main(): int32 =
  var argc: int32 = get_argc()

  if argc < 3:
    println(cast[ptr uint8]("bhasm - Brainhair Assembler Wrapper"))
    println(cast[ptr uint8]("Usage: bhasm <source.asm> <output> [format]"))
    println(cast[ptr uint8]("Formats: bin (default), elf32"))
    return 1

  var source: ptr uint8 = get_argv(1)
  var output: ptr uint8 = get_argv(2)
  var format: ptr uint8 = cast[ptr uint8]("bin")

  if argc >= 4:
    format = get_argv(3)

  # Allocate buffer for argv
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)
  var str_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var argv_buf: ptr int32 = cast[ptr int32](old_brk + 2048)

  print(cast[ptr uint8]("  Assembling "))
  print(source)
  print(cast[ptr uint8](" -> "))
  print(output)
  print(cast[ptr uint8](" ("))
  print(format)
  println(cast[ptr uint8](")"))

  # Build nasm command: nasm -f <format> <source> -o <output>
  var p: int32 = 0
  strcpy(str_buf, cast[ptr uint8]("/usr/bin/nasm"))
  argv_buf[0] = cast[int32](str_buf)
  p = p + 16

  strcpy(cast[ptr uint8](cast[int32](str_buf) + p), cast[ptr uint8]("-f"))
  argv_buf[1] = cast[int32](str_buf) + p
  p = p + 4

  strcpy(cast[ptr uint8](cast[int32](str_buf) + p), format)
  argv_buf[2] = cast[int32](str_buf) + p
  p = p + strlen(format) + 1

  strcpy(cast[ptr uint8](cast[int32](str_buf) + p), source)
  argv_buf[3] = cast[int32](str_buf) + p
  p = p + strlen(source) + 1

  strcpy(cast[ptr uint8](cast[int32](str_buf) + p), cast[ptr uint8]("-o"))
  argv_buf[4] = cast[int32](str_buf) + p
  p = p + 4

  strcpy(cast[ptr uint8](cast[int32](str_buf) + p), output)
  argv_buf[5] = cast[int32](str_buf) + p
  argv_buf[6] = 0

  var result: int32 = run_cmd(argv_buf)
  if result != 0:
    print_err(cast[ptr uint8]("bhasm: assembly failed\n"))
    return 1

  println(cast[ptr uint8]("  Done"))
  return 0
