# snake - Classic Snake Game
# Use arrow keys or WASD to control the snake
# Eat food (green) to grow, avoid walls and yourself

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192
const SYS_nanosleep: int32 = 162
const SYS_time: int32 = 13

const STDIN: int32 = 0
const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const GRID_SIZE: int32 = 20      # Pixels per grid cell
const GRID_WIDTH: int32 = 30     # Game grid width
const GRID_HEIGHT: int32 = 25    # Game grid height
const MAX_SNAKE: int32 = 500     # Maximum snake length

# Colors
const BG_COLOR: int32 = 0x1A1A2E
const GRID_COLOR: int32 = 0x252540
const SNAKE_HEAD: int32 = 0x00FF88
const SNAKE_BODY: int32 = 0x00CC66
const FOOD_COLOR: int32 = 0xFF4444
const WALL_COLOR: int32 = 0x404060
const TEXT_COLOR: int32 = 0xFFFFFF
const SCORE_BG: int32 = 0x0F0F1A

# Direction constants
const DIR_UP: int32 = 0
const DIR_DOWN: int32 = 1
const DIR_LEFT: int32 = 2
const DIR_RIGHT: int32 = 3

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Game state
var g_snake_x: array[500, int32]  # Snake segment X positions
var g_snake_y: array[500, int32]  # Snake segment Y positions
var g_snake_len: int32 = 3        # Current snake length
var g_direction: int32 = 3        # Current direction (start moving right)
var g_food_x: int32 = 15
var g_food_y: int32 = 12
var g_score: int32 = 0
var g_game_over: int32 = 0
var g_game_x: int32 = 0           # Game area offset X
var g_game_y: int32 = 0           # Game area offset Y

# Simple PRNG state
var g_rand_state: int32 = 12345

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: array[16, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(cast[ptr uint8](buf))
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(cast[ptr uint8](buf))

proc random(): int32 =
  g_rand_state = g_rand_state * 1103515245 + 12345
  var r: int32 = g_rand_state / 65536
  if r < 0:
    r = 0 - r
  return r

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0                    # seconds
  ts[1] = ms * 1000000         # nanoseconds
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

# ============ Drawing Primitives ============

proc buf_pixel(x: int32, y: int32, color: int32) =
  if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
    g_fb[y * g_xres + x] = cast[uint32](color)

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < g_yres:
      var cx: int32 = x
      while cx < x + w:
        if cx >= 0 and cx < g_xres:
          g_fb[cy * g_xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

# 8x8 font bitmap data
var font: array[768, uint8]

proc init_font() =
  # Initialize font (just digits and some letters for score)
  var i: int32 = 0
  while i < 768:
    font[i] = cast[uint8](0)
    i = i + 1

  # '0' = ASCII 48
  font[384] = cast[uint8](0x3C)
  font[385] = cast[uint8](0x66)
  font[386] = cast[uint8](0x6E)
  font[387] = cast[uint8](0x7E)
  font[388] = cast[uint8](0x76)
  font[389] = cast[uint8](0x66)
  font[390] = cast[uint8](0x3C)
  font[391] = cast[uint8](0x00)

  # '1'
  font[392] = cast[uint8](0x18)
  font[393] = cast[uint8](0x38)
  font[394] = cast[uint8](0x18)
  font[395] = cast[uint8](0x18)
  font[396] = cast[uint8](0x18)
  font[397] = cast[uint8](0x18)
  font[398] = cast[uint8](0x7E)
  font[399] = cast[uint8](0x00)

  # '2'
  font[400] = cast[uint8](0x3C)
  font[401] = cast[uint8](0x66)
  font[402] = cast[uint8](0x06)
  font[403] = cast[uint8](0x0C)
  font[404] = cast[uint8](0x18)
  font[405] = cast[uint8](0x30)
  font[406] = cast[uint8](0x7E)
  font[407] = cast[uint8](0x00)

  # '3'
  font[408] = cast[uint8](0x3C)
  font[409] = cast[uint8](0x66)
  font[410] = cast[uint8](0x06)
  font[411] = cast[uint8](0x1C)
  font[412] = cast[uint8](0x06)
  font[413] = cast[uint8](0x66)
  font[414] = cast[uint8](0x3C)
  font[415] = cast[uint8](0x00)

  # '4'
  font[416] = cast[uint8](0x0C)
  font[417] = cast[uint8](0x1C)
  font[418] = cast[uint8](0x3C)
  font[419] = cast[uint8](0x6C)
  font[420] = cast[uint8](0x7E)
  font[421] = cast[uint8](0x0C)
  font[422] = cast[uint8](0x0C)
  font[423] = cast[uint8](0x00)

  # '5'
  font[424] = cast[uint8](0x7E)
  font[425] = cast[uint8](0x60)
  font[426] = cast[uint8](0x7C)
  font[427] = cast[uint8](0x06)
  font[428] = cast[uint8](0x06)
  font[429] = cast[uint8](0x66)
  font[430] = cast[uint8](0x3C)
  font[431] = cast[uint8](0x00)

  # '6'
  font[432] = cast[uint8](0x1C)
  font[433] = cast[uint8](0x30)
  font[434] = cast[uint8](0x60)
  font[435] = cast[uint8](0x7C)
  font[436] = cast[uint8](0x66)
  font[437] = cast[uint8](0x66)
  font[438] = cast[uint8](0x3C)
  font[439] = cast[uint8](0x00)

  # '7'
  font[440] = cast[uint8](0x7E)
  font[441] = cast[uint8](0x06)
  font[442] = cast[uint8](0x0C)
  font[443] = cast[uint8](0x18)
  font[444] = cast[uint8](0x30)
  font[445] = cast[uint8](0x30)
  font[446] = cast[uint8](0x30)
  font[447] = cast[uint8](0x00)

  # '8'
  font[448] = cast[uint8](0x3C)
  font[449] = cast[uint8](0x66)
  font[450] = cast[uint8](0x66)
  font[451] = cast[uint8](0x3C)
  font[452] = cast[uint8](0x66)
  font[453] = cast[uint8](0x66)
  font[454] = cast[uint8](0x3C)
  font[455] = cast[uint8](0x00)

  # '9'
  font[456] = cast[uint8](0x3C)
  font[457] = cast[uint8](0x66)
  font[458] = cast[uint8](0x66)
  font[459] = cast[uint8](0x3E)
  font[460] = cast[uint8](0x06)
  font[461] = cast[uint8](0x0C)
  font[462] = cast[uint8](0x38)
  font[463] = cast[uint8](0x00)

  # 'S' = ASCII 83
  font[664] = cast[uint8](0x3C)
  font[665] = cast[uint8](0x66)
  font[666] = cast[uint8](0x60)
  font[667] = cast[uint8](0x3C)
  font[668] = cast[uint8](0x06)
  font[669] = cast[uint8](0x66)
  font[670] = cast[uint8](0x3C)
  font[671] = cast[uint8](0x00)

  # 'c' = ASCII 99
  font[792] = cast[uint8](0x00)
  font[793] = cast[uint8](0x00)
  font[794] = cast[uint8](0x3C)
  font[795] = cast[uint8](0x60)
  font[796] = cast[uint8](0x60)
  font[797] = cast[uint8](0x60)
  font[798] = cast[uint8](0x3C)
  font[399] = cast[uint8](0x00)

  # 'o' = ASCII 111
  font[888] = cast[uint8](0x00)
  font[889] = cast[uint8](0x00)
  font[890] = cast[uint8](0x3C)
  font[891] = cast[uint8](0x66)
  font[892] = cast[uint8](0x66)
  font[893] = cast[uint8](0x66)
  font[894] = cast[uint8](0x3C)
  font[895] = cast[uint8](0x00)

  # 'r' = ASCII 114
  font[912] = cast[uint8](0x00)
  font[913] = cast[uint8](0x00)
  font[914] = cast[uint8](0x6C)
  font[915] = cast[uint8](0x76)
  font[916] = cast[uint8](0x60)
  font[917] = cast[uint8](0x60)
  font[918] = cast[uint8](0x60)
  font[919] = cast[uint8](0x00)

  # 'e' = ASCII 101
  font[808] = cast[uint8](0x00)
  font[809] = cast[uint8](0x00)
  font[810] = cast[uint8](0x3C)
  font[811] = cast[uint8](0x66)
  font[812] = cast[uint8](0x7E)
  font[813] = cast[uint8](0x60)
  font[814] = cast[uint8](0x3C)
  font[815] = cast[uint8](0x00)

  # ':' = ASCII 58
  font[464] = cast[uint8](0x00)
  font[465] = cast[uint8](0x18)
  font[466] = cast[uint8](0x18)
  font[467] = cast[uint8](0x00)
  font[468] = cast[uint8](0x00)
  font[469] = cast[uint8](0x18)
  font[470] = cast[uint8](0x18)
  font[471] = cast[uint8](0x00)

proc draw_char(x: int32, y: int32, c: uint8, color: int32) =
  var idx: int32 = cast[int32](c) * 8
  if idx < 0 or idx >= 760:
    return
  var row: int32 = 0
  while row < 8:
    var bits: uint8 = font[idx + row]
    var col: int32 = 0
    while col < 8:
      var mask: int32 = 128
      var shift: int32 = col
      while shift > 0:
        mask = mask / 2
        shift = shift - 1
      if (cast[int32](bits) & mask) != 0:
        buf_pixel(x + col, y + row, color)
      col = col + 1
    row = row + 1

proc draw_text(x: int32, y: int32, text: ptr uint8, color: int32) =
  var i: int32 = 0
  var cx: int32 = x
  while text[i] != cast[uint8](0):
    draw_char(cx, y, text[i], color)
    cx = cx + 8
    i = i + 1

proc draw_number(x: int32, y: int32, n: int32, color: int32) =
  var buf: array[12, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    draw_text(x, y, cast[ptr uint8](buf), color)
    return
  var tmp: int32 = n
  if tmp < 0:
    tmp = 0 - tmp
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  # Reverse
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  draw_text(x, y, cast[ptr uint8](buf), color)

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  # Open framebuffer
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)
  var path: ptr uint8 = cast[ptr uint8](old_brk)
  path[0] = cast[uint8](47)   # /
  path[1] = cast[uint8](100)  # d
  path[2] = cast[uint8](101)  # e
  path[3] = cast[uint8](118)  # v
  path[4] = cast[uint8](47)   # /
  path[5] = cast[uint8](102)  # f
  path[6] = cast[uint8](98)   # b
  path[7] = cast[uint8](48)   # 0
  path[8] = cast[uint8](0)

  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  # Get screen info via ioctl
  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  var ret: int32 = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if ret < 0:
    print_str(cast[ptr uint8]("Error: ioctl failed\n"))
    return 1

  g_xres = vinfo[0]
  g_yres = vinfo[1]
  var bpp: int32 = vinfo[6]

  if bpp != 32:
    print_str(cast[ptr uint8]("Error: only 32bpp supported\n"))
    return 1

  # mmap framebuffer
  var fb_size: int32 = g_xres * g_yres * 4
  g_fb = cast[ptr uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

  if cast[int32](g_fb) < 0:
    print_str(cast[ptr uint8]("Error: mmap failed\n"))
    return 1

  # Set stdin to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

  # Calculate game area position (centered)
  g_game_x = (g_xres - GRID_WIDTH * GRID_SIZE) / 2
  g_game_y = (g_yres - GRID_HEIGHT * GRID_SIZE - 40) / 2 + 40  # Leave room for score

  return 0

# ============ Game Logic ============

proc init_game() =
  # Initialize snake in center
  g_snake_len = 3
  var start_x: int32 = GRID_WIDTH / 2
  var start_y: int32 = GRID_HEIGHT / 2

  g_snake_x[0] = start_x
  g_snake_y[0] = start_y
  g_snake_x[1] = start_x - 1
  g_snake_y[1] = start_y
  g_snake_x[2] = start_x - 2
  g_snake_y[2] = start_y

  g_direction = DIR_RIGHT
  g_score = 0
  g_game_over = 0

  # Initialize random seed with time
  g_rand_state = syscall1(SYS_time, 0)
  if g_rand_state == 0:
    g_rand_state = 12345

  # Place initial food
  g_food_x = (random() % (GRID_WIDTH - 2)) + 1
  g_food_y = (random() % (GRID_HEIGHT - 2)) + 1

proc spawn_food() =
  # Find a spot not occupied by snake
  var valid: int32 = 0
  var attempts: int32 = 0
  while valid == 0 and attempts < 100:
    g_food_x = (random() % (GRID_WIDTH - 2)) + 1
    g_food_y = (random() % (GRID_HEIGHT - 2)) + 1
    valid = 1
    var i: int32 = 0
    while i < g_snake_len:
      if g_snake_x[i] == g_food_x and g_snake_y[i] == g_food_y:
        valid = 0
      i = i + 1
    attempts = attempts + 1

proc move_snake() =
  if g_game_over != 0:
    return

  # Calculate new head position
  var new_x: int32 = g_snake_x[0]
  var new_y: int32 = g_snake_y[0]

  if g_direction == DIR_UP:
    new_y = new_y - 1
  else:
    if g_direction == DIR_DOWN:
      new_y = new_y + 1
    else:
      if g_direction == DIR_LEFT:
        new_x = new_x - 1
      else:
        new_x = new_x + 1

  # Check wall collision
  if new_x < 0 or new_x >= GRID_WIDTH or new_y < 0 or new_y >= GRID_HEIGHT:
    g_game_over = 1
    return

  # Check self collision
  var i: int32 = 0
  while i < g_snake_len:
    if g_snake_x[i] == new_x and g_snake_y[i] == new_y:
      g_game_over = 1
      return
    i = i + 1

  # Check food collision
  var ate_food: int32 = 0
  if new_x == g_food_x and new_y == g_food_y:
    ate_food = 1
    g_score = g_score + 10
    if g_snake_len < MAX_SNAKE:
      g_snake_len = g_snake_len + 1
    spawn_food()

  # Move body segments (from tail to head)
  i = g_snake_len - 1
  while i > 0:
    g_snake_x[i] = g_snake_x[i - 1]
    g_snake_y[i] = g_snake_y[i - 1]
    i = i - 1

  # Move head
  g_snake_x[0] = new_x
  g_snake_y[0] = new_y

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n > 0:
    var c: uint8 = buf[0]
    # WASD controls
    if c == cast[uint8](119) or c == cast[uint8](87):  # w/W
      if g_direction != DIR_DOWN:
        g_direction = DIR_UP
    else:
      if c == cast[uint8](115) or c == cast[uint8](83):  # s/S
        if g_direction != DIR_UP:
          g_direction = DIR_DOWN
      else:
        if c == cast[uint8](97) or c == cast[uint8](65):  # a/A
          if g_direction != DIR_RIGHT:
            g_direction = DIR_LEFT
        else:
          if c == cast[uint8](100) or c == cast[uint8](68):  # d/D
            if g_direction != DIR_LEFT:
              g_direction = DIR_RIGHT
          else:
            if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q
              g_game_over = 2  # Signal quit
            else:
              if c == cast[uint8](114) or c == cast[uint8](82):  # r/R
                if g_game_over == 1:
                  init_game()  # Restart

    # Arrow key handling (escape sequences)
    if n >= 3 and buf[0] == cast[uint8](27) and buf[1] == cast[uint8](91):
      if buf[2] == cast[uint8](65):  # Up
        if g_direction != DIR_DOWN:
          g_direction = DIR_UP
      else:
        if buf[2] == cast[uint8](66):  # Down
          if g_direction != DIR_UP:
            g_direction = DIR_DOWN
        else:
          if buf[2] == cast[uint8](68):  # Left
            if g_direction != DIR_RIGHT:
              g_direction = DIR_LEFT
          else:
            if buf[2] == cast[uint8](67):  # Right
              if g_direction != DIR_LEFT:
                g_direction = DIR_RIGHT

# ============ Rendering ============

proc draw_game() =
  # Clear screen
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](BG_COLOR)
    i = i + 1

  # Draw score bar
  fill_rect(0, 0, g_xres, 36, SCORE_BG)
  draw_text(10, 10, cast[ptr uint8]("Score: "), TEXT_COLOR)
  draw_number(66, 10, g_score, TEXT_COLOR)

  # Draw game border
  fill_rect(g_game_x - 4, g_game_y - 4, GRID_WIDTH * GRID_SIZE + 8, GRID_HEIGHT * GRID_SIZE + 8, WALL_COLOR)

  # Draw game area background with grid
  var gy: int32 = 0
  while gy < GRID_HEIGHT:
    var gx: int32 = 0
    while gx < GRID_WIDTH:
      var color: int32 = BG_COLOR
      if (gx + gy) % 2 == 0:
        color = GRID_COLOR
      fill_rect(g_game_x + gx * GRID_SIZE, g_game_y + gy * GRID_SIZE, GRID_SIZE, GRID_SIZE, color)
      gx = gx + 1
    gy = gy + 1

  # Draw food
  var food_px: int32 = g_game_x + g_food_x * GRID_SIZE + 2
  var food_py: int32 = g_game_y + g_food_y * GRID_SIZE + 2
  fill_rect(food_px, food_py, GRID_SIZE - 4, GRID_SIZE - 4, FOOD_COLOR)

  # Draw snake
  i = g_snake_len - 1
  while i >= 0:
    var sx: int32 = g_game_x + g_snake_x[i] * GRID_SIZE + 1
    var sy: int32 = g_game_y + g_snake_y[i] * GRID_SIZE + 1
    var color: int32 = SNAKE_BODY
    if i == 0:
      color = SNAKE_HEAD
    fill_rect(sx, sy, GRID_SIZE - 2, GRID_SIZE - 2, color)
    i = i - 1

  # Draw game over text
  if g_game_over == 1:
    var text_x: int32 = g_game_x + (GRID_WIDTH * GRID_SIZE - 80) / 2
    var text_y: int32 = g_game_y + (GRID_HEIGHT * GRID_SIZE - 16) / 2
    fill_rect(text_x - 10, text_y - 10, 100, 36, SCORE_BG)
    draw_text(text_x, text_y, cast[ptr uint8]("GAME OVER"), TEXT_COLOR)

# ============ Main ============

proc main(): int32 =
  print_str(cast[ptr uint8]("Snake Game - Use WASD or arrow keys, Q to quit, R to restart\n"))

  if init_framebuffer() != 0:
    return 1

  init_font()
  init_game()

  # Game loop
  while g_game_over != 2:
    handle_input()

    if g_game_over != 1:
      move_snake()

    draw_game()

    # Game speed (slower = easier)
    sleep_ms(120)

  # Clear screen on exit
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0)
    i = i + 1

  discard syscall1(SYS_close, g_fb_fd)
  print_str(cast[ptr uint8]("Final Score: "))
  print_num(g_score)
  print_str(cast[ptr uint8]("\n"))

  return 0

main()
