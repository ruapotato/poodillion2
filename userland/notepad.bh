# notepad - Simple Graphical Text Editor
# A basic text editor with file loading and saving

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192
const SYS_lseek: int32 = 19

const STDIN: int32 = 0
const STDOUT: int32 = 1
const O_RDONLY: int32 = 0
const O_WRONLY: int32 = 1
const O_RDWR: int32 = 2
const O_CREAT: int32 = 64
const O_TRUNC: int32 = 512
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3
const SEEK_END: int32 = 2
const SEEK_SET: int32 = 0

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Editor constants
const MAX_LINES: int32 = 1000
const MAX_LINE_LEN: int32 = 256
const MAX_TEXT: int32 = 262144  # 256KB max file size
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 10
const TAB_SIZE: int32 = 4

# Colors
const BG_COLOR: int32 = 0x1E1E2E
const TEXT_COLOR: int32 = 0xCDD6F4
const CURSOR_COLOR: int32 = 0xF5C2E7
const LINE_NUM_BG: int32 = 0x181825
const LINE_NUM_FG: int32 = 0x6C7086
const STATUS_BG: int32 = 0x313244
const STATUS_FG: int32 = 0xBAC2DE
const SELECTION_BG: int32 = 0x45475A

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Editor state
var g_text: ptr uint8 = cast[ptr uint8](0)  # Text buffer
var g_text_len: int32 = 0                    # Current text length
var g_cursor_pos: int32 = 0                  # Cursor position in text
var g_scroll_y: int32 = 0                    # Vertical scroll offset (lines)
var g_filename: array[256, uint8]            # Current filename
var g_modified: int32 = 0                    # Has file been modified?
var g_running: int32 = 1

# Computed values
var g_visible_lines: int32 = 0
var g_visible_cols: int32 = 0
var g_text_start_x: int32 = 50               # After line numbers

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: array[16, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(cast[ptr uint8](buf))
    return
  var tmp: int32 = n
  if tmp < 0:
    tmp = 0 - tmp
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(cast[ptr uint8](buf))

proc strlen(s: ptr uint8): int32 =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  return len

proc strcpy(dst: ptr uint8, src: ptr uint8) =
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dst[i] = src[i]
    i = i + 1
  dst[i] = cast[uint8](0)

# ============ Drawing Primitives ============

proc buf_pixel(x: int32, y: int32, color: int32) =
  if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
    g_fb[y * g_xres + x] = cast[uint32](color)

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < g_yres:
      var cx: int32 = x
      while cx < x + w:
        if cx >= 0 and cx < g_xres:
          g_fb[cy * g_xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

# Simple 8x8 font
var font: array[768, uint8]

proc init_font() =
  var i: int32 = 0
  while i < 768:
    font[i] = cast[uint8](0)
    i = i + 1

  # Space (32)
  # (all zeros)

  # Digits 0-9 (48-57)
  # '0'
  font[384] = cast[uint8](0x3C)
  font[385] = cast[uint8](0x66)
  font[386] = cast[uint8](0x6E)
  font[387] = cast[uint8](0x7E)
  font[388] = cast[uint8](0x76)
  font[389] = cast[uint8](0x66)
  font[390] = cast[uint8](0x3C)
  font[391] = cast[uint8](0x00)
  # '1'
  font[392] = cast[uint8](0x18)
  font[393] = cast[uint8](0x38)
  font[394] = cast[uint8](0x18)
  font[395] = cast[uint8](0x18)
  font[396] = cast[uint8](0x18)
  font[397] = cast[uint8](0x18)
  font[398] = cast[uint8](0x7E)
  font[399] = cast[uint8](0x00)
  # '2'
  font[400] = cast[uint8](0x3C)
  font[401] = cast[uint8](0x66)
  font[402] = cast[uint8](0x06)
  font[403] = cast[uint8](0x0C)
  font[404] = cast[uint8](0x18)
  font[405] = cast[uint8](0x30)
  font[406] = cast[uint8](0x7E)
  font[407] = cast[uint8](0x00)
  # '3'
  font[408] = cast[uint8](0x3C)
  font[409] = cast[uint8](0x66)
  font[410] = cast[uint8](0x06)
  font[411] = cast[uint8](0x1C)
  font[412] = cast[uint8](0x06)
  font[413] = cast[uint8](0x66)
  font[414] = cast[uint8](0x3C)
  font[415] = cast[uint8](0x00)
  # '4'
  font[416] = cast[uint8](0x0C)
  font[417] = cast[uint8](0x1C)
  font[418] = cast[uint8](0x3C)
  font[419] = cast[uint8](0x6C)
  font[420] = cast[uint8](0x7E)
  font[421] = cast[uint8](0x0C)
  font[422] = cast[uint8](0x0C)
  font[423] = cast[uint8](0x00)
  # '5'
  font[424] = cast[uint8](0x7E)
  font[425] = cast[uint8](0x60)
  font[426] = cast[uint8](0x7C)
  font[427] = cast[uint8](0x06)
  font[428] = cast[uint8](0x06)
  font[429] = cast[uint8](0x66)
  font[430] = cast[uint8](0x3C)
  font[431] = cast[uint8](0x00)
  # '6'
  font[432] = cast[uint8](0x1C)
  font[433] = cast[uint8](0x30)
  font[434] = cast[uint8](0x60)
  font[435] = cast[uint8](0x7C)
  font[436] = cast[uint8](0x66)
  font[437] = cast[uint8](0x66)
  font[438] = cast[uint8](0x3C)
  font[439] = cast[uint8](0x00)
  # '7'
  font[440] = cast[uint8](0x7E)
  font[441] = cast[uint8](0x06)
  font[442] = cast[uint8](0x0C)
  font[443] = cast[uint8](0x18)
  font[444] = cast[uint8](0x30)
  font[445] = cast[uint8](0x30)
  font[446] = cast[uint8](0x30)
  font[447] = cast[uint8](0x00)
  # '8'
  font[448] = cast[uint8](0x3C)
  font[449] = cast[uint8](0x66)
  font[450] = cast[uint8](0x66)
  font[451] = cast[uint8](0x3C)
  font[452] = cast[uint8](0x66)
  font[453] = cast[uint8](0x66)
  font[454] = cast[uint8](0x3C)
  font[455] = cast[uint8](0x00)
  # '9'
  font[456] = cast[uint8](0x3C)
  font[457] = cast[uint8](0x66)
  font[458] = cast[uint8](0x66)
  font[459] = cast[uint8](0x3E)
  font[460] = cast[uint8](0x06)
  font[461] = cast[uint8](0x0C)
  font[462] = cast[uint8](0x38)
  font[463] = cast[uint8](0x00)

  # Uppercase letters A-Z (65-90)
  # 'A' = 65
  font[520] = cast[uint8](0x18)
  font[521] = cast[uint8](0x3C)
  font[522] = cast[uint8](0x66)
  font[523] = cast[uint8](0x66)
  font[524] = cast[uint8](0x7E)
  font[525] = cast[uint8](0x66)
  font[526] = cast[uint8](0x66)
  font[527] = cast[uint8](0x00)

  # Lowercase letters (simplified - using same as uppercase for key ones)
  # 'a' = 97
  font[776] = cast[uint8](0x00)
  font[777] = cast[uint8](0x00)
  font[778] = cast[uint8](0x3C)
  font[779] = cast[uint8](0x06)
  font[780] = cast[uint8](0x3E)
  font[781] = cast[uint8](0x66)
  font[782] = cast[uint8](0x3E)
  font[783] = cast[uint8](0x00)

proc draw_char(x: int32, y: int32, c: uint8, color: int32) =
  var idx: int32 = cast[int32](c) * 8
  if idx < 0 or idx >= 760:
    return
  var row: int32 = 0
  while row < 8:
    var bits: uint8 = font[idx + row]
    var col: int32 = 0
    while col < 8:
      var mask: int32 = 128
      var shift: int32 = col
      while shift > 0:
        mask = mask / 2
        shift = shift - 1
      if (cast[int32](bits) & mask) != 0:
        buf_pixel(x + col, y + row, color)
      col = col + 1
    row = row + 1

proc draw_text(x: int32, y: int32, text: ptr uint8, color: int32) =
  var i: int32 = 0
  var cx: int32 = x
  while text[i] != cast[uint8](0):
    draw_char(cx, y, text[i], color)
    cx = cx + FONT_WIDTH
    i = i + 1

proc draw_number(x: int32, y: int32, n: int32, color: int32) =
  var buf: array[12, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    draw_text(x, y, cast[ptr uint8](buf), color)
    return
  var tmp: int32 = n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  draw_text(x, y, cast[ptr uint8](buf), color)

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 512)
  var path: ptr uint8 = cast[ptr uint8](old_brk)
  path[0] = cast[uint8](47)
  path[1] = cast[uint8](100)
  path[2] = cast[uint8](101)
  path[3] = cast[uint8](118)
  path[4] = cast[uint8](47)
  path[5] = cast[uint8](102)
  path[6] = cast[uint8](98)
  path[7] = cast[uint8](48)
  path[8] = cast[uint8](0)

  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  var ret: int32 = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if ret < 0:
    return 1

  g_xres = vinfo[0]
  g_yres = vinfo[1]
  var bpp: int32 = vinfo[6]

  if bpp != 32:
    print_str(cast[ptr uint8]("Error: only 32bpp supported\n"))
    return 1

  var fb_size: int32 = g_xres * g_yres * 4
  g_fb = cast[ptr uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

  if cast[int32](g_fb) < 0:
    return 1

  # Calculate visible area
  g_visible_lines = (g_yres - 30) / FONT_HEIGHT  # Leave room for status bar
  g_visible_cols = (g_xres - g_text_start_x) / FONT_WIDTH

  # Set stdin non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

  return 0

# ============ Text Buffer Operations ============

proc get_line_start(line_num: int32): int32 =
  # Returns position of the start of line_num (0-indexed)
  if line_num <= 0:
    return 0
  var pos: int32 = 0
  var line: int32 = 0
  while pos < g_text_len and line < line_num:
    if g_text[pos] == cast[uint8](10):  # newline
      line = line + 1
    pos = pos + 1
  return pos

proc get_cursor_line(): int32 =
  # Returns which line the cursor is on
  var line: int32 = 0
  var i: int32 = 0
  while i < g_cursor_pos and i < g_text_len:
    if g_text[i] == cast[uint8](10):
      line = line + 1
    i = i + 1
  return line

proc get_cursor_col(): int32 =
  # Returns column position on current line
  var col: int32 = 0
  var i: int32 = g_cursor_pos - 1
  while i >= 0:
    if g_text[i] == cast[uint8](10):
      return col
    col = col + 1
    i = i - 1
  return col

proc get_total_lines(): int32 =
  var lines: int32 = 1
  var i: int32 = 0
  while i < g_text_len:
    if g_text[i] == cast[uint8](10):
      lines = lines + 1
    i = i + 1
  return lines

proc insert_char(c: uint8) =
  if g_text_len >= MAX_TEXT - 1:
    return
  # Shift text after cursor
  var i: int32 = g_text_len
  while i > g_cursor_pos:
    g_text[i] = g_text[i - 1]
    i = i - 1
  g_text[g_cursor_pos] = c
  g_text_len = g_text_len + 1
  g_cursor_pos = g_cursor_pos + 1
  g_modified = 1

proc delete_char() =
  if g_cursor_pos > 0:
    var i: int32 = g_cursor_pos - 1
    while i < g_text_len - 1:
      g_text[i] = g_text[i + 1]
      i = i + 1
    g_text_len = g_text_len - 1
    g_cursor_pos = g_cursor_pos - 1
    g_modified = 1

proc move_cursor_up() =
  var cur_line: int32 = get_cursor_line()
  var cur_col: int32 = get_cursor_col()
  if cur_line > 0:
    var new_line_start: int32 = get_line_start(cur_line - 1)
    var new_line_end: int32 = get_line_start(cur_line) - 1
    var new_line_len: int32 = new_line_end - new_line_start
    if cur_col > new_line_len:
      g_cursor_pos = new_line_end
    else:
      g_cursor_pos = new_line_start + cur_col

proc move_cursor_down() =
  var cur_line: int32 = get_cursor_line()
  var cur_col: int32 = get_cursor_col()
  var total_lines: int32 = get_total_lines()
  if cur_line < total_lines - 1:
    var new_line_start: int32 = get_line_start(cur_line + 1)
    var next_line_start: int32 = get_line_start(cur_line + 2)
    var new_line_len: int32 = next_line_start - new_line_start - 1
    if next_line_start > g_text_len:
      new_line_len = g_text_len - new_line_start
    if cur_col > new_line_len:
      g_cursor_pos = new_line_start + new_line_len
    else:
      g_cursor_pos = new_line_start + cur_col

# ============ File Operations ============

proc load_file(filename: ptr uint8): int32 =
  var fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
  if fd < 0:
    return 1

  # Get file size
  var size: int32 = syscall3(SYS_lseek, fd, 0, SEEK_END)
  discard syscall3(SYS_lseek, fd, 0, SEEK_SET)

  if size > MAX_TEXT - 1:
    size = MAX_TEXT - 1

  if size > 0:
    g_text_len = syscall3(SYS_read, fd, cast[int32](g_text), size)
  else:
    g_text_len = 0

  discard syscall1(SYS_close, fd)
  g_cursor_pos = 0
  g_scroll_y = 0
  g_modified = 0
  strcpy(cast[ptr uint8](g_filename), filename)
  return 0

proc save_file(): int32 =
  if g_filename[0] == cast[uint8](0):
    return 1

  var fd: int32 = syscall3(SYS_open, cast[int32](g_filename), O_WRONLY + O_CREAT + O_TRUNC, 420)  # 0644
  if fd < 0:
    return 1

  if g_text_len > 0:
    discard syscall3(SYS_write, fd, cast[int32](g_text), g_text_len)

  discard syscall1(SYS_close, fd)
  g_modified = 0
  return 0

# ============ Input Handling ============

proc handle_input() =
  var buf: array[16, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 16)

  if n <= 0:
    return

  var c: uint8 = buf[0]

  # Escape sequences (arrow keys)
  if n >= 3 and c == cast[uint8](27) and buf[1] == cast[uint8](91):
    if buf[2] == cast[uint8](65):       # Up
      move_cursor_up()
    else:
      if buf[2] == cast[uint8](66):     # Down
        move_cursor_down()
      else:
        if buf[2] == cast[uint8](67):   # Right
          if g_cursor_pos < g_text_len:
            g_cursor_pos = g_cursor_pos + 1
        else:
          if buf[2] == cast[uint8](68): # Left
            if g_cursor_pos > 0:
              g_cursor_pos = g_cursor_pos - 1
    return

  # Ctrl+Q = quit
  if c == cast[uint8](17):
    g_running = 0
    return

  # Ctrl+S = save
  if c == cast[uint8](19):
    discard save_file()
    return

  # Backspace
  if c == cast[uint8](127) or c == cast[uint8](8):
    delete_char()
    return

  # Enter
  if c == cast[uint8](13) or c == cast[uint8](10):
    insert_char(cast[uint8](10))
    return

  # Tab
  if c == cast[uint8](9):
    var spaces: int32 = 0
    while spaces < TAB_SIZE:
      insert_char(cast[uint8](32))
      spaces = spaces + 1
    return

  # Regular printable characters
  if c >= cast[uint8](32) and c < cast[uint8](127):
    insert_char(c)

# ============ Rendering ============

proc draw_editor() =
  # Clear background
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](BG_COLOR)
    i = i + 1

  # Draw line number gutter
  fill_rect(0, 0, g_text_start_x - 5, g_yres - 24, LINE_NUM_BG)

  # Draw text content
  var line: int32 = g_scroll_y
  var y: int32 = 2
  var pos: int32 = get_line_start(g_scroll_y)

  while line < g_scroll_y + g_visible_lines and pos <= g_text_len:
    # Draw line number
    draw_number(5, y, line + 1, LINE_NUM_FG)

    # Draw line content
    var x: int32 = g_text_start_x
    while pos < g_text_len and g_text[pos] != cast[uint8](10):
      var ch: uint8 = g_text[pos]

      # Draw cursor
      if pos == g_cursor_pos:
        fill_rect(x, y, 2, FONT_HEIGHT, CURSOR_COLOR)

      # Draw character
      if ch >= cast[uint8](32) and ch < cast[uint8](127):
        draw_char(x, y, ch, TEXT_COLOR)
      x = x + FONT_WIDTH
      pos = pos + 1

    # Draw cursor at end of line or on newline
    if pos == g_cursor_pos:
      fill_rect(x, y, 2, FONT_HEIGHT, CURSOR_COLOR)

    if pos < g_text_len and g_text[pos] == cast[uint8](10):
      pos = pos + 1

    line = line + 1
    y = y + FONT_HEIGHT

  # Draw cursor at end of file
  if g_cursor_pos == g_text_len:
    var cursor_line: int32 = get_cursor_line()
    var cursor_col: int32 = get_cursor_col()
    if cursor_line >= g_scroll_y and cursor_line < g_scroll_y + g_visible_lines:
      var cx: int32 = g_text_start_x + cursor_col * FONT_WIDTH
      var cy: int32 = 2 + (cursor_line - g_scroll_y) * FONT_HEIGHT
      fill_rect(cx, cy, 2, FONT_HEIGHT, CURSOR_COLOR)

  # Draw status bar
  var status_y: int32 = g_yres - 22
  fill_rect(0, status_y, g_xres, 22, STATUS_BG)

  # Filename
  if g_filename[0] != cast[uint8](0):
    draw_text(10, status_y + 4, cast[ptr uint8](g_filename), STATUS_FG)
    if g_modified != 0:
      draw_text(10 + strlen(cast[ptr uint8](g_filename)) * FONT_WIDTH, status_y + 4, cast[ptr uint8](" [+]"), STATUS_FG)
  else:
    draw_text(10, status_y + 4, cast[ptr uint8]("[New File]"), STATUS_FG)

  # Line/column indicator
  var cur_line: int32 = get_cursor_line()
  var cur_col: int32 = get_cursor_col()
  var info_x: int32 = g_xres - 150
  draw_text(info_x, status_y + 4, cast[ptr uint8]("Ln "), STATUS_FG)
  draw_number(info_x + 24, status_y + 4, cur_line + 1, STATUS_FG)
  draw_text(info_x + 60, status_y + 4, cast[ptr uint8]("Col "), STATUS_FG)
  draw_number(info_x + 92, status_y + 4, cur_col + 1, STATUS_FG)

# ============ Main ============

proc main(): int32 =
  print_str(cast[ptr uint8]("Notepad - Ctrl+S to save, Ctrl+Q to quit\n"))

  if init_framebuffer() != 0:
    return 1

  init_font()

  # Allocate text buffer
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + MAX_TEXT)
  g_text = cast[ptr uint8](old_brk)
  g_text_len = 0
  g_cursor_pos = 0

  # Initialize empty filename
  g_filename[0] = cast[uint8](0)

  # Main loop
  while g_running != 0:
    handle_input()

    # Ensure cursor is visible (auto-scroll)
    var cursor_line: int32 = get_cursor_line()
    if cursor_line < g_scroll_y:
      g_scroll_y = cursor_line
    if cursor_line >= g_scroll_y + g_visible_lines:
      g_scroll_y = cursor_line - g_visible_lines + 1

    draw_editor()

    # Small delay to reduce CPU usage
    var old_brk2: int32 = syscall1(SYS_brk, 0)
    discard syscall1(SYS_brk, old_brk2 + 16)
    var ts: ptr int32 = cast[ptr int32](old_brk2)
    ts[0] = 0
    ts[1] = 16000000  # 16ms
    const SYS_nanosleep: int32 = 162
    discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

  # Clear screen
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0)
    i = i + 1

  discard syscall1(SYS_close, g_fb_fd)
  return 0

main()
