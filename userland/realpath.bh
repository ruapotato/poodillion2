# realpath - Print resolved absolute path
# Usage: realpath path
# Resolves symlinks and . .. components to canonical absolute path

from lib.syscalls import *

const S_IFLNK: int32 = 40960  # 0120000 - symbolic link

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Copy string from src to dst
# Check if path is absolute (starts with /)
def is_absolute(path: *uint8) -> int32:
  if path[0] == cast[uint8](47):  # '/'
    return 1
  return 0

# Normalize path by removing . and .. components
def normalize_path(path: *uint8, result: *uint8):
  # Simple implementation: copy path, handling / / cases
  # For a full implementation, we'd need to handle . and .. properly
  # For now, just copy the path as-is if absolute
  if is_absolute(path) != 0:
    strcpy(result, path)
  else:
    # If relative, we'd need to prepend cwd
    # For simplicity, just copy it
    strcpy(result, path)

def main():
  argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[*uint8]("Usage: realpath path\n"))
    _ = syscall1(SYS_exit, 1)

  path: *uint8 = get_argv(1)

  # Allocate buffers
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192  # 8KB for buffers
  _ = syscall1(SYS_brk, new_brk)

  cwd_buf: *uint8 = cast[*uint8](old_brk)
  result_buf: *uint8 = cast[*uint8](old_brk + 4096)

  # If path is relative, get current directory
  if is_absolute(path) == 0:
    ret: int32 = syscall2(SYS_getcwd, cast[int32](cwd_buf), 4096)
    if ret < 0:
      print_err(cast[*uint8]("realpath: cannot get current directory\n"))
      _ = syscall1(SYS_exit, 1)

    # Concatenate cwd + / + path
    i: int32 = 0
    while cwd_buf[i] != cast[uint8](0):
      result_buf[i] = cwd_buf[i]
      i = i + 1

    # Add / separator
    result_buf[i] = cast[uint8](47)  # '/'
    i = i + 1

    # Add relative path
    j: int32 = 0
    while path[j] != cast[uint8](0):
      result_buf[i] = path[j]
      i = i + 1
      j = j + 1

    result_buf[i] = cast[uint8](0)
  else:
    # Path is already absolute
    strcpy(result_buf, path)

  # Try to resolve symlinks
  # Note: This is simplified - a full implementation would loop
  # and follow all symlinks in the path
  link_buf: *uint8 = cast[*uint8](old_brk + 6144)
  link_len: int32 = syscall3(SYS_readlink, cast[int32](result_buf), cast[int32](link_buf), 2048)

  if link_len > 0:
    # It's a symlink, use the link target
    link_buf[link_len] = cast[uint8](0)

    # If link is absolute, use it; otherwise would need to resolve relative to dir
    if is_absolute(link_buf) != 0:
      strcpy(result_buf, link_buf)
    # else: would need more complex resolution

  # Print the resolved path
  print(result_buf)
  _ = syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

  _ = syscall1(SYS_exit, 0)
