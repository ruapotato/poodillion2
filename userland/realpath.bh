# realpath - Print resolved absolute path
# Usage: realpath path
# Resolves symlinks and . .. components to canonical absolute path

import "lib/syscalls"

const S_IFLNK: int32 = 40960  # 0120000 - symbolic link

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Copy string from src to dst
# Check if path is absolute (starts with /)
proc is_absolute(path: ptr uint8): int32 =
  if path[0] == cast[uint8](47):  # '/'
    return 1
  return 0

# Normalize path by removing . and .. components
proc normalize_path(path: ptr uint8, result: ptr uint8) =
  # Simple implementation: copy path, handling / / cases
  # For a full implementation, we'd need to handle . and .. properly
  # For now, just copy the path as-is if absolute
  if is_absolute(path) != 0:
    strcpy(result, path)
  else:
    # If relative, we'd need to prepend cwd
    # For simplicity, just copy it
    strcpy(result, path)

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("Usage: realpath path\n"))
    discard syscall1(SYS_exit, 1)

  var path: ptr uint8 = get_argv(1)

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192  # 8KB for buffers
  discard syscall1(SYS_brk, new_brk)

  var cwd_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var result_buf: ptr uint8 = cast[ptr uint8](old_brk + 4096)

  # If path is relative, get current directory
  if is_absolute(path) == 0:
    var ret: int32 = syscall2(SYS_getcwd, cast[int32](cwd_buf), 4096)
    if ret < 0:
      print_err(cast[ptr uint8]("realpath: cannot get current directory\n"))
      discard syscall1(SYS_exit, 1)

    # Concatenate cwd + / + path
    var i: int32 = 0
    while cwd_buf[i] != cast[uint8](0):
      result_buf[i] = cwd_buf[i]
      i = i + 1

    # Add / separator
    result_buf[i] = cast[uint8](47)  # '/'
    i = i + 1

    # Add relative path
    var j: int32 = 0
    while path[j] != cast[uint8](0):
      result_buf[i] = path[j]
      i = i + 1
      j = j + 1

    result_buf[i] = cast[uint8](0)
  else:
    # Path is already absolute
    strcpy(result_buf, path)

  # Try to resolve symlinks
  # Note: This is simplified - a full implementation would loop
  # and follow all symlinks in the path
  var link_buf: ptr uint8 = cast[ptr uint8](old_brk + 6144)
  var link_len: int32 = syscall3(SYS_readlink, cast[int32](result_buf), cast[int32](link_buf), 2048)

  if link_len > 0:
    # It's a symlink, use the link target
    link_buf[link_len] = cast[uint8](0)

    # If link is absolute, use it; otherwise would need to resolve relative to dir
    if is_absolute(link_buf) != 0:
      strcpy(result_buf, link_buf)
    # else: would need more complex resolution

  # Print the resolved path
  print(result_buf)
  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

  discard syscall1(SYS_exit, 0)
