from lib.syscalls import *
from lib.vtnext import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
GRID_SIZE: Final[int32] = 4
TILE_SIZE: Final[int32] = 120
TILE_GAP: Final[int32] = 15
BOARD_X: Final[int32] = 262
BOARD_Y: Final[int32] = 180

grid: Array[16, int32]

score: int32 = 0

best_score: int32 = 0

game_over: int32 = 0

won: int32 = 0

running: int32 = 1

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, (old_brk + 16))
    ts: Ptr[int32] = Ptr[int32](old_brk)
    ts[0] = 0
    ts[1] = (ms * 1000000)
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

rand_seed: int32 = 12345

def rand() -> int32:
    rand_seed = (((rand_seed * 1103515245) + 12345) / 65536)
    if (rand_seed < 0):
        rand_seed = (0 - rand_seed)
    return rand_seed

def get_tile_r(value: int32) -> int32:
    if (value == 0):
        return 205
    if (value == 2):
        return 238
    if (value == 4):
        return 237
    if (value == 8):
        return 242
    if (value == 16):
        return 245
    if (value == 32):
        return 246
    if (value == 64):
        return 246
    if (value == 128):
        return 237
    if (value == 256):
        return 237
    if (value == 512):
        return 237
    if (value == 1024):
        return 237
    if (value == 2048):
        return 237
    return 60

def get_tile_g(value: int32) -> int32:
    if (value == 0):
        return 193
    if (value == 2):
        return 228
    if (value == 4):
        return 224
    if (value == 8):
        return 177
    if (value == 16):
        return 149
    if (value == 32):
        return 124
    if (value == 64):
        return 94
    if (value == 128):
        return 207
    if (value == 256):
        return 204
    if (value == 512):
        return 200
    if (value == 1024):
        return 197
    if (value == 2048):
        return 194
    return 58

def get_tile_b(value: int32) -> int32:
    if (value == 0):
        return 180
    if (value == 2):
        return 218
    if (value == 4):
        return 200
    if (value == 8):
        return 121
    if (value == 16):
        return 99
    if (value == 32):
        return 77
    if (value == 64):
        return 59
    if (value == 128):
        return 114
    if (value == 256):
        return 97
    if (value == 512):
        return 80
    if (value == 1024):
        return 63
    if (value == 2048):
        return 46
    return 56

def get_text_dark(value: int32) -> int32:
    if (value <= 4):
        return 1
    return 0

def add_random_tile():
    empty_count: int32 = 0
    i: int32 = 0
    while (i < 16):
        if (grid[i] == 0):
            empty_count = (empty_count + 1)
        i = (i + 1)
    if (empty_count == 0):
        return
    target: int32 = ((rand() / 100) - (((rand() / 100) / empty_count) * empty_count))
    if (target < 0):
        target = 0
    if (target >= empty_count):
        target = (empty_count - 1)
    count: int32 = 0
    i = 0
    while (i < 16):
        if (grid[i] == 0):
            if (count == target):
                r: int32 = (rand() / 100)
                if ((r - ((r / 10) * 10)) == 0):
                    grid[i] = 4
                else:
                    grid[i] = 2
                return
            count = (count + 1)
        i = (i + 1)

def init_game():
    i: int32 = 0
    while (i < 16):
        grid[i] = 0
        i = (i + 1)
    score = 0
    game_over = 0
    won = 0
    rand_seed = syscall1(SYS_time, 0)
    if (rand_seed < 0):
        rand_seed = (0 - rand_seed)
    rand_seed = (rand_seed + 12345)
    add_random_tile()
    add_random_tile()

def can_move() -> int32:
    i: int32 = 0
    while (i < 16):
        if (grid[i] == 0):
            return 1
        i = (i + 1)
    row: int32 = 0
    while (row < 4):
        col: int32 = 0
        while (col < 3):
            idx: int32 = ((row * 4) + col)
            if (grid[idx] == grid[(idx + 1)]):
                return 1
            col = (col + 1)
        row = (row + 1)
    col2: int32 = 0
    while (col2 < 4):
        row2: int32 = 0
        while (row2 < 3):
            idx: int32 = ((row2 * 4) + col2)
            if (grid[idx] == grid[(idx + 4)]):
                return 1
            row2 = (row2 + 1)
        col2 = (col2 + 1)
    return 0

def move_left() -> int32:
    moved: int32 = 0
    row: int32 = 0
    while (row < 4):
        line: Array[4, int32]
        merged: Array[4, int32]
        i: int32 = 0
        while (i < 4):
            line[i] = grid[((row * 4) + i)]
            merged[i] = 0
            i = (i + 1)
        write_pos: int32 = 0
        i = 0
        while (i < 4):
            if (line[i] != 0):
                if (((write_pos > 0) and (line[(write_pos - 1)] == line[i])) and (merged[(write_pos - 1)] == 0)):
                    line[(write_pos - 1)] = (line[i] * 2)
                    merged[(write_pos - 1)] = 1
                    score = (score + line[(write_pos - 1)])
                    if (line[(write_pos - 1)] == 2048):
                        won = 1
                    line[i] = 0
                    moved = 1
                else:
                    if (write_pos != i):
                        line[write_pos] = line[i]
                        line[i] = 0
                        moved = 1
                    write_pos = (write_pos + 1)
            i = (i + 1)
        i = 0
        while (i < 4):
            grid[((row * 4) + i)] = line[i]
            i = (i + 1)
        row = (row + 1)
    return moved

def move_right() -> int32:
    moved: int32 = 0
    row: int32 = 0
    while (row < 4):
        line: Array[4, int32]
        merged: Array[4, int32]
        i: int32 = 0
        while (i < 4):
            line[i] = grid[((row * 4) + i)]
            merged[i] = 0
            i = (i + 1)
        write_pos: int32 = 3
        i = 3
        while (i >= 0):
            if (line[i] != 0):
                if (((write_pos < 3) and (line[(write_pos + 1)] == line[i])) and (merged[(write_pos + 1)] == 0)):
                    line[(write_pos + 1)] = (line[i] * 2)
                    merged[(write_pos + 1)] = 1
                    score = (score + line[(write_pos + 1)])
                    if (line[(write_pos + 1)] == 2048):
                        won = 1
                    line[i] = 0
                    moved = 1
                else:
                    if (write_pos != i):
                        line[write_pos] = line[i]
                        line[i] = 0
                        moved = 1
                    write_pos = (write_pos - 1)
            i = (i - 1)
        i = 0
        while (i < 4):
            grid[((row * 4) + i)] = line[i]
            i = (i + 1)
        row = (row + 1)
    return moved

def move_up() -> int32:
    moved: int32 = 0
    col: int32 = 0
    while (col < 4):
        line: Array[4, int32]
        merged: Array[4, int32]
        i: int32 = 0
        while (i < 4):
            line[i] = grid[((i * 4) + col)]
            merged[i] = 0
            i = (i + 1)
        write_pos: int32 = 0
        i = 0
        while (i < 4):
            if (line[i] != 0):
                if (((write_pos > 0) and (line[(write_pos - 1)] == line[i])) and (merged[(write_pos - 1)] == 0)):
                    line[(write_pos - 1)] = (line[i] * 2)
                    merged[(write_pos - 1)] = 1
                    score = (score + line[(write_pos - 1)])
                    if (line[(write_pos - 1)] == 2048):
                        won = 1
                    line[i] = 0
                    moved = 1
                else:
                    if (write_pos != i):
                        line[write_pos] = line[i]
                        line[i] = 0
                        moved = 1
                    write_pos = (write_pos + 1)
            i = (i + 1)
        i = 0
        while (i < 4):
            grid[((i * 4) + col)] = line[i]
            i = (i + 1)
        col = (col + 1)
    return moved

def move_down() -> int32:
    moved: int32 = 0
    col: int32 = 0
    while (col < 4):
        line: Array[4, int32]
        merged: Array[4, int32]
        i: int32 = 0
        while (i < 4):
            line[i] = grid[((i * 4) + col)]
            merged[i] = 0
            i = (i + 1)
        write_pos: int32 = 3
        i = 3
        while (i >= 0):
            if (line[i] != 0):
                if (((write_pos < 3) and (line[(write_pos + 1)] == line[i])) and (merged[(write_pos + 1)] == 0)):
                    line[(write_pos + 1)] = (line[i] * 2)
                    merged[(write_pos + 1)] = 1
                    score = (score + line[(write_pos + 1)])
                    if (line[(write_pos + 1)] == 2048):
                        won = 1
                    line[i] = 0
                    moved = 1
                else:
                    if (write_pos != i):
                        line[write_pos] = line[i]
                        line[i] = 0
                        moved = 1
                    write_pos = (write_pos - 1)
            i = (i - 1)
        i = 0
        while (i < 4):
            grid[((i * 4) + col)] = line[i]
            i = (i + 1)
        col = (col + 1)
    return moved

def draw_number(value: int32, x: int32, y: int32, dark: int32):
    if (value == 0):
        return
    digits: Array[8, uint8]
    num: int32 = value
    count: int32 = 0
    while (num > 0):
        digits[count] = cast[uint8]((48 + (num - ((num / 10) * 10))))
        num = (num / 10)
        count = (count + 1)
    s: Array[8, uint8]
    i: int32 = 0
    while (i < count):
        s[i] = digits[((count - 1) - i)]
        i = (i + 1)
    s[count] = cast[uint8](0)
    text_x: int32 = (x + ((TILE_SIZE - (count * 20)) / 2))
    text_y: int32 = (y + ((TILE_SIZE - 30) / 2))
    if (dark != 0):
        vtn_text(Ptr[uint8](addr(s)), text_x, text_y, 0, 0, 3, 119, 110, 101, 255)
    else:
        vtn_text(Ptr[uint8](addr(s)), text_x, text_y, 0, 0, 3, 249, 246, 242, 255)

def render():
    vtn_clear_color(250, 248, 239, 255)
    vtn_text(Ptr[uint8]("2048"), 420, 30, 0, 0, 6, 119, 110, 101, 255)
    vtn_rrect(650, 30, 120, 60, 8, 2, 187, 173, 160, 255, 1)
    vtn_text_simple(Ptr[uint8]("SCORE"), 680, 40, 238, 228, 218)
    score_str: Array[16, uint8]
    num: int32 = score
    count: int32 = 0
    if (num == 0):
        score_str[0] = cast[uint8](48)
        count = 1
    else:
        digits: Array[16, uint8]
        while (num > 0):
            digits[count] = cast[uint8]((48 + (num - ((num / 10) * 10))))
            num = (num / 10)
            count = (count + 1)
        i: int32 = 0
        while (i < count):
            score_str[i] = digits[((count - 1) - i)]
            i = (i + 1)
    score_str[count] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(score_str)), 680, 65, 255, 255, 255)
    vtn_rrect(790, 30, 120, 60, 8, 2, 187, 173, 160, 255, 1)
    vtn_text_simple(Ptr[uint8]("BEST"), 830, 40, 238, 228, 218)
    num = best_score
    count = 0
    if (num == 0):
        score_str[0] = cast[uint8](48)
        count = 1
    else:
        digits2: Array[16, uint8]
        while (num > 0):
            digits2[count] = cast[uint8]((48 + (num - ((num / 10) * 10))))
            num = (num / 10)
            count = (count + 1)
        i: int32 = 0
        while (i < count):
            score_str[i] = digits2[((count - 1) - i)]
            i = (i + 1)
    score_str[count] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(score_str)), 830, 65, 255, 255, 255)
    board_w: int32 = ((TILE_SIZE * 4) + (TILE_GAP * 5))
    vtn_rrect(BOARD_X, BOARD_Y, board_w, board_w, 10, 2, 187, 173, 160, 255, 1)
    row: int32 = 0
    while (row < 4):
        col: int32 = 0
        while (col < 4):
            x: int32 = ((BOARD_X + TILE_GAP) + (col * (TILE_SIZE + TILE_GAP)))
            y: int32 = ((BOARD_Y + TILE_GAP) + (row * (TILE_SIZE + TILE_GAP)))
            value: int32 = grid[((row * 4) + col)]
            vtn_rrect(x, y, TILE_SIZE, TILE_SIZE, 6, 2, get_tile_r(value), get_tile_g(value), get_tile_b(value), 255, 1)
            if (value > 0):
                draw_number(value, x, y, get_text_dark(value))
            col = (col + 1)
        row = (row + 1)
    vtn_text_simple(Ptr[uint8]("Arrow keys to move, R to restart, Q to quit"), 280, ((BOARD_Y + board_w) + 30), 119, 110, 101)
    if (game_over != 0):
        vtn_fill_rect(BOARD_X, BOARD_Y, board_w, board_w, 238, 228, 218, 180)
        vtn_text(Ptr[uint8]("Game Over!"), (BOARD_X + 100), (BOARD_Y + 220), 0, 0, 4, 119, 110, 101, 255)
    elif (won != 0):
        vtn_fill_rect(BOARD_X, BOARD_Y, board_w, board_w, 237, 194, 46, 180)
        vtn_text(Ptr[uint8]("You Win!"), (BOARD_X + 130), (BOARD_Y + 220), 0, 0, 4, 255, 255, 255, 255)
    vtn_flush()

def main() -> int32:
    vtn_init_raw()
    vtn_cursor_hide()
    vtn_flush()
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, (flags | O_NONBLOCK))
    init_game()
    while (running != 0):
        buf: Array[8, uint8]
        n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)
        if (n > 0):
            c: int32 = cast[int32](buf[0])
            if ((c == 113) or (c == 81)):
                running = 0
            elif ((c == 114) or (c == 82)):
                init_game()
            elif ((c == 27) and (n >= 3)):
                if (buf[1] == cast[uint8](91)):
                    moved: int32 = 0
                    if (buf[2] == cast[uint8](65)):
                        moved = move_up()
                    elif (buf[2] == cast[uint8](66)):
                        moved = move_down()
                    elif (buf[2] == cast[uint8](67)):
                        moved = move_right()
                    elif (buf[2] == cast[uint8](68)):
                        moved = move_left()
                    if ((moved != 0) and (game_over == 0)):
                        add_random_tile()
                        if (score > best_score):
                            best_score = score
                        if (can_move() == 0):
                            game_over = 1
        render()
        sleep_ms(16)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags)
    vtn_cursor_show()
    vtn_flush()
    return 0