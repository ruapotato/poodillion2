# nc.bh - Netcat for BrainhairOS
# A simple networking utility for reading/writing network connections
#
# Usage:
#   nc [-l] [-p port] [hostname] [port]
#
# Options:
#   -l           Listen mode (server)
#   -p port      Local port to bind (for listen mode)
#   -v           Verbose output
#   -u           UDP mode (not yet implemented)
#
# Examples:
#   nc example.com 80          Connect to port 80
#   nc -l -p 8080              Listen on port 8080
#   nc 10.0.2.2 1234           Connect to 10.0.2.2:1234
#   echo "GET /" | nc example.com 80

import "lib/syscalls"
import "lib/net"
import "lib/dns"

# Options
var opt_listen: int32 = 0
var opt_port: int32 = 0
var opt_verbose: int32 = 0
var opt_udp: int32 = 0
var opt_host: array[256, uint8]
var opt_remote_port: int32 = 0

# Buffer
const BUF_SIZE: int32 = 4096

proc show_usage() =
  println(cast[ptr uint8]("nc - netcat for BrainhairOS"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Usage: nc [-l] [-p port] [-v] [host] [port]"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Options:"))
  println(cast[ptr uint8]("  -l         Listen mode (act as server)"))
  println(cast[ptr uint8]("  -p port    Local port to use"))
  println(cast[ptr uint8]("  -v         Verbose mode"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Examples:"))
  println(cast[ptr uint8]("  nc 10.0.2.2 80           Connect to host"))
  println(cast[ptr uint8]("  nc -l -p 8080            Listen on port"))
  println(cast[ptr uint8]("  nc example.com 80        Connect with DNS"))

proc verbose(msg: ptr uint8) =
  if opt_verbose != 0:
    print(cast[ptr uint8]("[nc] "))
    println(msg)

proc verbose2(msg: ptr uint8, val: ptr uint8) =
  if opt_verbose != 0:
    print(cast[ptr uint8]("[nc] "))
    print(msg)
    println(val)

proc is_ip_address(host: ptr uint8): int32 =
  var i: int32 = 0
  var dots: int32 = 0
  var has_alpha: int32 = 0
  while host[i] != 0:
    if host[i] == 46:
      dots = dots + 1
    elif host[i] >= 97 and host[i] <= 122:
      has_alpha = 1
    elif host[i] >= 65 and host[i] <= 90:
      has_alpha = 1
    i = i + 1
  if dots == 3 and has_alpha == 0:
    return 1
  return 0

proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  while s[i] >= 48 and s[i] <= 57:
    result = result * 10 + (cast[int32](s[i]) - 48)
    i = i + 1
  return result

proc parse_args(argc: int32, argv: ptr ptr uint8): int32 =
  var i: int32 = 1
  var positional: int32 = 0

  while i < argc:
    var arg: ptr uint8 = argv[i]

    if arg[0] == 45:  # '-'
      if arg[1] == 108 and arg[2] == 0:  # -l
        opt_listen = 1
      elif arg[1] == 112 and arg[2] == 0:  # -p
        i = i + 1
        if i >= argc:
          println(cast[ptr uint8]("nc: -p requires argument"))
          return -1
        opt_port = parse_int(argv[i])
      elif arg[1] == 118 and arg[2] == 0:  # -v
        opt_verbose = 1
      elif arg[1] == 117 and arg[2] == 0:  # -u
        opt_udp = 1
        println(cast[ptr uint8]("nc: UDP mode not yet implemented"))
        return -1
      elif arg[1] == 104 and arg[2] == 0:  # -h
        show_usage()
        return -2
      else:
        print(cast[ptr uint8]("nc: unknown option: "))
        println(arg)
        return -1
    else:
      # Positional argument
      if positional == 0:
        # Host
        var j: int32 = 0
        while arg[j] != 0 and j < 255:
          opt_host[j] = arg[j]
          j = j + 1
        opt_host[j] = 0
        positional = 1
      elif positional == 1:
        # Port
        opt_remote_port = parse_int(arg)
        positional = 2

    i = i + 1

  # Validate arguments
  if opt_listen != 0:
    if opt_port == 0:
      println(cast[ptr uint8]("nc: listen mode requires -p port"))
      return -1
  else:
    if opt_host[0] == 0 or opt_remote_port == 0:
      println(cast[ptr uint8]("nc: connect mode requires host and port"))
      return -1

  return 0

# Client mode: connect to remote host
proc client_mode(): int32 =
  var ip: array[4, uint8]

  verbose2(cast[ptr uint8]("Connecting to "), addr(opt_host[0]))

  # Resolve hostname
  if is_ip_address(addr(opt_host[0])) == 1:
    if parse_ipv4(addr(opt_host[0]), addr(ip[0])) == 0:
      println(cast[ptr uint8]("nc: invalid IP address"))
      return 1
  else:
    verbose(cast[ptr uint8]("Resolving hostname..."))
    if dns_resolve(addr(opt_host[0]), addr(ip[0])) == 0:
      print(cast[ptr uint8]("nc: cannot resolve: "))
      println(addr(opt_host[0]))
      return 1

  if opt_verbose != 0:
    var ip_str: array[16, uint8]
    discard format_ipv4(addr(ip[0]), addr(ip_str[0]))
    verbose2(cast[ptr uint8]("Resolved to: "), addr(ip_str[0]))

  # Connect
  var sock: int32 = net_connect(addr(ip[0]), opt_remote_port)
  if sock < 0:
    println(cast[ptr uint8]("nc: connection failed"))
    return 1

  if net_wait_connected(sock, 10000) == 0:
    println(cast[ptr uint8]("nc: connection timeout"))
    net_close(sock)
    return 1

  verbose(cast[ptr uint8]("Connected"))

  # Main loop: read from stdin, write to socket; read from socket, write to stdout
  var buf: array[4096, uint8]

  while 1:
    net_poll()

    # Check socket state
    var state: int32 = net_state(sock)
    if state == TCP_CLOSED or state == TCP_CLOSE_WAIT:
      verbose(cast[ptr uint8]("Connection closed"))
      break

    # Read from socket, write to stdout
    var n: int32 = net_recv(sock, addr(buf[0]), 4096)
    if n > 0:
      discard write(STDOUT, addr(buf[0]), n)

    # Non-blocking read from stdin (check if data available)
    # For now, just poll the socket
    # TODO: implement select() or poll() syscall for proper I/O multiplexing

    # Small delay to prevent busy-waiting
    var delay: int32 = 0
    while delay < 10000:
      delay = delay + 1

  net_close(sock)
  return 0

# Server mode: listen for connections
proc server_mode(): int32 =
  verbose(cast[ptr uint8]("Starting listener..."))

  print(cast[ptr uint8]("Listening on port "))
  print_int(opt_port)
  println(cast[ptr uint8]("..."))

  var sock: int32 = net_listen(opt_port)
  if sock < 0:
    println(cast[ptr uint8]("nc: cannot listen on port"))
    return 1

  verbose(cast[ptr uint8]("Waiting for connection..."))

  # Wait for connection
  var timeout: int32 = 0
  while timeout < 60000:  # 60 second timeout
    net_poll()

    if net_accept_ready(sock) == 1:
      verbose(cast[ptr uint8]("Connection accepted"))

      # Handle connection
      var buf: array[4096, uint8]

      while 1:
        net_poll()

        var state: int32 = net_state(sock)
        if state == TCP_CLOSED or state == TCP_CLOSE_WAIT:
          verbose(cast[ptr uint8]("Client disconnected"))
          break

        # Read from socket
        var n: int32 = net_recv(sock, addr(buf[0]), 4096)
        if n > 0:
          discard write(STDOUT, addr(buf[0]), n)

        # Small delay
        var delay: int32 = 0
        while delay < 10000:
          delay = delay + 1

      net_close(sock)
      return 0

    # Small delay
    var delay: int32 = 0
    while delay < 100000:
      delay = delay + 1
    timeout = timeout + 10

  println(cast[ptr uint8]("nc: no connection received"))
  net_close(sock)
  return 1

proc main(argc: int32, argv: ptr ptr uint8): int32 =
  if argc < 2:
    show_usage()
    return 1

  var result: int32 = parse_args(argc, argv)
  if result == -2:
    return 0  # Help shown
  if result < 0:
    return 1

  # Initialize DNS
  dns_init()

  if opt_listen != 0:
    return server_mode()
  else:
    return client_mode()
