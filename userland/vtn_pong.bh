from lib.syscalls import *
from lib.vtnext import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
WIDTH: Final[int32] = 1024
HEIGHT: Final[int32] = 768
PADDLE_WIDTH: Final[int32] = 15
PADDLE_HEIGHT: Final[int32] = 100
PADDLE_SPEED: Final[int32] = 8
BALL_SIZE: Final[int32] = 15
BALL_SPEED: Final[int32] = 6
WIN_SCORE: Final[int32] = 10

g_paddle1_y: int32 = 0

g_paddle2_y: int32 = 0

g_ball_x: int32 = 0

g_ball_y: int32 = 0

g_ball_dx: int32 = 5

g_ball_dy: int32 = 3

g_score1: int32 = 0

g_score2: int32 = 0

g_running: int32 = 1

g_paused: int32 = 1

g_game_over: int32 = 0

g_winner: int32 = 0

g_key_w: int32 = 0

g_key_s: int32 = 0

g_key_up: int32 = 0

g_key_down: int32 = 0

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, (old_brk + 16))
    ts: Ptr[int32] = Ptr[int32](old_brk)
    ts[0] = 0
    ts[1] = (ms * 1000000)
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

def init_game():
    g_score1 = 0
    g_score2 = 0
    g_game_over = 0
    g_winner = 0
    g_paused = 1
    g_paddle1_y = ((HEIGHT / 2) - (PADDLE_HEIGHT / 2))
    g_paddle2_y = ((HEIGHT / 2) - (PADDLE_HEIGHT / 2))
    g_ball_x = ((WIDTH / 2) - (BALL_SIZE / 2))
    g_ball_y = ((HEIGHT / 2) - (BALL_SIZE / 2))
    g_ball_dx = BALL_SPEED
    g_ball_dy = 3

def reset_ball(direction: int32):
    g_ball_x = ((WIDTH / 2) - (BALL_SIZE / 2))
    g_ball_y = ((HEIGHT / 2) - (BALL_SIZE / 2))
    if (direction > 0):
        g_ball_dx = BALL_SPEED
    else:
        g_ball_dx = (0 - BALL_SPEED)
    t: int32 = syscall1(SYS_time, 0)
    if ((t - ((t / 2) * 2)) != 0):
        g_ball_dy = 3
    else:
        g_ball_dy = (0 - 3)
    g_paused = 1

def update_paddles():
    if (g_key_w != 0):
        g_paddle1_y = (g_paddle1_y - PADDLE_SPEED)
    if (g_key_s != 0):
        g_paddle1_y = (g_paddle1_y + PADDLE_SPEED)
    if (g_key_up != 0):
        g_paddle2_y = (g_paddle2_y - PADDLE_SPEED)
    if (g_key_down != 0):
        g_paddle2_y = (g_paddle2_y + PADDLE_SPEED)
    if (g_paddle1_y < 0):
        g_paddle1_y = 0
    if (g_paddle1_y > (HEIGHT - PADDLE_HEIGHT)):
        g_paddle1_y = (HEIGHT - PADDLE_HEIGHT)
    if (g_paddle2_y < 0):
        g_paddle2_y = 0
    if (g_paddle2_y > (HEIGHT - PADDLE_HEIGHT)):
        g_paddle2_y = (HEIGHT - PADDLE_HEIGHT)

def update_ball():
    if (g_paused != 0):
        return
    g_ball_x = (g_ball_x + g_ball_dx)
    g_ball_y = (g_ball_y + g_ball_dy)
    if (g_ball_y <= 0):
        g_ball_y = 0
        g_ball_dy = (0 - g_ball_dy)
    if ((g_ball_y + BALL_SIZE) >= HEIGHT):
        g_ball_y = (HEIGHT - BALL_SIZE)
        g_ball_dy = (0 - g_ball_dy)
    paddle1_x: int32 = 50
    if (g_ball_dx < 0):
        if (g_ball_x <= (paddle1_x + PADDLE_WIDTH)):
            if (((g_ball_y + BALL_SIZE) >= g_paddle1_y) and (g_ball_y <= (g_paddle1_y + PADDLE_HEIGHT))):
                g_ball_x = (paddle1_x + PADDLE_WIDTH)
                g_ball_dx = (0 - g_ball_dx)
                hit_offset: int32 = ((g_ball_y + (BALL_SIZE / 2)) - (g_paddle1_y + (PADDLE_HEIGHT / 2)))
                g_ball_dy = (g_ball_dy + (hit_offset / 10))
    paddle2_x: int32 = ((WIDTH - 50) - PADDLE_WIDTH)
    if (g_ball_dx > 0):
        if ((g_ball_x + BALL_SIZE) >= paddle2_x):
            if (((g_ball_y + BALL_SIZE) >= g_paddle2_y) and (g_ball_y <= (g_paddle2_y + PADDLE_HEIGHT))):
                g_ball_x = (paddle2_x - BALL_SIZE)
                g_ball_dx = (0 - g_ball_dx)
                hit_offset: int32 = ((g_ball_y + (BALL_SIZE / 2)) - (g_paddle2_y + (PADDLE_HEIGHT / 2)))
                g_ball_dy = (g_ball_dy + (hit_offset / 10))
    if (g_ball_dy > 8):
        g_ball_dy = 8
    if (g_ball_dy < -8):
        g_ball_dy = -8
    if (g_ball_x <= 0):
        g_score2 = (g_score2 + 1)
        if (g_score2 >= WIN_SCORE):
            g_game_over = 1
            g_winner = 2
        else:
            reset_ball(-1)
    if ((g_ball_x + BALL_SIZE) >= WIDTH):
        g_score1 = (g_score1 + 1)
        if (g_score1 >= WIN_SCORE):
            g_game_over = 1
            g_winner = 1
        else:
            reset_ball(1)

def draw_game():
    vtn_clear_color(20, 30, 50, 255)
    y: int32 = 10
    while (y < (HEIGHT - 10)):
        vtn_fill_rect(((WIDTH / 2) - 3), y, 6, 15, 60, 80, 120, 255)
        y = (y + 30)
    vtn_rrect(50, g_paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, 5, 1, 100, 200, 255, 255, 1)
    vtn_rrect(((WIDTH - 50) - PADDLE_WIDTH), g_paddle2_y, PADDLE_WIDTH, PADDLE_HEIGHT, 5, 1, 255, 100, 150, 255, 1)
    vtn_fill_circle((g_ball_x + (BALL_SIZE / 2)), (g_ball_y + (BALL_SIZE / 2)), (BALL_SIZE / 2), 255, 255, 255, 255)
    score1_x: int32 = ((WIDTH / 4) - 30)
    vtn_text(Ptr[uint8]("0"), score1_x, 50, 10, 0, 4, 100, 200, 255, 200)
    if (g_score1 > 0):
        buf: Array[4, uint8]
        buf[0] = cast[uint8]((48 + g_score1))
        buf[1] = cast[uint8](0)
        vtn_text(Ptr[uint8](addr(buf)), score1_x, 50, 10, 0, 4, 100, 200, 255, 200)
    score2_x: int32 = (((WIDTH * 3) / 4) - 30)
    vtn_text(Ptr[uint8]("0"), score2_x, 50, 10, 0, 4, 255, 100, 150, 200)
    if (g_score2 > 0):
        buf2: Array[4, uint8]
        buf2[0] = cast[uint8]((48 + g_score2))
        buf2[1] = cast[uint8](0)
        vtn_text(Ptr[uint8](addr(buf2)), score2_x, 50, 10, 0, 4, 255, 100, 150, 200)
    vtn_text_simple(Ptr[uint8]("W/S - Player 1"), 20, (HEIGHT - 40), 100, 100, 120)
    vtn_text_simple(Ptr[uint8]("Up/Down - Player 2"), (WIDTH - 180), (HEIGHT - 40), 100, 100, 120)
    vtn_text_simple(Ptr[uint8]("VTNext Pong"), ((WIDTH / 2) - 55), 15, 80, 90, 110)
    if ((g_paused != 0) and (g_game_over == 0)):
        vtn_fill_rect(((WIDTH / 2) - 80), ((HEIGHT / 2) + 150), 160, 30, 40, 50, 70, 200)
        vtn_text_simple(Ptr[uint8]("Press SPACE"), ((WIDTH / 2) - 55), ((HEIGHT / 2) + 155), 200, 200, 200)
    if (g_game_over != 0):
        vtn_fill_rect(((WIDTH / 2) - 100), ((HEIGHT / 2) - 50), 200, 100, 0, 80, 0, 220)
        if (g_winner == 1):
            vtn_text_simple(Ptr[uint8]("Player 1 Wins!"), ((WIDTH / 2) - 60), ((HEIGHT / 2) - 20), 0, 255, 0)
        else:
            vtn_text_simple(Ptr[uint8]("Player 2 Wins!"), ((WIDTH / 2) - 60), ((HEIGHT / 2) - 20), 0, 255, 0)
        vtn_text_simple(Ptr[uint8]("Press R to restart"), ((WIDTH / 2) - 75), ((HEIGHT / 2) + 20), 150, 200, 150)

def handle_input():
    buf: Array[8, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)
    if (n <= 0):
        return
    c: int32 = cast[int32](buf[0])
    if ((c == 27) and (n >= 3)):
        if (buf[1] == cast[uint8](91)):
            if (buf[2] == cast[uint8](65)):
                g_key_up = 1
            elif (buf[2] == cast[uint8](66)):
                g_key_down = 1
    if ((c == 119) or (c == 87)):
        g_key_w = 1
    elif ((c == 115) or (c == 83)):
        g_key_s = 1
    elif (c == 32):
        if (g_game_over == 0):
            g_paused = 0
    elif ((c == 113) or (c == 81)):
        g_running = 0
    elif ((c == 114) or (c == 82)):
        init_game()

def main() -> int32:
    vtn_init_raw()
    vtn_cursor_hide()
    vtn_flush()
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, (flags | O_NONBLOCK))
    init_game()
    while (g_running != 0):
        g_key_up = 0
        g_key_down = 0
        g_key_w = 0
        g_key_s = 0
        handle_input()
        if (g_game_over == 0):
            update_paddles()
            update_ball()
        draw_game()
        vtn_flush()
        sleep_ms(16)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags)
    vtn_cursor_show()
    vtn_flush()
    return 0