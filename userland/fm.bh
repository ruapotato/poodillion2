# fm - Graphical File Manager for Brainhair Display Server
# Shows files and directories with icons, supports navigation

import "lib/syscalls"

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3
const FBIOGET_VSCREENINFO: int32 = 0x4600

# File types (as int32 for comparison)
const DT_DIR: int32 = 4
const DT_REG: int32 = 8
const DT_LNK: int32 = 10

# Display constants
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 10
const ITEM_HEIGHT: int32 = 20
const ICON_SIZE: int32 = 16
const MAX_ENTRIES: int32 = 256
const MAX_NAME: int32 = 64
const ENTRY_SIZE: int32 = 72  # type(1) + pad(7) + name(64)

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var tmp: int32 = n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

# ============ Font Data (8x8 bitmap) ============

proc get_font_row(c: int32, row: int32): int32 =
  if c == 32: return 0
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c >= 65 and c <= 90:  # A-Z
    if c == 65:  # A
      if row == 0: return 0x18
      if row == 1: return 0x3C
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x7E
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 66:  # B
      if row == 0: return 0x7C
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x7C
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x7C
      return 0
    if c == 67:  # C
      if row == 0: return 0x3C
      if row == 1: return 0x66
      if row == 2: return 0x60
      if row == 3: return 0x60
      if row == 4: return 0x60
      if row == 5: return 0x66
      if row == 6: return 0x3C
      return 0
    if c == 68:  # D
      if row == 0: return 0x78
      if row == 1: return 0x6C
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x6C
      if row == 6: return 0x78
      return 0
    if c == 69:  # E
      if row == 0: return 0x7E
      if row == 1: return 0x60
      if row == 2: return 0x60
      if row == 3: return 0x78
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x7E
      return 0
    if c == 70:  # F
      if row == 0: return 0x7E
      if row == 1: return 0x60
      if row == 2: return 0x60
      if row == 3: return 0x78
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x60
      return 0
    if c == 71:  # G
      if row == 0: return 0x3C
      if row == 1: return 0x66
      if row == 2: return 0x60
      if row == 3: return 0x6E
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3E
      return 0
    if c == 72:  # H
      if row == 0: return 0x66
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x7E
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 73:  # I
      if row == 0: return 0x3C
      if row == 1: return 0x18
      if row == 2: return 0x18
      if row == 3: return 0x18
      if row == 4: return 0x18
      if row == 5: return 0x18
      if row == 6: return 0x3C
      return 0
    if c == 74:  # J
      if row == 0: return 0x1E
      if row == 1: return 0x0C
      if row == 2: return 0x0C
      if row == 3: return 0x0C
      if row == 4: return 0x0C
      if row == 5: return 0x6C
      if row == 6: return 0x38
      return 0
    if c == 75:  # K
      if row == 0: return 0x66
      if row == 1: return 0x6C
      if row == 2: return 0x78
      if row == 3: return 0x70
      if row == 4: return 0x78
      if row == 5: return 0x6C
      if row == 6: return 0x66
      return 0
    if c == 76:  # L
      if row == 0: return 0x60
      if row == 1: return 0x60
      if row == 2: return 0x60
      if row == 3: return 0x60
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x7E
      return 0
    if c == 77:  # M
      if row == 0: return 0x63
      if row == 1: return 0x77
      if row == 2: return 0x7F
      if row == 3: return 0x6B
      if row == 4: return 0x63
      if row == 5: return 0x63
      if row == 6: return 0x63
      return 0
    if c == 78:  # N
      if row == 0: return 0x66
      if row == 1: return 0x76
      if row == 2: return 0x7E
      if row == 3: return 0x7E
      if row == 4: return 0x6E
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 79:  # O
      if row == 0: return 0x3C
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3C
      return 0
    if c == 80:  # P
      if row == 0: return 0x7C
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x7C
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x60
      return 0
    if c == 81:  # Q
      if row == 0: return 0x3C
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x6A
      if row == 5: return 0x6C
      if row == 6: return 0x36
      return 0
    if c == 82:  # R
      if row == 0: return 0x7C
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x7C
      if row == 4: return 0x6C
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 83:  # S
      if row == 0: return 0x3C
      if row == 1: return 0x66
      if row == 2: return 0x60
      if row == 3: return 0x3C
      if row == 4: return 0x06
      if row == 5: return 0x66
      if row == 6: return 0x3C
      return 0
    if c == 84:  # T
      if row == 0: return 0x7E
      if row == 1: return 0x18
      if row == 2: return 0x18
      if row == 3: return 0x18
      if row == 4: return 0x18
      if row == 5: return 0x18
      if row == 6: return 0x18
      return 0
    if c == 85:  # U
      if row == 0: return 0x66
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3C
      return 0
    if c == 86:  # V
      if row == 0: return 0x66
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x3C
      if row == 6: return 0x18
      return 0
    if c == 87:  # W
      if row == 0: return 0x63
      if row == 1: return 0x63
      if row == 2: return 0x63
      if row == 3: return 0x6B
      if row == 4: return 0x7F
      if row == 5: return 0x77
      if row == 6: return 0x63
      return 0
    if c == 88:  # X
      if row == 0: return 0x66
      if row == 1: return 0x66
      if row == 2: return 0x3C
      if row == 3: return 0x18
      if row == 4: return 0x3C
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 89:  # Y
      if row == 0: return 0x66
      if row == 1: return 0x66
      if row == 2: return 0x66
      if row == 3: return 0x3C
      if row == 4: return 0x18
      if row == 5: return 0x18
      if row == 6: return 0x18
      return 0
    if c == 90:  # Z
      if row == 0: return 0x7E
      if row == 1: return 0x06
      if row == 2: return 0x0C
      if row == 3: return 0x18
      if row == 4: return 0x30
      if row == 5: return 0x60
      if row == 6: return 0x7E
      return 0
  if c >= 97 and c <= 122:  # a-z
    if c == 97:  # a
      if row == 2: return 0x3C
      if row == 3: return 0x06
      if row == 4: return 0x3E
      if row == 5: return 0x66
      if row == 6: return 0x3E
      return 0
    if c == 98:  # b
      if row == 0: return 0x60
      if row == 1: return 0x60
      if row == 2: return 0x7C
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x7C
      return 0
    if c == 99:  # c
      if row == 2: return 0x3C
      if row == 3: return 0x60
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x3C
      return 0
    if c == 100:  # d
      if row == 0: return 0x06
      if row == 1: return 0x06
      if row == 2: return 0x3E
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3E
      return 0
    if c == 101:  # e
      if row == 2: return 0x3C
      if row == 3: return 0x66
      if row == 4: return 0x7E
      if row == 5: return 0x60
      if row == 6: return 0x3C
      return 0
    if c == 102:  # f
      if row == 0: return 0x1C
      if row == 1: return 0x30
      if row == 2: return 0x7C
      if row == 3: return 0x30
      if row == 4: return 0x30
      if row == 5: return 0x30
      if row == 6: return 0x30
      return 0
    if c == 103:  # g
      if row == 2: return 0x3E
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x3E
      if row == 6: return 0x06
      if row == 7: return 0x3C
      return 0
    if c == 104:  # h
      if row == 0: return 0x60
      if row == 1: return 0x60
      if row == 2: return 0x7C
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 105:  # i
      if row == 0: return 0x18
      if row == 2: return 0x38
      if row == 3: return 0x18
      if row == 4: return 0x18
      if row == 5: return 0x18
      if row == 6: return 0x3C
      return 0
    if c == 106:  # j
      if row == 0: return 0x0C
      if row == 2: return 0x1C
      if row == 3: return 0x0C
      if row == 4: return 0x0C
      if row == 5: return 0x0C
      if row == 6: return 0x6C
      if row == 7: return 0x38
      return 0
    if c == 107:  # k
      if row == 0: return 0x60
      if row == 1: return 0x60
      if row == 2: return 0x66
      if row == 3: return 0x6C
      if row == 4: return 0x78
      if row == 5: return 0x6C
      if row == 6: return 0x66
      return 0
    if c == 108:  # l
      if row == 0: return 0x38
      if row == 1: return 0x18
      if row == 2: return 0x18
      if row == 3: return 0x18
      if row == 4: return 0x18
      if row == 5: return 0x18
      if row == 6: return 0x3C
      return 0
    if c == 109:  # m
      if row == 2: return 0x76
      if row == 3: return 0x7F
      if row == 4: return 0x6B
      if row == 5: return 0x63
      if row == 6: return 0x63
      return 0
    if c == 110:  # n
      if row == 2: return 0x7C
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x66
      return 0
    if c == 111:  # o
      if row == 2: return 0x3C
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3C
      return 0
    if c == 112:  # p
      if row == 2: return 0x7C
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x7C
      if row == 6: return 0x60
      if row == 7: return 0x60
      return 0
    if c == 113:  # q
      if row == 2: return 0x3E
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x3E
      if row == 6: return 0x06
      if row == 7: return 0x06
      return 0
    if c == 114:  # r
      if row == 2: return 0x6C
      if row == 3: return 0x76
      if row == 4: return 0x60
      if row == 5: return 0x60
      if row == 6: return 0x60
      return 0
    if c == 115:  # s
      if row == 2: return 0x3E
      if row == 3: return 0x60
      if row == 4: return 0x3C
      if row == 5: return 0x06
      if row == 6: return 0x7C
      return 0
    if c == 116:  # t
      if row == 0: return 0x30
      if row == 1: return 0x30
      if row == 2: return 0x7C
      if row == 3: return 0x30
      if row == 4: return 0x30
      if row == 5: return 0x30
      if row == 6: return 0x1C
      return 0
    if c == 117:  # u
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x66
      if row == 6: return 0x3E
      return 0
    if c == 118:  # v
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x3C
      if row == 6: return 0x18
      return 0
    if c == 119:  # w
      if row == 2: return 0x63
      if row == 3: return 0x6B
      if row == 4: return 0x6B
      if row == 5: return 0x7F
      if row == 6: return 0x36
      return 0
    if c == 120:  # x
      if row == 2: return 0x66
      if row == 3: return 0x3C
      if row == 4: return 0x18
      if row == 5: return 0x3C
      if row == 6: return 0x66
      return 0
    if c == 121:  # y
      if row == 2: return 0x66
      if row == 3: return 0x66
      if row == 4: return 0x66
      if row == 5: return 0x3E
      if row == 6: return 0x06
      if row == 7: return 0x3C
      return 0
    if c == 122:  # z
      if row == 2: return 0x7E
      if row == 3: return 0x0C
      if row == 4: return 0x18
      if row == 5: return 0x30
      if row == 6: return 0x7E
      return 0
  # Symbols
  if c == 46:  # .
    if row == 6: return 0x18
    return 0
  if c == 47:  # /
    if row == 0: return 0x02
    if row == 1: return 0x04
    if row == 2: return 0x08
    if row == 3: return 0x10
    if row == 4: return 0x20
    if row == 5: return 0x40
    return 0
  if c == 45:  # -
    if row == 3: return 0x7E
    return 0
  if c == 95:  # _
    if row == 7: return 0x7E
    return 0
  return 0xFF

# ============ Drawing Primitives ============

proc fill_rect(fd: int32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32, line_buf: ptr uint32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      if sx < ex:
        var width: int32 = ex - sx
        var i: int32 = 0
        while i < width:
          line_buf[i] = cast[uint32](color)
          i = i + 1
        var offset: int32 = (cy * xres + sx) * 4
        discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
        discard syscall3(SYS_write, fd, cast[int32](line_buf), width * 4)
    cy = cy + 1

proc draw_char(fd: int32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, pixel_buf: ptr uint32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0:
        color = fg
      pixel_buf[col] = cast[uint32](color)
      col = col + 1
    var offset: int32 = ((y + row) * xres + x) * 4
    discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 32)
    row = row + 1

proc draw_text(fd: int32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, pixel_buf: ptr uint32, max_chars: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0) and i < max_chars:
    draw_char(fd, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, pixel_buf)
    i = i + 1

# Draw folder icon (yellow folder shape)
proc draw_folder_icon(fd: int32, x: int32, y: int32, xres: int32, line_buf: ptr uint32) =
  fill_rect(fd, x, y + 2, 6, 2, 0xFFCC00, xres, 999, line_buf)  # Tab
  fill_rect(fd, x, y + 4, 14, 10, 0xFFCC00, xres, 999, line_buf)  # Body
  fill_rect(fd, x + 1, y + 5, 12, 8, 0xFFE066, xres, 999, line_buf)  # Inner

# Draw file icon (white page shape)
proc draw_file_icon(fd: int32, x: int32, y: int32, xres: int32, line_buf: ptr uint32) =
  fill_rect(fd, x, y + 2, 12, 12, 0xFFFFFF, xres, 999, line_buf)  # Body
  fill_rect(fd, x + 8, y + 2, 4, 4, 0xCCCCCC, xres, 999, line_buf)  # Corner fold
  fill_rect(fd, x + 2, y + 6, 8, 1, 0xCCCCCC, xres, 999, line_buf)  # Line 1
  fill_rect(fd, x + 2, y + 8, 8, 1, 0xCCCCCC, xres, 999, line_buf)  # Line 2
  fill_rect(fd, x + 2, y + 10, 6, 1, 0xCCCCCC, xres, 999, line_buf)  # Line 3

# Draw cursor
proc draw_cursor(fd: int32, x: int32, y: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  var i: int32 = 0
  while i < 14:
    # Draw cursor line
    pixel_buf[0] = cast[uint32](0xFFFFFF)
    var offset: int32 = ((y + i) * xres + x) * 4
    discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)
    if i < 10:
      var offset2: int32 = ((y + i) * xres + x + i) * 4
      discard syscall3(SYS_lseek, fd, offset2, SEEK_SET)
      discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)
    i = i + 1

# ============ Directory Reading ============

proc read_directory(fd: int32, entries: ptr uint8, max_entries: int32, buf: ptr uint8): int32 =
  var count: int32 = 0
  var nread: int32 = syscall3(SYS_getdents64, fd, cast[int32](buf), 4096)

  while nread > 0:
    var pos: int32 = 0
    while pos < nread and count < max_entries:
      var d_reclen: int32 = cast[int32](buf[pos + 16]) + cast[int32](buf[pos + 17]) * 256
      var d_type: uint8 = buf[pos + 18]
      var d_name: ptr uint8 = cast[ptr uint8](cast[int32](buf) + pos + 19)

      # Skip . and ..
      if d_name[0] != cast[uint8](46) or (d_name[1] != cast[uint8](0) and (d_name[1] != cast[uint8](46) or d_name[2] != cast[uint8](0))):
        # Store entry: [type(1), pad(7), name(64)]
        var entry_ptr: ptr uint8 = cast[ptr uint8](cast[int32](entries) + count * ENTRY_SIZE)
        entry_ptr[0] = d_type

        # Copy name (max 63 chars + null)
        var i: int32 = 0
        while d_name[i] != cast[uint8](0) and i < MAX_NAME - 1:
          entry_ptr[8 + i] = d_name[i]
          i = i + 1
        entry_ptr[8 + i] = cast[uint8](0)

        count = count + 1

      pos = pos + d_reclen
    nread = syscall3(SYS_getdents64, fd, cast[int32](buf), 4096)

  return count

proc get_entry_type(entries: ptr uint8, idx: int32): uint8 =
  return entries[idx * ENTRY_SIZE]

proc get_entry_name(entries: ptr uint8, idx: int32): ptr uint8 =
  return cast[ptr uint8](cast[int32](entries) + idx * ENTRY_SIZE + 8)

# ============ Main ============

proc main() =
  print_str(cast[ptr uint8]("Brainhair File Manager v0.1\n"))

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDONLY)
  if mouse_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open mouse\n"))
    discard syscall1(SYS_exit, 1)

  var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
  discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Allocate memory (128KB)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 131072
  discard syscall1(SYS_brk, new_brk)

  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var pixel_buf: ptr uint32 = cast[ptr uint32](old_brk + 256)
  var line_buf: ptr uint32 = cast[ptr uint32](old_brk + 512)
  var entries: ptr uint8 = cast[ptr uint8](old_brk + 8192)
  var dirent_buf: ptr uint8 = cast[ptr uint8](old_brk + 32768)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 40960)
  var cwd_buf: ptr uint8 = cast[ptr uint8](old_brk + 41024)

  # Get screen info
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # Window geometry
  var win_x: int32 = 50
  var win_y: int32 = 50
  var win_w: int32 = 500
  var win_h: int32 = 400
  var title_h: int32 = 24
  var list_y: int32 = win_y + title_h + 30

  # Colors
  var bg_color: int32 = 0x1A3A5A
  var win_bg: int32 = 0xF0F0F0
  var title_bg: int32 = 0x2060A0
  var title_fg: int32 = 0xFFFFFF
  var list_bg: int32 = 0xFFFFFF
  var list_fg: int32 = 0x000000
  var sel_bg: int32 = 0x3080D0
  var sel_fg: int32 = 0xFFFFFF
  var path_bg: int32 = 0xE0E0E0

  # Get current directory
  discard syscall2(SYS_getcwd, cast[int32](cwd_buf), 256)

  # Read directory
  var dir_fd: int32 = syscall2(SYS_open, cast[int32]("."), O_RDONLY | O_DIRECTORY)
  var entry_count: int32 = 0
  if dir_fd >= 0:
    entry_count = read_directory(dir_fd, entries, MAX_ENTRIES, dirent_buf)
    discard syscall1(SYS_close, dir_fd)

  print_str(cast[ptr uint8]("Entries: "))
  print_num(entry_count)
  print_str(cast[ptr uint8]("\n"))

  # State
  var cursor_x: int32 = xres / 2
  var cursor_y: int32 = yres / 2
  var selected: int32 = 0
  var scroll_offset: int32 = 0
  var visible_items: int32 = (win_h - title_h - 40) / ITEM_HEIGHT
  var needs_redraw: int32 = 1
  var prev_left: int32 = 0
  var running: int32 = 1

  # Main loop
  while running != 0:
    # Redraw
    if needs_redraw != 0:
      # Background
      fill_rect(fb_fd, 0, 0, xres, yres, bg_color, xres, yres, line_buf)

      # Window shadow
      fill_rect(fb_fd, win_x + 4, win_y + 4, win_w, win_h, 0x0A1A2A, xres, yres, line_buf)

      # Window background
      fill_rect(fb_fd, win_x, win_y, win_w, win_h, win_bg, xres, yres, line_buf)

      # Title bar
      fill_rect(fb_fd, win_x, win_y, win_w, title_h, title_bg, xres, yres, line_buf)
      draw_text(fb_fd, win_x + 8, win_y + 8, cast[ptr uint8]("File Manager"), title_fg, title_bg, xres, pixel_buf, 50)

      # Close button
      fill_rect(fb_fd, win_x + win_w - 22, win_y + 4, 16, 16, 0xDD4444, xres, yres, line_buf)

      # Path bar
      fill_rect(fb_fd, win_x + 4, win_y + title_h + 4, win_w - 8, 20, path_bg, xres, yres, line_buf)
      draw_text(fb_fd, win_x + 8, win_y + title_h + 8, cwd_buf, 0x404040, path_bg, xres, pixel_buf, 60)

      # List background
      fill_rect(fb_fd, win_x + 4, list_y, win_w - 8, win_h - title_h - 40, list_bg, xres, yres, line_buf)

      # List entries
      var i: int32 = 0
      while i < visible_items and i + scroll_offset < entry_count:
        var idx: int32 = i + scroll_offset
        var entry_y: int32 = list_y + i * ITEM_HEIGHT

        var item_bg: int32 = list_bg
        var item_fg: int32 = list_fg
        if idx == selected:
          item_bg = sel_bg
          item_fg = sel_fg
          fill_rect(fb_fd, win_x + 4, entry_y, win_w - 8, ITEM_HEIGHT, item_bg, xres, yres, line_buf)

        var d_type: uint8 = get_entry_type(entries, idx)
        var d_name: ptr uint8 = get_entry_name(entries, idx)

        # Draw icon
        if cast[int32](d_type) == DT_DIR:
          draw_folder_icon(fb_fd, win_x + 8, entry_y + 2, xres, line_buf)
        else:
          draw_file_icon(fb_fd, win_x + 8, entry_y + 2, xres, line_buf)

        # Draw name
        draw_text(fb_fd, win_x + 30, entry_y + 6, d_name, item_fg, item_bg, xres, pixel_buf, 55)

        i = i + 1

      needs_redraw = 0

    # Draw cursor
    draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

    # Read mouse
    var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 3)

    if bytes == 3:
      var btns: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      if (btns & 0x10) != 0: dx = dx - 256
      if (btns & 0x20) != 0: dy = dy - 256

      var left: int32 = btns & 0x01
      var middle: int32 = btns & 0x04

      if middle != 0:
        running = 0

      # Erase cursor area
      fill_rect(fb_fd, cursor_x, cursor_y, 14, 16, bg_color, xres, yres, line_buf)

      # Update cursor
      cursor_x = cursor_x + dx
      cursor_y = cursor_y - dy
      if cursor_x < 0: cursor_x = 0
      if cursor_x >= xres - 14: cursor_x = xres - 15
      if cursor_y < 0: cursor_y = 0
      if cursor_y >= yres - 16: cursor_y = yres - 17

      # Check clicks
      if left != 0 and prev_left == 0:
        # Close button
        if cursor_x >= win_x + win_w - 22 and cursor_x < win_x + win_w - 6:
          if cursor_y >= win_y + 4 and cursor_y < win_y + 20:
            running = 0

        # List click
        if cursor_x >= win_x + 4 and cursor_x < win_x + win_w - 4:
          if cursor_y >= list_y and cursor_y < list_y + visible_items * ITEM_HEIGHT:
            var click_idx: int32 = (cursor_y - list_y) / ITEM_HEIGHT + scroll_offset
            if click_idx < entry_count:
              if click_idx == selected:
                # Double click - navigate into directory
                var d_type: uint8 = get_entry_type(entries, selected)
                if cast[int32](d_type) == DT_DIR:
                  var d_name: ptr uint8 = get_entry_name(entries, selected)
                  discard syscall1(SYS_chdir, cast[int32](d_name))
                  discard syscall2(SYS_getcwd, cast[int32](cwd_buf), 256)

                  dir_fd = syscall2(SYS_open, cast[int32]("."), O_RDONLY | O_DIRECTORY)
                  if dir_fd >= 0:
                    entry_count = read_directory(dir_fd, entries, MAX_ENTRIES, dirent_buf)
                    discard syscall1(SYS_close, dir_fd)
                  selected = 0
                  scroll_offset = 0
              else:
                selected = click_idx
              needs_redraw = 1

      prev_left = left

  # Cleanup
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_close, mouse_fd)

  print_str(cast[ptr uint8]("File Manager closed\n"))
  discard syscall1(SYS_exit, 0)

main()
