# shuf - Shuffle lines randomly
# Usage: shuf [FILE]
# Randomly permute lines from FILE or stdin
# Uses simple LCG random number generator
# Part of BrainhairOS math utilities

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# Global random state
rand_state: uint32

# Print error
def print_err(msg: *uint8, len: int32):
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Initialize random number generator
def init_rand():
  # Try to read from /dev/urandom
  urandom_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/urandom"), O_RDONLY)

  if urandom_fd >= 0:
    # Read 4 bytes for seed - allocate on heap
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 16
    syscall1(SYS_brk, new_brk)
    seed_buf: *int32 = cast[*int32](old_brk)

    n: int32 = syscall3(SYS_read, urandom_fd, cast[int32](seed_buf), 4)
    if n == 4:
      rand_state = cast[uint32](seed_buf[0])
    syscall1(SYS_close, urandom_fd)
  else:
    # Fallback to time
    t: int32 = syscall1(SYS_time, 0)
    rand_state = cast[uint32](t)

  # Ensure non-zero seed
  if rand_state == cast[uint32](0):
    rand_state = cast[uint32](12345)

# Linear Congruential Generator
# Using constants from glibc: a=1103515245, c=12345, m=2^31
def random() -> uint32:
  rand_state = (cast[uint32](1103515245) * rand_state + cast[uint32](12345)) & cast[uint32](2147483647)
  return rand_state

# Random number in range [0, n)
def random_range(n: uint32) -> uint32:
  if n == cast[uint32](0):
    return cast[uint32](0)
  return random() % n

# Swap two line pointers
def swap_lines(lines: *uint32, i: int32, j: int32):
  temp: uint32 = lines[i]
  lines[i] = lines[j]
  lines[j] = temp

# Fisher-Yates shuffle
def shuffle_array(lines: *uint32, count: int32):
  i: int32 = count - 1
  while i > 0:
    j: uint32 = random_range(cast[uint32](i + 1))
    swap_lines(lines, i, cast[int32](j))
    i = i - 1

# Read all input and store line pointers
def read_and_shuffle(fd: int32):
  # Allocate large buffer for input (64KB)
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 65536
  syscall1(SYS_brk, new_brk)
  buffer: *uint8 = cast[*uint8](old_brk)

  # Read all input
  total: int32 = 0
  running: int32 = 1

  while running != 0:
    n: int32 = syscall3(SYS_read, fd, cast[int32](buffer + total), 65536 - total)
    if n <= 0:
      running = 0
    else:
      total = total + n
      if total >= 65536:
        running = 0  # Buffer full, stop reading

  if total == 0:
    syscall1(SYS_exit, 0)

  # Count lines and store pointers
  # Allocate space for line pointers (max 4096 lines)
  old_brk = syscall1(SYS_brk, 0)
  new_brk = old_brk + 16384  # 4096 * 4 bytes
  syscall1(SYS_brk, new_brk)
  line_ptrs: *uint32 = cast[*uint32](old_brk)

  line_count: int32 = 0
  line_start: int32 = 0
  i: int32 = 0

  while i < total:
    if buffer[i] == cast[uint8](10):  # newline
      # Store line pointer (offset from buffer)
      line_ptrs[line_count] = cast[uint32](line_start)
      line_count = line_count + 1
      line_start = i + 1

      if line_count >= 4096:
        break  # Max lines reached
    i = i + 1

  # Handle last line if no trailing newline
  if line_start < total:
    if line_count < 4096:
      line_ptrs[line_count] = cast[uint32](line_start)
      line_count = line_count + 1

  # Shuffle line pointers
  shuffle_array(line_ptrs, line_count)

  # Output shuffled lines
  j: int32 = 0
  while j < line_count:
    start: int32 = cast[int32](line_ptrs[j])
    end: int32 = start

    # Find end of line
    while end < total and buffer[end] != cast[uint8](10):
      end = end + 1

    # Write line
    if end > start:
      syscall3(SYS_write, STDOUT, cast[int32](buffer + start), end - start)

    # Write newline
    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

    j = j + 1

def main():
  argc: int32 = get_argc()

  # Initialize random seed
  init_rand()

  fd: int32

  if argc < 2:
    # Read from stdin
    fd = STDIN
  else:
    # Open file
    filename: *uint8 = get_argv(1)
    fd = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
    if fd < 0:
      print_err(cast[*uint8]("shuf: cannot open file\n"), 23)
      syscall1(SYS_exit, 1)

  # Read and shuffle
  read_and_shuffle(fd)

  # Close file if not stdin
  if fd != STDIN:
    syscall1(SYS_close, fd)

  syscall1(SYS_exit, 0)
