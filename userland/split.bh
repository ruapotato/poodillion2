# split - split file into pieces
# Usage: split [-l LINES] [FILE] [PREFIX]
# Default: 1000 lines per piece, prefix = x

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

# Build output filename: prefix + suffix (aa, ab, ac, ...)
def make_filename(base: *uint8, idx: int32, dest: *uint8):
  strcpy(dest, base)
  len: int32 = strlen(base)
  first: int32 = idx / 26
  second: int32 = idx % 26
  dest[len] = cast[uint8](97 + first)
  dest[len + 1] = cast[uint8](97 + second)
  dest[len + 2] = cast[uint8](0)

def main():
  argc: int32 = get_argc()
  lines_per_file: int32 = 1000
  input_fd: int32 = STDIN
  prefix: *uint8 = cast[*uint8]("x")
  arg_idx: int32 = 1

  # Parse arguments
  if argc > 1:
    arg: *uint8 = get_argv(arg_idx)
    # Check for -l option
    if arg[0] == cast[uint8](45):  # '-'
      if arg[1] == cast[uint8](108):  # 'l'
        arg_idx = arg_idx + 1
        if argc > arg_idx:
          arg = get_argv(arg_idx)
          lines_per_file = parse_int(arg)
          if lines_per_file <= 0:
            lines_per_file = 1000
          arg_idx = arg_idx + 1

  # Get input file
  if argc > arg_idx:
    filename: *uint8 = get_argv(arg_idx)
    input_fd = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
    if input_fd < 0:
      print_err(cast[*uint8]("split: cannot open input file\n"))
      syscall1(SYS_exit, 1)
    arg_idx = arg_idx + 1

  # Get prefix
  if argc > arg_idx:
    prefix = get_argv(arg_idx)

  # Allocate buffers
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  syscall1(SYS_brk, new_brk)
  buffer: *uint8 = cast[*uint8](old_brk)
  out_name: *uint8 = cast[*uint8](old_brk + 4096)
  line_buf: *uint8 = cast[*uint8](old_brk + 4096 + 256)

  file_count: int32 = 0
  line_count: int32 = 0
  out_fd: int32 = -1

  buf_pos: int32 = 0
  buf_size: int32 = 0
  running: int32 = 1

  while running != 0:
    # Open new output file if needed
    if line_count == 0:
      if out_fd >= 0:
        syscall1(SYS_close, out_fd)
      make_filename(prefix, file_count, out_name)
      out_fd = syscall3(SYS_open, cast[int32](out_name), O_WRONLY + O_CREAT + O_TRUNC, 420)
      if out_fd < 0:
        print_err(cast[*uint8]("split: cannot create output file\n"))
        syscall1(SYS_exit, 1)
      file_count = file_count + 1

    # Read and process a line
    line_start: int32 = 0
    line_done: int32 = 0

    while line_done == 0:
      # Need more data?
      if buf_pos >= buf_size:
        buf_size = syscall3(SYS_read, input_fd, cast[int32](buffer), 4096)
        buf_pos = 0
        if buf_size <= 0:
          running = 0
          line_done = 1
          break

      if buf_pos < buf_size:
        c: uint8 = buffer[buf_pos]
        buf_pos = buf_pos + 1

        line_buf[line_start] = c
        line_start = line_start + 1

        if c == cast[uint8](10):  # newline
          line_done = 1

    # Write the line to output
    if line_start > 0:
      syscall3(SYS_write, out_fd, cast[int32](line_buf), line_start)
      line_count = line_count + 1

      # Check if we need a new file
      if line_count >= lines_per_file:
        line_count = 0

  # Close files
  if out_fd >= 0:
    syscall1(SYS_close, out_fd)
  if input_fd != STDIN:
    syscall1(SYS_close, input_fd)

  syscall1(SYS_exit, 0)
