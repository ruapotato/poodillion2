# kill - Send signal to process
# Usage: kill PID or kill -9 PID

const SYS_write: int32 = 4
const SYS_exit: int32 = 1
const SYS_kill: int32 = 37
const SYS_brk: int32 = 45

const STDOUT: int32 = 1
const STDERR: int32 = 2

const SIGTERM: int32 = 15
const SIGKILL: int32 = 9

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32

proc strlen(s: ptr uint8): int32 =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    i = i + 1
  return i

proc print(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDOUT, cast[int32](msg), len)

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Parse integer from string
proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  # Skip leading whitespace
  while s[i] == cast[uint8](32):
    i = i + 1
  # Handle negative
  var neg: int32 = 0
  if s[i] == cast[uint8](45):  # '-'
    neg = 1
    i = i + 1
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  if neg == 1:
    result = 0 - result
  return result

# Check if string starts with prefix
proc starts_with(s: ptr uint8, prefix: ptr uint8): int32 =
  var i: int32 = 0
  while prefix[i] != cast[uint8](0):
    if s[i] != prefix[i]:
      return 0
    i = i + 1
  return 1

proc main() =
  # Get command line arguments from environment
  # argc is at [esp], argv is at [esp+4]
  # In Brainhair, we need to simulate this
  # For now, read from a simple buffer

  # Allocate memory for argument parsing
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)

  # For this simple implementation, we'll parse a hardcoded example
  # In a real implementation, this would come from argc/argv
  # Example: "kill 1234" or "kill -9 1234"

  # Since we don't have argc/argv yet, we'll implement the logic
  # that can work when called from a shell that passes arguments

  # Default: SIGTERM (15), PID 1 (for testing)
  var signal: int32 = SIGTERM
  var pid: int32 = 1

  # Usage message
  print_err(cast[ptr uint8]("Usage: kill [-SIGNAL] PID\n"))
  print_err(cast[ptr uint8]("  kill PID       - Send SIGTERM (15) to process\n"))
  print_err(cast[ptr uint8]("  kill -9 PID    - Send SIGKILL (9) to process\n"))
  print_err(cast[ptr uint8]("  kill -15 PID   - Send SIGTERM (15) to process\n"))

  # For testing without args, just demonstrate the syscall
  # This will fail unless running as root or killing own process
  # In a real shell, arguments would be parsed here

  # Example: Send SIGTERM to PID 1 (will likely fail with EPERM)
  var result: int32 = syscall2(SYS_kill, pid, signal)

  if result < 0:
    print_err(cast[ptr uint8]("kill: failed to send signal\n"))
    discard syscall1(SYS_exit, 1)

  print(cast[ptr uint8]("Signal sent successfully\n"))
  discard syscall1(SYS_exit, 0)
