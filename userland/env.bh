# env - Run program in modified environment
# Usage: env (prints environment)
#        env VAR=VAL COMMAND (runs command with environment)

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# Check if string contains '=' (is an environment variable assignment)
def is_env_var(s: *uint8) -> int32:
    i: int32 = 0
    while s[i] != cast[uint8](0):
        if s[i] == cast[uint8](61):  # '='
            return 1
        i = i + 1
    return 0

# Read and print environment from /proc/self/environ
def print_environ():
    fd: int32 = open("/proc/self/environ", O_RDONLY, 0)
    if fd < 0:
        perror("env: cannot open /proc/self/environ")
        exit(1)

    # Allocate read buffer
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 8192
    syscall1(SYS_brk, new_brk)
    buf: *uint8 = cast[*uint8](old_brk)

    # Read environment (null-separated strings)
    total_read: int32 = 0
    while 1 == 1:
        n: int32 = read(fd, cast[*uint8](cast[int32](buf) + total_read), 8192 - total_read)
        if n <= 0:
            break
        total_read = total_read + n

    close(fd)

    # Print each environment variable (replace null with newline)
    i: int32 = 0
    line_start: int32 = 0
    while i < total_read:
        if buf[i] == cast[uint8](0):
            if i > line_start:
                # Print line
                write(STDOUT, cast[*uint8](cast[int32](buf) + line_start), i - line_start)
                newline()
            line_start = i + 1
        i = i + 1

def main() -> int32:
    argc: int32 = get_argc()

    # No arguments: print environment
    if argc == 1:
        print_environ()
        return 0

    # Allocate memory for building environment and argv
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 16384  # 16KB
    syscall1(SYS_brk, new_brk)

    # Memory layout:
    # 0-4096: envp array (256 pointers)
    # 4096-8192: argv array (256 pointers)
    # 8192-16384: environment storage
    envp_array: *int32 = cast[*int32](old_brk)
    argv_array: *int32 = cast[*int32](old_brk + 4096)
    env_storage: *uint8 = cast[*uint8](old_brk + 8192)
    env_pos: int32 = 0

    # Parse arguments
    arg_idx: int32 = 1
    env_count: int32 = 0

    # First, collect VAR=VAL assignments
    while arg_idx < argc:
        arg: *uint8 = get_argv(arg_idx)
        if is_env_var(arg) == 0:
            break  # Not an env var, must be command

        # Copy to env storage
        j: int32 = 0
        while arg[j] != cast[uint8](0):
            env_storage[env_pos + j] = arg[j]
            j = j + 1
        env_storage[env_pos + j] = cast[uint8](0)

        # Add to envp
        envp_array[env_count] = cast[int32](env_storage) + env_pos
        env_count = env_count + 1
        env_pos = env_pos + j + 1

        arg_idx = arg_idx + 1

    # Null terminate envp
    envp_array[env_count] = 0

    # If no command specified, just print environment vars
    if arg_idx >= argc:
        i: int32 = 0
        while i < env_count:
            env_str: *uint8 = cast[*uint8](envp_array[i])
            println(env_str)
            i = i + 1
        return 0

    # Build argv for command
    cmd_argc: int32 = 0
    while arg_idx < argc:
        argv_array[cmd_argc] = cast[int32](get_argv(arg_idx))
        cmd_argc = cmd_argc + 1
        arg_idx = arg_idx + 1

    # Null terminate argv
    argv_array[cmd_argc] = 0

    # Execute command
    cmd: *uint8 = cast[*uint8](argv_array[0])
    env_ptr: int32 = 0
    if env_count > 0:
        env_ptr = cast[int32](envp_array)

    execve(cmd, argv_array, cast[*int32](env_ptr))

    # If execve returns, it failed
    perror("env: exec failed")
    return 1
