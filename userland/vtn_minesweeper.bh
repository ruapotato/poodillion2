from lib.syscalls import *
from lib.vtnext import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
SCREEN_WIDTH: Final[int32] = 1024
SCREEN_HEIGHT: Final[int32] = 768
GRID_WIDTH: Final[int32] = 16
GRID_HEIGHT: Final[int32] = 16
MINE_COUNT: Final[int32] = 40
CELL_SIZE: Final[int32] = 36
GRID_LEFT: Final[int32] = 224
GRID_TOP: Final[int32] = 150
CELL_HIDDEN: Final[int32] = 0
CELL_REVEALED: Final[int32] = 1
CELL_FLAGGED: Final[int32] = 2
BG_R: Final[int32] = 50
BG_G: Final[int32] = 55
BG_B: Final[int32] = 65
HIDDEN_R: Final[int32] = 130
HIDDEN_G: Final[int32] = 140
HIDDEN_B: Final[int32] = 160
HIDDEN_LIGHT_R: Final[int32] = 150
HIDDEN_LIGHT_G: Final[int32] = 160
HIDDEN_LIGHT_B: Final[int32] = 180
REVEALED_R: Final[int32] = 180
REVEALED_G: Final[int32] = 185
REVEALED_B: Final[int32] = 195
MINE_R: Final[int32] = 40
MINE_G: Final[int32] = 40
MINE_B: Final[int32] = 45
FLAG_R: Final[int32] = 255
FLAG_G: Final[int32] = 80
FLAG_B: Final[int32] = 80
TEXT_R: Final[int32] = 220
TEXT_G: Final[int32] = 225
TEXT_B: Final[int32] = 230

num_colors_r: Array[9, int32]

num_colors_g: Array[9, int32]

num_colors_b: Array[9, int32]

grid: Array[256, int32]

state: Array[256, int32]

cursor_x: int32 = 8

cursor_y: int32 = 8

game_over: int32 = 0

game_won: int32 = 0

running: int32 = 1

first_click: int32 = 1

flags_placed: int32 = 0

cells_revealed: int32 = 0

rand_seed: int32 = 12345

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, (old_brk + 16))
    ts: Ptr[int32] = Ptr[int32](old_brk)
    ts[0] = 0
    ts[1] = (ms * 1000000)
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

def rand() -> int32:
    rand_seed = ((rand_seed * 1103515245) + 12345)
    r: int32 = rand_seed
    if (r < 0):
        r = (0 - r)
    return r

def get_cell(x: int32, y: int32) -> int32:
    if ((x < 0) or (x >= GRID_WIDTH)):
        return 0
    if ((y < 0) or (y >= GRID_HEIGHT)):
        return 0
    return grid[((y * GRID_WIDTH) + x)]

def set_cell(x: int32, y: int32, val: int32):
    if ((x < 0) or (x >= GRID_WIDTH)):
        return
    if ((y < 0) or (y >= GRID_HEIGHT)):
        return
    grid[((y * GRID_WIDTH) + x)] = val

def get_state(x: int32, y: int32) -> int32:
    if ((x < 0) or (x >= GRID_WIDTH)):
        return CELL_REVEALED
    if ((y < 0) or (y >= GRID_HEIGHT)):
        return CELL_REVEALED
    return state[((y * GRID_WIDTH) + x)]

def set_state(x: int32, y: int32, val: int32):
    if ((x < 0) or (x >= GRID_WIDTH)):
        return
    if ((y < 0) or (y >= GRID_HEIGHT)):
        return
    state[((y * GRID_WIDTH) + x)] = val

def count_adjacent_mines(x: int32, y: int32) -> int32:
    count: int32 = 0
    dx: int32 = -1
    while (dx <= 1):
        dy: int32 = -1
        while (dy <= 1):
            if ((dx != 0) or (dy != 0)):
                if (get_cell((x + dx), (y + dy)) == -1):
                    count = (count + 1)
            dy = (dy + 1)
        dx = (dx + 1)
    return count

def init_game():
    num_colors_r[1] = 50
    num_colors_g[1] = 100
    num_colors_b[1] = 200
    num_colors_r[2] = 50
    num_colors_g[2] = 150
    num_colors_b[2] = 50
    num_colors_r[3] = 200
    num_colors_g[3] = 50
    num_colors_b[3] = 50
    num_colors_r[4] = 100
    num_colors_g[4] = 50
    num_colors_b[4] = 150
    num_colors_r[5] = 150
    num_colors_g[5] = 50
    num_colors_b[5] = 50
    num_colors_r[6] = 50
    num_colors_g[6] = 150
    num_colors_b[6] = 150
    num_colors_r[7] = 50
    num_colors_g[7] = 50
    num_colors_b[7] = 50
    num_colors_r[8] = 100
    num_colors_g[8] = 100
    num_colors_b[8] = 100
    i: int32 = 0
    while (i < (GRID_WIDTH * GRID_HEIGHT)):
        grid[i] = 0
        state[i] = CELL_HIDDEN
        i = (i + 1)
    game_over = 0
    game_won = 0
    first_click = 1
    flags_placed = 0
    cells_revealed = 0

def place_mines(safe_x: int32, safe_y: int32):
    placed: int32 = 0
    while (placed < MINE_COUNT):
        x: int32 = (rand() - ((rand() / GRID_WIDTH) * GRID_WIDTH))
        y: int32 = (rand() - ((rand() / GRID_HEIGHT) * GRID_HEIGHT))
        dx: int32 = (x - safe_x)
        dy: int32 = (y - safe_y)
        if (dx < 0):
            dx = (0 - dx)
        if (dy < 0):
            dy = (0 - dy)
        if ((dx > 1) or (dy > 1)):
            if (get_cell(x, y) != -1):
                set_cell(x, y, -1)
                placed = (placed + 1)
    y: int32 = 0
    while (y < GRID_HEIGHT):
        x: int32 = 0
        while (x < GRID_WIDTH):
            if (get_cell(x, y) != -1):
                set_cell(x, y, count_adjacent_mines(x, y))
            x = (x + 1)
        y = (y + 1)

def reveal_cell(x: int32, y: int32):
    if ((x < 0) or (x >= GRID_WIDTH)):
        return
    if ((y < 0) or (y >= GRID_HEIGHT)):
        return
    st: int32 = get_state(x, y)
    if (st != CELL_HIDDEN):
        return
    set_state(x, y, CELL_REVEALED)
    cells_revealed = (cells_revealed + 1)
    cell: int32 = get_cell(x, y)
    if (cell == -1):
        game_over = 1
        return
    if (cell == 0):
        dx: int32 = -1
        while (dx <= 1):
            dy: int32 = -1
            while (dy <= 1):
                if ((dx != 0) or (dy != 0)):
                    reveal_cell((x + dx), (y + dy))
                dy = (dy + 1)
            dx = (dx + 1)

def check_win():
    required: int32 = ((GRID_WIDTH * GRID_HEIGHT) - MINE_COUNT)
    if (cells_revealed == required):
        game_won = 1
        game_over = 1

def click_cell():
    if (game_over != 0):
        return
    st: int32 = get_state(cursor_x, cursor_y)
    if (st == CELL_FLAGGED):
        return
    if (first_click != 0):
        first_click = 0
        place_mines(cursor_x, cursor_y)
    reveal_cell(cursor_x, cursor_y)
    check_win()

def toggle_flag():
    if (game_over != 0):
        return
    st: int32 = get_state(cursor_x, cursor_y)
    if (st == CELL_HIDDEN):
        set_state(cursor_x, cursor_y, CELL_FLAGGED)
        flags_placed = (flags_placed + 1)
    elif (st == CELL_FLAGGED):
        set_state(cursor_x, cursor_y, CELL_HIDDEN)
        flags_placed = (flags_placed - 1)

def draw_cell(x: int32, y: int32):
    px: int32 = (GRID_LEFT + (x * CELL_SIZE))
    py: int32 = (GRID_TOP + (y * CELL_SIZE))
    st: int32 = get_state(x, y)
    cell: int32 = get_cell(x, y)
    is_cursor: int32 = 0
    if ((x == cursor_x) and (y == cursor_y)):
        is_cursor = 1
    if (st == CELL_HIDDEN):
        vtn_fill_rect(px, py, (CELL_SIZE - 1), (CELL_SIZE - 1), HIDDEN_R, HIDDEN_G, HIDDEN_B, 255)
        vtn_fill_rect(px, py, (CELL_SIZE - 2), 2, HIDDEN_LIGHT_R, HIDDEN_LIGHT_G, HIDDEN_LIGHT_B, 255)
        vtn_fill_rect(px, py, 2, (CELL_SIZE - 2), HIDDEN_LIGHT_R, HIDDEN_LIGHT_G, HIDDEN_LIGHT_B, 255)
        vtn_fill_rect((px + 2), ((py + CELL_SIZE) - 3), (CELL_SIZE - 3), 2, 80, 85, 95, 255)
        vtn_fill_rect(((px + CELL_SIZE) - 3), (py + 2), 2, (CELL_SIZE - 4), 80, 85, 95, 255)
    elif (st == CELL_FLAGGED):
        vtn_fill_rect(px, py, (CELL_SIZE - 1), (CELL_SIZE - 1), HIDDEN_R, HIDDEN_G, HIDDEN_B, 255)
        vtn_fill_rect(px, py, (CELL_SIZE - 2), 2, HIDDEN_LIGHT_R, HIDDEN_LIGHT_G, HIDDEN_LIGHT_B, 255)
        vtn_fill_rect(px, py, 2, (CELL_SIZE - 2), HIDDEN_LIGHT_R, HIDDEN_LIGHT_G, HIDDEN_LIGHT_B, 255)
        vtn_fill_rect((px + 2), ((py + CELL_SIZE) - 3), (CELL_SIZE - 3), 2, 80, 85, 95, 255)
        vtn_fill_rect(((px + CELL_SIZE) - 3), (py + 2), 2, (CELL_SIZE - 4), 80, 85, 95, 255)
        fx: int32 = ((px + (CELL_SIZE / 2)) - 4)
        fy: int32 = (py + 6)
        vtn_fill_rect((fx + 4), (fy + 4), 2, 18, 60, 60, 70, 255)
        vtn_fill_rect(fx, fy, 10, 3, FLAG_R, FLAG_G, FLAG_B, 255)
        vtn_fill_rect((fx + 2), (fy + 3), 8, 3, FLAG_R, FLAG_G, FLAG_B, 255)
        vtn_fill_rect((fx + 4), (fy + 6), 6, 2, FLAG_R, FLAG_G, FLAG_B, 255)
    else:
        vtn_fill_rect(px, py, (CELL_SIZE - 1), (CELL_SIZE - 1), REVEALED_R, REVEALED_G, REVEALED_B, 255)
        vtn_fill_rect(px, py, (CELL_SIZE - 1), 1, 150, 155, 165, 255)
        vtn_fill_rect(px, py, 1, (CELL_SIZE - 1), 150, 155, 165, 255)
        if (cell == -1):
            mx: int32 = (px + (CELL_SIZE / 2))
            my: int32 = (py + (CELL_SIZE / 2))
            vtn_fill_circle(mx, my, 10, MINE_R, MINE_G, MINE_B, 255)
            vtn_fill_rect((mx - 12), (my - 1), 24, 3, MINE_R, MINE_G, MINE_B, 255)
            vtn_fill_rect((mx - 1), (my - 12), 3, 24, MINE_R, MINE_G, MINE_B, 255)
            vtn_fill_rect((mx - 4), (my - 4), 3, 3, 100, 100, 110, 255)
        elif (cell > 0):
            num_str: Array[2, uint8]
            num_str[0] = cast[uint8]((48 + cell))
            num_str[1] = cast[uint8](0)
            tx: int32 = ((px + (CELL_SIZE / 2)) - 4)
            ty: int32 = ((py + (CELL_SIZE / 2)) - 8)
            vtn_text_simple(Ptr[uint8](addr(num_str)), tx, ty, num_colors_r[cell], num_colors_g[cell], num_colors_b[cell])
    if (is_cursor != 0):
        vtn_fill_rect((px - 2), (py - 2), (CELL_SIZE + 3), 3, 255, 220, 100, 255)
        vtn_fill_rect((px - 2), (py - 2), 3, (CELL_SIZE + 3), 255, 220, 100, 255)
        vtn_fill_rect((px - 2), ((py + CELL_SIZE) - 2), (CELL_SIZE + 3), 3, 255, 220, 100, 255)
        vtn_fill_rect(((px + CELL_SIZE) - 2), (py - 2), 3, (CELL_SIZE + 3), 255, 220, 100, 255)

def render():
    vtn_clear_color(BG_R, BG_G, BG_B, 255)
    vtn_text_simple(Ptr[uint8]("MINESWEEPER"), ((SCREEN_WIDTH / 2) - 60), 30, 200, 210, 220)
    mines_left: int32 = (MINE_COUNT - flags_placed)
    counter_str: Array[20, uint8]
    pos: int32 = 0
    counter_str[pos] = cast[uint8](77)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](105)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](110)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](101)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](115)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](58)
    pos = (pos + 1)
    counter_str[pos] = cast[uint8](32)
    pos = (pos + 1)
    num: int32 = mines_left
    if (num < 0):
        counter_str[pos] = cast[uint8](45)
        pos = (pos + 1)
        num = (0 - num)
    digits: Array[10, uint8]
    dcount: int32 = 0
    if (num == 0):
        digits[0] = cast[uint8](48)
        dcount = 1
    else:
        while (num > 0):
            digits[dcount] = cast[uint8]((48 + (num - ((num / 10) * 10))))
            num = (num / 10)
            dcount = (dcount + 1)
    i: int32 = (dcount - 1)
    while (i >= 0):
        counter_str[pos] = digits[i]
        pos = (pos + 1)
        i = (i - 1)
    counter_str[pos] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(counter_str)), 50, 70, 255, 100, 100)
    y: int32 = 0
    while (y < GRID_HEIGHT):
        x: int32 = 0
        while (x < GRID_WIDTH):
            draw_cell(x, y)
            x = (x + 1)
        y = (y + 1)
    if (game_over != 0):
        if (game_won != 0):
            vtn_fill_rect(((SCREEN_WIDTH / 2) - 150), ((SCREEN_HEIGHT / 2) - 50), 300, 100, 50, 150, 50, 230)
            vtn_text_simple(Ptr[uint8]("YOU WIN!"), ((SCREEN_WIDTH / 2) - 50), ((SCREEN_HEIGHT / 2) - 20), 255, 255, 255)
            vtn_text_simple(Ptr[uint8]("Press R to play again"), ((SCREEN_WIDTH / 2) - 90), ((SCREEN_HEIGHT / 2) + 10), 200, 200, 200)
        else:
            vtn_fill_rect(((SCREEN_WIDTH / 2) - 150), ((SCREEN_HEIGHT / 2) - 50), 300, 100, 150, 50, 50, 230)
            vtn_text_simple(Ptr[uint8]("GAME OVER"), ((SCREEN_WIDTH / 2) - 55), ((SCREEN_HEIGHT / 2) - 20), 255, 255, 255)
            vtn_text_simple(Ptr[uint8]("Press R to play again"), ((SCREEN_WIDTH / 2) - 90), ((SCREEN_HEIGHT / 2) + 10), 200, 200, 200)
    vtn_text_simple(Ptr[uint8]("Arrow keys: Move   Space: Reveal   F: Flag   R: Restart   Q: Quit"), 180, (SCREEN_HEIGHT - 40), 150, 160, 175)
    vtn_flush()

def handle_input():
    buf: Array[16, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 16)
    if (n <= 0):
        return
    i: int32 = 0
    while (i < n):
        c: int32 = cast[int32](buf[i])
        if ((c == 27) and ((i + 2) < n)):
            if (buf[(i + 1)] == cast[uint8](91)):
                code: int32 = cast[int32](buf[(i + 2)])
                if (code == 65):
                    if (cursor_y > 0):
                        cursor_y = (cursor_y - 1)
                elif (code == 66):
                    if (cursor_y < (GRID_HEIGHT - 1)):
                        cursor_y = (cursor_y + 1)
                elif (code == 67):
                    if (cursor_x < (GRID_WIDTH - 1)):
                        cursor_x = (cursor_x + 1)
                elif (code == 68):
                    if (cursor_x > 0):
                        cursor_x = (cursor_x - 1)
                i = (i + 3)
                continue
        if ((c == 113) or (c == 81)):
            running = 0
        elif (c == 17):
            running = 0
        elif ((c == 114) or (c == 82)):
            init_game()
        elif (((c == 32) or (c == 10)) or (c == 13)):
            click_cell()
        elif ((c == 102) or (c == 70)):
            toggle_flag()
        i = (i + 1)

def main() -> int32:
    vtn_init_raw()
    vtn_cursor_hide()
    vtn_flush()
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, (flags | O_NONBLOCK))
    rand_seed = syscall1(SYS_time, 0)
    if (rand_seed == 0):
        rand_seed = 54321
    init_game()
    while (running != 0):
        handle_input()
        render()
        sleep_ms(16)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags)
    vtn_cursor_show()
    vtn_flush()
    return 0