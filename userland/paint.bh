# paint - Simple Drawing Application
# Use mouse or keyboard (WASD + Space) to draw

from lib.syscalls import *

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Toolbar height
const TOOLBAR_HEIGHT: int32 = 50
const COLOR_BOX_SIZE: int32 = 30
const BRUSH_MAX: int32 = 20
const BRUSH_MIN: int32 = 1

# Colors for palette
const PALETTE_SIZE: int32 = 16

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Canvas buffer (to preserve drawings)
g_canvas: *uint32 = cast[*uint32](0)
g_canvas_width: int32 = 0
g_canvas_height: int32 = 0

# Drawing state
g_cursor_x: int32 = 400
g_cursor_y: int32 = 300
g_brush_size: int32 = 3
g_current_color: int32 = 0
g_drawing: int32 = 0
g_running: int32 = 1

# Color palette
g_palette: array[16, int32]

# Mouse state
g_mouse_fd: int32 = 0
g_mouse_x: int32 = 0
g_mouse_y: int32 = 0
g_mouse_btn: int32 = 0

def print_str(s: *uint8):
  len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 16)
  ts: *int32 = cast[*int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  _ = syscall2(SYS_nanosleep, cast[int32](ts), 0)

# ============ Drawing Primitives ============

def fb_pixel(x: int32, y: int32, color: int32):
  if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
    g_fb[y * g_xres + x] = cast[uint32](color)

def canvas_pixel(x: int32, y: int32, color: int32):
  if x >= 0 and x < g_canvas_width and y >= 0 and y < g_canvas_height:
    g_canvas[y * g_canvas_width + x] = cast[uint32](color)

def fill_rect_fb(x: int32, y: int32, w: int32, h: int32, color: int32):
  cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < g_yres:
      cx: int32 = x
      while cx < x + w:
        if cx >= 0 and cx < g_xres:
          g_fb[cy * g_xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

def fill_circle_canvas(cx: int32, cy: int32, r: int32, color: int32):
  y: int32 = 0 - r
  while y <= r:
    x: int32 = 0 - r
    while x <= r:
      if x * x + y * y <= r * r:
        canvas_pixel(cx + x, cy + y, color)
      x = x + 1
    y = y + 1

def draw_rect_outline(x: int32, y: int32, w: int32, h: int32, color: int32):
  i: int32 = 0
  while i < w:
    fb_pixel(x + i, y, color)
    fb_pixel(x + i, y + h - 1, color)
    i = i + 1
  i = 0
  while i < h:
    fb_pixel(x, y + i, color)
    fb_pixel(x + w - 1, y + i, color)
    i = i + 1

# Simple 8x8 font for labels
font: array[768, uint8]

def init_font():
  i: int32 = 0
  while i < 768:
    font[i] = cast[uint8](0)
    i = i + 1

  # Some basic characters for labels
  # 'C' = 67
  font[536] = cast[uint8](0x3C)
  font[537] = cast[uint8](0x66)
  font[538] = cast[uint8](0x60)
  font[539] = cast[uint8](0x60)
  font[540] = cast[uint8](0x60)
  font[541] = cast[uint8](0x66)
  font[542] = cast[uint8](0x3C)
  font[543] = cast[uint8](0x00)

  # 'L' = 76
  font[608] = cast[uint8](0x60)
  font[609] = cast[uint8](0x60)
  font[610] = cast[uint8](0x60)
  font[611] = cast[uint8](0x60)
  font[612] = cast[uint8](0x60)
  font[613] = cast[uint8](0x60)
  font[614] = cast[uint8](0x7E)
  font[615] = cast[uint8](0x00)

  # 'R' = 82
  font[656] = cast[uint8](0x7C)
  font[657] = cast[uint8](0x66)
  font[658] = cast[uint8](0x66)
  font[659] = cast[uint8](0x7C)
  font[660] = cast[uint8](0x6C)
  font[661] = cast[uint8](0x66)
  font[662] = cast[uint8](0x66)
  font[663] = cast[uint8](0x00)

def draw_char(x: int32, y: int32, c: uint8, color: int32):
  idx: int32 = cast[int32](c) * 8
  if idx < 0 or idx >= 760:
    return
  row: int32 = 0
  while row < 8:
    bits: uint8 = font[idx + row]
    col: int32 = 0
    while col < 8:
      mask: int32 = 128
      shift: int32 = col
      while shift > 0:
        mask = mask / 2
        shift = shift - 1
      if (cast[int32](bits) & mask) != 0:
        fb_pixel(x + col, y + row, color)
      col = col + 1
    row = row + 1

def draw_text(x: int32, y: int32, text: *uint8, color: int32):
  i: int32 = 0
  cx: int32 = x
  while text[i] != cast[uint8](0):
    draw_char(cx, y, text[i], color)
    cx = cx + 8
    i = i + 1

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 512)
  path: *uint8 = cast[*uint8](old_brk)
  path[0] = cast[uint8](47)
  path[1] = cast[uint8](100)
  path[2] = cast[uint8](101)
  path[3] = cast[uint8](118)
  path[4] = cast[uint8](47)
  path[5] = cast[uint8](102)
  path[6] = cast[uint8](98)
  path[7] = cast[uint8](48)
  path[8] = cast[uint8](0)

  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  vinfo: *int32 = cast[*int32](old_brk + 32)
  i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  ret: int32 = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if ret < 0:
    return 1

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  fb_size: int32 = g_xres * g_yres * 4
  g_fb = cast[*uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

  if cast[int32](g_fb) < 0:
    return 1

  # Allocate canvas buffer
  g_canvas_width = g_xres
  g_canvas_height = g_yres - TOOLBAR_HEIGHT
  canvas_size: int32 = g_canvas_width * g_canvas_height * 4

  old_brk = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + canvas_size)
  g_canvas = cast[*uint32](old_brk)

  # Initialize canvas to white
  i = 0
  while i < g_canvas_width * g_canvas_height:
    g_canvas[i] = cast[uint32](0xFFFFFF)
    i = i + 1

  # Set stdin non-blocking
  flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

  # Initialize cursor position
  g_cursor_x = g_xres / 2
  g_cursor_y = TOOLBAR_HEIGHT + g_canvas_height / 2

  return 0

def init_palette():
  g_palette[0] = 0x000000   # Black
  g_palette[1] = 0xFFFFFF   # White
  g_palette[2] = 0xFF0000   # Red
  g_palette[3] = 0x00FF00   # Green
  g_palette[4] = 0x0000FF   # Blue
  g_palette[5] = 0xFFFF00   # Yellow
  g_palette[6] = 0xFF00FF   # Magenta
  g_palette[7] = 0x00FFFF   # Cyan
  g_palette[8] = 0xFF8000   # Orange
  g_palette[9] = 0x8000FF   # Purple
  g_palette[10] = 0x00FF80  # Teal
  g_palette[11] = 0xFF0080  # Pink
  g_palette[12] = 0x808080  # Gray
  g_palette[13] = 0x404040  # Dark Gray
  g_palette[14] = 0xC0C0C0  # Light Gray
  g_palette[15] = 0x800000  # Dark Red

  g_current_color = 0  # Start with black

def try_open_mouse():
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 64)
  path: *uint8 = cast[*uint8](old_brk)

  # Try /dev/input/mice
  path[0] = cast[uint8](47)   # /
  path[1] = cast[uint8](100)  # d
  path[2] = cast[uint8](101)  # e
  path[3] = cast[uint8](118)  # v
  path[4] = cast[uint8](47)   # /
  path[5] = cast[uint8](105)  # i
  path[6] = cast[uint8](110)  # n
  path[7] = cast[uint8](112)  # p
  path[8] = cast[uint8](117)  # u
  path[9] = cast[uint8](116)  # t
  path[10] = cast[uint8](47)  # /
  path[11] = cast[uint8](109) # m
  path[12] = cast[uint8](105) # i
  path[13] = cast[uint8](99)  # c
  path[14] = cast[uint8](101) # e
  path[15] = cast[uint8](0)

  g_mouse_fd = syscall3(SYS_open, cast[int32](path), O_RDONLY + O_NONBLOCK, 0)
  if g_mouse_fd >= 0:
    g_mouse_x = g_xres / 2
    g_mouse_y = TOOLBAR_HEIGHT + g_canvas_height / 2

# ============ Input Handling ============

def handle_mouse():
  if g_mouse_fd < 0:
    return

  buf: array[4, uint8]
  n: int32 = syscall3(SYS_read, g_mouse_fd, cast[int32](buf), 3)

  if n >= 3:
    buttons: int32 = cast[int32](buf[0])
    dx: int32 = cast[int32](buf[1])
    dy: int32 = cast[int32](buf[2])

    # Sign extend
    if (buttons & 0x10) != 0:
      dx = dx - 256
    if (buttons & 0x20) != 0:
      dy = dy - 256

    g_mouse_x = g_mouse_x + dx
    g_mouse_y = g_mouse_y - dy  # Y is inverted

    # Clamp to screen
    if g_mouse_x < 0:
      g_mouse_x = 0
    if g_mouse_x >= g_xres:
      g_mouse_x = g_xres - 1
    if g_mouse_y < TOOLBAR_HEIGHT:
      g_mouse_y = TOOLBAR_HEIGHT
    if g_mouse_y >= g_yres:
      g_mouse_y = g_yres - 1

    g_cursor_x = g_mouse_x
    g_cursor_y = g_mouse_y

    # Left button = draw
    if (buttons & 1) != 0:
      if g_cursor_y >= TOOLBAR_HEIGHT:
        fill_circle_canvas(g_cursor_x, g_cursor_y - TOOLBAR_HEIGHT, g_brush_size, g_palette[g_current_color])
      else:
        # Check palette clicks
        i: int32 = 0
        while i < PALETTE_SIZE:
          px: int32 = 10 + i * (COLOR_BOX_SIZE + 5)
          if g_cursor_x >= px and g_cursor_x < px + COLOR_BOX_SIZE and g_cursor_y >= 10 and g_cursor_y < 10 + COLOR_BOX_SIZE:
            g_current_color = i
          i = i + 1

def handle_keyboard():
  buf: array[8, uint8]
  n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  c: uint8 = buf[0]

  # WASD movement
  if c == cast[uint8](119) or c == cast[uint8](87):  # w/W - up
    g_cursor_y = g_cursor_y - 5
    if g_cursor_y < TOOLBAR_HEIGHT:
      g_cursor_y = TOOLBAR_HEIGHT
  else:
    if c == cast[uint8](115) or c == cast[uint8](83):  # s/S - down
      g_cursor_y = g_cursor_y + 5
      if g_cursor_y >= g_yres:
        g_cursor_y = g_yres - 1
    else:
      if c == cast[uint8](97) or c == cast[uint8](65):  # a/A - left
        g_cursor_x = g_cursor_x - 5
        if g_cursor_x < 0:
          g_cursor_x = 0
      else:
        if c == cast[uint8](100) or c == cast[uint8](68):  # d/D - right
          g_cursor_x = g_cursor_x + 5
          if g_cursor_x >= g_xres:
            g_cursor_x = g_xres - 1

  # Space = draw
  if c == cast[uint8](32):
    if g_cursor_y >= TOOLBAR_HEIGHT:
      fill_circle_canvas(g_cursor_x, g_cursor_y - TOOLBAR_HEIGHT, g_brush_size, g_palette[g_current_color])

  # +/= increase brush
  if c == cast[uint8](43) or c == cast[uint8](61):
    g_brush_size = g_brush_size + 1
    if g_brush_size > BRUSH_MAX:
      g_brush_size = BRUSH_MAX

  # - decrease brush
  if c == cast[uint8](45):
    g_brush_size = g_brush_size - 1
    if g_brush_size < BRUSH_MIN:
      g_brush_size = BRUSH_MIN

  # 1-9, 0 for colors
  if c >= cast[uint8](48) and c <= cast[uint8](57):
    color_idx: int32 = cast[int32](c) - 48
    if color_idx == 0:
      color_idx = 10
    else:
      color_idx = color_idx - 1
    if color_idx < PALETTE_SIZE:
      g_current_color = color_idx

  # c = clear canvas
  if c == cast[uint8](99) or c == cast[uint8](67):
    i: int32 = 0
    while i < g_canvas_width * g_canvas_height:
      g_canvas[i] = cast[uint32](0xFFFFFF)
      i = i + 1

  # q = quit
  if c == cast[uint8](113) or c == cast[uint8](81):
    g_running = 0

  # Arrow keys
  if n >= 3 and buf[0] == cast[uint8](27) and buf[1] == cast[uint8](91):
    if buf[2] == cast[uint8](65):  # Up
      g_cursor_y = g_cursor_y - 5
      if g_cursor_y < TOOLBAR_HEIGHT:
        g_cursor_y = TOOLBAR_HEIGHT
    else:
      if buf[2] == cast[uint8](66):  # Down
        g_cursor_y = g_cursor_y + 5
        if g_cursor_y >= g_yres:
          g_cursor_y = g_yres - 1
      else:
        if buf[2] == cast[uint8](68):  # Left
          g_cursor_x = g_cursor_x - 5
          if g_cursor_x < 0:
            g_cursor_x = 0
        else:
          if buf[2] == cast[uint8](67):  # Right
            g_cursor_x = g_cursor_x + 5
            if g_cursor_x >= g_xres:
              g_cursor_x = g_xres - 1

# ============ Rendering ============

def draw_toolbar():
  # Toolbar background
  fill_rect_fb(0, 0, g_xres, TOOLBAR_HEIGHT, 0x303030)

  # Draw color palette
  i: int32 = 0
  while i < PALETTE_SIZE:
    x: int32 = 10 + i * (COLOR_BOX_SIZE + 5)
    fill_rect_fb(x, 10, COLOR_BOX_SIZE, COLOR_BOX_SIZE, g_palette[i])

    # Highlight selected color
    if i == g_current_color:
      draw_rect_outline(x - 2, 8, COLOR_BOX_SIZE + 4, COLOR_BOX_SIZE + 4, 0xFFFFFF)
    i = i + 1

  # Draw brush size indicator
  brush_x: int32 = g_xres - 100
  fill_rect_fb(brush_x, 10, 80, 30, 0x404040)
  # Draw current brush size circle
  center_x: int32 = brush_x + 40
  center_y: int32 = 25
  by: int32 = 0 - g_brush_size
  while by <= g_brush_size:
    bx: int32 = 0 - g_brush_size
    while bx <= g_brush_size:
      if bx * bx + by * by <= g_brush_size * g_brush_size:
        fb_pixel(center_x + bx, center_y + by, g_palette[g_current_color])
      bx = bx + 1
    by = by + 1

def draw_canvas():
  # Copy canvas to framebuffer
  y: int32 = 0
  while y < g_canvas_height:
    x: int32 = 0
    while x < g_canvas_width:
      g_fb[(y + TOOLBAR_HEIGHT) * g_xres + x] = g_canvas[y * g_canvas_width + x]
      x = x + 1
    y = y + 1

def draw_cursor():
  # Draw crosshair cursor
  cx: int32 = g_cursor_x
  cy: int32 = g_cursor_y
  size: int32 = 10

  # Horizontal line
  i: int32 = 0 - size
  while i <= size:
    if i < -2 or i > 2:  # Gap in middle
      fb_pixel(cx + i, cy, 0xFF0000)
    i = i + 1

  # Vertical line
  i = 0 - size
  while i <= size:
    if i < -2 or i > 2:
      fb_pixel(cx, cy + i, 0xFF0000)
    i = i + 1

def render():
  draw_toolbar()
  draw_canvas()
  draw_cursor()

# ============ Main ============

def main() -> int32:
  print_str(cast[*uint8]("Paint - WASD/arrows to move, Space to draw, +/- brush size, 1-0 colors, C clear, Q quit\n"))

  if init_framebuffer() != 0:
    return 1

  init_font()
  init_palette()
  try_open_mouse()

  # Main loop
  while g_running != 0:
    handle_mouse()
    handle_keyboard()
    render()
    sleep_ms(16)

  # Clear screen
  i: int32 = 0
  total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0)
    i = i + 1

  if g_mouse_fd >= 0:
    _ = syscall1(SYS_close, g_mouse_fd)
  _ = syscall1(SYS_close, g_fb_fd)
  return 0

main()
