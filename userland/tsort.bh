# tsort - Topological sort
# Usage: tsort [FILE]
# Reads pairs "A B" meaning A depends on B
# Outputs sorted order, detects cycles

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Compare strings
# Copy string
# Node in dependency graph (max 64 nodes, 16 char names)
const MAX_NODES: int32 = 64
const NAME_LEN: int32 = 16

# Find or add node, return index
def find_or_add_node(nodes: *uint8, node_count_ptr: *int32, name: *uint8) -> int32:
  node_count: int32 = node_count_ptr[0]
  i: int32 = 0

  # Search for existing node
  while i < node_count:
    node_name: *uint8 = cast[*uint8](cast[int32](nodes) + i * NAME_LEN)
    cmp: int32 = strcmp(node_name, name)
    if cmp == 0:
      return i
    i = i + 1

  # Add new node
  if node_count >= MAX_NODES:
    return -1

  new_node: *uint8 = cast[*uint8](cast[int32](nodes) + node_count * NAME_LEN)
  strcpy(new_node, name)
  node_count_ptr[0] = node_count + 1
  return node_count

# Parse input and build graph
# Returns 1 on success, 0 on error
def parse_input(fd: int32, nodes: *uint8, edges: *int32, node_count_ptr: *int32, edge_count_ptr: *int32) -> int32:
  # Allocate input buffer
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  syscall1(SYS_brk, new_brk)
  buffer: *uint8 = cast[*uint8](old_brk)
  word1: *uint8 = cast[*uint8](old_brk + 4096)
  word2: *uint8 = cast[*uint8](old_brk + 4096 + 64)

  bytes_read: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
  if bytes_read <= 0:
    return 1

  pos: int32 = 0
  while pos < bytes_read:
    # Skip whitespace
    while pos < bytes_read:
      if buffer[pos] == cast[uint8](32):
        pos = pos + 1
      else:
        if buffer[pos] == cast[uint8](9):
          pos = pos + 1
        else:
          if buffer[pos] == cast[uint8](10):
            pos = pos + 1
          else:
            break

    if pos >= bytes_read:
      break

    # Read first word
    w1_len: int32 = 0
    while pos < bytes_read:
      if buffer[pos] != cast[uint8](32):
        if buffer[pos] != cast[uint8](9):
          if buffer[pos] != cast[uint8](10):
            word1[w1_len] = buffer[pos]
            w1_len = w1_len + 1
            pos = pos + 1
          else:
            break
        else:
          break
      else:
        break
    word1[w1_len] = cast[uint8](0)

    if w1_len == 0:
      break

    # Skip whitespace
    while pos < bytes_read:
      if buffer[pos] == cast[uint8](32):
        pos = pos + 1
      else:
        if buffer[pos] == cast[uint8](9):
          pos = pos + 1
        else:
          break

    # Read second word
    w2_len: int32 = 0
    while pos < bytes_read:
      if buffer[pos] != cast[uint8](32):
        if buffer[pos] != cast[uint8](9):
          if buffer[pos] != cast[uint8](10):
            word2[w2_len] = buffer[pos]
            w2_len = w2_len + 1
            pos = pos + 1
          else:
            break
        else:
          break
      else:
        break
    word2[w2_len] = cast[uint8](0)

    if w2_len == 0:
      break

    # Add nodes and edge
    node1: int32 = find_or_add_node(nodes, node_count_ptr, word1)
    node2: int32 = find_or_add_node(nodes, node_count_ptr, word2)

    if node1 < 0:
      return 0
    if node2 < 0:
      return 0

    # Store edge (node1 depends on node2)
    edge_count: int32 = edge_count_ptr[0]
    edge_ptr: *int32 = cast[*int32](cast[int32](edges) + edge_count * 8)
    edge_ptr[0] = node1
    edge_ptr[1] = node2
    edge_count_ptr[0] = edge_count + 1

  return 1

# Topological sort using Kahn's algorithm
def topo_sort(nodes: *uint8, edges: *int32, node_count: int32, edge_count: int32, in_degree: *int32, output: *int32) -> int32:
  # Calculate in-degrees
  i: int32 = 0
  while i < node_count:
    in_degree[i] = 0
    i = i + 1

  i = 0
  while i < edge_count:
    edge_ptr: *int32 = cast[*int32](cast[int32](edges) + i * 8)
    from_node: int32 = edge_ptr[0]
    to: int32 = edge_ptr[1]
    in_degree[from_node] = in_degree[from_node] + 1
    i = i + 1

  # Find nodes with no incoming edges (queue)
  queue: *int32 = output
  queue_start: int32 = 0
  queue_end: int32 = 0

  i = 0
  while i < node_count:
    if in_degree[i] == 0:
      queue[queue_end] = i
      queue_end = queue_end + 1
    i = i + 1

  sorted_count: int32 = 0

  # Process queue
  while queue_start < queue_end:
    node: int32 = queue[queue_start]
    queue_start = queue_start + 1
    sorted_count = sorted_count + 1

    # Output this node
    node_name: *uint8 = cast[*uint8](cast[int32](nodes) + node * NAME_LEN)
    print(node_name)
    print(cast[*uint8]("\n"))

    # Remove edges from this node
    i = 0
    while i < edge_count:
      edge_ptr: *int32 = cast[*int32](cast[int32](edges) + i * 8)
      from_node: int32 = edge_ptr[0]
      to: int32 = edge_ptr[1]

      if to == node:
        in_degree[from_node] = in_degree[from_node] - 1
        if in_degree[from_node] == 0:
          queue[queue_end] = from_node
          queue_end = queue_end + 1

      i = i + 1

  # Check for cycles
  if sorted_count < node_count:
    return 0

  return 1

def main():
  argc: int32 = get_argc()
  fd: int32 = STDIN

  # Open file if provided
  if argc >= 2:
    filename: *uint8 = get_argv(1)
    fd = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
    if fd < 0:
      print_err(cast[*uint8]("tsort: cannot open file\n"))
      syscall1(SYS_exit, 1)

  # Allocate data structures
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16384
  syscall1(SYS_brk, new_brk)

  nodes: *uint8 = cast[*uint8](old_brk)
  edges: *int32 = cast[*int32](old_brk + 1024)
  in_degree: *int32 = cast[*int32](old_brk + 5120)
  output: *int32 = cast[*int32](old_brk + 5376)

  node_count: int32 = 0
  node_count_ptr: *int32 = cast[*int32](old_brk + 8192)
  node_count_ptr[0] = 0

  edge_count: int32 = 0
  edge_count_ptr: *int32 = cast[*int32](old_brk + 8196)
  edge_count_ptr[0] = 0

  # Parse input
  parse_result: int32 = parse_input(fd, nodes, edges, node_count_ptr, edge_count_ptr)
  if parse_result == 0:
    print_err(cast[*uint8]("tsort: too many nodes\n"))
    syscall1(SYS_exit, 1)

  node_count = node_count_ptr[0]
  edge_count = edge_count_ptr[0]

  if fd != STDIN:
    syscall1(SYS_close, fd)

  # Perform topological sort
  sort_result: int32 = topo_sort(nodes, edges, node_count, edge_count, in_degree, output)

  if sort_result == 0:
    print_err(cast[*uint8]("tsort: cycle detected\n"))
    syscall1(SYS_exit, 1)

  syscall1(SYS_exit, 0)
