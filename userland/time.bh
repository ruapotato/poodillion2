# time - Time command execution
# Usage: time COMMAND [ARGS...]
# Print elapsed time in format: real 0m1.234s

from lib.syscalls import *

const CLOCK_MONOTONIC: int32 = 1

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print unsigned integer to stderr
def print_uint_err(n: int32):
  if n == 0:
    syscall3(SYS_write, STDERR, cast[int32]("0"), 1)
    return

  num: int32 = n
  temp: int32 = 0
  digits: int32 = 0

  while num > 0:
    temp = temp * 10 + (num % 10)
    num = num / 10
    digits = digits + 1

  while digits > 0:
    d: uint8 = cast[uint8](48 + (temp % 10))
    syscall3(SYS_write, STDERR, cast[int32](addr(d)), 1)
    temp = temp / 10
    digits = digits - 1

def main():
  argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[*uint8]("Usage: time COMMAND [ARGS...]\n"))
    syscall1(SYS_exit, 1)

  # Allocate memory for timespec structures
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 4096
  syscall1(SYS_brk, new_brk)

  start_time: *int32 = cast[*int32](old_brk)
  end_time: *int32 = cast[*int32](old_brk + 16)
  status: *int32 = cast[*int32](old_brk + 32)

  # Get start time
  result: int32 = syscall2(SYS_clock_gettime, CLOCK_MONOTONIC, cast[int32](start_time))

  if result < 0:
    print_err(cast[*uint8]("time: clock_gettime failed\n"))
    syscall1(SYS_exit, 1)

  # Fork to run the command
  pid: int32 = syscall1(SYS_fork, 0)

  if pid < 0:
    print_err(cast[*uint8]("time: fork failed\n"))
    syscall1(SYS_exit, 1)

  if pid == 0:
    # Child process - exec the command
    # Build argv array for command
    argv: *int32 = cast[*int32](old_brk + 64)
    i: int32 = 1
    arg_idx: int32 = 0
    while i < argc:
      argv[arg_idx] = cast[int32](get_argv(i))
      arg_idx = arg_idx + 1
      i = i + 1
    argv[arg_idx] = 0  # NULL terminate

    # Exec the command
    cmd: *uint8 = get_argv(1)
    syscall3(SYS_execve, cast[int32](cmd), cast[int32](argv), 0)

    # If execve returns, it failed
    print_err(cast[*uint8]("time: cannot execute command\n"))
    syscall1(SYS_exit, 127)

  # Parent process - wait for child
  status[0] = 0
  result = syscall3(SYS_waitpid, pid, cast[int32](status), 0)

  if result < 0:
    print_err(cast[*uint8]("time: waitpid failed\n"))
    syscall1(SYS_exit, 1)

  # Get end time
  result = syscall2(SYS_clock_gettime, CLOCK_MONOTONIC, cast[int32](end_time))

  if result < 0:
    print_err(cast[*uint8]("time: clock_gettime failed\n"))
    syscall1(SYS_exit, 1)

  # Calculate elapsed time
  start_sec: int32 = start_time[0]
  start_nsec: int32 = start_time[1]
  end_sec: int32 = end_time[0]
  end_nsec: int32 = end_time[1]

  elapsed_sec: int32 = end_sec - start_sec
  elapsed_nsec: int32 = end_nsec - start_nsec

  if elapsed_nsec < 0:
    elapsed_sec = elapsed_sec - 1
    elapsed_nsec = elapsed_nsec + 1000000000

  # Convert to minutes and seconds
  minutes: int32 = elapsed_sec / 60
  seconds: int32 = elapsed_sec % 60
  milliseconds: int32 = elapsed_nsec / 1000000

  # Print in format: real 0m1.234s
  print_err(cast[*uint8]("\nreal "))
  print_uint_err(cast[uint32](minutes))
  print_err(cast[*uint8]("m"))
  print_uint_err(cast[uint32](seconds))
  print_err(cast[*uint8]("."))

  # Print milliseconds (3 digits)
  if milliseconds < 100:
    print_err(cast[*uint8]("0"))
  if milliseconds < 10:
    print_err(cast[*uint8]("0"))
  print_uint_err(cast[uint32](milliseconds))
  print_err(cast[*uint8]("s\n"))

  # Extract exit code from status
  exit_code: int32 = (status[0] / 256) % 256

  syscall1(SYS_exit, exit_code)
