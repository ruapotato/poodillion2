# time - Time command execution
# Usage: time COMMAND [ARGS...]
# Print elapsed time in format: real 0m1.234s

import "lib/syscalls"

const CLOCK_MONOTONIC: int32 = 1

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print unsigned integer to stderr
proc print_uint_err(n: int32) =
  if n == 0:
    discard syscall3(SYS_write, STDERR, cast[int32]("0"), 1)
    return

  var num: int32 = n
  var temp: int32 = 0
  var digits: int32 = 0

  while num > 0:
    temp = temp * 10 + (num % 10)
    num = num / 10
    digits = digits + 1

  while digits > 0:
    var d: uint8 = cast[uint8](48 + (temp % 10))
    discard syscall3(SYS_write, STDERR, cast[int32](addr(d)), 1)
    temp = temp / 10
    digits = digits - 1

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("Usage: time COMMAND [ARGS...]\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate memory for timespec structures
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)

  var start_time: ptr int32 = cast[ptr int32](old_brk)
  var end_time: ptr int32 = cast[ptr int32](old_brk + 16)
  var status: ptr int32 = cast[ptr int32](old_brk + 32)

  # Get start time
  var result: int32 = syscall2(SYS_clock_gettime, CLOCK_MONOTONIC, cast[int32](start_time))

  if result < 0:
    print_err(cast[ptr uint8]("time: clock_gettime failed\n"))
    discard syscall1(SYS_exit, 1)

  # Fork to run the command
  var pid: int32 = syscall1(SYS_fork, 0)

  if pid < 0:
    print_err(cast[ptr uint8]("time: fork failed\n"))
    discard syscall1(SYS_exit, 1)

  if pid == 0:
    # Child process - exec the command
    # Build argv array for command
    var argv: ptr int32 = cast[ptr int32](old_brk + 64)
    var i: int32 = 1
    var arg_idx: int32 = 0
    while i < argc:
      argv[arg_idx] = cast[int32](get_argv(i))
      arg_idx = arg_idx + 1
      i = i + 1
    argv[arg_idx] = 0  # NULL terminate

    # Exec the command
    var cmd: ptr uint8 = get_argv(1)
    discard syscall3(SYS_execve, cast[int32](cmd), cast[int32](argv), 0)

    # If execve returns, it failed
    print_err(cast[ptr uint8]("time: cannot execute command\n"))
    discard syscall1(SYS_exit, 127)

  # Parent process - wait for child
  status[0] = 0
  result = syscall3(SYS_waitpid, pid, cast[int32](status), 0)

  if result < 0:
    print_err(cast[ptr uint8]("time: waitpid failed\n"))
    discard syscall1(SYS_exit, 1)

  # Get end time
  result = syscall2(SYS_clock_gettime, CLOCK_MONOTONIC, cast[int32](end_time))

  if result < 0:
    print_err(cast[ptr uint8]("time: clock_gettime failed\n"))
    discard syscall1(SYS_exit, 1)

  # Calculate elapsed time
  var start_sec: int32 = start_time[0]
  var start_nsec: int32 = start_time[1]
  var end_sec: int32 = end_time[0]
  var end_nsec: int32 = end_time[1]

  var elapsed_sec: int32 = end_sec - start_sec
  var elapsed_nsec: int32 = end_nsec - start_nsec

  if elapsed_nsec < 0:
    elapsed_sec = elapsed_sec - 1
    elapsed_nsec = elapsed_nsec + 1000000000

  # Convert to minutes and seconds
  var minutes: int32 = elapsed_sec / 60
  var seconds: int32 = elapsed_sec % 60
  var milliseconds: int32 = elapsed_nsec / 1000000

  # Print in format: real 0m1.234s
  print_err(cast[ptr uint8]("\nreal "))
  print_uint_err(cast[uint32](minutes))
  print_err(cast[ptr uint8]("m"))
  print_uint_err(cast[uint32](seconds))
  print_err(cast[ptr uint8]("."))

  # Print milliseconds (3 digits)
  if milliseconds < 100:
    print_err(cast[ptr uint8]("0"))
  if milliseconds < 10:
    print_err(cast[ptr uint8]("0"))
  print_uint_err(cast[uint32](milliseconds))
  print_err(cast[ptr uint8]("s\n"))

  # Extract exit code from status
  var exit_code: int32 = (status[0] / 256) % 256

  discard syscall1(SYS_exit, exit_code)
