# sed - stream editor
# Usage: sed SCRIPT [FILE]
#        sed -n SCRIPT [FILE] (suppress default print)
# Part of BrainhairOS text utilities
#
# Supported commands:
#   s/PATTERN/REPLACEMENT/     - substitute first occurrence
#   s/PATTERN/REPLACEMENT/g    - substitute all occurrences
#   d                          - delete line
#   Nd                         - delete line N
#   p                          - print line
#   Np                         - print line N
#   q                          - quit
#   /PATTERN/d                 - delete matching lines
#   /PATTERN/p                 - print matching lines

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

# Find a literal string in a buffer
# Returns position of matched or -1 if not found
def find_pattern(line: *uint8, line_len: int32, pattern: *uint8, pattern_len: int32) -> int32:
  if pattern_len == 0:
    return 0
  if pattern_len > line_len:
    return -1

  i: int32 = 0
  while i <= line_len - pattern_len:
    matched: int32 = 1
    j: int32 = 0
    while j < pattern_len:
      if line[i + j] != pattern[j]:
        matched = 0
        break
      j = j + 1
    if matched != 0:
      return i
    i = i + 1

  return -1

# Perform substitution
# Returns new length of line
def substitute(line: *uint8, line_len: int32, output: *uint8, pattern: *uint8, pattern_len: int32, replacement: *uint8, replacement_len: int32, global: int32) -> int32:
  out_pos: int32 = 0
  in_pos: int32 = 0
  subs_made: int32 = 0

  while in_pos < line_len:
    match_pos: int32 = find_pattern(line + in_pos, line_len - in_pos, pattern, pattern_len)

    if match_pos >= 0:
      # Copy everything before the matched
      k: int32 = 0
      while k < match_pos:
        output[out_pos] = line[in_pos + k]
        out_pos = out_pos + 1
        k = k + 1

      # Copy replacement
      m: int32 = 0
      while m < replacement_len:
        output[out_pos] = replacement[m]
        out_pos = out_pos + 1
        m = m + 1

      # Move past the pattern
      in_pos = in_pos + match_pos + pattern_len
      subs_made = subs_made + 1

      # If not global, copy rest of line and exit
      if global == 0:
        while in_pos < line_len:
          output[out_pos] = line[in_pos]
          out_pos = out_pos + 1
          in_pos = in_pos + 1
        break
    else:
      # No matched, copy rest of line
      while in_pos < line_len:
        output[out_pos] = line[in_pos]
        out_pos = out_pos + 1
        in_pos = in_pos + 1
      break

  return out_pos

# Parse s/pattern/replacement/flags command
# Returns: 0 on success, -1 on error
def parse_substitute_cmd(script: *uint8, pattern_out: *uint8, pattern_len_out: *int32, replacement_out: *uint8, replacement_len_out: *int32, global_out: *int32) -> int32:
  # Expect s/pattern/replacement/[flags]
  if script[0] != cast[uint8](115):  # 's'
    return -1
  if script[1] != cast[uint8](47):  # '/'
    return -1

  # Find pattern (between first and second /)
  i: int32 = 2
  pattern_len: int32 = 0
  while script[i] != cast[uint8](0):
    if script[i] == cast[uint8](47):  # '/'
      break
    pattern_out[pattern_len] = script[i]
    pattern_len = pattern_len + 1
    i = i + 1

  if script[i] != cast[uint8](47):  # Must have second /
    return -1

  pattern_len_out[0] = pattern_len
  i = i + 1  # Skip second /

  # Find replacement (between second and third /)
  replacement_len: int32 = 0
  while script[i] != cast[uint8](0):
    if script[i] == cast[uint8](47):  # '/'
      break
    replacement_out[replacement_len] = script[i]
    replacement_len = replacement_len + 1
    i = i + 1

  replacement_len_out[0] = replacement_len

  # Check for flags
  global: int32 = 0
  if script[i] == cast[uint8](47):  # Third /
    i = i + 1
    while script[i] != cast[uint8](0):
      if script[i] == cast[uint8](103):  # 'g'
        global = 1
      i = i + 1

  global_out[0] = global
  return 0

def main():
  argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[*uint8]("sed: usage: sed [-n] SCRIPT [FILE]\n"))
    syscall1(SYS_exit, 1)

  # Allocate buffers
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 32768
  syscall1(SYS_brk, new_brk)

  line_buffer: *uint8 = cast[*uint8](old_brk)
  output_buffer: *uint8 = cast[*uint8](old_brk + 8192)
  pattern: *uint8 = cast[*uint8](old_brk + 16384)
  replacement: *uint8 = cast[*uint8](old_brk + 20480)
  temp_buffer: *uint8 = cast[*uint8](old_brk + 24576)

  # Parse arguments
  suppress_print: int32 = 0
  script: *uint8 = cast[*uint8](0)
  input_fd: int32 = STDIN
  arg_idx: int32 = 1

  # Check for -n flag
  first_arg: *uint8 = get_argv(1)
  if strcmp(first_arg, cast[*uint8]("-n")) == 0:
    suppress_print = 1
    arg_idx = 2
    if argc < 3:
      print_err(cast[*uint8]("sed: -n requires SCRIPT\n"))
      syscall1(SYS_exit, 1)

  # Get script
  script = get_argv(arg_idx)
  arg_idx = arg_idx + 1

  # Check for input file
  if arg_idx < argc:
    filename: *uint8 = get_argv(arg_idx)
    input_fd = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
    if input_fd < 0:
      print_err(cast[*uint8]("sed: cannot open file\n"))
      syscall1(SYS_exit, 1)

  # Parse the script command
  cmd_type: int32 = 0  # 0=unknown, 1=substitute, 2=delete, 3=print, 4=quit
  pattern_len: int32 = 0
  replacement_len: int32 = 0
  global_flag: int32 = 0
  line_number_target: int32 = 0
  pattern_delete: int32 = 0  # 1 if /pattern/d
  pattern_print: int32 = 0   # 1 if /pattern/p

  # Check what command it is
  if script[0] == cast[uint8](115):  # 's' - substitute
    cmd_type = 1
    if parse_substitute_cmd(script, pattern, addr(pattern_len), replacement, addr(replacement_len), addr(global_flag)) < 0:
      print_err(cast[*uint8]("sed: invalid substitute command\n"))
      syscall1(SYS_exit, 1)
  else:
    if script[0] == cast[uint8](100):  # 'd' - delete all
      cmd_type = 2
    else:
      if script[0] == cast[uint8](112):  # 'p' - print
        cmd_type = 3
      else:
        if script[0] == cast[uint8](113):  # 'q' - quit
          cmd_type = 4
        else:
          if script[0] == cast[uint8](47):  # '/pattern/...'
            # Pattern-based command
            i: int32 = 1
            pattern_len = 0
            while script[i] != cast[uint8](0):
              if script[i] == cast[uint8](47):
                break
              pattern[pattern_len] = script[i]
              pattern_len = pattern_len + 1
              i = i + 1

            if script[i] == cast[uint8](47):
              i = i + 1
              if script[i] == cast[uint8](100):  # 'd'
                cmd_type = 2
                pattern_delete = 1
              else:
                if script[i] == cast[uint8](112):  # 'p'
                  cmd_type = 3
                  pattern_print = 1
          else:
            # Check if it's a number followed by a command
            if script[0] >= cast[uint8](48):
              if script[0] <= cast[uint8](57):
                line_number_target = parse_int(script)
                i: int32 = 0
                while script[i] >= cast[uint8](48):
                  if script[i] <= cast[uint8](57):
                    i = i + 1
                  else:
                    break
                if script[i] == cast[uint8](100):  # 'd'
                  cmd_type = 2
                else:
                  if script[i] == cast[uint8](112):  # 'p'
                    cmd_type = 3

  # Process input line by line
  line_len: int32 = 0
  running: int32 = 1
  line_number: int32 = 0

  while running != 0:
    c: uint8 = 0
    n: int32 = syscall3(SYS_read, input_fd, cast[int32](addr(c)), 1)

    if n <= 0:
      # Process last line if any
      if line_len > 0:
        line_number = line_number + 1

        should_delete: int32 = 0
        should_print_extra: int32 = 0

        # Check if we should process this line
        if line_number_target > 0:
          if line_number != line_number_target:
            # Not our target line, skip command
            if suppress_print == 0:
              syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
              syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
            line_len = 0
            running = 0
            break

        # Pattern-based commands
        if pattern_delete != 0:
          if find_pattern(line_buffer, line_len, pattern, pattern_len) >= 0:
            should_delete = 1

        if pattern_print != 0:
          if find_pattern(line_buffer, line_len, pattern, pattern_len) >= 0:
            should_print_extra = 1

        # Execute command
        if cmd_type == 1:  # substitute
          new_len: int32 = substitute(line_buffer, line_len, output_buffer, pattern, pattern_len, replacement, replacement_len, global_flag)
          if suppress_print == 0:
            syscall3(SYS_write, STDOUT, cast[int32](output_buffer), new_len)
            syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
        else:
          if cmd_type == 2:  # delete
            if should_delete == 0:
              should_delete = 1
          else:
            if cmd_type == 3:  # print
              should_print_extra = 1

        # Output line if not deleted
        if should_delete == 0:
          if cmd_type != 1:  # not substitute (already printed)
            if suppress_print == 0:
              syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
              syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

        # Print extra if p command
        if should_print_extra != 0:
          syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
          syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

      running = 0
      break

    if c == cast[uint8](10):  # newline
      line_number = line_number + 1

      should_delete: int32 = 0
      should_print_extra: int32 = 0
      should_quit: int32 = 0

      # Check if we should process this line
      if line_number_target > 0:
        if line_number != line_number_target:
          # Not our target line, skip command
          if suppress_print == 0:
            syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
            syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
          line_len = 0
          # Continue to next line - don't break
          if 1 == 1:
            line_len = 0
          else:
            break
        else:
          # Target line matched
          if 1 == 1:
            line_len = line_len  # dummy
      else:
        # Process normally
        if 1 == 1:
          line_len = line_len  # dummy

      # Pattern-based commands
      if pattern_delete != 0:
        if find_pattern(line_buffer, line_len, pattern, pattern_len) >= 0:
          should_delete = 1

      if pattern_print != 0:
        if find_pattern(line_buffer, line_len, pattern, pattern_len) >= 0:
          should_print_extra = 1

      # Execute command
      if cmd_type == 1:  # substitute
        new_len: int32 = substitute(line_buffer, line_len, output_buffer, pattern, pattern_len, replacement, replacement_len, global_flag)
        if suppress_print == 0:
          syscall3(SYS_write, STDOUT, cast[int32](output_buffer), new_len)
          syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      else:
        if cmd_type == 2:  # delete
          if should_delete == 0:
            if line_number_target > 0:
              if line_number == line_number_target:
                should_delete = 1
            else:
              if pattern_delete == 0:
                should_delete = 1
        else:
          if cmd_type == 3:  # print
            if line_number_target > 0:
              if line_number == line_number_target:
                should_print_extra = 1
            else:
              if pattern_print == 0:
                should_print_extra = 1
          else:
            if cmd_type == 4:  # quit
              should_quit = 1

      # Output line if not deleted
      if should_delete == 0:
        if cmd_type != 1:  # not substitute (already printed)
          if suppress_print == 0:
            syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
            syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

      # Print extra if p command
      if should_print_extra != 0:
        syscall3(SYS_write, STDOUT, cast[int32](line_buffer), line_len)
        syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

      # Reset for next line
      line_len = 0

      # Quit if requested
      if should_quit != 0:
        running = 0
    else:
      # Add character to line buffer
      if line_len < 8192:
        line_buffer[line_len] = c
        line_len = line_len + 1

  if input_fd != STDIN:
    syscall1(SYS_close, input_fd)

  syscall1(SYS_exit, 0)
