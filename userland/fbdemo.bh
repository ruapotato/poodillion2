# fbdemo - Graphics demo for framebuffer
# Draws various shapes and text to demonstrate graphics capabilities

const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_write: int32 = 4
const SYS_lseek: int32 = 19
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45

const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const FBIOGET_VSCREENINFO: int32 = 0x4600
const SEEK_SET: int32 = 0

const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

# Draw a filled rectangle
proc fill_rect(fd: int32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32, line_buf: ptr uint32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var start_x: int32 = x
      var end_x: int32 = x + w
      if start_x < 0:
        start_x = 0
      if end_x > xres:
        end_x = xres
      if start_x < end_x:
        var width: int32 = end_x - start_x
        var i: int32 = 0
        while i < width:
          line_buf[i] = cast[uint32](color)
          i = i + 1
        var offset: int32 = (cy * xres + start_x) * 4
        discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
        discard syscall3(SYS_write, fd, cast[int32](line_buf), width * 4)
    cy = cy + 1

# Draw a single pixel
proc draw_pixel(fd: int32, x: int32, y: int32, color: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    pixel_buf[0] = cast[uint32](color)
    var offset: int32 = (y * xres + x) * 4
    discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

# Draw a circle outline using midpoint algorithm
proc draw_circle(fd: int32, cx: int32, cy: int32, r: int32, color: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  var x: int32 = r
  var y: int32 = 0
  var d: int32 = 1 - r

  while x >= y:
    draw_pixel(fd, cx + x, cy + y, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx - x, cy + y, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx + x, cy - y, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx - x, cy - y, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx + y, cy + x, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx - y, cy + x, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx + y, cy - x, color, xres, yres, pixel_buf)
    draw_pixel(fd, cx - y, cy - x, color, xres, yres, pixel_buf)

    y = y + 1
    if d < 0:
      d = d + 2 * y + 1
    else:
      x = x - 1
      d = d + 2 * (y - x) + 1

# Draw outline rectangle
proc draw_rect(fd: int32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32, line_buf: ptr uint32, pixel_buf: ptr uint32) =
  # Top and bottom
  fill_rect(fd, x, y, w, 1, color, xres, yres, line_buf)
  fill_rect(fd, x, y + h - 1, w, 1, color, xres, yres, line_buf)
  # Left and right
  var i: int32 = 0
  while i < h:
    draw_pixel(fd, x, y + i, color, xres, yres, pixel_buf)
    draw_pixel(fd, x + w - 1, y + i, color, xres, yres, pixel_buf)
    i = i + 1

# Simple font for demo text
proc get_font_row(c: int32, row: int32): int32 =
  if c == 32: return 0  # space
  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0
  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0
  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 83:  # S
    if row == 0: return 0x3C
    if row == 1: return 0x60
    if row == 2: return 0x3C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 97:  # a
    if row == 2: return 0x3C
    if row == 3: return 0x06
    if row == 4: return 0x3E
    if row == 5: return 0x66
    if row == 6: return 0x3E
    return 0
  if c == 104:  # h
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 105:  # i
    if row == 0: return 0x18
    if row == 1: return 0x00
    if row == 2: return 0x38
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0
  if c == 110:  # n
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 114:  # r
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  return 0

proc draw_char(fd: int32, x: int32, y: int32, c: int32, fg: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  var row: int32 = 0
  while row < 8:
    var font_row: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      if ((font_row >> (7 - col)) & 1) != 0:
        draw_pixel(fd, x + col, y + row, fg, xres, yres, pixel_buf)
      col = col + 1
    row = row + 1

proc draw_text(fd: int32, x: int32, y: int32, text: ptr uint8, fg: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  var cur_x: int32 = x
  var i: int32 = 0
  while text[i] != cast[uint8](0):
    draw_char(fd, cur_x, y, cast[int32](text[i]), fg, xres, yres, pixel_buf)
    cur_x = cur_x + 8
    i = i + 1

proc main() =
  print_str(cast[ptr uint8]("BrainhairOS Graphics Demo\n"))

  var fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate memory
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 16384
  discard syscall1(SYS_brk, new_brk)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var line_buf: ptr uint32 = cast[ptr uint32](old_brk + 256)
  var pixel_buf: ptr uint32 = cast[ptr uint32](old_brk + 8192)

  var result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if result < 0:
    print_str(cast[ptr uint8]("Error: Cannot get screen info\n"))
    discard syscall1(SYS_close, fd)
    discard syscall1(SYS_exit, 1)

  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  # Clear to dark blue background
  fill_rect(fd, 0, 0, xres, yres, 0x001030, xres, yres, line_buf)

  # Draw a green filled rectangle
  fill_rect(fd, 50, 50, 200, 100, 0x00AA00, xres, yres, line_buf)

  # Draw a red outlined rectangle
  draw_rect(fd, 300, 50, 150, 100, 0xFF0000, xres, yres, line_buf, pixel_buf)

  # Draw yellow circles
  draw_circle(fd, 550, 100, 40, 0xFFFF00, xres, yres, pixel_buf)
  draw_circle(fd, 550, 100, 30, 0xFFAA00, xres, yres, pixel_buf)
  draw_circle(fd, 550, 100, 20, 0xFF5500, xres, yres, pixel_buf)

  # Draw white text
  draw_text(fd, 50, 200, cast[ptr uint8]("BrainhairOS"), 0xFFFFFF, xres, yres, pixel_buf)

  # Draw a cyan filled rectangle as footer
  fill_rect(fd, 0, yres - 30, xres, 30, 0x008888, xres, yres, line_buf)

  discard syscall1(SYS_close, fd)

  print_str(cast[ptr uint8]("Demo complete!\n"))
  discard syscall1(SYS_exit, 0)

main()
