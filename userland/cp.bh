# cp - copy file
# Usage: cp source destination

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc main(): int32 =
  var argc: int32 = get_argc()

  if argc < 3:
    perror("Usage: cp source destination")
    return 1

  var source: ptr uint8 = get_argv(1)
  var dest: ptr uint8 = get_argv(2)

  # Open source file for reading
  var src_fd: int32 = open(source, O_RDONLY, 0)
  if src_fd < 0:
    perror("cp: cannot open source file")
    return 1

  # Create destination file for writing
  var mode: int32 = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
  var dest_fd: int32 = open(dest, O_WRONLY | O_CREAT | O_TRUNC, mode)
  if dest_fd < 0:
    perror("cp: cannot create destination file")
    discard close(src_fd)
    return 1

  # Allocate buffer for copying
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)

  # Copy loop: read from source, write to destination
  var running: int32 = 1
  while running != 0:
    var bytes_read: int32 = read(src_fd, buffer, 4096)

    if bytes_read < 0:
      perror("cp: read error")
      discard close(src_fd)
      discard close(dest_fd)
      return 1

    if bytes_read == 0:
      running = 0

    if bytes_read > 0:
      var bytes_written: int32 = write(dest_fd, buffer, bytes_read)
      if bytes_written != bytes_read:
        perror("cp: write error")
        discard close(src_fd)
        discard close(dest_fd)
        return 1

  # Close both files
  discard close(src_fd)
  discard close(dest_fd)
  return 0
