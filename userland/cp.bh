# cp - copy file
# Usage: cp source destination

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def main() -> int32:
    argc: int32 = get_argc()

    if argc < 3:
        perror("Usage: cp source destination")
        return 1

    source: *uint8 = get_argv(1)
    dest: *uint8 = get_argv(2)

    # Open source file for reading
    src_fd: int32 = open(source, O_RDONLY, 0)
    if src_fd < 0:
        perror("cp: cannot open source file")
        return 1

    # Create destination file for writing
    mode: int32 = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
    dest_fd: int32 = open(dest, O_WRONLY | O_CREAT | O_TRUNC, mode)
    if dest_fd < 0:
        perror("cp: cannot create destination file")
        close(src_fd)
        return 1

    # Allocate buffer for copying
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    syscall1(SYS_brk, new_brk)
    buffer: *uint8 = cast[*uint8](old_brk)

    # Copy loop: read from source, write to destination
    running: int32 = 1
    while running != 0:
        bytes_read: int32 = read(src_fd, buffer, 4096)

        if bytes_read < 0:
            perror("cp: read error")
            close(src_fd)
            close(dest_fd)
            return 1

        if bytes_read == 0:
            running = 0

        if bytes_read > 0:
            bytes_written: int32 = write(dest_fd, buffer, bytes_read)
            if bytes_written != bytes_read:
                perror("cp: write error")
                close(src_fd)
                close(dest_fd)
                return 1

    # Close both files
    close(src_fd)
    close(dest_fd)
    return 0
