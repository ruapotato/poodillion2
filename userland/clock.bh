# clock - Desktop Clock Widget
# Displays current time with analog and digital clock

from lib.syscalls import *

O_NONBLOCK: int32 = 2048
F_SETFL: int32 = 4
F_GETFL: int32 = 3

PROT_READ: int32 = 1
PROT_WRITE: int32 = 2
MAP_SHARED: int32 = 1

# Clock dimensions
CLOCK_SIZE: int32 = 300
CLOCK_RADIUS: int32 = 140

# Colors
BG_COLOR: int32 = 0x1A1A2E
CLOCK_FACE: int32 = 0x16213E
CLOCK_BORDER: int32 = 0x0F3460
HOUR_COLOR: int32 = 0xE94560
MINUTE_COLOR: int32 = 0x53BFDC
SECOND_COLOR: int32 = 0xFFFFFF
TICK_COLOR: int32 = 0x0F3460
TEXT_COLOR: int32 = 0xFFFFFF
CENTER_COLOR: int32 = 0xE94560

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Clock position
g_clock_x: int32 = 0
g_clock_y: int32 = 0

g_running: int32 = 1

# Sine table (scaled by 1000) for 0-90 degrees
sin_table: array[91, int32]

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, old_brk + 16)
    ts: *int32 = cast[*int32](old_brk)
    ts[0] = 0
    ts[1] = ms * 1000000
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

def init_sin_table():
    # Pre-computed sine values * 1000 for 0-90 degrees
    sin_table[0] = 0
    sin_table[1] = 17
    sin_table[2] = 35
    sin_table[3] = 52
    sin_table[4] = 70
    sin_table[5] = 87
    sin_table[6] = 105
    sin_table[7] = 122
    sin_table[8] = 139
    sin_table[9] = 156
    sin_table[10] = 174
    sin_table[11] = 191
    sin_table[12] = 208
    sin_table[13] = 225
    sin_table[14] = 242
    sin_table[15] = 259
    sin_table[16] = 276
    sin_table[17] = 292
    sin_table[18] = 309
    sin_table[19] = 326
    sin_table[20] = 342
    sin_table[21] = 358
    sin_table[22] = 375
    sin_table[23] = 391
    sin_table[24] = 407
    sin_table[25] = 423
    sin_table[26] = 438
    sin_table[27] = 454
    sin_table[28] = 469
    sin_table[29] = 485
    sin_table[30] = 500
    sin_table[31] = 515
    sin_table[32] = 530
    sin_table[33] = 545
    sin_table[34] = 559
    sin_table[35] = 574
    sin_table[36] = 588
    sin_table[37] = 602
    sin_table[38] = 616
    sin_table[39] = 629
    sin_table[40] = 643
    sin_table[41] = 656
    sin_table[42] = 669
    sin_table[43] = 682
    sin_table[44] = 695
    sin_table[45] = 707
    sin_table[46] = 719
    sin_table[47] = 731
    sin_table[48] = 743
    sin_table[49] = 755
    sin_table[50] = 766
    sin_table[51] = 777
    sin_table[52] = 788
    sin_table[53] = 799
    sin_table[54] = 809
    sin_table[55] = 819
    sin_table[56] = 829
    sin_table[57] = 839
    sin_table[58] = 848
    sin_table[59] = 857
    sin_table[60] = 866
    sin_table[61] = 875
    sin_table[62] = 883
    sin_table[63] = 891
    sin_table[64] = 899
    sin_table[65] = 906
    sin_table[66] = 914
    sin_table[67] = 921
    sin_table[68] = 927
    sin_table[69] = 934
    sin_table[70] = 940
    sin_table[71] = 946
    sin_table[72] = 951
    sin_table[73] = 956
    sin_table[74] = 961
    sin_table[75] = 966
    sin_table[76] = 970
    sin_table[77] = 974
    sin_table[78] = 978
    sin_table[79] = 982
    sin_table[80] = 985
    sin_table[81] = 988
    sin_table[82] = 990
    sin_table[83] = 993
    sin_table[84] = 995
    sin_table[85] = 996
    sin_table[86] = 998
    sin_table[87] = 999
    sin_table[88] = 999
    sin_table[89] = 1000
    sin_table[90] = 1000

def sin_deg(deg: int32) -> int32:
    # Returns sin(deg) * 1000
    d: int32 = deg
    while d < 0:
        d = d + 360
    while d >= 360:
        d = d - 360

    if d <= 90:
        return sin_table[d]
    if d <= 180:
        return sin_table[180 - d]
    if d <= 270:
        return 0 - sin_table[d - 180]
    return 0 - sin_table[360 - d]

def cos_deg(deg: int32) -> int32:
    return sin_deg(deg + 90)

# ============ Drawing Primitives ============

def fb_pixel(x: int32, y: int32, color: int32):
    if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
        g_fb[y * g_xres + x] = cast[uint32](color)

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
    cy: int32 = y
    while cy < y + h:
        if cy >= 0 and cy < g_yres:
            cx: int32 = x
            while cx < x + w:
                if cx >= 0 and cx < g_xres:
                    g_fb[cy * g_xres + cx] = cast[uint32](color)
                cx = cx + 1
        cy = cy + 1

def fill_circle(cx: int32, cy: int32, r: int32, color: int32):
    y: int32 = 0 - r
    while y <= r:
        x: int32 = 0 - r
        while x <= r:
            if x * x + y * y <= r * r:
                fb_pixel(cx + x, cy + y, color)
            x = x + 1
        y = y + 1

def draw_circle_outline(cx: int32, cy: int32, r: int32, thickness: int32, color: int32):
    y: int32 = 0 - r - thickness
    while y <= r + thickness:
        x: int32 = 0 - r - thickness
        while x <= r + thickness:
            dist_sq: int32 = x * x + y * y
            outer_sq: int32 = (r + thickness) * (r + thickness)
            inner_sq: int32 = (r - thickness) * (r - thickness)
            if dist_sq <= outer_sq and dist_sq >= inner_sq:
                fb_pixel(cx + x, cy + y, color)
            x = x + 1
        y = y + 1

def draw_line(x0: int32, y0: int32, x1: int32, y1: int32, thickness: int32, color: int32):
    dx: int32 = x1 - x0
    dy: int32 = y1 - y0
    if dx < 0:
        dx = 0 - dx
    if dy < 0:
        dy = 0 - dy

    sx: int32 = 1
    if x0 > x1:
        sx = 0 - 1
    sy: int32 = 1
    if y0 > y1:
        sy = 0 - 1

    err: int32 = dx - dy
    x: int32 = x0
    y: int32 = y0

    while x != x1 or y != y1:
        # Draw thick point
        ty: int32 = 0 - thickness / 2
        while ty <= thickness / 2:
            tx: int32 = 0 - thickness / 2
            while tx <= thickness / 2:
                fb_pixel(x + tx, y + ty, color)
                tx = tx + 1
            ty = ty + 1

        e2: int32 = 2 * err
        if e2 > 0 - dy:
            err = err - dy
            x = x + sx
        if e2 < dx:
            err = err + dx
            y = y + sy

# 8x8 font for digital clock
font: array[768, uint8]

def init_font():
    i: int32 = 0
    while i < 768:
        font[i] = cast[uint8](0)
        i = i + 1

    # Digits 0-9
    font[384] = cast[uint8](0x3C)
    font[385] = cast[uint8](0x66)
    font[386] = cast[uint8](0x6E)
    font[387] = cast[uint8](0x7E)
    font[388] = cast[uint8](0x76)
    font[389] = cast[uint8](0x66)
    font[390] = cast[uint8](0x3C)
    font[391] = cast[uint8](0x00)

    font[392] = cast[uint8](0x18)
    font[393] = cast[uint8](0x38)
    font[394] = cast[uint8](0x18)
    font[395] = cast[uint8](0x18)
    font[396] = cast[uint8](0x18)
    font[397] = cast[uint8](0x18)
    font[398] = cast[uint8](0x7E)
    font[399] = cast[uint8](0x00)

    font[400] = cast[uint8](0x3C)
    font[401] = cast[uint8](0x66)
    font[402] = cast[uint8](0x06)
    font[403] = cast[uint8](0x0C)
    font[404] = cast[uint8](0x18)
    font[405] = cast[uint8](0x30)
    font[406] = cast[uint8](0x7E)
    font[407] = cast[uint8](0x00)

    font[408] = cast[uint8](0x3C)
    font[409] = cast[uint8](0x66)
    font[410] = cast[uint8](0x06)
    font[411] = cast[uint8](0x1C)
    font[412] = cast[uint8](0x06)
    font[413] = cast[uint8](0x66)
    font[414] = cast[uint8](0x3C)
    font[415] = cast[uint8](0x00)

    font[416] = cast[uint8](0x0C)
    font[417] = cast[uint8](0x1C)
    font[418] = cast[uint8](0x3C)
    font[419] = cast[uint8](0x6C)
    font[420] = cast[uint8](0x7E)
    font[421] = cast[uint8](0x0C)
    font[422] = cast[uint8](0x0C)
    font[423] = cast[uint8](0x00)

    font[424] = cast[uint8](0x7E)
    font[425] = cast[uint8](0x60)
    font[426] = cast[uint8](0x7C)
    font[427] = cast[uint8](0x06)
    font[428] = cast[uint8](0x06)
    font[429] = cast[uint8](0x66)
    font[430] = cast[uint8](0x3C)
    font[431] = cast[uint8](0x00)

    font[432] = cast[uint8](0x1C)
    font[433] = cast[uint8](0x30)
    font[434] = cast[uint8](0x60)
    font[435] = cast[uint8](0x7C)
    font[436] = cast[uint8](0x66)
    font[437] = cast[uint8](0x66)
    font[438] = cast[uint8](0x3C)
    font[439] = cast[uint8](0x00)

    font[440] = cast[uint8](0x7E)
    font[441] = cast[uint8](0x06)
    font[442] = cast[uint8](0x0C)
    font[443] = cast[uint8](0x18)
    font[444] = cast[uint8](0x30)
    font[445] = cast[uint8](0x30)
    font[446] = cast[uint8](0x30)
    font[447] = cast[uint8](0x00)

    font[448] = cast[uint8](0x3C)
    font[449] = cast[uint8](0x66)
    font[450] = cast[uint8](0x66)
    font[451] = cast[uint8](0x3C)
    font[452] = cast[uint8](0x66)
    font[453] = cast[uint8](0x66)
    font[454] = cast[uint8](0x3C)
    font[455] = cast[uint8](0x00)

    font[456] = cast[uint8](0x3C)
    font[457] = cast[uint8](0x66)
    font[458] = cast[uint8](0x66)
    font[459] = cast[uint8](0x3E)
    font[460] = cast[uint8](0x06)
    font[461] = cast[uint8](0x0C)
    font[462] = cast[uint8](0x38)
    font[463] = cast[uint8](0x00)

    # ':' = 58
    font[464] = cast[uint8](0x00)
    font[465] = cast[uint8](0x18)
    font[466] = cast[uint8](0x18)
    font[467] = cast[uint8](0x00)
    font[468] = cast[uint8](0x00)
    font[469] = cast[uint8](0x18)
    font[470] = cast[uint8](0x18)
    font[471] = cast[uint8](0x00)

def draw_char_big(x: int32, y: int32, c: uint8, color: int32, scale: int32):
    idx: int32 = cast[int32](c) * 8
    if idx < 0 or idx >= 760:
        return
    row: int32 = 0
    while row < 8:
        bits: uint8 = font[idx + row]
        col: int32 = 0
        while col < 8:
            mask: int32 = 128
            shift: int32 = col
            while shift > 0:
                mask = mask / 2
                shift = shift - 1
            if (cast[int32](bits) & mask) != 0:
                fill_rect(x + col * scale, y + row * scale, scale, scale, color)
            col = col + 1
        row = row + 1

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, old_brk + 512)
    path: *uint8 = cast[*uint8](old_brk)
    path[0] = cast[uint8](47)
    path[1] = cast[uint8](100)
    path[2] = cast[uint8](101)
    path[3] = cast[uint8](118)
    path[4] = cast[uint8](47)
    path[5] = cast[uint8](102)
    path[6] = cast[uint8](98)
    path[7] = cast[uint8](48)
    path[8] = cast[uint8](0)

    g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
    if g_fb_fd < 0:
        print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
        return 1

    vinfo: *int32 = cast[*int32](old_brk + 32)
    i: int32 = 0
    while i < 40:
        vinfo[i] = 0
        i = i + 1

    FBIOGET_VSCREENINFO: int32 = 0x4600
    syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

    g_xres = vinfo[0]
    g_yres = vinfo[1]

    fb_size: int32 = g_xres * g_yres * 4
    g_fb = cast[*uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

    if cast[int32](g_fb) < 0:
        return 1

    # Center clock
    g_clock_x = g_xres / 2
    g_clock_y = g_yres / 2 - 30

    # Set stdin non-blocking
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

    return 0

# ============ Time Functions ============

def get_time(hours: *int32, minutes: *int32, seconds: *int32):
    t: int32 = syscall1(SYS_time, 0)

    # Convert to local time (simple, no timezone)
    secs: int32 = t % 60
    mins: int32 = (t / 60) % 60
    hrs: int32 = (t / 3600) % 24

    hours[0] = hrs
    minutes[0] = mins
    seconds[0] = secs

# ============ Clock Drawing ============

def draw_clock_face():
    # Draw clock border
    draw_circle_outline(g_clock_x, g_clock_y, CLOCK_RADIUS, 4, CLOCK_BORDER)

    # Fill clock face
    fill_circle(g_clock_x, g_clock_y, CLOCK_RADIUS - 5, CLOCK_FACE)

    # Draw hour ticks
    i: int32 = 0
    while i < 12:
        angle: int32 = i * 30 - 90  # 30 degrees per hour, start at 12 o'clock
        outer_r: int32 = CLOCK_RADIUS - 10
        inner_r: int32 = CLOCK_RADIUS - 25

        x1: int32 = g_clock_x + (inner_r * cos_deg(angle)) / 1000
        y1: int32 = g_clock_y + (inner_r * sin_deg(angle)) / 1000
        x2: int32 = g_clock_x + (outer_r * cos_deg(angle)) / 1000
        y2: int32 = g_clock_y + (outer_r * sin_deg(angle)) / 1000

        draw_line(x1, y1, x2, y2, 3, TICK_COLOR)
        i = i + 1

    # Draw minute ticks
    i = 0
    while i < 60:
        if i % 5 != 0:  # Skip hour positions
            angle: int32 = i * 6 - 90
            outer_r: int32 = CLOCK_RADIUS - 10
            inner_r: int32 = CLOCK_RADIUS - 15

            x1: int32 = g_clock_x + (inner_r * cos_deg(angle)) / 1000
            y1: int32 = g_clock_y + (inner_r * sin_deg(angle)) / 1000
            x2: int32 = g_clock_x + (outer_r * cos_deg(angle)) / 1000
            y2: int32 = g_clock_y + (outer_r * sin_deg(angle)) / 1000

            draw_line(x1, y1, x2, y2, 1, TICK_COLOR)
        i = i + 1

def draw_hands(hours: int32, minutes: int32, seconds: int32):
    # Calculate angles (0 degrees = 12 o'clock, clockwise positive)
    second_angle: int32 = seconds * 6 - 90
    minute_angle: int32 = minutes * 6 + seconds / 10 - 90
    hour_angle: int32 = hours * 30 + minutes / 2 - 90

    # Hour hand (short, thick)
    hour_len: int32 = 70
    hx: int32 = g_clock_x + (hour_len * cos_deg(hour_angle)) / 1000
    hy: int32 = g_clock_y + (hour_len * sin_deg(hour_angle)) / 1000
    draw_line(g_clock_x, g_clock_y, hx, hy, 6, HOUR_COLOR)

    # Minute hand (longer, medium)
    min_len: int32 = 100
    mx: int32 = g_clock_x + (min_len * cos_deg(minute_angle)) / 1000
    my: int32 = g_clock_y + (min_len * sin_deg(minute_angle)) / 1000
    draw_line(g_clock_x, g_clock_y, mx, my, 4, MINUTE_COLOR)

    # Second hand (longest, thin)
    sec_len: int32 = 120
    sx: int32 = g_clock_x + (sec_len * cos_deg(second_angle)) / 1000
    sy: int32 = g_clock_y + (sec_len * sin_deg(second_angle)) / 1000
    draw_line(g_clock_x, g_clock_y, sx, sy, 2, SECOND_COLOR)

    # Center dot
    fill_circle(g_clock_x, g_clock_y, 8, CENTER_COLOR)

def draw_digital_time(hours: int32, minutes: int32, seconds: int32):
    y: int32 = g_clock_y + CLOCK_RADIUS + 30
    x: int32 = g_clock_x - 60

    # Hours
    h1: int32 = hours / 10
    h2: int32 = hours % 10
    draw_char_big(x, y, cast[uint8](48 + h1), TEXT_COLOR, 3)
    draw_char_big(x + 24, y, cast[uint8](48 + h2), TEXT_COLOR, 3)

    # Colon
    draw_char_big(x + 48, y, cast[uint8](58), TEXT_COLOR, 3)

    # Minutes
    m1: int32 = minutes / 10
    m2: int32 = minutes % 10
    draw_char_big(x + 72, y, cast[uint8](48 + m1), TEXT_COLOR, 3)
    draw_char_big(x + 96, y, cast[uint8](48 + m2), TEXT_COLOR, 3)

def render_clock():
    # Clear background
    i: int32 = 0
    total: int32 = g_xres * g_yres
    while i < total:
        g_fb[i] = cast[uint32](BG_COLOR)
        i = i + 1

    # Get current time
    hours: int32 = 0
    minutes: int32 = 0
    seconds: int32 = 0
    get_time(cast[*int32](hours), cast[*int32](minutes), cast[*int32](seconds))

    # Draw clock
    draw_clock_face()
    draw_hands(hours, minutes, seconds)
    draw_digital_time(hours, minutes, seconds)

# ============ Input ============

def handle_input():
    buf: array[8, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

    if n > 0:
        c: uint8 = buf[0]
        if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q
            g_running = 0

# ============ Main ============

def main() -> int32:
    print_str(cast[*uint8]("Clock - Press Q to quit\n"))

    if init_framebuffer() != 0:
        return 1

    init_font()
    init_sin_table()

    while g_running != 0:
        handle_input()
        render_clock()
        sleep_ms(100)

    # Clear screen
    i: int32 = 0
    total: int32 = g_xres * g_yres
    while i < total:
        g_fb[i] = cast[uint32](0)
        i = i + 1

    syscall1(SYS_close, g_fb_fd)
    return 0

main()
