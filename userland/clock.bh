# clock - Desktop Clock Widget
# Displays current time with analog and digital clock

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192
const SYS_nanosleep: int32 = 162
const SYS_time: int32 = 13

const STDIN: int32 = 0
const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Clock dimensions
const CLOCK_SIZE: int32 = 300
const CLOCK_RADIUS: int32 = 140

# Colors
const BG_COLOR: int32 = 0x1A1A2E
const CLOCK_FACE: int32 = 0x16213E
const CLOCK_BORDER: int32 = 0x0F3460
const HOUR_COLOR: int32 = 0xE94560
const MINUTE_COLOR: int32 = 0x53BFDC
const SECOND_COLOR: int32 = 0xFFFFFF
const TICK_COLOR: int32 = 0x0F3460
const TEXT_COLOR: int32 = 0xFFFFFF
const CENTER_COLOR: int32 = 0xE94560

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Clock position
var g_clock_x: int32 = 0
var g_clock_y: int32 = 0

var g_running: int32 = 1

# Sine table (scaled by 1000) for 0-90 degrees
var sin_table: array[91, int32]

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

proc init_sin_table() =
  # Pre-computed sine values * 1000 for 0-90 degrees
  sin_table[0] = 0
  sin_table[1] = 17
  sin_table[2] = 35
  sin_table[3] = 52
  sin_table[4] = 70
  sin_table[5] = 87
  sin_table[6] = 105
  sin_table[7] = 122
  sin_table[8] = 139
  sin_table[9] = 156
  sin_table[10] = 174
  sin_table[11] = 191
  sin_table[12] = 208
  sin_table[13] = 225
  sin_table[14] = 242
  sin_table[15] = 259
  sin_table[16] = 276
  sin_table[17] = 292
  sin_table[18] = 309
  sin_table[19] = 326
  sin_table[20] = 342
  sin_table[21] = 358
  sin_table[22] = 375
  sin_table[23] = 391
  sin_table[24] = 407
  sin_table[25] = 423
  sin_table[26] = 438
  sin_table[27] = 454
  sin_table[28] = 469
  sin_table[29] = 485
  sin_table[30] = 500
  sin_table[31] = 515
  sin_table[32] = 530
  sin_table[33] = 545
  sin_table[34] = 559
  sin_table[35] = 574
  sin_table[36] = 588
  sin_table[37] = 602
  sin_table[38] = 616
  sin_table[39] = 629
  sin_table[40] = 643
  sin_table[41] = 656
  sin_table[42] = 669
  sin_table[43] = 682
  sin_table[44] = 695
  sin_table[45] = 707
  sin_table[46] = 719
  sin_table[47] = 731
  sin_table[48] = 743
  sin_table[49] = 755
  sin_table[50] = 766
  sin_table[51] = 777
  sin_table[52] = 788
  sin_table[53] = 799
  sin_table[54] = 809
  sin_table[55] = 819
  sin_table[56] = 829
  sin_table[57] = 839
  sin_table[58] = 848
  sin_table[59] = 857
  sin_table[60] = 866
  sin_table[61] = 875
  sin_table[62] = 883
  sin_table[63] = 891
  sin_table[64] = 899
  sin_table[65] = 906
  sin_table[66] = 914
  sin_table[67] = 921
  sin_table[68] = 927
  sin_table[69] = 934
  sin_table[70] = 940
  sin_table[71] = 946
  sin_table[72] = 951
  sin_table[73] = 956
  sin_table[74] = 961
  sin_table[75] = 966
  sin_table[76] = 970
  sin_table[77] = 974
  sin_table[78] = 978
  sin_table[79] = 982
  sin_table[80] = 985
  sin_table[81] = 988
  sin_table[82] = 990
  sin_table[83] = 993
  sin_table[84] = 995
  sin_table[85] = 996
  sin_table[86] = 998
  sin_table[87] = 999
  sin_table[88] = 999
  sin_table[89] = 1000
  sin_table[90] = 1000

proc sin_deg(deg: int32): int32 =
  # Returns sin(deg) * 1000
  var d: int32 = deg
  while d < 0:
    d = d + 360
  while d >= 360:
    d = d - 360

  if d <= 90:
    return sin_table[d]
  if d <= 180:
    return sin_table[180 - d]
  if d <= 270:
    return 0 - sin_table[d - 180]
  return 0 - sin_table[360 - d]

proc cos_deg(deg: int32): int32 =
  return sin_deg(deg + 90)

# ============ Drawing Primitives ============

proc fb_pixel(x: int32, y: int32, color: int32) =
  if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
    g_fb[y * g_xres + x] = cast[uint32](color)

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < g_yres:
      var cx: int32 = x
      while cx < x + w:
        if cx >= 0 and cx < g_xres:
          g_fb[cy * g_xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc fill_circle(cx: int32, cy: int32, r: int32, color: int32) =
  var y: int32 = 0 - r
  while y <= r:
    var x: int32 = 0 - r
    while x <= r:
      if x * x + y * y <= r * r:
        fb_pixel(cx + x, cy + y, color)
      x = x + 1
    y = y + 1

proc draw_circle_outline(cx: int32, cy: int32, r: int32, thickness: int32, color: int32) =
  var y: int32 = 0 - r - thickness
  while y <= r + thickness:
    var x: int32 = 0 - r - thickness
    while x <= r + thickness:
      var dist_sq: int32 = x * x + y * y
      var outer_sq: int32 = (r + thickness) * (r + thickness)
      var inner_sq: int32 = (r - thickness) * (r - thickness)
      if dist_sq <= outer_sq and dist_sq >= inner_sq:
        fb_pixel(cx + x, cy + y, color)
      x = x + 1
    y = y + 1

proc draw_line(x0: int32, y0: int32, x1: int32, y1: int32, thickness: int32, color: int32) =
  var dx: int32 = x1 - x0
  var dy: int32 = y1 - y0
  if dx < 0:
    dx = 0 - dx
  if dy < 0:
    dy = 0 - dy

  var sx: int32 = 1
  if x0 > x1:
    sx = 0 - 1
  var sy: int32 = 1
  if y0 > y1:
    sy = 0 - 1

  var err: int32 = dx - dy
  var x: int32 = x0
  var y: int32 = y0

  while x != x1 or y != y1:
    # Draw thick point
    var ty: int32 = 0 - thickness / 2
    while ty <= thickness / 2:
      var tx: int32 = 0 - thickness / 2
      while tx <= thickness / 2:
        fb_pixel(x + tx, y + ty, color)
        tx = tx + 1
      ty = ty + 1

    var e2: int32 = 2 * err
    if e2 > 0 - dy:
      err = err - dy
      x = x + sx
    if e2 < dx:
      err = err + dx
      y = y + sy

# 8x8 font for digital clock
var font: array[768, uint8]

proc init_font() =
  var i: int32 = 0
  while i < 768:
    font[i] = cast[uint8](0)
    i = i + 1

  # Digits 0-9
  font[384] = cast[uint8](0x3C)
  font[385] = cast[uint8](0x66)
  font[386] = cast[uint8](0x6E)
  font[387] = cast[uint8](0x7E)
  font[388] = cast[uint8](0x76)
  font[389] = cast[uint8](0x66)
  font[390] = cast[uint8](0x3C)
  font[391] = cast[uint8](0x00)

  font[392] = cast[uint8](0x18)
  font[393] = cast[uint8](0x38)
  font[394] = cast[uint8](0x18)
  font[395] = cast[uint8](0x18)
  font[396] = cast[uint8](0x18)
  font[397] = cast[uint8](0x18)
  font[398] = cast[uint8](0x7E)
  font[399] = cast[uint8](0x00)

  font[400] = cast[uint8](0x3C)
  font[401] = cast[uint8](0x66)
  font[402] = cast[uint8](0x06)
  font[403] = cast[uint8](0x0C)
  font[404] = cast[uint8](0x18)
  font[405] = cast[uint8](0x30)
  font[406] = cast[uint8](0x7E)
  font[407] = cast[uint8](0x00)

  font[408] = cast[uint8](0x3C)
  font[409] = cast[uint8](0x66)
  font[410] = cast[uint8](0x06)
  font[411] = cast[uint8](0x1C)
  font[412] = cast[uint8](0x06)
  font[413] = cast[uint8](0x66)
  font[414] = cast[uint8](0x3C)
  font[415] = cast[uint8](0x00)

  font[416] = cast[uint8](0x0C)
  font[417] = cast[uint8](0x1C)
  font[418] = cast[uint8](0x3C)
  font[419] = cast[uint8](0x6C)
  font[420] = cast[uint8](0x7E)
  font[421] = cast[uint8](0x0C)
  font[422] = cast[uint8](0x0C)
  font[423] = cast[uint8](0x00)

  font[424] = cast[uint8](0x7E)
  font[425] = cast[uint8](0x60)
  font[426] = cast[uint8](0x7C)
  font[427] = cast[uint8](0x06)
  font[428] = cast[uint8](0x06)
  font[429] = cast[uint8](0x66)
  font[430] = cast[uint8](0x3C)
  font[431] = cast[uint8](0x00)

  font[432] = cast[uint8](0x1C)
  font[433] = cast[uint8](0x30)
  font[434] = cast[uint8](0x60)
  font[435] = cast[uint8](0x7C)
  font[436] = cast[uint8](0x66)
  font[437] = cast[uint8](0x66)
  font[438] = cast[uint8](0x3C)
  font[439] = cast[uint8](0x00)

  font[440] = cast[uint8](0x7E)
  font[441] = cast[uint8](0x06)
  font[442] = cast[uint8](0x0C)
  font[443] = cast[uint8](0x18)
  font[444] = cast[uint8](0x30)
  font[445] = cast[uint8](0x30)
  font[446] = cast[uint8](0x30)
  font[447] = cast[uint8](0x00)

  font[448] = cast[uint8](0x3C)
  font[449] = cast[uint8](0x66)
  font[450] = cast[uint8](0x66)
  font[451] = cast[uint8](0x3C)
  font[452] = cast[uint8](0x66)
  font[453] = cast[uint8](0x66)
  font[454] = cast[uint8](0x3C)
  font[455] = cast[uint8](0x00)

  font[456] = cast[uint8](0x3C)
  font[457] = cast[uint8](0x66)
  font[458] = cast[uint8](0x66)
  font[459] = cast[uint8](0x3E)
  font[460] = cast[uint8](0x06)
  font[461] = cast[uint8](0x0C)
  font[462] = cast[uint8](0x38)
  font[463] = cast[uint8](0x00)

  # ':' = 58
  font[464] = cast[uint8](0x00)
  font[465] = cast[uint8](0x18)
  font[466] = cast[uint8](0x18)
  font[467] = cast[uint8](0x00)
  font[468] = cast[uint8](0x00)
  font[469] = cast[uint8](0x18)
  font[470] = cast[uint8](0x18)
  font[471] = cast[uint8](0x00)

proc draw_char_big(x: int32, y: int32, c: uint8, color: int32, scale: int32) =
  var idx: int32 = cast[int32](c) * 8
  if idx < 0 or idx >= 760:
    return
  var row: int32 = 0
  while row < 8:
    var bits: uint8 = font[idx + row]
    var col: int32 = 0
    while col < 8:
      var mask: int32 = 128
      var shift: int32 = col
      while shift > 0:
        mask = mask / 2
        shift = shift - 1
      if (cast[int32](bits) & mask) != 0:
        fill_rect(x + col * scale, y + row * scale, scale, scale, color)
      col = col + 1
    row = row + 1

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 512)
  var path: ptr uint8 = cast[ptr uint8](old_brk)
  path[0] = cast[uint8](47)
  path[1] = cast[uint8](100)
  path[2] = cast[uint8](101)
  path[3] = cast[uint8](118)
  path[4] = cast[uint8](47)
  path[5] = cast[uint8](102)
  path[6] = cast[uint8](98)
  path[7] = cast[uint8](48)
  path[8] = cast[uint8](0)

  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  var fb_size: int32 = g_xres * g_yres * 4
  g_fb = cast[ptr uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

  if cast[int32](g_fb) < 0:
    return 1

  # Center clock
  g_clock_x = g_xres / 2
  g_clock_y = g_yres / 2 - 30

  # Set stdin non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

  return 0

# ============ Time Functions ============

proc get_time(hours: ptr int32, minutes: ptr int32, seconds: ptr int32) =
  var t: int32 = syscall1(SYS_time, 0)

  # Convert to local time (simple, no timezone)
  var secs: int32 = t % 60
  var mins: int32 = (t / 60) % 60
  var hrs: int32 = (t / 3600) % 24

  hours[0] = hrs
  minutes[0] = mins
  seconds[0] = secs

# ============ Clock Drawing ============

proc draw_clock_face() =
  # Draw clock border
  draw_circle_outline(g_clock_x, g_clock_y, CLOCK_RADIUS, 4, CLOCK_BORDER)

  # Fill clock face
  fill_circle(g_clock_x, g_clock_y, CLOCK_RADIUS - 5, CLOCK_FACE)

  # Draw hour ticks
  var i: int32 = 0
  while i < 12:
    var angle: int32 = i * 30 - 90  # 30 degrees per hour, start at 12 o'clock
    var outer_r: int32 = CLOCK_RADIUS - 10
    var inner_r: int32 = CLOCK_RADIUS - 25

    var x1: int32 = g_clock_x + (inner_r * cos_deg(angle)) / 1000
    var y1: int32 = g_clock_y + (inner_r * sin_deg(angle)) / 1000
    var x2: int32 = g_clock_x + (outer_r * cos_deg(angle)) / 1000
    var y2: int32 = g_clock_y + (outer_r * sin_deg(angle)) / 1000

    draw_line(x1, y1, x2, y2, 3, TICK_COLOR)
    i = i + 1

  # Draw minute ticks
  i = 0
  while i < 60:
    if i % 5 != 0:  # Skip hour positions
      var angle: int32 = i * 6 - 90
      var outer_r: int32 = CLOCK_RADIUS - 10
      var inner_r: int32 = CLOCK_RADIUS - 15

      var x1: int32 = g_clock_x + (inner_r * cos_deg(angle)) / 1000
      var y1: int32 = g_clock_y + (inner_r * sin_deg(angle)) / 1000
      var x2: int32 = g_clock_x + (outer_r * cos_deg(angle)) / 1000
      var y2: int32 = g_clock_y + (outer_r * sin_deg(angle)) / 1000

      draw_line(x1, y1, x2, y2, 1, TICK_COLOR)
    i = i + 1

proc draw_hands(hours: int32, minutes: int32, seconds: int32) =
  # Calculate angles (0 degrees = 12 o'clock, clockwise positive)
  var second_angle: int32 = seconds * 6 - 90
  var minute_angle: int32 = minutes * 6 + seconds / 10 - 90
  var hour_angle: int32 = hours * 30 + minutes / 2 - 90

  # Hour hand (short, thick)
  var hour_len: int32 = 70
  var hx: int32 = g_clock_x + (hour_len * cos_deg(hour_angle)) / 1000
  var hy: int32 = g_clock_y + (hour_len * sin_deg(hour_angle)) / 1000
  draw_line(g_clock_x, g_clock_y, hx, hy, 6, HOUR_COLOR)

  # Minute hand (longer, medium)
  var min_len: int32 = 100
  var mx: int32 = g_clock_x + (min_len * cos_deg(minute_angle)) / 1000
  var my: int32 = g_clock_y + (min_len * sin_deg(minute_angle)) / 1000
  draw_line(g_clock_x, g_clock_y, mx, my, 4, MINUTE_COLOR)

  # Second hand (longest, thin)
  var sec_len: int32 = 120
  var sx: int32 = g_clock_x + (sec_len * cos_deg(second_angle)) / 1000
  var sy: int32 = g_clock_y + (sec_len * sin_deg(second_angle)) / 1000
  draw_line(g_clock_x, g_clock_y, sx, sy, 2, SECOND_COLOR)

  # Center dot
  fill_circle(g_clock_x, g_clock_y, 8, CENTER_COLOR)

proc draw_digital_time(hours: int32, minutes: int32, seconds: int32) =
  var y: int32 = g_clock_y + CLOCK_RADIUS + 30
  var x: int32 = g_clock_x - 60

  # Hours
  var h1: int32 = hours / 10
  var h2: int32 = hours % 10
  draw_char_big(x, y, cast[uint8](48 + h1), TEXT_COLOR, 3)
  draw_char_big(x + 24, y, cast[uint8](48 + h2), TEXT_COLOR, 3)

  # Colon
  draw_char_big(x + 48, y, cast[uint8](58), TEXT_COLOR, 3)

  # Minutes
  var m1: int32 = minutes / 10
  var m2: int32 = minutes % 10
  draw_char_big(x + 72, y, cast[uint8](48 + m1), TEXT_COLOR, 3)
  draw_char_big(x + 96, y, cast[uint8](48 + m2), TEXT_COLOR, 3)

proc render_clock() =
  # Clear background
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](BG_COLOR)
    i = i + 1

  # Get current time
  var hours: int32 = 0
  var minutes: int32 = 0
  var seconds: int32 = 0
  get_time(cast[ptr int32](hours), cast[ptr int32](minutes), cast[ptr int32](seconds))

  # Draw clock
  draw_clock_face()
  draw_hands(hours, minutes, seconds)
  draw_digital_time(hours, minutes, seconds)

# ============ Input ============

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n > 0:
    var c: uint8 = buf[0]
    if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q
      g_running = 0

# ============ Main ============

proc main(): int32 =
  print_str(cast[ptr uint8]("Clock - Press Q to quit\n"))

  if init_framebuffer() != 0:
    return 1

  init_font()
  init_sin_table()

  while g_running != 0:
    handle_input()
    render_clock()
    sleep_ms(100)

  # Clear screen
  var i: int32 = 0
  var total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0)
    i = i + 1

  discard syscall1(SYS_close, g_fb_fd)
  return 0

main()
