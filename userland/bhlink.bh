# bhlink.bh - Brainhair ELF32 Linker
# Links ELF32 relocatable object files into executables

from lib.syscalls import *

# ELF constants
const ELF_MAGIC: int32 = 0x464C457F   # "\x7fELF"
const ET_REL: int32 = 1                # Relocatable file
const ET_EXEC: int32 = 2               # Executable file
const EM_386: int32 = 3                # Intel 80386
const PT_LOAD: int32 = 1               # Loadable segment

# Relocation types
const R_386_32: int32 = 1              # Direct 32-bit
const R_386_PC32: int32 = 2            # PC-relative 32-bit

# Section header types
const SHT_NULL: int32 = 0
const SHT_PROGBITS: int32 = 1
const SHT_SYMTAB: int32 = 2
const SHT_STRTAB: int32 = 3
const SHT_NOBITS: int32 = 8
const SHT_REL: int32 = 9

# Base addresses for ELF segments
const BASE_ADDR: int32 = 0x08048000    # Load address
const TEXT_ADDR: int32 = 0x08049000    # Code segment
const DATA_ADDR: int32 = 0x0804A000    # Data segment

# Maximum sizes
const MAX_FILES: int32 = 16
const MAX_SYMBOLS: int32 = 4096
const MAX_SECTIONS: int32 = 64
const MAX_RELOCS: int32 = 4096

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# Output buffer
g_output: *uint8 = cast[*uint8](0)
g_output_len: int32 = 0
g_output_cap: int32 = 0

# Combined sections
g_text: *uint8 = cast[*uint8](0)
g_text_len: int32 = 0
g_data: *uint8 = cast[*uint8](0)
g_data_len: int32 = 0
g_bss_len: int32 = 0

# Symbol table
g_sym_names: *uint8 = cast[*uint8](0)    # String pool for names
g_sym_name_len: int32 = 0
g_sym_values: *int32 = cast[*int32](0)   # Symbol values (addresses)
g_sym_sections: *int32 = cast[*int32](0) # Symbol sections (0=undef, 1=text, 2=data, 3=bss)
g_sym_offsets: *int32 = cast[*int32](0)  # Offsets into g_sym_names
g_sym_count: int32 = 0

# Relocations
g_reloc_offsets: *int32 = cast[*int32](0)  # Offset in text section
g_reloc_types: *int32 = cast[*int32](0)    # R_386_32 or R_386_PC32
g_reloc_syms: *int32 = cast[*int32](0)     # Symbol index
g_reloc_count: int32 = 0

# Entry point symbol
g_entry_point: int32 = 0

# Data file offset (calculated dynamically)
g_data_file_off: int32 = 0

# Data virtual address (calculated dynamically based on text size)
g_data_vaddr: int32 = 0

# Error flag
g_error: int32 = 0

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

def print_num(n: int32):
  buf: array[12, uint8]
  i: int32 = 10
  buf[11] = cast[uint8](0)
  if n == 0:
    buf[10] = cast[uint8](48)
    i = 10
  else:
    num: int32 = n
    neg: int32 = 0
    if num < 0:
      neg = 1
      num = 0 - num
    while num > 0 and i > 0:
      buf[i] = cast[uint8](48 + (num % 10))
      num = num / 10
      i = i - 1
    if neg == 1:
      buf[i] = cast[uint8](45)
      i = i - 1
    i = i + 1
  print(cast[*uint8](cast[int32](addr(buf)) + i))

def print_hex(n: int32):
  buf: array[12, uint8]
  # Initialize buffer with "0x00000000\0"
  buf[0] = cast[uint8](48)  # '0'
  buf[1] = cast[uint8](120) # 'x'
  j: int32 = 2
  while j < 10:
    buf[j] = cast[uint8](48)  # '0'
    j = j + 1
  buf[10] = cast[uint8](0)
  # Fill in hex digits from right to left
  i: int32 = 9
  num: int32 = n
  while num != 0 and i >= 2:
    digit: int32 = num & 15
    if digit < 10:
      buf[i] = cast[uint8](48 + digit)
    else:
      buf[i] = cast[uint8](87 + digit)  # 'a' - 10 = 87
    num = num >> 4
    i = i - 1
  print(cast[*uint8](addr(buf)))

def alloc(size: int32) -> *uint8:
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + size
  _ = syscall1(SYS_brk, new_brk)
  return cast[*uint8](old_brk)

def streq(a: *uint8, b: *uint8) -> int32:
  i: int32 = 0
  while a[i] != cast[uint8](0) and b[i] != cast[uint8](0):
    if a[i] != b[i]:
      return 0
    i = i + 1
  if a[i] != b[i]:
    return 0
  return 1

def read_u32(buf: *uint8, offset: int32) -> int32:
  p: *uint8 = cast[*uint8](cast[int32](buf) + offset)
  b0: int32 = cast[int32](p[0])
  b1: int32 = cast[int32](p[1])
  b2: int32 = cast[int32](p[2])
  b3: int32 = cast[int32](p[3])
  return b0 + (b1 << 8) + (b2 << 16) + (b3 << 24)

def read_u16(buf: *uint8, offset: int32) -> int32:
  p: *uint8 = cast[*uint8](cast[int32](buf) + offset)
  b0: int32 = cast[int32](p[0])
  b1: int32 = cast[int32](p[1])
  return b0 + (b1 << 8)

def write_u32(buf: *uint8, offset: int32, val: int32):
  p: *uint8 = cast[*uint8](cast[int32](buf) + offset)
  p[0] = cast[uint8](val & 255)
  p[1] = cast[uint8]((val >> 8) & 255)
  p[2] = cast[uint8]((val >> 16) & 255)
  p[3] = cast[uint8]((val >> 24) & 255)

def write_u16(buf: *uint8, offset: int32, val: int32):
  p: *uint8 = cast[*uint8](cast[int32](buf) + offset)
  p[0] = cast[uint8](val & 255)
  p[1] = cast[uint8]((val >> 8) & 255)

# Find or add a symbol
def find_or_add_symbol(name: *uint8, value: int32, section: int32) -> int32:
  # Don't merge empty-named section symbols - each needs its own entry
  skip_search: int32 = 0
  if name[0] == cast[uint8](0):
    skip_search = 1

  # Search for existing symbol (use read_u32 to avoid ptr indexing bug)
  i: int32 = 0
  while i < g_sym_count and skip_search == 0:
    name_off: int32 = read_u32(cast[*uint8](g_sym_offsets), i * 4)
    sym_name: *uint8 = cast[*uint8](cast[int32](g_sym_names) + name_off)
    if streq(sym_name, name) == 1:
      # Update if this definition is better (defined vs undefined)
      sym_sec: int32 = read_u32(cast[*uint8](g_sym_sections), i * 4)
      if sym_sec == 0 and section != 0:
        write_u32(cast[*uint8](g_sym_values), i * 4, value)
        write_u32(cast[*uint8](g_sym_sections), i * 4, section)
      return i
    i = i + 1

  # Add new symbol
  if g_sym_count >= MAX_SYMBOLS:
    print_err(cast[*uint8]("Error: too many symbols\n"))
    g_error = 1
    return -1

  # Copy name to string pool
  name_len: int32 = strlen(name) + 1
  name_off: int32 = g_sym_name_len
  memcpy(cast[*uint8](cast[int32](g_sym_names) + g_sym_name_len), name, name_len)
  g_sym_name_len = g_sym_name_len + name_len

  # Add symbol entry (use write_u32 to avoid ptr indexing bug)
  idx: int32 = g_sym_count
  write_u32(cast[*uint8](g_sym_offsets), idx * 4, name_off)
  write_u32(cast[*uint8](g_sym_values), idx * 4, value)
  write_u32(cast[*uint8](g_sym_sections), idx * 4, section)
  g_sym_count = g_sym_count + 1

  return idx

# Parse an object file and add its symbols/sections
def parse_object_file(filename: *uint8, file_buf: *uint8, file_len: int32, text_base: int32, data_base: int32) -> int32:
  # Verify ELF magic
  magic: int32 = read_u32(file_buf, 0)
  if magic != ELF_MAGIC:
    print_err(cast[*uint8]("Error: not an ELF file: "))
    print_err(filename)
    print_err(cast[*uint8]("\n"))
    return 1

  # Check type
  elf_type: int32 = read_u16(file_buf, 16)
  if elf_type != ET_REL:
    print_err(cast[*uint8]("Error: not a relocatable file\n"))
    return 1

  # Get section header info
  shoff: int32 = read_u32(file_buf, 32)       # Section header offset
  shentsize: int32 = read_u16(file_buf, 46)   # Section header entry size
  shnum: int32 = read_u16(file_buf, 48)       # Number of section headers
  shstrndx: int32 = read_u16(file_buf, 50)    # Section header string table index

  # Find section header string table
  shstrtab_off: int32 = shoff + (shstrndx * shentsize)
  shstrtab_addr: int32 = read_u32(file_buf, shstrtab_off + 16)
  shstrtab: *uint8 = cast[*uint8](cast[int32](file_buf) + shstrtab_addr)

  # Variables to track section locations AND their ELF indices
  text_sh_idx: int32 = -1
  text_sh_size: int32 = 0
  text_file_off: int32 = 0
  data_sh_idx: int32 = -1
  data_sh_size: int32 = 0
  data_file_off: int32 = 0
  bss_sh_idx: int32 = -1
  bss_sh_size: int32 = 0
  symtab_off: int32 = 0
  symtab_size: int32 = 0
  symtab_entsize: int32 = 0
  symtab_link: int32 = 0
  strtab_off: int32 = 0
  rel_text_off: int32 = 0
  rel_text_size: int32 = 0

  # Scan sections - record the actual ELF section indices
  i: int32 = 0
  while i < shnum:
    sh_off: int32 = shoff + (i * shentsize)
    sh_name: int32 = read_u32(file_buf, sh_off)
    sh_type: int32 = read_u32(file_buf, sh_off + 4)
    sh_offset: int32 = read_u32(file_buf, sh_off + 16)
    sh_size: int32 = read_u32(file_buf, sh_off + 20)
    sh_link: int32 = read_u32(file_buf, sh_off + 24)
    sh_entsize: int32 = read_u32(file_buf, sh_off + 36)

    name: *uint8 = cast[*uint8](cast[int32](shstrtab) + sh_name)

    if streq(name, cast[*uint8](".text")) == 1:
      text_sh_idx = i
      text_sh_size = sh_size
      text_file_off = sh_offset
    else:
      if streq(name, cast[*uint8](".data")) == 1:
        data_sh_idx = i
        data_sh_size = sh_size
        data_file_off = sh_offset
      else:
        if streq(name, cast[*uint8](".bss")) == 1:
          bss_sh_idx = i
          bss_sh_size = sh_size
        else:
          if sh_type == SHT_SYMTAB:
            symtab_off = sh_offset
            symtab_size = sh_size
            symtab_entsize = sh_entsize
            symtab_link = sh_link
          else:
            if streq(name, cast[*uint8](".rel.text")) == 1:
              rel_text_off = sh_offset
              rel_text_size = sh_size

    i = i + 1

  # Get string table for symbols
  if symtab_link > 0:
    strtab_sh: int32 = shoff + (symtab_link * shentsize)
    strtab_off = read_u32(file_buf, strtab_sh + 16)

  # Map from file symbol index to global symbol index
  sym_map: *int32 = cast[*int32](alloc(1024 * 4))

  # Guard against divide-by-zero
  sym_count: int32 = 0
  if symtab_entsize > 0:
    sym_count = symtab_size / symtab_entsize

  # Calculate where bss starts for this file (after its data section)
  # Align to 4 bytes for proper BSS placement
  bss_base: int32 = g_data_len + data_sh_size
  if bss_base % 4 != 0:
    bss_base = bss_base + (4 - (bss_base % 4))

  # Process symbols - use the recorded section indices
  i = 0
  while i < sym_count:
    sym_off: int32 = symtab_off + (i * symtab_entsize)
    st_name: int32 = read_u32(file_buf, sym_off)
    st_value: int32 = read_u32(file_buf, sym_off + 4)
    st_info: int32 = cast[int32](file_buf[sym_off + 12])
    st_shndx: int32 = read_u16(file_buf, sym_off + 14)

    name: *uint8 = cast[*uint8](cast[int32](file_buf) + strtab_off + st_name)

    # Determine section and adjust value by comparing against actual section indices
    section: int32 = 0
    value: int32 = st_value

    if st_shndx == 0:
      section = 0  # Undefined
    else:
      if st_shndx == text_sh_idx:
        section = 1  # .text
        value = text_base + st_value
      else:
        if st_shndx == data_sh_idx:
          section = 2  # .data
          value = data_base + st_value
        else:
          if st_shndx == bss_sh_idx:
            section = 3  # .bss - store offset relative to data segment
            value = bss_base + st_value
            # DEBUG: print BSS symbol info
            print(cast[*uint8]("  BSS symbol: "))
            print(name)
            print(cast[*uint8](" value="))
            print_num(value)
            print(cast[*uint8](" bss_base="))
            print_num(bss_base)
            println(cast[*uint8](""))

    # Skip null symbol
    if i > 0:
      global_idx: int32 = find_or_add_symbol(name, value, section)
      sym_map[i] = global_idx

      # Check for _start entry point
      if streq(name, cast[*uint8]("_start")) == 1:
        g_entry_point = value
    else:
      sym_map[i] = -1

    i = i + 1

  # Copy .text section
  if text_sh_size > 0:
    memcpy(cast[*uint8](cast[int32](g_text) + text_base),
           cast[*uint8](cast[int32](file_buf) + text_file_off),
           text_sh_size)
    g_text_len = text_base + text_sh_size

  # Copy .data section
  if data_sh_size > 0:
    memcpy(cast[*uint8](cast[int32](g_data) + data_base),
           cast[*uint8](cast[int32](file_buf) + data_file_off),
           data_sh_size)
    g_data_len = data_base + data_sh_size

  # Update .bss size
  g_bss_len = g_bss_len + bss_sh_size

  # Calculate dynamic data virtual address based on actual text size
  # Data starts at next page boundary after text ends
  text_end_vaddr: int32 = TEXT_ADDR + g_text_len
  g_data_vaddr = (text_end_vaddr + 0xFFF) & (0 - 0x1000)

  # Process relocations
  if rel_text_size > 0:
    rel_count: int32 = rel_text_size / 8
    i = 0
    while i < rel_count:
      rel_off: int32 = rel_text_off + (i * 8)
      r_offset: int32 = read_u32(file_buf, rel_off)
      r_info: int32 = read_u32(file_buf, rel_off + 4)
      r_sym: int32 = r_info >> 8
      r_type: int32 = r_info & 255

      # Add relocation with adjusted offset and global symbol index
      if g_reloc_count < MAX_RELOCS:
        # Use write_u32 to bypass potentially buggy ptr indexing
        write_u32(cast[*uint8](g_reloc_offsets), g_reloc_count * 4, text_base + r_offset)
        write_u32(cast[*uint8](g_reloc_types), g_reloc_count * 4, r_type)
        write_u32(cast[*uint8](g_reloc_syms), g_reloc_count * 4, sym_map[r_sym])
        g_reloc_count = g_reloc_count + 1

      i = i + 1

  return 0

# Apply relocations
def apply_relocations() -> int32:
  i: int32 = 0
  while i < g_reloc_count:
    offset: int32 = read_u32(cast[*uint8](g_reloc_offsets), i * 4)
    rtype: int32 = read_u32(cast[*uint8](g_reloc_types), i * 4)
    sym_idx: int32 = read_u32(cast[*uint8](g_reloc_syms), i * 4)

    if sym_idx < 0 or sym_idx >= g_sym_count:
      i = i + 1
      continue

    sym_value: int32 = read_u32(cast[*uint8](g_sym_values), sym_idx * 4)
    sym_section: int32 = read_u32(cast[*uint8](g_sym_sections), sym_idx * 4)

    if sym_section == 0:
      sym_name_off: int32 = read_u32(cast[*uint8](g_sym_offsets), sym_idx * 4)
      sym_name: *uint8 = cast[*uint8](cast[int32](g_sym_names) + sym_name_off)
      print_err(cast[*uint8]("Error: undefined symbol: "))
      print_err(sym_name)
      print_err(cast[*uint8]("\n"))
      return 1

    # Calculate final symbol address based on section
    # sym_value is already section-relative offset for all sections
    final_addr: int32 = 0
    if sym_section == 1:
      final_addr = TEXT_ADDR + sym_value
    else:
      if sym_section == 2:
        final_addr = g_data_vaddr + sym_value
      else:
        if sym_section == 3:
          # bss follows data, sym_value already includes data offset
          final_addr = g_data_vaddr + sym_value
          # DEBUG: print BSS relocation
          if offset < 100:
            print(cast[*uint8]("  BSS reloc at "))
            print_num(offset)
            print(cast[*uint8](" sym_idx="))
            print_num(sym_idx)
            print(cast[*uint8](" sym_value="))
            print_num(sym_value)
            print(cast[*uint8](" final="))
            print_hex(final_addr)
            println(cast[*uint8](""))

    # Read current value at relocation site (addend)
    addend: int32 = read_u32(g_text, offset)

    # Apply relocation
    if rtype == R_386_32:
      # S + A
      result: int32 = final_addr + addend
      write_u32(g_text, offset, result)
    else:
      if rtype == R_386_PC32:
        # S + A - P
        place: int32 = TEXT_ADDR + offset
        result: int32 = final_addr + addend - place
        write_u32(g_text, offset, result)

    i = i + 1

  return 0

# Write ELF executable header
def write_elf_header():
  hdr: *uint8 = g_output

  # ELF magic
  hdr[0] = cast[uint8](0x7F)
  hdr[1] = cast[uint8](0x45)  # 'E'
  hdr[2] = cast[uint8](0x4C)  # 'L'
  hdr[3] = cast[uint8](0x46)  # 'F'

  # ELF32, little-endian, version 1
  hdr[4] = cast[uint8](1)     # 32-bit
  hdr[5] = cast[uint8](1)     # Little-endian
  hdr[6] = cast[uint8](1)     # ELF version

  # Pad to 16
  i: int32 = 7
  while i < 16:
    hdr[i] = cast[uint8](0)
    i = i + 1

  # Type: EXEC
  write_u16(hdr, 16, ET_EXEC)
  # Machine: 386
  write_u16(hdr, 18, EM_386)
  # Version
  write_u32(hdr, 20, 1)
  # Entry point
  write_u32(hdr, 24, TEXT_ADDR + g_entry_point)
  # Program header offset (right after ELF header)
  write_u32(hdr, 28, 52)
  # Section header offset (0 for minimal executable)
  write_u32(hdr, 32, 0)
  # Flags
  write_u32(hdr, 36, 0)
  # ELF header size
  write_u16(hdr, 40, 52)
  # Program header entry size
  write_u16(hdr, 42, 32)
  # Number of program headers
  write_u16(hdr, 44, 3)
  # Section header entry size
  write_u16(hdr, 46, 0)
  # Number of section headers
  write_u16(hdr, 48, 0)
  # Section name string table index
  write_u16(hdr, 50, 0)

  g_output_len = 52

# Write program headers
def write_program_headers():
  # Calculate file offsets dynamically based on actual section sizes
  hdr_size: int32 = 52 + 96  # ELF header + 3 program headers
  text_file_off: int32 = 0x1000  # Page-aligned

  # Data follows text, aligned to page boundary
  text_end: int32 = text_file_off + g_text_len
  # Round up to next page boundary (0x1000 = 4096)
  data_file_off: int32 = (text_end + 0xFFF) & (0 - 0x1000)

  # Store for use in write_output
  g_data_file_off = data_file_off

  phdr: *uint8 = cast[*uint8](cast[int32](g_output) + 52)

  # Program header 1: ELF headers (read-only)
  write_u32(phdr, 0, PT_LOAD)      # Type
  write_u32(phdr, 4, 0)            # File offset
  write_u32(phdr, 8, BASE_ADDR)    # Virtual address
  write_u32(phdr, 12, BASE_ADDR)   # Physical address
  write_u32(phdr, 16, hdr_size)    # File size
  write_u32(phdr, 20, hdr_size)    # Memory size
  write_u32(phdr, 24, 4)           # Flags: R
  write_u32(phdr, 28, 0x1000)      # Alignment

  # Program header 2: .text (read + execute)
  phdr = cast[*uint8](cast[int32](g_output) + 52 + 32)
  write_u32(phdr, 0, PT_LOAD)
  write_u32(phdr, 4, text_file_off)
  write_u32(phdr, 8, TEXT_ADDR)
  write_u32(phdr, 12, TEXT_ADDR)
  write_u32(phdr, 16, g_text_len)
  write_u32(phdr, 20, g_text_len)
  write_u32(phdr, 24, 5)           # Flags: R+X
  write_u32(phdr, 28, 0x1000)

  # Program header 3: .data + .bss (read + write)
  phdr = cast[*uint8](cast[int32](g_output) + 52 + 64)
  write_u32(phdr, 0, PT_LOAD)
  write_u32(phdr, 4, data_file_off)
  write_u32(phdr, 8, g_data_vaddr)
  write_u32(phdr, 12, g_data_vaddr)
  write_u32(phdr, 16, g_data_len)
  # Align data for BSS placement (BSS symbols calculated with aligned base)
  aligned_data_len: int32 = g_data_len
  if aligned_data_len % 4 != 0:
    aligned_data_len = aligned_data_len + (4 - (aligned_data_len % 4))
  write_u32(phdr, 20, aligned_data_len + g_bss_len)
  write_u32(phdr, 24, 6)           # Flags: R+W
  write_u32(phdr, 28, 0x1000)

  g_output_len = 52 + 96

# Write output file
def write_output(filename: *uint8) -> int32:
  # Write ELF header and program headers
  write_elf_header()
  write_program_headers()

  # Pad to text section offset (0x1000)
  while g_output_len < 0x1000:
    g_output[g_output_len] = cast[uint8](0)
    g_output_len = g_output_len + 1

  # Write .text section
  memcpy(cast[*uint8](cast[int32](g_output) + g_output_len), g_text, g_text_len)
  g_output_len = g_output_len + g_text_len

  # Pad to data section offset (dynamically calculated)
  while g_output_len < g_data_file_off:
    g_output[g_output_len] = cast[uint8](0)
    g_output_len = g_output_len + 1

  # Write .data section
  memcpy(cast[*uint8](cast[int32](g_output) + g_output_len), g_data, g_data_len)
  g_output_len = g_output_len + g_data_len

  # Open output file
  fd: int32 = syscall3(SYS_open, cast[int32](filename), O_WRONLY + O_CREAT + O_TRUNC, 493)  # 0755
  if fd < 0:
    print_err(cast[*uint8]("Error: cannot create output file\n"))
    return 1

  # Write
  _ = syscall3(SYS_write, fd, cast[int32](g_output), g_output_len)
  _ = syscall1(SYS_close, fd)

  return 0

def main() -> int32:
  println(cast[*uint8]("bhlink - Brainhair Linker v0.1"))

  argc: int32 = get_argc()
  if argc < 3:
    println(cast[*uint8]("Usage: bhlink input.o [...] -o output"))
    return 1

  # Allocate buffers
  g_output = alloc(1048576)       # 1MB output buffer
  g_output_cap = 1048576
  g_text = alloc(262144)          # 256KB text section
  g_data = alloc(262144)          # 256KB data section
  g_sym_names = alloc(65536)      # 64KB symbol names
  g_sym_values = cast[*int32](alloc(MAX_SYMBOLS * 4))
  g_sym_sections = cast[*int32](alloc(MAX_SYMBOLS * 4))
  g_sym_offsets = cast[*int32](alloc(MAX_SYMBOLS * 4))
  g_reloc_offsets = cast[*int32](alloc(MAX_RELOCS * 4))
  g_reloc_types = cast[*int32](alloc(MAX_RELOCS * 4))
  g_reloc_syms = cast[*int32](alloc(MAX_RELOCS * 4))

  # Find -o argument
  output_file: *uint8 = cast[*uint8](0)
  i: int32 = 1
  while i < argc:
    arg: *uint8 = get_argv(i)
    if arg[0] == cast[uint8](45) and arg[1] == cast[uint8](111):  # "-o"
      if i + 1 < argc:
        output_file = get_argv(i + 1)
      i = i + 2
    else:
      i = i + 1

  if output_file == cast[*uint8](0):
    print_err(cast[*uint8]("Error: no output file specified (-o)\n"))
    return 1

  print(cast[*uint8]("  Output: "))
  println(output_file)

  # Process input files
  text_offset: int32 = 0
  data_offset: int32 = 0
  i = 1
  while i < argc:
    arg: *uint8 = get_argv(i)
    if arg[0] == cast[uint8](45) and arg[1] == cast[uint8](111):  # "-o"
      i = i + 2
      continue

    # Read input file
    print(cast[*uint8]("  Reading "))
    println(arg)

    fd: int32 = syscall3(SYS_open, cast[int32](arg), O_RDONLY, 0)
    if fd < 0:
      print_err(cast[*uint8]("Error: cannot open file: "))
      print_err(arg)
      print_err(cast[*uint8]("\n"))
      return 1

    file_buf: *uint8 = alloc(262144)
    file_len: int32 = 0
    n: int32 = syscall3(SYS_read, fd, cast[int32](file_buf), 262144)
    while n > 0:
      file_len = file_len + n
      n = syscall3(SYS_read, fd, cast[int32](file_buf) + file_len, 262144 - file_len)
    _ = syscall1(SYS_close, fd)

    # Parse and merge
    if parse_object_file(arg, file_buf, file_len, text_offset, data_offset) != 0:
      return 1

    # Update offsets for next file
    text_offset = g_text_len
    data_offset = g_data_len

    i = i + 1

  print(cast[*uint8]("  Symbols: "))
  print_num(g_sym_count)
  println(cast[*uint8](""))

  print(cast[*uint8]("  Relocations: "))
  print_num(g_reloc_count)
  println(cast[*uint8](""))

  # Apply relocations
  if apply_relocations() != 0:
    return 1

  print(cast[*uint8]("  Text: "))
  print_num(g_text_len)
  println(cast[*uint8](" bytes"))

  print(cast[*uint8]("  Data: "))
  print_num(g_data_len)
  println(cast[*uint8](" bytes"))

  print(cast[*uint8]("  BSS: "))
  print_num(g_bss_len)
  println(cast[*uint8](" bytes"))

  print(cast[*uint8]("  Entry: "))
  print_hex(TEXT_ADDR + g_entry_point)
  println(cast[*uint8](""))

  # Write output
  if write_output(output_file) != 0:
    return 1

  println(cast[*uint8]("Done."))
  return 0
