# hexview - Graphical hex viewer with scrolling
# Usage: hexview <filename>
# Displays file contents in classic hex dump format on framebuffer
# Format: 00000000  48 65 6C 6C 6F 20 57 6F  72 6C 64 21 0A 00 00 00  |Hello World!....|
# Controls: Mouse wheel or Up/Down arrows to scroll

import "lib/syscalls"

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

const FBIOGET_VSCREENINFO: int32 = 0x4600

# Display constants
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8
const LINE_HEIGHT: int32 = 10
const TOP_MARGIN: int32 = 10
const LEFT_MARGIN: int32 = 10
const BYTES_PER_LINE: int32 = 16
const CHUNK_SIZE: int32 = 4096

# Colors
const COLOR_BG: int32 = 0x000000
const COLOR_OFFSET: int32 = 0x00AAFF
const COLOR_HEX: int32 = 0x00FF00
const COLOR_ASCII: int32 = 0xFFFFFF
const COLOR_TITLE: int32 = 0xFFFF00

extern fast_memcpy(dst: int32, src: int32, count_bytes: int32)
extern get_argc(): int32
extern get_argv(i: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# ============ Font Rendering ============

proc get_font_row(c: int32, row: int32): int32 =
  # 8x8 bitmap font - returns 8 bits for each row
  if c == 32: return 0  # space

  # Uppercase letters A-Z (65-90)
  if c == 65:  # A
    if row == 0: return 0x18
    if row == 1: return 0x3C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0
  if c == 67:  # C
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0
  if c == 69:  # E
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 70:  # F
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 71:  # G
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x6E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 72:  # H
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 73:  # I
    if row == 0: return 0x3C
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0
  if c == 76:  # L
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 86:  # V
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0
  if c == 87:  # W
    if row == 0: return 0x63
    if row == 1: return 0x63
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x7F
    if row == 5: return 0x77
    if row == 6: return 0x63
    return 0
  if c == 88:  # X
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  # Lowercase letters - use same as uppercase
  if c >= 97 and c <= 122:
    return get_font_row(c - 32, row)

  # Numbers 0-9 (48-57)
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0
  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0
  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  # Special characters
  if c == 45:  # '-'
    if row == 3: return 0x7E
    return 0
  if c == 46:  # '.'
    if row == 6: return 0x18
    return 0
  if c == 58:  # ':'
    if row == 2: return 0x18
    if row == 5: return 0x18
    return 0
  if c == 124:  # '|'
    if row == 0: return 0x18
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0

  return 0

proc buf_pixel(buf: ptr uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

proc fill_rect(buf: ptr uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      var cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc draw_char(buf: ptr uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

proc draw_text(buf: ptr uint32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, yres: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

# ============ Hex Formatting ============

proc hex_char(n: int32): uint8 =
  if n < 10:
    return cast[uint8](48 + n)
  else:
    return cast[uint8](97 + n - 10)

proc draw_hex_digit(buf: ptr uint32, x: int32, y: int32, n: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var c: int32 = cast[int32](hex_char(n))
  draw_char(buf, x, y, c, fg, bg, xres, yres)

proc draw_hex_byte(buf: ptr uint32, x: int32, y: int32, b: uint8, fg: int32, bg: int32, xres: int32, yres: int32) =
  var high: int32 = cast[int32](b) / 16
  var low: int32 = cast[int32](b) % 16
  draw_hex_digit(buf, x, y, high, fg, bg, xres, yres)
  draw_hex_digit(buf, x + FONT_WIDTH, y, low, fg, bg, xres, yres)

proc draw_offset(buf: ptr uint32, x: int32, y: int32, offset: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  # Draw 8 hex digits for offset
  var px: int32 = x
  draw_hex_digit(buf, px, y, (offset / 268435456) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 16777216) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 1048576) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 65536) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 4096) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 256) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, (offset / 16) % 16, fg, bg, xres, yres)
  px = px + FONT_WIDTH
  draw_hex_digit(buf, px, y, offset % 16, fg, bg, xres, yres)

proc draw_ascii_char(buf: ptr uint32, x: int32, y: int32, c: uint8, fg: int32, bg: int32, xres: int32, yres: int32) =
  var ch: int32 = cast[int32](c)
  if c >= cast[uint8](32) and c < cast[uint8](127):
    draw_char(buf, x, y, ch, fg, bg, xres, yres)
  else:
    draw_char(buf, x, y, 46, fg, bg, xres, yres)  # '.'

# ============ Hex Line Rendering ============

proc draw_hex_line(buf: ptr uint32, y: int32, offset: int32, data: ptr uint8, len: int32, xres: int32, yres: int32) =
  # Draw offset (8 hex digits)
  var px: int32 = LEFT_MARGIN
  draw_offset(buf, px, y, offset, COLOR_OFFSET, COLOR_BG, xres, yres)
  px = px + FONT_WIDTH * 8

  # Draw separator "  "
  px = px + FONT_WIDTH * 2

  # Draw hex bytes (16 bytes with space after 8)
  var i: int32 = 0
  while i < BYTES_PER_LINE:
    if i < len:
      draw_hex_byte(buf, px, y, data[i], COLOR_HEX, COLOR_BG, xres, yres)
    else:
      # Padding for incomplete line
      draw_char(buf, px, y, 32, COLOR_HEX, COLOR_BG, xres, yres)
      draw_char(buf, px + FONT_WIDTH, y, 32, COLOR_HEX, COLOR_BG, xres, yres)

    px = px + FONT_WIDTH * 2
    px = px + FONT_WIDTH  # Space after each byte

    # Extra space after 8th byte
    if i == 7:
      px = px + FONT_WIDTH

    i = i + 1

  # Draw separator " |"
  draw_char(buf, px, y, 32, COLOR_ASCII, COLOR_BG, xres, yres)
  px = px + FONT_WIDTH
  draw_char(buf, px, y, 124, COLOR_ASCII, COLOR_BG, xres, yres)
  px = px + FONT_WIDTH

  # Draw ASCII representation
  i = 0
  while i < len:
    draw_ascii_char(buf, px, y, data[i], COLOR_ASCII, COLOR_BG, xres, yres)
    px = px + FONT_WIDTH
    i = i + 1

  # Pad ASCII section if incomplete
  while i < BYTES_PER_LINE:
    draw_char(buf, px, y, 32, COLOR_ASCII, COLOR_BG, xres, yres)
    px = px + FONT_WIDTH
    i = i + 1

  # Draw closing "|"
  draw_char(buf, px, y, 124, COLOR_ASCII, COLOR_BG, xres, yres)

# ============ File Reading ============

proc read_chunk(fd: int32, buffer: ptr uint8, size: int32): int32 =
  return syscall3(SYS_read, fd, cast[int32](buffer), size)

# ============ Main ============

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("Usage: hexview <filename>\n"))
    discard syscall1(SYS_exit, 1)

  var filename: ptr uint8 = get_argv(1)

  # Open file
  var fd: int32 = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
  if fd < 0:
    print_err(cast[ptr uint8]("hexview: cannot open file\n"))
    discard syscall1(SYS_exit, 1)

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_err(cast[ptr uint8]("hexview: cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16384)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var file_buffer: ptr uint8 = cast[ptr uint8](old_brk + 256)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 8192)

  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  # mmap framebuffer
  var buf_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    print_err(cast[ptr uint8]("hexview: mmap failed\n"))
    discard syscall1(SYS_exit, 1)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd >= 0:
    var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
    discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Calculate lines per screen
  var lines_per_screen: int32 = (yres - TOP_MARGIN * 3) / LINE_HEIGHT
  var scroll_offset: int32 = 0  # Offset in lines

  # Clear screen and draw title
  fill_rect(framebuffer, 0, 0, xres, yres, COLOR_BG, xres, yres)
  draw_text(framebuffer, LEFT_MARGIN, TOP_MARGIN, cast[ptr uint8]("HEX VIEWER - "), COLOR_TITLE, COLOR_BG, xres, yres)
  draw_text(framebuffer, LEFT_MARGIN + FONT_WIDTH * 13, TOP_MARGIN, filename, COLOR_TITLE, COLOR_BG, xres, yres)

  # Main loop
  var running: int32 = 1
  var need_redraw: int32 = 1

  while running != 0:
    # Handle mouse input
    if mouse_fd >= 0:
      var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
      while bytes >= 3:
        var btns: int32 = cast[int32](mouse_buf[0])
        var dx: int32 = cast[int32](mouse_buf[1])
        var dy: int32 = cast[int32](mouse_buf[2])

        # Check for scroll wheel (buttons 3 and 4)
        # Mouse wheel up = button 3
        if (btns & 0x08) != 0:
          if scroll_offset > 0:
            scroll_offset = scroll_offset - 1
            need_redraw = 1
        # Mouse wheel down = button 4
        if (btns & 0x10) != 0:
          scroll_offset = scroll_offset + 1
          need_redraw = 1

        bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

    if need_redraw != 0:
      need_redraw = 0

      # Clear data area (keep title)
      fill_rect(framebuffer, 0, TOP_MARGIN * 2, xres, yres - TOP_MARGIN * 2, COLOR_BG, xres, yres)

      # Seek to correct position in file
      # Each line represents 16 bytes
      var file_offset: int32 = scroll_offset * BYTES_PER_LINE

      # Read and display lines
      var line_num: int32 = 0
      var current_offset: int32 = file_offset

      # Reset file position by closing and reopening
      discard syscall1(SYS_close, fd)
      fd = syscall2(SYS_open, cast[int32](filename), O_RDONLY)

      # Skip to desired offset by reading in chunks
      var skip_remaining: int32 = file_offset
      while skip_remaining > 0:
        var to_skip: int32 = CHUNK_SIZE
        if to_skip > skip_remaining:
          to_skip = skip_remaining
        var skipped: int32 = read_chunk(fd, file_buffer, to_skip)
        if skipped <= 0:
          break
        skip_remaining = skip_remaining - skipped

      while line_num < lines_per_screen:
        var bytes_read: int32 = read_chunk(fd, file_buffer, BYTES_PER_LINE)
        if bytes_read <= 0:
          break

        var y: int32 = TOP_MARGIN * 2 + line_num * LINE_HEIGHT
        draw_hex_line(framebuffer, y, current_offset, file_buffer, bytes_read, xres, yres)

        current_offset = current_offset + bytes_read
        line_num = line_num + 1

        if bytes_read < BYTES_PER_LINE:
          break

    # Small delay to prevent busy loop
    var sleep_brk: int32 = syscall1(SYS_brk, 0)
    discard syscall1(SYS_brk, sleep_brk + 16)
    var timespec: ptr int32 = cast[ptr int32](sleep_brk)
    timespec[0] = 0
    timespec[1] = 16000000  # 16ms
    discard syscall2(162, cast[int32](timespec), 0)  # nanosleep

  # Cleanup
  if mouse_fd >= 0:
    discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_close, fd)
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_exit, 0)

main()
