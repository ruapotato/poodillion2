# timeout - Run command with time limit
# Usage: timeout SECONDS COMMAND [ARGS...]
# Exit with 124 if timeout, else command's exit code

from lib.syscalls import *

const SIGTERM: int32 = 15
const SIGKILL: int32 = 9
const SIGALRM: int32 = 14

const WNOHANG: int32 = 1

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

def main():
  argc: int32 = get_argc()

  if argc < 3:
    print_err(cast[*uint8]("Usage: timeout SECONDS COMMAND [ARGS...]\n"))
    syscall1(SYS_exit, 1)

  # Get timeout value
  timeout_arg: *uint8 = get_argv(1)
  timeout_seconds: int32 = atoi(timeout_arg)

  if timeout_seconds <= 0:
    print_err(cast[*uint8]("timeout: invalid timeout value\n"))
    syscall1(SYS_exit, 1)

  # Fork to run the command
  pid: int32 = syscall1(SYS_fork, 0)

  if pid < 0:
    print_err(cast[*uint8]("timeout: fork failed\n"))
    syscall1(SYS_exit, 1)

  if pid == 0:
    # Child process - exec the command
    # Build argv array for command (skip "timeout" and seconds)
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    syscall1(SYS_brk, new_brk)

    argv: *int32 = cast[*int32](old_brk)
    i: int32 = 2
    arg_idx: int32 = 0
    while i < argc:
      argv[arg_idx] = cast[int32](get_argv(i))
      arg_idx = arg_idx + 1
      i = i + 1
    argv[arg_idx] = 0  # NULL terminate

    # Exec the command
    cmd: *uint8 = get_argv(2)
    syscall3(SYS_execve, cast[int32](cmd), cast[int32](argv), 0)

    # If execve returns, it failed
    print_err(cast[*uint8]("timeout: cannot execute command\n"))
    syscall1(SYS_exit, 127)

  # Parent process - wait with timeout
  # Set alarm for timeout
  syscall1(SYS_alarm, timeout_seconds)

  # Wait for child
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16
  syscall1(SYS_brk, new_brk)
  status: *int32 = cast[*int32](old_brk)
  status[0] = 0

  result: int32 = syscall3(SYS_waitpid, pid, cast[int32](status), 0)

  # Cancel alarm
  syscall1(SYS_alarm, 0)

  if result < 0:
    # Wait failed - might be because alarm interrupted it
    # Try to kill the child
    syscall2(SYS_kill, pid, SIGTERM)

    # Wait a bit and then SIGKILL
    # (simplified: just send SIGKILL)
    syscall2(SYS_kill, pid, SIGKILL)

    # Try to reap the child
    syscall3(SYS_waitpid, pid, cast[int32](status), 0)

    print_err(cast[*uint8]("timeout: command timed out\n"))
    syscall1(SYS_exit, 124)

  # Extract exit code from status
  # status is in the format: low byte = signal, next byte = exit code
  exit_code: int32 = (status[0] / 256) % 256

  syscall1(SYS_exit, exit_code)
