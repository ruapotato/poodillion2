# printf - formatted printing
# Usage: printf FORMAT [ARGS...]
# Format specifiers:
#   %s - string
#   %d - decimal integer
#   %x - hex integer
#   %c - character
#   %% - literal %
# Escape sequences:
#   \n - newline
#   \t - tab
#   \\ - backslash
# Part of BrainhairOS text utilities

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  var negative: int32 = 0

  if s[i] == cast[uint8](45):  # '-'
    negative = 1
    i = i + 1

  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1

  if negative != 0:
    result = 0 - result

  return result

proc int_to_str(n: int32, buf: ptr uint8): int32 =
  var num: int32 = n
  var len: int32 = 0
  var negative: int32 = 0

  if num < 0:
    negative = 1
    num = 0 - num

  if num == 0:
    buf[0] = cast[uint8](48)
    return 1

  # Convert digits in reverse
  var temp_buf: ptr uint8 = buf
  while num > 0:
    var digit: int32 = num % 10
    temp_buf[len] = cast[uint8](48 + digit)
    len = len + 1
    num = num / 10

  if negative != 0:
    temp_buf[len] = cast[uint8](45)  # '-'
    len = len + 1

  # Reverse the string
  var i: int32 = 0
  var j: int32 = len - 1
  while i < j:
    var tmp: uint8 = temp_buf[i]
    temp_buf[i] = temp_buf[j]
    temp_buf[j] = tmp
    i = i + 1
    j = j - 1

  return len

proc int_to_hex(n: int32, buf: ptr uint8): int32 =
  var num: int32 = n
  var len: int32 = 0

  if num == 0:
    buf[0] = cast[uint8](48)
    return 1

  # Convert hex digits in reverse
  var temp_buf: ptr uint8 = buf
  while num > 0:
    var digit: int32 = num % 16
    if digit < 10:
      temp_buf[len] = cast[uint8](48 + digit)
    else:
      temp_buf[len] = cast[uint8](87 + digit)  # 'a' = 97, so 97-10 = 87
    len = len + 1
    num = num / 16

  # Reverse the string
  var i: int32 = 0
  var j: int32 = len - 1
  while i < j:
    var tmp: uint8 = temp_buf[i]
    temp_buf[i] = temp_buf[j]
    temp_buf[j] = tmp
    i = i + 1
    j = j - 1

  return len

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("printf: usage: printf FORMAT [ARGS...]\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate buffer for number conversion
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 1024
  discard syscall1(SYS_brk, new_brk)
  var num_buf: ptr uint8 = cast[ptr uint8](old_brk)

  var format: ptr uint8 = get_argv(1)
  var arg_idx: int32 = 2

  # Process format string
  var i: int32 = 0
  while format[i] != cast[uint8](0):
    var ch: uint8 = format[i]

    if ch == cast[uint8](37):  # '%'
      i = i + 1
      var spec: uint8 = format[i]

      if spec == cast[uint8](37):  # %%
        discard syscall3(SYS_write, STDOUT, cast[int32]("%"), 1)
      else:
        if spec == cast[uint8](115):  # %s
          if arg_idx < argc:
            var arg: ptr uint8 = get_argv(arg_idx)
            var arg_len: int32 = strlen(arg)
            discard syscall3(SYS_write, STDOUT, cast[int32](arg), arg_len)
            arg_idx = arg_idx + 1
        else:
          if spec == cast[uint8](100):  # %d
            if arg_idx < argc:
              var arg: ptr uint8 = get_argv(arg_idx)
              var num: int32 = parse_int(arg)
              var len: int32 = int_to_str(num, num_buf)
              discard syscall3(SYS_write, STDOUT, cast[int32](num_buf), len)
              arg_idx = arg_idx + 1
          else:
            if spec == cast[uint8](120):  # %x
              if arg_idx < argc:
                var arg: ptr uint8 = get_argv(arg_idx)
                var num: int32 = parse_int(arg)
                var len: int32 = int_to_hex(num, num_buf)
                discard syscall3(SYS_write, STDOUT, cast[int32](num_buf), len)
                arg_idx = arg_idx + 1
            else:
              if spec == cast[uint8](99):  # %c
                if arg_idx < argc:
                  var arg: ptr uint8 = get_argv(arg_idx)
                  discard syscall3(SYS_write, STDOUT, cast[int32](arg), 1)
                  arg_idx = arg_idx + 1
    else:
      if ch == cast[uint8](92):  # backslash
        i = i + 1
        var esc: uint8 = format[i]
        if esc == cast[uint8](110):  # \n
          discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
        else:
          if esc == cast[uint8](116):  # \t
            discard syscall3(SYS_write, STDOUT, cast[int32]("\t"), 1)
          else:
            if esc == cast[uint8](92):  # \\
              discard syscall3(SYS_write, STDOUT, cast[int32]("\\"), 1)
            else:
              # Unknown escape, print as-is
              discard syscall3(SYS_write, STDOUT, cast[int32](addr(esc)), 1)
      else:
        # Regular character
        discard syscall3(SYS_write, STDOUT, cast[int32](addr(ch)), 1)

    i = i + 1

  discard syscall1(SYS_exit, 0)
