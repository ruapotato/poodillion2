# groups - Print group memberships
# Usage: groups [USER]
# Uses SYS_getgroups (80) for current user
# Prints group IDs (numeric)

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print integer
def main():
    argc: int32 = get_argc()

    # For now, we only support current user (no argument)
    # Supporting arbitrary users would require parsing /etc/group
    if argc > 1:
        print_err(cast[*uint8]("groups: user lookup not yet supported\n"))
        _ = syscall1(SYS_exit, 1)

    # Allocate buffer for group IDs
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 512  # Space for up to 128 group IDs (4 bytes each)
    _ = syscall1(SYS_brk, new_brk)
    gid_list: *int32 = cast[*int32](old_brk)

    # Get groups (first call to get count)
    ngroups: int32 = syscall2(SYS_getgroups, 0, 0)
    if ngroups < 0:
        print_err(cast[*uint8]("groups: cannot get group list\n"))
        _ = syscall1(SYS_exit, 1)

    # Get actual groups
    if ngroups > 0:
        ret: int32 = syscall2(SYS_getgroups, ngroups, cast[int32](gid_list))
        if ret < 0:
            print_err(cast[*uint8]("groups: cannot get group list\n"))
            _ = syscall1(SYS_exit, 1)
        ngroups = ret

    # Print groups
    if ngroups == 0:
        print(cast[*uint8]("0\n"))
    else:
        i: int32 = 0
        while i < ngroups:
            if i > 0:
                print(cast[*uint8](" "))
            print_int(gid_list[i])
            i = i + 1
        print(cast[*uint8]("\n"))

    _ = syscall1(SYS_exit, 0)
