# csplit - Split file by context
# Usage: csplit FILE PATTERN
# Split at lines matching pattern
# Output: xx00, xx01, xx02...

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(i: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print integer
# Check if string contains substring
proc contains(haystack: ptr uint8, needle: ptr uint8): int32 =
  var h_len: int32 = strlen(haystack)
  var n_len: int32 = strlen(needle)

  if n_len == 0:
    return 1

  var i: int32 = 0
  while i <= h_len - n_len:
    var j: int32 = 0
    var matched: int32 = 1
    while j < n_len:
      if haystack[i + j] != needle[j]:
        matched = 0
        break
      j = j + 1

    if matched != 0:
      return 1

    i = i + 1

  return 0

# Create output filename: xx00, xx01, etc.
proc make_filename(buf: ptr uint8, index: int32) =
  buf[0] = cast[uint8](120)  # 'x'
  buf[1] = cast[uint8](120)  # 'x'

  # Convert index to 2 digits
  var tens: int32 = index / 10
  var ones: int32 = index % 10

  buf[2] = cast[uint8](48 + tens)
  buf[3] = cast[uint8](48 + ones)
  buf[4] = cast[uint8](0)

proc main() =
  var argc: int32 = get_argc()

  if argc < 3:
    print_err(cast[ptr uint8]("Usage: csplit FILE PATTERN\n"))
    discard syscall1(SYS_exit, 1)

  var filename: ptr uint8 = get_argv(1)
  var pattern: ptr uint8 = get_argv(2)

  # Open input file
  var fd: int32 = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
  if fd < 0:
    print_err(cast[ptr uint8]("csplit: cannot open file\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 12288
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var line_buf: ptr uint8 = cast[ptr uint8](old_brk + 4096)
  var out_name: ptr uint8 = cast[ptr uint8](old_brk + 8192)

  var file_index: int32 = 0
  var line_pos: int32 = 0
  var out_fd: int32 = -1
  var line_count: int32 = 0

  # Create first output file
  make_filename(out_name, file_index)
  out_fd = syscall3(SYS_open, cast[int32](out_name), O_WRONLY + O_CREAT + O_TRUNC, 420)  # 0644
  if out_fd < 0:
    print_err(cast[ptr uint8]("csplit: cannot create output file\n"))
    discard syscall1(SYS_exit, 1)

  # Print byte count for first file
  print_int(0)
  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

  var byte_count: int32 = 0

  var running: int32 = 1
  while running != 0:
    var n: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
    if n <= 0:
      # Flush last line if any
      if line_pos > 0:
        discard syscall3(SYS_write, out_fd, cast[int32](line_buf), line_pos)
        discard syscall3(SYS_write, out_fd, cast[int32]("\n"), 1)
        byte_count = byte_count + line_pos + 1
      running = 0
      break

    var i: int32 = 0
    while i < n:
      var c: uint8 = buffer[i]

      if c == cast[uint8](10):  # newline
        # Check if line matches pattern
        line_buf[line_pos] = cast[uint8](0)

        if contains(line_buf, pattern) != 0:
          # Close current file
          if out_fd >= 0:
            discard syscall1(SYS_close, out_fd)

          # Print byte count for completed file
          print_int(byte_count)
          discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

          # Open new file
          file_index = file_index + 1
          make_filename(out_name, file_index)
          out_fd = syscall3(SYS_open, cast[int32](out_name), O_WRONLY + O_CREAT + O_TRUNC, 420)
          byte_count = 0

        # Write line to current file
        discard syscall3(SYS_write, out_fd, cast[int32](line_buf), line_pos)
        discard syscall3(SYS_write, out_fd, cast[int32]("\n"), 1)
        byte_count = byte_count + line_pos + 1

        line_pos = 0
      else:
        # Add to line buffer
        if line_pos < 4095:
          line_buf[line_pos] = c
          line_pos = line_pos + 1

      i = i + 1

  # Print final byte count
  print_int(byte_count)
  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

  if out_fd >= 0:
    discard syscall1(SYS_close, out_fd)

  discard syscall1(SYS_close, fd)
  discard syscall1(SYS_exit, 0)
