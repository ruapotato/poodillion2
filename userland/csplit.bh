# csplit - Split file by context
# Usage: csplit FILE PATTERN
# Split at lines matching pattern
# Output: xx00, xx01, xx02...

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print integer
# Check if string contains substring
def contains(haystack: *uint8, needle: *uint8) -> int32:
    h_len: int32 = strlen(haystack)
    n_len: int32 = strlen(needle)

    if n_len == 0:
        return 1

    i: int32 = 0
    while i <= h_len - n_len:
        j: int32 = 0
        matched: int32 = 1
        while j < n_len:
            if haystack[i + j] != needle[j]:
                matched = 0
                break
            j = j + 1

        if matched != 0:
            return 1

        i = i + 1

    return 0

# Create output filename: xx00, xx01, etc.
def make_filename(buf: *uint8, index: int32):
    buf[0] = cast[uint8](120)  # 'x'
    buf[1] = cast[uint8](120)  # 'x'

    # Convert index to 2 digits
    tens: int32 = index / 10
    ones: int32 = index % 10

    buf[2] = cast[uint8](48 + tens)
    buf[3] = cast[uint8](48 + ones)
    buf[4] = cast[uint8](0)

def main():
    argc: int32 = get_argc()

    if argc < 3:
        print_err(cast[*uint8]("Usage: csplit FILE PATTERN\n"))
        syscall1(SYS_exit, 1)

    filename: *uint8 = get_argv(1)
    pattern: *uint8 = get_argv(2)

    # Open input file
    fd: int32 = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
    if fd < 0:
        print_err(cast[*uint8]("csplit: cannot open file\n"))
        syscall1(SYS_exit, 1)

    # Allocate buffers
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 12288
    syscall1(SYS_brk, new_brk)
    buffer: *uint8 = cast[*uint8](old_brk)
    line_buf: *uint8 = cast[*uint8](old_brk + 4096)
    out_name: *uint8 = cast[*uint8](old_brk + 8192)

    file_index: int32 = 0
    line_pos: int32 = 0
    out_fd: int32 = -1
    line_count: int32 = 0

    # Create first output file
    make_filename(out_name, file_index)
    out_fd = syscall3(SYS_open, cast[int32](out_name), O_WRONLY + O_CREAT + O_TRUNC, 420)  # 0644
    if out_fd < 0:
        print_err(cast[*uint8]("csplit: cannot create output file\n"))
        syscall1(SYS_exit, 1)

    # Print byte count for first file
    print_int(0)
    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

    byte_count: int32 = 0

    running: int32 = 1
    while running != 0:
        n: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
        if n <= 0:
            # Flush last line if any
            if line_pos > 0:
                syscall3(SYS_write, out_fd, cast[int32](line_buf), line_pos)
                syscall3(SYS_write, out_fd, cast[int32]("\n"), 1)
                byte_count = byte_count + line_pos + 1
            running = 0
            break

        i: int32 = 0
        while i < n:
            c: uint8 = buffer[i]

            if c == cast[uint8](10):  # newline
                # Check if line matches pattern
                line_buf[line_pos] = cast[uint8](0)

                if contains(line_buf, pattern) != 0:
                    # Close current file
                    if out_fd >= 0:
                        syscall1(SYS_close, out_fd)

                    # Print byte count for completed file
                    print_int(byte_count)
                    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

                    # Open new file
                    file_index = file_index + 1
                    make_filename(out_name, file_index)
                    out_fd = syscall3(SYS_open, cast[int32](out_name), O_WRONLY + O_CREAT + O_TRUNC, 420)
                    byte_count = 0

                # Write line to current file
                syscall3(SYS_write, out_fd, cast[int32](line_buf), line_pos)
                syscall3(SYS_write, out_fd, cast[int32]("\n"), 1)
                byte_count = byte_count + line_pos + 1

                line_pos = 0
            else:
                # Add to line buffer
                if line_pos < 4095:
                    line_buf[line_pos] = c
                    line_pos = line_pos + 1

            i = i + 1

    # Print final byte count
    print_int(byte_count)
    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

    if out_fd >= 0:
        syscall1(SYS_close, out_fd)

    syscall1(SYS_close, fd)
    syscall1(SYS_exit, 0)
