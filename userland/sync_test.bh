# sync_test.bh - Test synchronization primitives
# Demonstrates spinlocks, mutexes, atomic operations, and other sync primitives

import "lib/syscalls"
import "lib/sync"

# Thread system calls
const SYS_thread_create: int32 = 200
const SYS_thread_exit: int32 = 201
const SYS_thread_yield: int32 = 202
const SYS_get_thread_id: int32 = 203

proc thread_create(entry: int32, stack_ptr: int32): int32 =
  return syscall2(SYS_thread_create, entry, stack_ptr)

proc thread_exit(code: int32) =
  discard syscall1(SYS_thread_exit, code)

proc thread_yield() =
  discard syscall1(SYS_thread_yield, 0)

proc get_thread_id(): int32 =
  return syscall1(SYS_get_thread_id, 0)

# Print helpers
proc print_msg(msg: ptr uint8) =
  var len: int32 = 0
  while msg[len] != cast[uint8](0):
    len = len + 1
  discard write(STDOUT, msg, len)

proc print_int(num: int32) =
  if num == 0:
    discard write(STDOUT, "0", 1)
    return

  var buf: array[12, uint8]
  var i: int32 = 0
  var n: int32 = num

  if n < 0:
    discard write(STDOUT, "-", 1)
    n = 0 - n

  while n > 0:
    var digit: int32 = n - (n / 10) * 10
    buf[i] = cast[uint8](48 + digit)
    n = n / 10
    i = i + 1

  while i > 0:
    i = i - 1
    discard write(STDOUT, addr(buf[i]), 1)

# ===========================================================================
# Test 1: Atomic Counter
# ===========================================================================

var atomic_test_counter: AtomicCounter = 0

proc test_atomic_operations() =
  print_msg("\n=== Test 1: Atomic Operations ===\n")

  atomic_counter_init(addr(atomic_test_counter), 0)
  print_msg("Initial counter: ")
  print_int(atomic_counter_get(addr(atomic_test_counter)))
  print_msg("\n")

  # Increment
  var old_val: int32 = atomic_counter_inc(addr(atomic_test_counter))
  print_msg("After increment (old value was ")
  print_int(old_val)
  print_msg("): ")
  print_int(atomic_counter_get(addr(atomic_test_counter)))
  print_msg("\n")

  # Add 10
  old_val = atomic_counter_add(addr(atomic_test_counter), 10)
  print_msg("After add 10 (old value was ")
  print_int(old_val)
  print_msg("): ")
  print_int(atomic_counter_get(addr(atomic_test_counter)))
  print_msg("\n")

  # Decrement
  old_val = atomic_counter_dec(addr(atomic_test_counter))
  print_msg("After decrement (old value was ")
  print_int(old_val)
  print_msg("): ")
  print_int(atomic_counter_get(addr(atomic_test_counter)))
  print_msg("\n")

  print_msg("Atomic operations test: PASSED\n")

# ===========================================================================
# Test 2: Spinlock
# ===========================================================================

var spinlock_test_lock: Spinlock = 0
var spinlock_test_counter: int32 = 0

proc test_spinlock() =
  print_msg("\n=== Test 2: Spinlock ===\n")

  spinlock_init(addr(spinlock_test_lock))
  print_msg("Spinlock initialized\n")

  # Lock
  print_msg("Acquiring spinlock...\n")
  spinlock_lock(addr(spinlock_test_lock))
  print_msg("Spinlock acquired\n")

  # Critical section
  spinlock_test_counter = spinlock_test_counter + 1
  print_msg("In critical section, counter = ")
  print_int(spinlock_test_counter)
  print_msg("\n")

  # Unlock
  print_msg("Releasing spinlock...\n")
  spinlock_unlock(addr(spinlock_test_lock))
  print_msg("Spinlock released\n")

  # Try lock
  var result: int32 = spinlock_trylock(addr(spinlock_test_lock))
  if result == 1:
    print_msg("Trylock succeeded\n")
    spinlock_unlock(addr(spinlock_test_lock))
  else:
    print_msg("Trylock failed (unexpected!)\n")

  print_msg("Spinlock test: PASSED\n")

# ===========================================================================
# Test 3: Mutex
# ===========================================================================

var mutex_test: Mutex
var mutex_test_counter: int32 = 0

proc test_mutex() =
  print_msg("\n=== Test 3: Mutex ===\n")

  mutex_init(addr(mutex_test))
  print_msg("Mutex initialized\n")

  # Lock
  print_msg("Locking mutex...\n")
  mutex_lock(addr(mutex_test))
  print_msg("Mutex locked\n")

  # Critical section
  mutex_test_counter = mutex_test_counter + 1
  print_msg("In critical section, counter = ")
  print_int(mutex_test_counter)
  print_msg("\n")

  # Unlock
  print_msg("Unlocking mutex...\n")
  mutex_unlock(addr(mutex_test))
  print_msg("Mutex unlocked\n")

  # Try lock
  var result: int32 = mutex_trylock(addr(mutex_test))
  if result == 1:
    print_msg("Mutex trylock succeeded\n")
    mutex_unlock(addr(mutex_test))
  else:
    print_msg("Mutex trylock failed (unexpected!)\n")

  print_msg("Mutex test: PASSED\n")

# ===========================================================================
# Test 4: Semaphore
# ===========================================================================

var semaphore_test: Semaphore

proc test_semaphore() =
  print_msg("\n=== Test 4: Semaphore ===\n")

  # Initialize with count=3, max=5
  semaphore_init(addr(semaphore_test), 3, 5)
  print_msg("Semaphore initialized (initial=3, max=5)\n")

  print_msg("Initial value: ")
  print_int(semaphore_getvalue(addr(semaphore_test)))
  print_msg("\n")

  # Wait (decrement)
  semaphore_wait(addr(semaphore_test))
  print_msg("After wait: ")
  print_int(semaphore_getvalue(addr(semaphore_test)))
  print_msg("\n")

  # Post (increment)
  semaphore_post(addr(semaphore_test))
  print_msg("After post: ")
  print_int(semaphore_getvalue(addr(semaphore_test)))
  print_msg("\n")

  # Try wait
  var result: int32 = semaphore_trywait(addr(semaphore_test))
  if result == 1:
    print_msg("Trywait succeeded, value: ")
    print_int(semaphore_getvalue(addr(semaphore_test)))
    print_msg("\n")
  else:
    print_msg("Trywait failed (unexpected!)\n")

  print_msg("Semaphore test: PASSED\n")

# ===========================================================================
# Test 5: Read-Write Lock
# ===========================================================================

var rwlock_test: RWLock
var rwlock_shared_data: int32 = 42

proc test_rwlock() =
  print_msg("\n=== Test 5: Read-Write Lock ===\n")

  rwlock_init(addr(rwlock_test))
  print_msg("RWLock initialized\n")

  # Read lock
  print_msg("Acquiring read lock...\n")
  rwlock_read_lock(addr(rwlock_test))
  print_msg("Read lock acquired, data = ")
  print_int(rwlock_shared_data)
  print_msg("\n")
  rwlock_read_unlock(addr(rwlock_test))
  print_msg("Read lock released\n")

  # Write lock
  print_msg("Acquiring write lock...\n")
  rwlock_write_lock(addr(rwlock_test))
  print_msg("Write lock acquired, modifying data...\n")
  rwlock_shared_data = rwlock_shared_data + 10
  print_msg("New data value = ")
  print_int(rwlock_shared_data)
  print_msg("\n")
  rwlock_write_unlock(addr(rwlock_test))
  print_msg("Write lock released\n")

  print_msg("RWLock test: PASSED\n")

# ===========================================================================
# Test 6: Atomic Flag
# ===========================================================================

var flag_test: AtomicFlag = 0

proc test_atomic_flag() =
  print_msg("\n=== Test 6: Atomic Flag ===\n")

  atomic_flag_clear(addr(flag_test))
  print_msg("Flag cleared\n")

  # Test and set (should succeed first time)
  var result: int32 = atomic_flag_test_and_set(addr(flag_test))
  print_msg("First test_and_set returned: ")
  print_int(result)
  print_msg(" (should be 0)\n")

  # Test and set again (should fail, flag already set)
  result = atomic_flag_test_and_set(addr(flag_test))
  print_msg("Second test_and_set returned: ")
  print_int(result)
  print_msg(" (should be 1)\n")

  # Clear
  atomic_flag_clear(addr(flag_test))
  print_msg("Flag cleared again\n")

  print_msg("Atomic flag test: PASSED\n")

# ===========================================================================
# Test 7: Barrier (single-threaded simulation)
# ===========================================================================

var barrier_test: Barrier

proc test_barrier() =
  print_msg("\n=== Test 7: Barrier (single-threaded) ===\n")

  # Initialize for 1 thread (just to test structure)
  barrier_init(addr(barrier_test), 1)
  print_msg("Barrier initialized for 1 thread\n")

  print_msg("Waiting at barrier...\n")
  barrier_wait(addr(barrier_test))
  print_msg("Barrier passed (immediate, as threshold=1)\n")

  print_msg("Barrier test: PASSED\n")

# ===========================================================================
# Main Program
# ===========================================================================

proc main(): int32 =
  print_msg("\n")
  print_msg("=====================================\n")
  print_msg("  BrainhairOS Synchronization Tests\n")
  print_msg("=====================================\n")

  # Run all tests
  test_atomic_operations()
  test_spinlock()
  test_mutex()
  test_semaphore()
  test_rwlock()
  test_atomic_flag()
  test_barrier()

  print_msg("\n=====================================\n")
  print_msg("  All Synchronization Tests PASSED!\n")
  print_msg("=====================================\n\n")

  print_msg("NOTE: These tests demonstrate the API.\n")
  print_msg("Actual synchronization requires kernel syscalls\n")
  print_msg("(syscalls 210-217) to be implemented.\n\n")

  print_msg("To test with actual threads, use the threading\n")
  print_msg("test program (thread_test).\n\n")

  return 0

main()
