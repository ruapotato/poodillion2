# term - Terminal Emulator for Brainhair Display Server
# Opens a PTY, forks a shell, renders output to framebuffer
# Supports basic ANSI escape sequences

const SYS_exit: int32 = 1
const SYS_fork: int32 = 2
const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_waitpid: int32 = 7
const SYS_execve: int32 = 11
const SYS_lseek: int32 = 19
const SYS_dup2: int32 = 63
const SYS_ioctl: int32 = 54
const SYS_fcntl: int32 = 55
const SYS_setsid: int32 = 66
const SYS_brk: int32 = 45
const SYS_select: int32 = 142

const STDOUT: int32 = 1
const STDIN: int32 = 0
const O_RDWR: int32 = 2
const O_NOCTTY: int32 = 256
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3
const SEEK_SET: int32 = 0

# Framebuffer ioctl
const FBIOGET_VSCREENINFO: int32 = 0x4600

# TTY ioctls
const TIOCSPTLCK: int32 = 0x40045431  # Unlock PTY
# TIOCGPTN (0x80045430) computed at runtime due to high bit
const TIOCSCTTY: int32 = 0x540E       # Set controlling terminal

# Terminal constants
const TERM_COLS: int32 = 100
const TERM_ROWS: int32 = 30
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 10  # 8 pixels + 2 spacing

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall5(num: int32, a1: int32, a2: int32, a3: int32, a4: int32, a5: int32): int32

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)

  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return

  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n

  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1

  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)

  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1

  print_str(buf)

# ============ Font Data (8x8 bitmap) ============

proc get_font_row(c: int32, row: int32): int32 =
  # Space
  if c == 32:
    return 0

  # Numbers 0-9
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0

  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0

  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0

  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  # Uppercase A-Z
  if c == 65:  # A
    if row == 0: return 0x18
    if row == 1: return 0x3C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0

  if c == 67:  # C
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0

  if c == 69:  # E
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x78
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  if c == 70:  # F
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x78
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0

  if c == 71:  # G
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x6E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3E
    return 0

  if c == 72:  # H
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 73:  # I
    if row == 0: return 0x3C
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0

  if c == 74:  # J
    if row == 0: return 0x1E
    if row == 1: return 0x0C
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x6C
    if row == 6: return 0x38
    return 0

  if c == 75:  # K
    if row == 0: return 0x66
    if row == 1: return 0x6C
    if row == 2: return 0x78
    if row == 3: return 0x70
    if row == 4: return 0x78
    if row == 5: return 0x6C
    if row == 6: return 0x66
    return 0

  if c == 76:  # L
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  if c == 77:  # M
    if row == 0: return 0x63
    if row == 1: return 0x77
    if row == 2: return 0x7F
    if row == 3: return 0x6B
    if row == 4: return 0x63
    if row == 5: return 0x63
    if row == 6: return 0x63
    return 0

  if c == 78:  # N
    if row == 0: return 0x66
    if row == 1: return 0x76
    if row == 2: return 0x7E
    if row == 3: return 0x7E
    if row == 4: return 0x6E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 80:  # P
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0

  if c == 81:  # Q
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x6A
    if row == 5: return 0x6C
    if row == 6: return 0x36
    return 0

  if c == 82:  # R
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x6C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 83:  # S
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x3C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 84:  # T
    if row == 0: return 0x7E
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0

  if c == 85:  # U
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 86:  # V
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0

  if c == 87:  # W
    if row == 0: return 0x63
    if row == 1: return 0x63
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x7F
    if row == 5: return 0x77
    if row == 6: return 0x63
    return 0

  if c == 88:  # X
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 89:  # Y
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0

  if c == 90:  # Z
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  # Lowercase a-z
  if c == 97:  # a
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3C
    if row == 3: return 0x06
    if row == 4: return 0x3E
    if row == 5: return 0x66
    if row == 6: return 0x3E
    return 0

  if c == 98:  # b
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0

  if c == 99:  # c
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3C
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x3C
    return 0

  if c == 100:  # d
    if row == 0: return 0x06
    if row == 1: return 0x06
    if row == 2: return 0x3E
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3E
    return 0

  if c == 101:  # e
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3C
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x60
    if row == 6: return 0x3C
    return 0

  if c == 102:  # f
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x7C
    if row == 3: return 0x30
    if row == 4: return 0x30
    if row == 5: return 0x30
    if row == 6: return 0x30
    return 0

  if c == 103:  # g
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3E
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3E
    if row == 6: return 0x06
    if row == 7: return 0x3C
    return 0

  if c == 104:  # h
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 105:  # i
    if row == 0: return 0x18
    if row == 1: return 0x00
    if row == 2: return 0x38
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0

  if c == 106:  # j
    if row == 0: return 0x0C
    if row == 1: return 0x00
    if row == 2: return 0x1C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x0C
    if row == 6: return 0x6C
    if row == 7: return 0x38
    return 0

  if c == 107:  # k
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x66
    if row == 3: return 0x6C
    if row == 4: return 0x78
    if row == 5: return 0x6C
    if row == 6: return 0x66
    return 0

  if c == 108:  # l
    if row == 0: return 0x38
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0

  if c == 109:  # m
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x76
    if row == 3: return 0x7F
    if row == 4: return 0x6B
    if row == 5: return 0x63
    if row == 6: return 0x63
    return 0

  if c == 110:  # n
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  if c == 111:  # o
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  if c == 112:  # p
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x7C
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x7C
    if row == 6: return 0x60
    if row == 7: return 0x60
    return 0

  if c == 113:  # q
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3E
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3E
    if row == 6: return 0x06
    if row == 7: return 0x06
    return 0

  if c == 114:  # r
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x6C
    if row == 3: return 0x76
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0

  if c == 115:  # s
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x3E
    if row == 3: return 0x60
    if row == 4: return 0x3C
    if row == 5: return 0x06
    if row == 6: return 0x7C
    return 0

  if c == 116:  # t
    if row == 0: return 0x30
    if row == 1: return 0x30
    if row == 2: return 0x7C
    if row == 3: return 0x30
    if row == 4: return 0x30
    if row == 5: return 0x30
    if row == 6: return 0x1C
    return 0

  if c == 117:  # u
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3E
    return 0

  if c == 118:  # v
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0

  if c == 119:  # w
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x6B
    if row == 5: return 0x7F
    if row == 6: return 0x36
    return 0

  if c == 120:  # x
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x18
    if row == 5: return 0x3C
    if row == 6: return 0x66
    return 0

  if c == 121:  # y
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3E
    if row == 6: return 0x06
    if row == 7: return 0x3C
    return 0

  if c == 122:  # z
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x7E
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0

  # Symbols
  if c == 33:  # !
    if row == 0: return 0x18
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x00
    if row == 6: return 0x18
    return 0

  if c == 34:  # "
    if row == 0: return 0x6C
    if row == 1: return 0x6C
    if row == 2: return 0x24
    return 0

  if c == 35:  # #
    if row == 0: return 0x24
    if row == 1: return 0x7E
    if row == 2: return 0x24
    if row == 3: return 0x24
    if row == 4: return 0x7E
    if row == 5: return 0x24
    return 0

  if c == 36:  # $
    if row == 0: return 0x18
    if row == 1: return 0x3E
    if row == 2: return 0x60
    if row == 3: return 0x3C
    if row == 4: return 0x06
    if row == 5: return 0x7C
    if row == 6: return 0x18
    return 0

  if c == 37:  # %
    if row == 0: return 0x62
    if row == 1: return 0x64
    if row == 2: return 0x08
    if row == 3: return 0x10
    if row == 4: return 0x26
    if row == 5: return 0x46
    return 0

  if c == 40:  # (
    if row == 0: return 0x0C
    if row == 1: return 0x18
    if row == 2: return 0x30
    if row == 3: return 0x30
    if row == 4: return 0x30
    if row == 5: return 0x18
    if row == 6: return 0x0C
    return 0

  if c == 41:  # )
    if row == 0: return 0x30
    if row == 1: return 0x18
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x18
    if row == 6: return 0x30
    return 0

  if c == 42:  # *
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0xFF
    if row == 4: return 0x3C
    if row == 5: return 0x66
    return 0

  if c == 43:  # +
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x7E
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0

  if c == 44:  # ,
    if row == 5: return 0x18
    if row == 6: return 0x18
    if row == 7: return 0x30
    return 0

  if c == 45:  # -
    if row == 3: return 0x7E
    return 0

  if c == 46:  # .
    if row == 6: return 0x18
    return 0

  if c == 47:  # /
    if row == 0: return 0x02
    if row == 1: return 0x04
    if row == 2: return 0x08
    if row == 3: return 0x10
    if row == 4: return 0x20
    if row == 5: return 0x40
    return 0

  if c == 58:  # :
    if row == 2: return 0x18
    if row == 5: return 0x18
    return 0

  if c == 59:  # ;
    if row == 2: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x30
    return 0

  if c == 60:  # <
    if row == 1: return 0x06
    if row == 2: return 0x18
    if row == 3: return 0x60
    if row == 4: return 0x18
    if row == 5: return 0x06
    return 0

  if c == 61:  # =
    if row == 2: return 0x7E
    if row == 4: return 0x7E
    return 0

  if c == 62:  # >
    if row == 1: return 0x60
    if row == 2: return 0x18
    if row == 3: return 0x06
    if row == 4: return 0x18
    if row == 5: return 0x60
    return 0

  if c == 63:  # ?
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x00
    if row == 6: return 0x18
    return 0

  if c == 91:  # [
    if row == 0: return 0x3C
    if row == 1: return 0x30
    if row == 2: return 0x30
    if row == 3: return 0x30
    if row == 4: return 0x30
    if row == 5: return 0x30
    if row == 6: return 0x3C
    return 0

  if c == 92:  # \
    if row == 0: return 0x40
    if row == 1: return 0x20
    if row == 2: return 0x10
    if row == 3: return 0x08
    if row == 4: return 0x04
    if row == 5: return 0x02
    return 0

  if c == 93:  # ]
    if row == 0: return 0x3C
    if row == 1: return 0x0C
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x0C
    if row == 6: return 0x3C
    return 0

  if c == 95:  # _
    if row == 7: return 0x7E
    return 0

  if c == 124:  # |
    if row == 0: return 0x18
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    if row == 7: return 0x18
    return 0

  if c == 126:  # ~
    if row == 2: return 0x32
    if row == 3: return 0x4C
    return 0

  # Default: solid block
  return 0xFF

# ============ Framebuffer Drawing ============

proc draw_char(fb_fd: int32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, pixel_buf: ptr uint32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0:
        color = fg
      pixel_buf[col] = cast[uint32](color)
      col = col + 1
    var offset: int32 = ((y + row) * xres + x) * 4
    discard syscall3(SYS_lseek, fb_fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fb_fd, cast[int32](pixel_buf), 32)
    row = row + 1

proc fill_rect(fb_fd: int32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32, line_buf: ptr uint32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      if sx < ex:
        var width: int32 = ex - sx
        var i: int32 = 0
        while i < width:
          line_buf[i] = cast[uint32](color)
          i = i + 1
        var offset: int32 = (cy * xres + sx) * 4
        discard syscall3(SYS_lseek, fb_fd, offset, SEEK_SET)
        discard syscall3(SYS_write, fb_fd, cast[int32](line_buf), width * 4)
    cy = cy + 1

# ============ Terminal State ============

# Global state passed around
proc term_init(screen_buf: ptr uint8, cols: int32, rows: int32) =
  # Initialize screen buffer with spaces
  var i: int32 = 0
  while i < cols * rows:
    screen_buf[i] = cast[uint8](32)  # Space
    i = i + 1

proc term_scroll(screen_buf: ptr uint8, cols: int32, rows: int32) =
  # Move all lines up by one
  var i: int32 = 0
  while i < (rows - 1) * cols:
    screen_buf[i] = screen_buf[i + cols]
    i = i + 1
  # Clear last line
  while i < rows * cols:
    screen_buf[i] = cast[uint8](32)
    i = i + 1

proc term_putchar(screen_buf: ptr uint8, cx: ptr int32, cy: ptr int32, cols: int32, rows: int32, c: uint8) =
  var x: int32 = cx[0]
  var y: int32 = cy[0]

  if c == cast[uint8](10):  # Newline
    x = 0
    y = y + 1
  else:
    if c == cast[uint8](13):  # Carriage return
      x = 0
    else:
      if c == cast[uint8](8) or c == cast[uint8](127):  # Backspace/DEL
        if x > 0:
          x = x - 1
          screen_buf[y * cols + x] = cast[uint8](32)
      else:
        if c == cast[uint8](9):  # Tab
          x = ((x / 8) + 1) * 8
        else:
          if c >= cast[uint8](32) and c < cast[uint8](127):
            screen_buf[y * cols + x] = c
            x = x + 1

  # Wrap
  if x >= cols:
    x = 0
    y = y + 1

  # Scroll if needed
  if y >= rows:
    term_scroll(screen_buf, cols, rows)
    y = rows - 1

  cx[0] = x
  cy[0] = y

proc term_render(fb_fd: int32, screen_buf: ptr uint8, cols: int32, rows: int32, term_x: int32, term_y: int32, xres: int32, fg: int32, bg: int32, pixel_buf: ptr uint32) =
  var row: int32 = 0
  while row < rows:
    var col: int32 = 0
    while col < cols:
      var c: uint8 = screen_buf[row * cols + col]
      var px: int32 = term_x + col * FONT_WIDTH
      var py: int32 = term_y + row * FONT_HEIGHT
      draw_char(fb_fd, px, py, cast[int32](c), fg, bg, xres, pixel_buf)
      col = col + 1
    row = row + 1

proc term_render_cursor(fb_fd: int32, cx: int32, cy: int32, term_x: int32, term_y: int32, xres: int32, pixel_buf: ptr uint32) =
  # Draw a block cursor
  var px: int32 = term_x + cx * FONT_WIDTH
  var py: int32 = term_y + cy * FONT_HEIGHT + 7
  var i: int32 = 0
  while i < 8:
    pixel_buf[i] = cast[uint32](0x00FF00)  # Green cursor
    i = i + 1
  var offset: int32 = (py * xres + px) * 4
  discard syscall3(SYS_lseek, fb_fd, offset, SEEK_SET)
  discard syscall3(SYS_write, fb_fd, cast[int32](pixel_buf), 32)

# ============ PTY Functions ============

proc open_pty(unlock_buf: ptr int32): int32 =
  # Open /dev/ptmx
  var master_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/ptmx"), O_RDWR | O_NOCTTY)
  if master_fd < 0:
    return -1

  # Unlock the slave
  unlock_buf[0] = 0
  discard syscall3(SYS_ioctl, master_fd, TIOCSPTLCK, cast[int32](unlock_buf))

  return master_fd

proc get_pts_num(master_fd: int32, pts_buf: ptr int32): int32 =
  pts_buf[0] = 0
  # TIOCGPTN = 0x80045430 = -2147199952 as signed int32
  # Build it by parts: 0x80000000 + 0x45430
  var tiocgptn: int32 = 0x45430 - 0x7FFFC000
  tiocgptn = tiocgptn - 0x4000
  discard syscall3(SYS_ioctl, master_fd, tiocgptn, cast[int32](pts_buf))
  return pts_buf[0]

proc build_pts_path(buf: ptr uint8, num: int32) =
  # Build "/dev/pts/N" string
  buf[0] = cast[uint8](47)   # /
  buf[1] = cast[uint8](100)  # d
  buf[2] = cast[uint8](101)  # e
  buf[3] = cast[uint8](118)  # v
  buf[4] = cast[uint8](47)   # /
  buf[5] = cast[uint8](112)  # p
  buf[6] = cast[uint8](116)  # t
  buf[7] = cast[uint8](115)  # s
  buf[8] = cast[uint8](47)   # /

  # Convert number to string
  var n: int32 = num
  if n == 0:
    buf[9] = cast[uint8](48)
    buf[10] = cast[uint8](0)
    return

  var digits: int32 = 0
  var tmp: int32 = n
  while tmp > 0:
    tmp = tmp / 10
    digits = digits + 1

  buf[9 + digits] = cast[uint8](0)
  var i: int32 = digits - 1
  while n > 0:
    buf[9 + i] = cast[uint8](48 + n - (n / 10) * 10)
    n = n / 10
    i = i - 1

# ============ Main ============

proc main() =
  print_str(cast[ptr uint8]("Brainhair Terminal v0.1\n"))

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate memory (128KB)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 131072
  discard syscall1(SYS_brk, new_brk)

  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var pixel_buf: ptr uint32 = cast[ptr uint32](old_brk + 256)
  var line_buf: ptr uint32 = cast[ptr uint32](old_brk + 512)
  var screen_buf: ptr uint8 = cast[ptr uint8](old_brk + 8192)
  var read_buf: ptr uint8 = cast[ptr uint8](old_brk + 16384)
  var pts_path: ptr uint8 = cast[ptr uint8](old_brk + 17408)
  var argv_buf: ptr int32 = cast[ptr int32](old_brk + 17536)
  var pty_buf: ptr int32 = cast[ptr int32](old_brk + 17600)
  var status_buf: ptr int32 = cast[ptr int32](old_brk + 17608)

  # Get screen info
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # Calculate terminal dimensions
  var cols: int32 = (xres - 40) / FONT_WIDTH
  var rows: int32 = (yres - 60) / FONT_HEIGHT
  if cols > TERM_COLS: cols = TERM_COLS
  if rows > TERM_ROWS: rows = TERM_ROWS

  var term_x: int32 = 20
  var term_y: int32 = 30
  var term_w: int32 = cols * FONT_WIDTH + 10
  var term_h: int32 = rows * FONT_HEIGHT + 10

  print_str(cast[ptr uint8]("Terminal: "))
  print_num(cols)
  print_str(cast[ptr uint8]("x"))
  print_num(rows)
  print_str(cast[ptr uint8]("\n"))

  # Open PTY
  var master_fd: int32 = open_pty(pty_buf)
  if master_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/ptmx\n"))
    discard syscall1(SYS_exit, 1)

  var pts_num: int32 = get_pts_num(master_fd, pty_buf)
  build_pts_path(pts_path, pts_num)

  print_str(cast[ptr uint8]("PTY: "))
  print_str(pts_path)
  print_str(cast[ptr uint8]("\n"))

  # Fork and exec shell
  var pid: int32 = syscall1(SYS_fork, 0)

  if pid == 0:
    # Child process
    discard syscall1(SYS_close, master_fd)
    discard syscall1(SYS_setsid, 0)

    var slave_fd: int32 = syscall2(SYS_open, cast[int32](pts_path), O_RDWR)
    if slave_fd >= 0:
      discard syscall3(SYS_ioctl, slave_fd, TIOCSCTTY, 0)
      discard syscall2(SYS_dup2, slave_fd, 0)
      discard syscall2(SYS_dup2, slave_fd, 1)
      discard syscall2(SYS_dup2, slave_fd, 2)
      if slave_fd > 2:
        discard syscall1(SYS_close, slave_fd)

    # Build argv: ["/bin/sh", NULL]
    var shell: ptr uint8 = cast[ptr uint8]("/bin/sh")
    argv_buf[0] = cast[int32](shell)
    argv_buf[1] = 0

    # execve
    discard syscall3(SYS_execve, cast[int32](shell), cast[int32](argv_buf), 0)
    discard syscall1(SYS_exit, 1)

  if pid < 0:
    print_str(cast[ptr uint8]("Error: fork failed\n"))
    discard syscall1(SYS_exit, 1)

  print_str(cast[ptr uint8]("Shell PID: "))
  print_num(pid)
  print_str(cast[ptr uint8]("\n"))

  # Set master to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, master_fd, F_GETFL)
  discard syscall3(SYS_fcntl, master_fd, F_SETFL, flags | O_NONBLOCK)

  # Also set stdin to non-blocking
  flags = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

  # Initialize terminal
  term_init(screen_buf, cols, rows)

  var cursor_x: int32 = 0
  var cursor_y: int32 = 0
  var cursor_state: ptr int32 = cast[ptr int32](old_brk + 17700)
  cursor_state[0] = cursor_x
  cursor_state[1] = cursor_y

  # Colors
  var fg_color: int32 = 0xCCCCCC
  var bg_color: int32 = 0x1A1A2E
  var border_color: int32 = 0x404060

  # Draw initial frame
  fill_rect(fb_fd, 0, 0, xres, yres, 0x101020, xres, yres, line_buf)
  fill_rect(fb_fd, term_x - 5, term_y - 5, term_w, term_h, border_color, xres, yres, line_buf)
  fill_rect(fb_fd, term_x, term_y, term_w - 10, term_h - 10, bg_color, xres, yres, line_buf)

  # Write welcome message to buffer
  var welcome: ptr uint8 = cast[ptr uint8]("Brainhair Terminal\n$ ")
  var wi: int32 = 0
  while welcome[wi] != cast[uint8](0):
    term_putchar(screen_buf, cast[ptr int32](cast[int32](cursor_state)), cast[ptr int32](cast[int32](cursor_state) + 4), cols, rows, welcome[wi])
    wi = wi + 1

  # Main loop
  var running: int32 = 1
  var redraw_count: int32 = 0

  while running != 0:
    # Read from PTY (shell output)
    var n: int32 = syscall3(SYS_read, master_fd, cast[int32](read_buf), 1024)
    if n > 0:
      var i: int32 = 0
      while i < n:
        var c: uint8 = read_buf[i]
        term_putchar(screen_buf, cast[ptr int32](cast[int32](cursor_state)), cast[ptr int32](cast[int32](cursor_state) + 4), cols, rows, c)
        i = i + 1
      redraw_count = redraw_count + 1

    # Read from stdin (keyboard)
    n = syscall3(SYS_read, STDIN, cast[int32](read_buf), 256)
    if n > 0:
      # Check for Ctrl+D (exit)
      var i: int32 = 0
      while i < n:
        if read_buf[i] == cast[uint8](4):  # Ctrl+D
          running = 0
        i = i + 1

      # Write to PTY
      if running != 0:
        discard syscall3(SYS_write, master_fd, cast[int32](read_buf), n)

    # Redraw terminal every few iterations
    if redraw_count > 0:
      term_render(fb_fd, screen_buf, cols, rows, term_x, term_y, xres, fg_color, bg_color, pixel_buf)
      term_render_cursor(fb_fd, cursor_state[0], cursor_state[1], term_x, term_y, xres, pixel_buf)
      redraw_count = 0

    # Check if child exited
    status_buf[0] = 0
    var w: int32 = syscall3(SYS_waitpid, pid, cast[int32](status_buf), 1)  # WNOHANG = 1
    if w == pid:
      print_str(cast[ptr uint8]("Shell exited\n"))
      running = 0

  # Cleanup
  discard syscall1(SYS_close, master_fd)
  discard syscall1(SYS_close, fb_fd)

  print_str(cast[ptr uint8]("Terminal closed\n"))
  discard syscall1(SYS_exit, 0)

main()
