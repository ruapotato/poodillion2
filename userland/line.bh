# line - Draw a line from (x1,y1) to (x2,y2)
# Usage: line <x1> <y1> <x2> <y2> <color>
# Uses Bresenham's line algorithm

from lib.syscalls import *

const FBIOGET_VSCREENINFO: int32 = 0x4600

def my_abs(x: int32) -> int32:
    if x < 0:
        return -x
    else:
        return x

def plot_pixel(fd: int32, x: int32, y: int32, xres: int32, yres: int32, color: int32, pixel_buf: *uint32):
    if x < 0 or x >= xres or y < 0 or y >= yres:
        return

    offset: int32 = (y * xres + x) * 4
    _ = syscall3(SYS_lseek, fd, offset, SEEK_SET)
    pixel_buf[0] = color
    _ = syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

def main():
    # For testing: Draw diagonal line (0,0) to (200,200)
    x1: int32 = 0
    y1: int32 = 0
    x2: int32 = 200
    y2: int32 = 200
    color: int32 = 0x00FF00  # Green

    fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fd < 0:
        print(cast[*uint8]("Error: Cannot open /dev/fb0\n"), 29)
        _ = syscall1(SYS_exit, 1)

    # Get screen info
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 160
    _ = syscall1(SYS_brk, new_brk)
    vinfo: *uint32 = cast[*uint32](old_brk)

    result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    if result < 0:
        print(cast[*uint8]("Error: Cannot get screen info\n"), 31)
        _ = syscall1(SYS_close, fd)
        _ = syscall1(SYS_exit, 1)

    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    # Allocate pixel buffer
    pixel_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, pixel_brk + 4)
    pixel: *uint32 = cast[*uint32](pixel_brk)

    # Bresenham's line algorithm
    dx: int32 = my_abs(x2 - x1)
    dy: int32 = my_abs(y2 - y1)
    sx: int32 = 1
    if x1 >= x2:
        sx = -1
    sy: int32 = 1
    if y1 >= y2:
        sy = -1
    err: int32 = dx - dy
    x: int32 = x1
    y: int32 = y1

    while true:
        plot_pixel(fd, x, y, xres, yres, color, pixel)

        if x == x2 and y == y2:
            break

        e2: int32 = 2 * err
        if e2 > -dy:
            err = err - dy
            x = x + sx
        if e2 < dx:
            err = err + dx
            y = y + sy

    _ = syscall1(SYS_close, fd)
    _ = syscall1(SYS_exit, 0)

main()
