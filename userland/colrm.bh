# colrm - remove columns from lines
# Usage: colrm START [STOP]
# Remove columns START through STOP (1-indexed)
# If STOP not given, remove from START to end of line
# Part of BrainhairOS text utilities

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDERR, cast[int32](msg), len)

def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    while s[i] >= cast[uint8](48):
        if s[i] > cast[uint8](57):
            break
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
    return result

def main():
    argc: int32 = get_argc()

    if argc < 2:
        print_err(cast[*uint8]("colrm: usage: colrm START [STOP]\n"))
        syscall1(SYS_exit, 1)

    # Parse arguments
    start_col: int32 = parse_int(get_argv(1))
    stop_col: int32 = -1

    if argc > 2:
        stop_col = parse_int(get_argv(2))

    if start_col <= 0:
        start_col = 1

    # Allocate buffers
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 8192
    syscall1(SYS_brk, new_brk)
    buffer: *uint8 = cast[*uint8](old_brk)
    line_buf: *uint8 = cast[*uint8](old_brk + 4096)

    # Process input line by line
    line_len: int32 = 0
    running: int32 = 1

    while running != 0:
        n: int32 = syscall3(SYS_read, STDIN, cast[int32](buffer), 4096)
        if n <= 0:
            # Output remaining line if any
            if line_len > 0:
                i: int32 = 0
                while i < line_len:
                    col: int32 = i + 1
                    if col < start_col:
                        syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
                    else:
                        if stop_col > 0:
                            if col > stop_col:
                                syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
                    i = i + 1
                syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
            running = 0
            break

        j: int32 = 0
        while j < n:
            ch: uint8 = buffer[j]

            if ch == cast[uint8](10):  # newline
                # Process current line - output chars not in remove range
                i: int32 = 0
                while i < line_len:
                    col: int32 = i + 1
                    if col < start_col:
                        # Before remove range
                        syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
                    else:
                        if stop_col > 0:
                            # Stop column specified
                            if col > stop_col:
                                # After remove range
                                syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
                    # else: in remove range, skip
                    i = i + 1

                syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                line_len = 0
            else:
                # Add character to line buffer
                if line_len < 4096:
                    line_buf[line_len] = ch
                    line_len = line_len + 1

            j = j + 1

    syscall1(SYS_exit, 0)
