# colrm - remove columns from lines
# Usage: colrm START [STOP]
# Remove columns START through STOP (1-indexed)
# If STOP not given, remove from START to end of line
# Part of BrainhairOS text utilities

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("colrm: usage: colrm START [STOP]\n"))
    discard syscall1(SYS_exit, 1)

  # Parse arguments
  var start_col: int32 = parse_int(get_argv(1))
  var stop_col: int32 = -1

  if argc > 2:
    stop_col = parse_int(get_argv(2))

  if start_col <= 0:
    start_col = 1

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var line_buf: ptr uint8 = cast[ptr uint8](old_brk + 4096)

  # Process input line by line
  var line_len: int32 = 0
  var running: int32 = 1

  while running != 0:
    var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buffer), 4096)
    if n <= 0:
      # Output remaining line if any
      if line_len > 0:
        var i: int32 = 0
        while i < line_len:
          var col: int32 = i + 1
          if col < start_col:
            discard syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
          else:
            if stop_col > 0:
              if col > stop_col:
                discard syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
          i = i + 1
        discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      running = 0
      break

    var j: int32 = 0
    while j < n:
      var ch: uint8 = buffer[j]

      if ch == cast[uint8](10):  # newline
        # Process current line - output chars not in remove range
        var i: int32 = 0
        while i < line_len:
          var col: int32 = i + 1
          if col < start_col:
            # Before remove range
            discard syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
          else:
            if stop_col > 0:
              # Stop column specified
              if col > stop_col:
                # After remove range
                discard syscall3(SYS_write, STDOUT, cast[int32](line_buf + i), 1)
          # else: in remove range, skip
          i = i + 1

        discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
        line_len = 0
      else:
        # Add character to line buffer
        if line_len < 4096:
          line_buf[line_len] = ch
          line_len = line_len + 1

      j = j + 1

  discard syscall1(SYS_exit, 0)
