# file - Determine file type
# Usage: file filename [filename...]
# Detects: ELF binary, shell script, text, directory, symlink, etc.

import "lib/syscalls"

# File mode bits
const S_IFMT: int32 = 61440    # 0170000
const S_IFSOCK: int32 = 49152  # 0140000
const S_IFLNK: int32 = 40960   # 0120000
const S_IFREG: int32 = 32768   # 0100000
const S_IFBLK: int32 = 24576   # 0060000
const S_IFDIR: int32 = 16384   # 0040000
const S_IFCHR: int32 = 8192    # 0020000
const S_IFIFO: int32 = 4096    # 0010000

extern get_argc(): int32
extern get_argv(i: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if file is mostly printable ASCII
proc is_text(buf: ptr uint8, size: int32): int32 =
  var printable: int32 = 0
  var i: int32 = 0
  while i < size:
    var c: uint8 = buf[i]
    # Check if printable ASCII or whitespace
    if (c >= 32 and c <= 126) or c == 9 or c == 10 or c == 13:
      printable = printable + 1
    i = i + 1

  # If more than 90% printable, consider it text
  if size > 0 and (printable * 100 / size) > 90:
    return 1
  return 0

# Detect file type
proc detect_file_type(filename: ptr uint8, stat_buf: ptr uint8, read_buf: ptr uint8) =
  print(filename)
  print(cast[ptr uint8](": "))

  # Get file stats
  var ret: int32 = syscall2(SYS_lstat, cast[int32](filename), cast[int32](stat_buf))
  if ret < 0:
    print(cast[ptr uint8]("cannot stat\n"))
    return

  # Parse stat structure
  var mode_ptr: ptr uint32 = cast[ptr uint32](cast[int32](stat_buf) + 16)
  var size_ptr: ptr int32 = cast[ptr int32](cast[int32](stat_buf) + 48)

  var mode: int32 = cast[int32](mode_ptr[0])
  var size: int32 = size_ptr[0]
  var file_type: int32 = mode & S_IFMT

  # Check special file types
  if file_type == S_IFDIR:
    print(cast[ptr uint8]("directory\n"))
    return

  if file_type == S_IFLNK:
    print(cast[ptr uint8]("symbolic link\n"))
    return

  if file_type == S_IFCHR:
    print(cast[ptr uint8]("character special\n"))
    return

  if file_type == S_IFBLK:
    print(cast[ptr uint8]("block special\n"))
    return

  if file_type == S_IFIFO:
    print(cast[ptr uint8]("FIFO (named pipe)\n"))
    return

  if file_type == S_IFSOCK:
    print(cast[ptr uint8]("socket\n"))
    return

  # Check if empty
  if size == 0:
    print(cast[ptr uint8]("empty\n"))
    return

  # For regular files, read first bytes to detect type
  var fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
  if fd < 0:
    print(cast[ptr uint8]("cannot open\n"))
    return

  # Read first 512 bytes
  var nread: int32 = syscall3(SYS_read, fd, cast[int32](read_buf), 512)
  discard syscall1(SYS_close, fd)

  if nread < 0:
    print(cast[ptr uint8]("cannot read\n"))
    return

  # Check for ELF magic
  if nread >= 4:
    if read_buf[0] == 127 and read_buf[1] == cast[uint8](69) and read_buf[2] == cast[uint8](76) and read_buf[3] == cast[uint8](70):
      print(cast[ptr uint8]("ELF"))
      # Check ELF class (32-bit or 64-bit)
      if nread >= 5:
        if read_buf[4] == 1:
          print(cast[ptr uint8](" 32-bit"))
        if read_buf[4] == 2:
          print(cast[ptr uint8](" 64-bit"))
      # Check ELF type
      if nread >= 18:
        var etype_ptr: ptr uint16 = cast[ptr uint16](cast[int32](read_buf) + 16)
        var etype: int32 = cast[int32](etype_ptr[0])
        if etype == 2:
          print(cast[ptr uint8](" executable"))
        if etype == 3:
          print(cast[ptr uint8](" shared object"))
      discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      return

  # Check for shebang (#!)
  if nread >= 2:
    if read_buf[0] == cast[uint8](35) and read_buf[1] == cast[uint8](33):
      print(cast[ptr uint8]("shell script"))
      # Try to extract interpreter
      if nread > 2:
        discard syscall3(SYS_write, STDOUT, cast[int32](", "), 2)
        var i: int32 = 2
        while i < nread and read_buf[i] != cast[uint8](10) and read_buf[i] != cast[uint8](13):
          discard syscall3(SYS_write, STDOUT, cast[int32](read_buf) + i, 1)
          i = i + 1
      discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      return

  # Check for common archive formats
  if nread >= 4:
    # ZIP magic
    if read_buf[0] == cast[uint8](80) and read_buf[1] == cast[uint8](75):
      if read_buf[2] == cast[uint8](3) and read_buf[3] == cast[uint8](4):
        print(cast[ptr uint8]("Zip archive\n"))
        return
      if read_buf[2] == cast[uint8](5) and read_buf[3] == cast[uint8](6):
        print(cast[ptr uint8]("Zip archive (empty)\n"))
        return

  # Check for gzip
  if nread >= 2:
    if read_buf[0] == cast[uint8](31) and read_buf[1] == cast[uint8](139):
      print(cast[ptr uint8]("gzip compressed data\n"))
      return

  # Check for bzip2
  if nread >= 3:
    if read_buf[0] == cast[uint8](66) and read_buf[1] == cast[uint8](90) and read_buf[2] == cast[uint8](104):
      print(cast[ptr uint8]("bzip2 compressed data\n"))
      return

  # Check for tar
  if nread >= 262:
    # tar has "ustar" at offset 257
    if read_buf[257] == cast[uint8](117) and read_buf[258] == cast[uint8](115) and read_buf[259] == cast[uint8](116) and read_buf[260] == cast[uint8](97) and read_buf[261] == cast[uint8](114):
      print(cast[ptr uint8]("POSIX tar archive\n"))
      return

  # Check for PDF
  if nread >= 4:
    if read_buf[0] == cast[uint8](37) and read_buf[1] == cast[uint8](80) and read_buf[2] == cast[uint8](68) and read_buf[3] == cast[uint8](70):
      print(cast[ptr uint8]("PDF document\n"))
      return

  # Check for PNG
  if nread >= 8:
    if read_buf[0] == cast[uint8](137) and read_buf[1] == cast[uint8](80) and read_buf[2] == cast[uint8](78) and read_buf[3] == cast[uint8](71):
      print(cast[ptr uint8]("PNG image\n"))
      return

  # Check for JPEG
  if nread >= 2:
    if read_buf[0] == cast[uint8](255) and read_buf[1] == cast[uint8](216):
      print(cast[ptr uint8]("JPEG image\n"))
      return

  # Check for GIF
  if nread >= 6:
    if read_buf[0] == cast[uint8](71) and read_buf[1] == cast[uint8](73) and read_buf[2] == cast[uint8](70):
      if read_buf[3] == cast[uint8](56) and (read_buf[4] == cast[uint8](55) or read_buf[4] == cast[uint8](57)):
        print(cast[ptr uint8]("GIF image\n"))
        return

  # Check if text
  if is_text(read_buf, nread) != 0:
    print(cast[ptr uint8]("ASCII text\n"))
    return

  # Default to data
  print(cast[ptr uint8]("data\n"))

proc main() =
  var argc: int32 = get_argc()
  if argc < 2:
    print_err(cast[ptr uint8]("Usage: file filename [...]\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 1024
  discard syscall1(SYS_brk, new_brk)

  var stat_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var read_buf: ptr uint8 = cast[ptr uint8](old_brk + 256)

  # Process each file
  var i: int32 = 1
  while i < argc:
    var filename: ptr uint8 = get_argv(i)
    detect_file_type(filename, stat_buf, read_buf)
    i = i + 1

  discard syscall1(SYS_exit, 0)
