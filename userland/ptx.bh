# ptx - Produce permuted index
# Usage: ptx [FILE]
# Simplified version: list words with context
# Output: word CONTEXT

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if character is whitespace
def is_whitespace(c: uint8) -> int32:
  if c == cast[uint8](32):  # space
    return 1
  if c == cast[uint8](9):   # tab
    return 1
  if c == cast[uint8](10):  # newline
    return 1
  if c == cast[uint8](13):  # carriage return
    return 1
  return 0

# Check if character is alphanumeric or punctuation (not whitespace)
def is_word_char(c: uint8) -> int32:
  # Letters, digits, and some punctuation
  if c >= cast[uint8](48) and c <= cast[uint8](57):  # 0-9
    return 1
  if c >= cast[uint8](65) and c <= cast[uint8](90):  # A-Z
    return 1
  if c >= cast[uint8](97) and c <= cast[uint8](122): # a-z
    return 1
  if c == cast[uint8](45):  # hyphen
    return 1
  if c == cast[uint8](39):  # apostrophe
    return 1
  return 0

# Print word with context
def print_word_with_context(word: *uint8, word_len: int32, line: *uint8, line_len: int32):
  # Print word (left-aligned, 20 chars)
  _ = syscall3(SYS_write, STDOUT, cast[int32](word), word_len)

  padding: int32 = 20 - word_len
  if padding < 0:
    padding = 0

  i: int32 = 0
  while i < padding:
    _ = syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
    i = i + 1

  # Print context (up to 60 chars)
  context_len: int32 = line_len
  if context_len > 60:
    context_len = 60

  _ = syscall3(SYS_write, STDOUT, cast[int32](line), context_len)
  _ = syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

# Extract words from line and print with context
def process_line(line: *uint8, line_len: int32):
  i: int32 = 0
  word_start: int32 = -1
  word_len: int32 = 0

  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 256
  _ = syscall1(SYS_brk, new_brk)
  word_buf: *uint8 = cast[*uint8](old_brk)

  while i <= line_len:
    c: uint8 = cast[uint8](0)
    if i < line_len:
      c = line[i]

    if is_word_char(c) != 0:
      if word_start < 0:
        word_start = i
        word_len = 0

      if word_len < 255:
        word_buf[word_len] = c
        word_len = word_len + 1
    else:
      # End of word
      if word_start >= 0:
        # Ignore very short words (1 or 2 chars)
        if word_len >= 3:
          word_buf[word_len] = cast[uint8](0)
          print_word_with_context(word_buf, word_len, line, line_len)

        word_start = -1
        word_len = 0

    i = i + 1

def main():
  argc: int32 = get_argc()
  fd: int32 = STDIN
  filename: *uint8 = cast[*uint8](0)

  # Parse arguments
  i: int32 = 1
  while i < argc:
    arg: *uint8 = get_argv(i)
    filename = arg
    i = i + 1

  # Open file if provided
  if filename != cast[*uint8](0):
    fd = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
    if fd < 0:
      print_err(cast[*uint8]("ptx: cannot open file\n"))
      _ = syscall1(SYS_exit, 1)

  # Allocate buffers
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  _ = syscall1(SYS_brk, new_brk)
  buffer: *uint8 = cast[*uint8](old_brk)
  line_buf: *uint8 = cast[*uint8](old_brk + 4096)

  line_pos: int32 = 0

  running: int32 = 1
  while running != 0:
    n: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
    if n <= 0:
      # Process last line if any
      if line_pos > 0:
        line_buf[line_pos] = cast[uint8](0)
        process_line(line_buf, line_pos)

      running = 0
      break

    j: int32 = 0
    while j < n:
      c: uint8 = buffer[j]

      if c == cast[uint8](10):  # newline
        # Process complete line
        line_buf[line_pos] = cast[uint8](0)
        process_line(line_buf, line_pos)
        line_pos = 0
      else:
        # Add to line buffer
        if line_pos < 4095:
          line_buf[line_pos] = c
          line_pos = line_pos + 1

      j = j + 1

  if fd != STDIN:
    _ = syscall1(SYS_close, fd)

  _ = syscall1(SYS_exit, 0)
