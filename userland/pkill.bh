# pkill - Kill processes by name
# Usage: pkill PATTERN
#        pkill -9 PATTERN (with signal)
# Combines pgrep + kill functionality

import "lib/syscalls"

const SIGTERM: int32 = 15
const SIGKILL: int32 = 9
const SIGHUP: int32 = 1
const SIGINT: int32 = 2

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if string is all digits
proc is_numeric(s: ptr uint8): int32 =
  var i: int32 = 0
  if s[0] == cast[uint8](0):
    return 0
  while s[i] != cast[uint8](0):
    if s[i] < cast[uint8](48):  # '0'
      return 0
    if s[i] > cast[uint8](57):  # '9'
      return 0
    i = i + 1
  return 1

# Parse integer from string
proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  # Skip leading whitespace
  while s[i] == cast[uint8](32):
    i = i + 1
  # Handle negative
  var neg: int32 = 0
  if s[i] == cast[uint8](45):  # '-'
    neg = 1
    i = i + 1
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  if neg == 1:
    result = 0 - result
  return result

# Print integer
# Simple substring search
proc contains(haystack: ptr uint8, needle: ptr uint8): int32 =
  var haystack_len: int32 = strlen(haystack)
  var needle_len: int32 = strlen(needle)

  if needle_len == 0:
    return 1

  if needle_len > haystack_len:
    return 0

  var i: int32 = 0
  while i <= haystack_len - needle_len:
    var j: int32 = 0
    var matched: int32 = 1
    while j < needle_len:
      if haystack[i + j] != needle[j]:
        matched = 0
        break
      j = j + 1
    if matched == 1:
      return 1
    i = i + 1

  return 0

# Build path: /proc/PID/comm
proc build_comm_path(path: ptr uint8, pid_str: ptr uint8) =
  path[0] = cast[uint8](47)   # /
  path[1] = cast[uint8](112)  # p
  path[2] = cast[uint8](114)  # r
  path[3] = cast[uint8](111)  # o
  path[4] = cast[uint8](99)   # c
  path[5] = cast[uint8](47)   # /
  var pos: int32 = 6
  # Copy PID
  var i: int32 = 0
  while pid_str[i] != cast[uint8](0):
    path[pos] = pid_str[i]
    pos = pos + 1
    i = i + 1
  # /comm
  path[pos] = cast[uint8](47)      # /
  path[pos + 1] = cast[uint8](99)  # c
  path[pos + 2] = cast[uint8](111) # o
  path[pos + 3] = cast[uint8](109) # m
  path[pos + 4] = cast[uint8](109) # m
  path[pos + 5] = cast[uint8](0)

proc main() =
  # Allocate memory
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 40960
  discard syscall1(SYS_brk, new_brk)

  # Memory layout:
  # +0: dent buffer (8KB)
  # +8192: comm buffer (256 bytes)
  # +8448: path buffer (256 bytes)
  # +8704: search pattern buffer (256 bytes)
  # +8960: PID list (1024 PIDs * 4 bytes = 4KB)
  var dent_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var comm_buf: ptr uint8 = cast[ptr uint8](old_brk + 8192)
  var path_buf: ptr uint8 = cast[ptr uint8](old_brk + 8448)
  var pattern: ptr uint8 = cast[ptr uint8](old_brk + 8704)
  var pid_list: ptr int32 = cast[ptr int32](old_brk + 8960)

  # Default: SIGTERM
  var signal: int32 = SIGTERM

  # For demonstration, kill pattern "sleep"
  # In a real implementation, this would come from argv
  # To support -9 flag, we'd check argv[1] for "-9" or "-SIGKILL"
  pattern[0] = cast[uint8](115)  # s
  pattern[1] = cast[uint8](108)  # l
  pattern[2] = cast[uint8](101)  # e
  pattern[3] = cast[uint8](101)  # e
  pattern[4] = cast[uint8](112)  # p
  pattern[5] = cast[uint8](0)

  # Open /proc
  path_buf[0] = cast[uint8](47)   # /
  path_buf[1] = cast[uint8](112)  # p
  path_buf[2] = cast[uint8](114)  # r
  path_buf[3] = cast[uint8](111)  # o
  path_buf[4] = cast[uint8](99)   # c
  path_buf[5] = cast[uint8](0)

  var proc_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY | O_DIRECTORY, 0)
  if proc_fd < 0:
    print_err(cast[ptr uint8]("pkill: cannot open /proc\n"))
    discard syscall1(SYS_exit, 1)

  var found_count: int32 = 0

  # Read /proc directory and collect matching PIDs
  var nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  while nread > 0:
    var pos: int32 = 0
    while pos < nread:
      # Parse dirent64
      var reclen_ptr: ptr uint16 = cast[ptr uint16](cast[int32](dent_buf) + pos + 16)
      var reclen: int32 = cast[int32](reclen_ptr[0])
      var d_name: ptr uint8 = cast[ptr uint8](cast[int32](dent_buf) + pos + 19)

      # Check if this is a PID directory (all numeric)
      if is_numeric(d_name) == 1:
        # Build path to /proc/PID/comm
        build_comm_path(path_buf, d_name)

        # Open and read comm file
        var comm_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
        if comm_fd >= 0:
          var comm_len: int32 = syscall3(SYS_read, comm_fd, cast[int32](comm_buf), 255)
          discard syscall1(SYS_close, comm_fd)

          if comm_len > 0:
            # Remove trailing newline
            if comm_buf[comm_len - 1] == cast[uint8](10):
              comm_len = comm_len - 1
            comm_buf[comm_len] = cast[uint8](0)

            # Check if comm contains pattern
            if contains(comm_buf, pattern) == 1:
              # Found a matched - store PID
              var pid: int32 = parse_int(d_name)
              if found_count < 1024:
                pid_list[found_count] = pid
                found_count = found_count + 1

      pos = pos + reclen

    nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  discard syscall1(SYS_close, proc_fd)

  # Check if any processes were found
  if found_count == 0:
    print_err(cast[ptr uint8]("pkill: no process found\n"))
    discard syscall1(SYS_exit, 1)

  # Kill all found processes
  var killed: int32 = 0
  var i: int32 = 0
  while i < found_count:
    var pid: int32 = pid_list[i]
    var result: int32 = syscall2(SYS_kill, pid, signal)

    if result == 0:
      killed = killed + 1

    i = i + 1

  # Report results
  if killed > 0:
    print_err(cast[ptr uint8]("pkill: killed "))
    print_int(killed)
    print_err(cast[ptr uint8](" process(es)\n"))
    discard syscall1(SYS_exit, 0)

  print_err(cast[ptr uint8]("pkill: failed to kill any processes\n"))
  discard syscall1(SYS_exit, 1)
