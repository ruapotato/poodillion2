# bsh - Brainhair Shell (brainshell)
# The shell for BrainhairOS - understands structured data and schemas!

import "lib/syscalls"

# Terminal control
const TCGETS: int32 = 0x5401
const TCSETS: int32 = 0x5402
const TCSETSW: int32 = 0x5403

# termios c_lflag bits
const ECHO_FLAG: int32 = 8       # 0x08 - echo input characters
const ICANON_FLAG: int32 = 2     # 0x02 - canonical mode (line-by-line)

# Global termios storage (36 bytes each for 32-bit Linux)
var g_orig_termios: ptr uint8    # Original terminal settings
var g_raw_termios: ptr uint8     # Raw mode settings

# Global state for shell (allocated in main)
var g_cwd_buf: ptr uint8
var g_prev_dir: ptr uint8
var g_home_dir: ptr uint8
var g_history: ptr int32  # Array of string pointers
var g_history_count: int32 = 0
var g_history_storage: ptr uint8  # Buffer for history strings

# Print utilities
proc print_err(msg: ptr uint8) =
  var i: int32 = 0
  while msg[i] != cast[uint8](0):
    i = i + 1
  discard syscall3(SYS_write, STDERR, cast[int32](msg), i)

# Print number
proc print_num(n: int32) =
  if n == 0:
    discard syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
    return

  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 32
  discard syscall1(SYS_brk, new_brk)
  var buf: ptr uint8 = cast[ptr uint8](old_brk)

  var temp: int32 = n
  var count: int32 = 0
  while temp > 0:
    var digit: int32 = temp % 10
    buf[count] = cast[uint8](48 + digit)
    count = count + 1
    temp = temp / 10

  var i: int32 = count - 1
  while i >= 0:
    discard syscall3(SYS_write, STDOUT, cast[int32](addr(buf[i])), 1)
    i = i - 1

# String utilities
# Concatenate two strings
# Copy n bytes from src to dest
# Save current terminal settings
proc save_termios() =
  discard syscall3(SYS_ioctl, STDIN, TCGETS, cast[int32](g_orig_termios))
  # Copy to raw termios
  memcpy(g_raw_termios, g_orig_termios, 36)

# Set terminal to raw mode (disable ECHO and ICANON)
proc set_raw_mode() =
  # c_lflag is at offset 12 in termios struct (4 bytes)
  var lflag_ptr: ptr int32 = cast[ptr int32](cast[int32](g_raw_termios) + 12)
  var lflag: int32 = lflag_ptr[0]
  # Clear ECHO and ICANON bits
  lflag = lflag & (0 - 1 - ECHO_FLAG - ICANON_FLAG)
  lflag_ptr[0] = lflag
  discard syscall3(SYS_ioctl, STDIN, TCSETS, cast[int32](g_raw_termios))

# Restore original terminal settings
proc restore_termios() =
  discard syscall3(SYS_ioctl, STDIN, TCSETS, cast[int32](g_orig_termios))

# Check if file exists and is executable (simplified)
proc file_exists(path: ptr uint8): int32 =
  var result: int32 = syscall2(SYS_access, cast[int32](path), 0)  # F_OK = 0
  if result == 0:
    return 1
  return 0

# Try to find command in PATH directories
# Returns pointer to resolved path in path_buf, or original cmd if not found
proc resolve_path(cmd: ptr uint8, path_buf: ptr uint8): ptr uint8 =
  # If command starts with / or ./, use as-is
  if cmd[0] == cast[uint8](47):  # '/'
    strcpy(path_buf, cmd)
    return path_buf
  if cmd[0] == cast[uint8](46):  # '.'
    strcpy(path_buf, cmd)
    return path_buf

  # Try ./bin/
  strcpy(path_buf, cast[ptr uint8]("./bin/"))
  strcat(path_buf, cmd)
  if file_exists(path_buf) != 0:
    return path_buf

  # Try /bin/
  strcpy(path_buf, cast[ptr uint8]("/bin/"))
  strcat(path_buf, cmd)
  if file_exists(path_buf) != 0:
    return path_buf

  # Try /usr/bin/
  strcpy(path_buf, cast[ptr uint8]("/usr/bin/"))
  strcat(path_buf, cmd)
  if file_exists(path_buf) != 0:
    return path_buf

  # Not found, return original with ./ prefix if needed
  if cmd[0] == cast[uint8](47):  # starts with '/'
    strcpy(path_buf, cmd)
  else:
    strcpy(path_buf, cast[ptr uint8]("./"))
    strcat(path_buf, cmd)
  return path_buf

# Get current working directory
# Returns length of path on success, -1 on error
proc get_cwd(buf: ptr uint8, size: int32): int32 =
  var result: int32 = syscall2(SYS_getcwd, cast[int32](buf), size)
  if result < 0:
    return -1
  return strlen(buf)

# Built-in: pwd - Print working directory
# Uses g_cwd_buf for temp storage
proc builtin_pwd(): int32 =
  var len: int32 = get_cwd(g_cwd_buf, 512)
  if len < 0:
    print_err(cast[ptr uint8]("pwd: error getting current directory\n"))
    return 1

  println(g_cwd_buf)
  return 0

# Built-in: cd - Change directory
proc builtin_cd(arg: ptr uint8): int32 =
  var target: ptr uint8

  # Handle different cd arguments
  if arg == cast[ptr uint8](0):
    # cd with no args - go to home
    target = g_home_dir
  else:
    # cd path - go to specified path
    target = arg

  var result: int32 = syscall1(SYS_chdir, cast[int32](target))
  if result != 0:
    print_err(cast[ptr uint8]("cd: "))
    print_err(target)
    print_err(cast[ptr uint8](": No such file or directory\n"))
    return 1

  return 0

# Built-in: env - Display environment variables
proc builtin_env(): int32 =
  # Read /proc/self/environ
  var fd: int32 = syscall3(SYS_open, cast[int32]("/proc/self/environ"), 0, 0)  # O_RDONLY
  if fd < 0:
    print_err(cast[ptr uint8]("env: cannot open /proc/self/environ\n"))
    return 1

  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192
  discard syscall1(SYS_brk, new_brk)
  var buf: ptr uint8 = cast[ptr uint8](old_brk)

  var n: int32 = syscall3(SYS_read, fd, cast[int32](buf), 8000)
  discard syscall1(SYS_close, fd)

  if n <= 0:
    print_err(cast[ptr uint8]("env: error reading environment\n"))
    return 1

  # Environment variables are null-separated, print each one
  var i: int32 = 0
  while i < n:
    if buf[i] == cast[uint8](0):
      discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      i = i + 1
    else:
      var start: int32 = i
      while i < n:
        if buf[i] == cast[uint8](0):
          break
        i = i + 1
      discard syscall3(SYS_write, STDOUT, cast[int32](buf) + start, i - start)

  return 0

# Built-in: history - Display command history
proc builtin_history(): int32 =
  var i: int32 = 0
  while i < g_history_count:
    # Print command (without line numbers to avoid brk issues)
    var cmd_ptr: ptr uint8 = cast[ptr uint8](g_history[i])
    println(cmd_ptr)
    i = i + 1
  return 0

# Global for script execution (to avoid recursion issues)
var g_script_buf: ptr uint8
var g_script_line: ptr uint8
var g_in_script: int32 = 0

# Built-in: source - Execute a brainscript file
# Note: For simplicity, scripts execute commands directly (no nested builtins)
proc builtin_source(filename: ptr uint8): int32 =
  if filename == cast[ptr uint8](0):
    print_err(cast[ptr uint8]("source: missing filename\n"))
    return 1

  # Open script file
  var fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
  if fd < 0:
    print_err(cast[ptr uint8]("source: cannot open "))
    print_err(filename)
    print_err(cast[ptr uint8]("\n"))
    return 1

  # Allocate buffer for script (use brk)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 65536  # 64KB for script
  discard syscall1(SYS_brk, new_brk)
  var script_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var line_buf: ptr uint8 = cast[ptr uint8](old_brk + 32768)

  # Read entire script
  var total: int32 = 0
  var n: int32 = syscall3(SYS_read, fd, cast[int32](script_buf), 32000)
  while n > 0:
    total = total + n
    if total >= 32000:
      break
    n = syscall3(SYS_read, fd, cast[int32](script_buf) + total, 32000 - total)
  discard syscall1(SYS_close, fd)
  script_buf[total] = cast[uint8](0)

  # Execute line by line
  var pos: int32 = 0
  while pos < total:
    # Skip leading whitespace
    while pos < total:
      if script_buf[pos] != cast[uint8](32) and script_buf[pos] != cast[uint8](9):
        break
      pos = pos + 1

    # Skip comments
    if script_buf[pos] == cast[uint8](35):  # '#'
      while pos < total and script_buf[pos] != cast[uint8](10):
        pos = pos + 1
      pos = pos + 1
      continue

    # Skip empty lines
    if script_buf[pos] == cast[uint8](10):
      pos = pos + 1
      continue

    # Copy line to line buffer
    var line_len: int32 = 0
    while pos < total and script_buf[pos] != cast[uint8](10):
      line_buf[line_len] = script_buf[pos]
      line_len = line_len + 1
      pos = pos + 1
    line_buf[line_len] = cast[uint8](0)
    pos = pos + 1  # Skip newline

    # Execute line if not empty
    if line_len > 0:
      # Check for builtins inline (to avoid circular dependency)
      var cmd_end: int32 = 0
      while line_buf[cmd_end] != cast[uint8](0) and line_buf[cmd_end] != cast[uint8](32):
        cmd_end = cmd_end + 1

      # Check pwd
      if cmd_end == 3 and line_buf[0] == cast[uint8](112) and line_buf[1] == cast[uint8](119) and line_buf[2] == cast[uint8](100):
        discard builtin_pwd()
      # Check cd
      else:
        if cmd_end == 2 and line_buf[0] == cast[uint8](99) and line_buf[1] == cast[uint8](100):
          # Get arg after "cd "
          var arg_start: int32 = 2
          while line_buf[arg_start] == cast[uint8](32):
            arg_start = arg_start + 1
          if line_buf[arg_start] == cast[uint8](0):
            discard builtin_cd(cast[ptr uint8](0))
          else:
            discard builtin_cd(cast[ptr uint8](cast[int32](line_buf) + arg_start))
        # Check env
        else:
          if cmd_end == 3 and line_buf[0] == cast[uint8](101) and line_buf[1] == cast[uint8](110) and line_buf[2] == cast[uint8](118):
            discard builtin_env()
          # Check echo (print text)
          else:
            if cmd_end == 4 and line_buf[0] == cast[uint8](101) and line_buf[1] == cast[uint8](99) and line_buf[2] == cast[uint8](104) and line_buf[3] == cast[uint8](111):
              var arg_start: int32 = 4
              while line_buf[arg_start] == cast[uint8](32):
                arg_start = arg_start + 1
              println(cast[ptr uint8](cast[int32](line_buf) + arg_start))
            # Not a builtin - execute as external command
            else:
              # Set in_script flag to prevent recursive source
              g_in_script = 1
              exec_pipeline(line_buf)
              g_in_script = 0

  return 0

# Add command to history
proc add_to_history(cmd: ptr uint8) =
  var cmd_len: int32 = strlen(cmd)
  if cmd_len == 0:
    return

  # Use a circular buffer approach to avoid shifting
  # For now, limit to 20 commands, then stop adding (simpler)
  if g_history_count < 20:
    # Calculate storage offset for this command
    var storage_offset: int32 = g_history_count * 256
    var dest: ptr uint8 = cast[ptr uint8](cast[int32](g_history_storage) + storage_offset)

    # Copy command to storage
    strcpy(dest, cmd)

    # Store pointer in history array
    g_history[g_history_count] = cast[int32](dest)
    g_history_count = g_history_count + 1

# Check if command is a built-in and execute it
# Returns 1 if it was a built-in, 0 if not, -1 on error
# cmd_buf should be pre-allocated by caller
proc try_builtin_impl(trimmed: ptr uint8, cmd_buf: ptr uint8): int32 =
  var i: int32 = 0
  while trimmed[i] != cast[uint8](0):
    if trimmed[i] == cast[uint8](32):  # space
      break
    cmd_buf[i] = trimmed[i]
    i = i + 1
  cmd_buf[i] = cast[uint8](0)

  # Find argument (skip spaces)
  while trimmed[i] == cast[uint8](32):
    i = i + 1
  var arg: ptr uint8
  if trimmed[i] == cast[uint8](0):
    arg = cast[ptr uint8](0)
  else:
    arg = cast[ptr uint8](cast[int32](trimmed) + i)

  # Check for built-ins
  if strcmp(cmd_buf, cast[ptr uint8]("pwd")) == 0:
    discard builtin_pwd()
    return 1

  if strcmp(cmd_buf, cast[ptr uint8]("cd")) == 0:
    discard builtin_cd(arg)
    return 1

  if strcmp(cmd_buf, cast[ptr uint8]("env")) == 0:
    discard builtin_env()
    return 1

  if strcmp(cmd_buf, cast[ptr uint8]("history")) == 0:
    discard builtin_history()
    return 1

  if strcmp(cmd_buf, cast[ptr uint8]("source")) == 0:
    discard builtin_source(arg)
    return 1

  # Also support "." as alias for source
  if strcmp(cmd_buf, cast[ptr uint8](".")) == 0:
    discard builtin_source(arg)
    return 1

  return 0

# Display PSCH schema as a pretty table
proc display_schema(buffer: ptr uint8) =
  print(cast[ptr uint8]("\n┌─── Schema ───────────────────────┐\n"))
  print(cast[ptr uint8]("│ Magic:   "))
  var i: int32 = 0
  while i < 4:
    discard syscall3(SYS_write, STDOUT, cast[int32](buffer + i), 1)
    i = i + 1

  print(cast[ptr uint8]("                     │\n│ Version: "))
  print_num(cast[int32](buffer[4]))

  print(cast[ptr uint8]("                        │\n│ Fields:  "))
  print_num(cast[int32](buffer[5]))

  print(cast[ptr uint8]("                        │\n│ RecSize: "))
  var rec_size_ptr: ptr uint16 = cast[ptr uint16](buffer + 6)
  print_num(cast[int32](rec_size_ptr[0]))
  print(cast[ptr uint8](" bytes                 │\n└──────────────────────────────────┘\n"))

# Display binary data as hex table
proc display_records(buffer: ptr uint8, rec_count: int32, rec_size: int32) =
  print(cast[ptr uint8]("\n┌─── Data ("))
  print_num(rec_count)
  print(cast[ptr uint8](" records) ───────────────┐\n"))

  var rec_idx: int32 = 0
  while rec_idx < rec_count:
    print(cast[ptr uint8]("│ ["))
    print_num(rec_idx)
    print(cast[ptr uint8]("] "))

    # Print first 12 bytes or rec_size, whichever is smaller
    var bytes_to_show: int32 = 12
    if rec_size < bytes_to_show:
      bytes_to_show = rec_size

    var byte_idx: int32 = 0
    while byte_idx < bytes_to_show:
      var byte_val: uint8 = buffer[12 + rec_idx * rec_size + byte_idx]
      var upper: uint8 = byte_val >> 4
      var lower: uint8 = byte_val & cast[uint8](15)

      var hex_upper: uint8 = cast[uint8](48 + cast[int32](upper))
      if upper > cast[uint8](9):
        hex_upper = cast[uint8](97 + cast[int32](upper) - 10)

      var hex_lower: uint8 = cast[uint8](48 + cast[int32](lower))
      if lower > cast[uint8](9):
        hex_lower = cast[uint8](97 + cast[int32](lower) - 10)

      discard syscall3(SYS_write, STDOUT, cast[int32](addr(hex_upper)), 1)
      discard syscall3(SYS_write, STDOUT, cast[int32](addr(hex_lower)), 1)
      discard syscall3(SYS_write, STDOUT, cast[int32](" "), 1)

      byte_idx = byte_idx + 1

    if rec_size > bytes_to_show:
      print(cast[ptr uint8]("..."))

    print(cast[ptr uint8](" │\n"))
    rec_idx = rec_idx + 1

  print(cast[ptr uint8]("└──────────────────────────────────┘\n"))

# Trim leading whitespace from a string, return pointer to first non-space
proc trim_start(s: ptr uint8): ptr uint8 =
  var i: int32 = 0
  while s[i] == cast[uint8](32):  # space
    i = i + 1
  return cast[ptr uint8](cast[int32](s) + i)

# Trim trailing whitespace from a string (modifies in place)
proc trim_end(s: ptr uint8) =
  var len: int32 = strlen(s)
  while len > 0:
    if s[len - 1] == cast[uint8](32):  # space
      s[len - 1] = cast[uint8](0)
      len = len - 1
    else:
      return

# Find the position of '|' in string, return -1 if not found
proc find_pipe(s: ptr uint8): int32 =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    if s[i] == cast[uint8](124):  # '|'
      return i
    i = i + 1
  return -1

# Count number of commands in pipeline (number of '|' + 1)
proc count_commands(s: ptr uint8): int32 =
  var count: int32 = 1
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    if s[i] == cast[uint8](124):  # '|'
      count = count + 1
    i = i + 1
  return count

# Check if path needs ./ prefix (not absolute and not already ./)
proc needs_dot_slash(s: ptr uint8): int32 =
  if s[0] == cast[uint8](47):  # starts with '/'
    return 0
  if s[0] == cast[uint8](46):  # starts with '.'
    return 0
  return 1

# Prepend ./ to a path if needed, returns new pointer (uses dest buffer)
proc make_exec_path(src: ptr uint8, dest: ptr uint8): ptr uint8 =
  if needs_dot_slash(src) == 0:
    # Just copy as-is
    strcpy(dest, src)
    return dest
  # Prepend ./
  dest[0] = cast[uint8](46)  # '.'
  dest[1] = cast[uint8](47)  # '/'
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dest[i + 2] = src[i]
    i = i + 1
  dest[i + 2] = cast[uint8](0)
  return dest

# Parse command string into argv array
# Returns number of arguments
# cmd_str: "bin/where 0 > 1000" -> argv = ["./bin/where", "0", ">", "1000", NULL]
# arg_buf: buffer for copying argument strings
# argv: pointer array for argument pointers (must have room for up to 16 args)
proc parse_args(cmd_str: ptr uint8, arg_buf: ptr uint8, argv: ptr int32): int32 =
  var argc: int32 = 0
  var src_pos: int32 = 0
  var dst_pos: int32 = 0

  # Skip leading whitespace
  while cmd_str[src_pos] == cast[uint8](32):
    src_pos = src_pos + 1

  while cmd_str[src_pos] != cast[uint8](0):
    # Start of argument
    var arg_start: int32 = dst_pos

    # Copy argument until space or end
    while cmd_str[src_pos] != cast[uint8](0):
      if cmd_str[src_pos] == cast[uint8](32):  # space
        break
      arg_buf[dst_pos] = cmd_str[src_pos]
      dst_pos = dst_pos + 1
      src_pos = src_pos + 1

    # Null-terminate this argument
    arg_buf[dst_pos] = cast[uint8](0)
    dst_pos = dst_pos + 1

    # Store pointer in argv
    argv[argc] = cast[int32](arg_buf) + arg_start
    argc = argc + 1

    # Skip whitespace between arguments
    while cmd_str[src_pos] == cast[uint8](32):
      src_pos = src_pos + 1

    # Safety limit
    if argc >= 15:
      break

  # Null-terminate argv
  argv[argc] = 0
  return argc

# Execute a pipeline of commands: cmd1 | cmd2 | cmd3 | ...
proc exec_pipeline(input: ptr uint8) =
  # Allocate working memory
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 32768
  discard syscall1(SYS_brk, new_brk)

  # Memory layout:
  # old_brk + 0:     output buffer (8KB)
  # old_brk + 8192:  command strings storage (8KB)
  # old_brk + 16384: pipe fd array (256 bytes)
  # old_brk + 16640: pid array (256 bytes)
  # old_brk + 16896: cmd_ptrs array (256 bytes)
  # old_brk + 17152: argv arrays (2KB for 8 cmds * 16 args * 4 bytes)
  # old_brk + 19200: arg string buffers (8KB for 8 cmds * 1KB each)
  # old_brk + 27392: path buffers (2KB for 8 cmds * 256 each)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var cmd_storage: ptr uint8 = cast[ptr uint8](old_brk + 8192)
  var pipe_fds: ptr int32 = cast[ptr int32](old_brk + 16384)
  var pids: ptr int32 = cast[ptr int32](old_brk + 16640)
  var cmd_ptrs: ptr int32 = cast[ptr int32](old_brk + 16896)
  var argv_base: ptr int32 = cast[ptr int32](old_brk + 17152)
  var arg_str_base: ptr uint8 = cast[ptr uint8](old_brk + 19200)
  var path_base: ptr uint8 = cast[ptr uint8](old_brk + 27392)

  # Parse pipeline: split by '|' and store command pointers
  var num_cmds: int32 = 0
  var src_pos: int32 = 0
  var dst_pos: int32 = 0
  var cmd_start: int32 = dst_pos

  # Copy input to storage while parsing
  while input[src_pos] != cast[uint8](0):
    if input[src_pos] == cast[uint8](124):  # '|'
      # End current command
      cmd_storage[dst_pos] = cast[uint8](0)
      dst_pos = dst_pos + 1

      # Trim and store command pointer
      var trimmed: ptr uint8 = trim_start(cast[ptr uint8](cast[int32](cmd_storage) + cmd_start))
      trim_end(trimmed)
      cmd_ptrs[num_cmds] = cast[int32](trimmed)
      num_cmds = num_cmds + 1

      # Skip whitespace after |
      src_pos = src_pos + 1
      while input[src_pos] == cast[uint8](32):
        src_pos = src_pos + 1

      cmd_start = dst_pos
    else:
      cmd_storage[dst_pos] = input[src_pos]
      dst_pos = dst_pos + 1
      src_pos = src_pos + 1

  # Don't forget the last command
  cmd_storage[dst_pos] = cast[uint8](0)
  var last_trimmed: ptr uint8 = trim_start(cast[ptr uint8](cast[int32](cmd_storage) + cmd_start))
  trim_end(last_trimmed)
  cmd_ptrs[num_cmds] = cast[int32](last_trimmed)
  num_cmds = num_cmds + 1

  # If only 1 command, no pipes between commands needed, but still pipe to parent
  # For N commands, we need N pipes total:
  # - N-1 pipes between commands
  # - 1 pipe from last command to parent (for PSCH detection)

  # Create all pipes: pipe_fds[i*2] = read, pipe_fds[i*2+1] = write
  var num_pipes: int32 = num_cmds  # N pipes for N commands
  var i: int32 = 0
  while i < num_pipes:
    var pipe_result: int32 = syscall1(SYS_pipe, cast[int32](addr(pipe_fds[i * 2])))
    if pipe_result != 0:
      print_err(cast[ptr uint8]("Error: pipe() failed\n"))
      return
    i = i + 1

  # Fork all children
  i = 0
  while i < num_cmds:
    var pid: int32 = syscall1(SYS_fork, 0)

    if pid == 0:
      # Child process

      # Set up stdin: if not first command, read from previous pipe
      if i > 0:
        discard syscall2(SYS_dup2, pipe_fds[(i - 1) * 2], STDIN)

      # Set up stdout: write to our pipe
      discard syscall2(SYS_dup2, pipe_fds[i * 2 + 1], STDOUT)

      # Close all pipe fds
      var j: int32 = 0
      while j < num_pipes * 2:
        discard syscall1(SYS_close, pipe_fds[j])
        j = j + 1

      # Parse arguments from command string
      var arg_buf: ptr uint8 = cast[ptr uint8](cast[int32](arg_str_base) + i * 1024)
      var argv: ptr int32 = cast[ptr int32](cast[int32](argv_base) + i * 64)  # 16 args * 4 bytes
      var argc: int32 = parse_args(cast[ptr uint8](cmd_ptrs[i]), arg_buf, argv)

      # Build exec path from first argument (use PATH resolution)
      var path_buf: ptr uint8 = cast[ptr uint8](cast[int32](path_base) + i * 256)
      var first_arg: ptr uint8 = cast[ptr uint8](argv[0])
      var exec_path: ptr uint8 = resolve_path(first_arg, path_buf)

      # Update argv[0] to use the exec path
      argv[0] = cast[int32](exec_path)

      # Exec!
      discard syscall3(SYS_execve, cast[int32](exec_path), cast[int32](argv), 0)

      # Exec failed
      print_err(cast[ptr uint8]("Error: exec failed: "))
      print_err(exec_path)
      print_err(cast[ptr uint8]("\n"))
      discard syscall1(SYS_exit, 1)

    # Parent: store pid
    pids[i] = pid
    i = i + 1

  # Parent: close all pipe ends except the read end of the last pipe
  i = 0
  while i < num_pipes:
    # Close write end of all pipes
    discard syscall1(SYS_close, pipe_fds[i * 2 + 1])
    # Close read end of all but the last pipe
    if i < num_pipes - 1:
      discard syscall1(SYS_close, pipe_fds[i * 2])
    i = i + 1

  # Read from the last pipe (final output)
  var final_read_fd: int32 = pipe_fds[(num_pipes - 1) * 2]

  # Read magic bytes to check if it's PSCH format
  var n: int32 = syscall3(SYS_read, final_read_fd, cast[int32](buffer), 4)

  if n == 4:
    # Check for "PSCH" magic
    if buffer[0] == cast[uint8](80):  # 'P'
      if buffer[1] == cast[uint8](83):  # 'S'
        if buffer[2] == cast[uint8](67):  # 'C'
          if buffer[3] == cast[uint8](72):  # 'H'
            # It's PSCH format! Read the rest of schema
            n = syscall3(SYS_read, final_read_fd, cast[int32](buffer + 4), 8)

            display_schema(buffer)

            var rec_size_ptr: ptr uint16 = cast[ptr uint16](buffer + 6)
            var rec_size: int32 = cast[int32](rec_size_ptr[0])
            var rec_count_ptr: ptr int32 = cast[ptr int32](buffer + 8)
            var rec_count: int32 = rec_count_ptr[0]

            var total_size: int32 = rec_count * rec_size
            if total_size > 8000:
              total_size = 8000
            n = syscall3(SYS_read, final_read_fd, cast[int32](buffer + 12), total_size)

            display_records(buffer, rec_count, rec_size)

            discard syscall1(SYS_close, final_read_fd)

            # Wait for all children
            i = 0
            while i < num_cmds:
              var status: int32 = 0
              discard syscall3(SYS_waitpid, pids[i], cast[int32](addr(status)), 0)
              i = i + 1
            return

  # Not PSCH format - pass through raw output
  if n > 0:
    discard syscall3(SYS_write, STDOUT, cast[int32](buffer), n)

  # Read and output remaining data
  n = syscall3(SYS_read, final_read_fd, cast[int32](buffer), 8000)
  while n > 0:
    discard syscall3(SYS_write, STDOUT, cast[int32](buffer), n)
    n = syscall3(SYS_read, final_read_fd, cast[int32](buffer), 8000)

  discard syscall1(SYS_close, final_read_fd)

  # Wait for all children
  i = 0
  while i < num_cmds:
    var status: int32 = 0
    discard syscall3(SYS_waitpid, pids[i], cast[int32](addr(status)), 0)
    i = i + 1

# Tab completion - find commands in /bin/ matching prefix
# Returns number of matches, stores matches in match_buf (space-separated)
proc find_completions(prefix: ptr uint8, prefix_len: int32, match_buf: ptr uint8, single_match: ptr uint8): int32 =
  var match_count: int32 = 0
  var match_pos: int32 = 0
  single_match[0] = cast[uint8](0)
  match_buf[0] = cast[uint8](0)

  # Allocate buffer for directory reading
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192
  discard syscall1(SYS_brk, new_brk)
  var dent_buf: ptr uint8 = cast[ptr uint8](old_brk)

  # Open /bin/
  var bin_path: ptr uint8 = cast[ptr uint8]("/bin")
  var fd: int32 = syscall3(SYS_open, cast[int32](bin_path), O_RDONLY | O_DIRECTORY, 0)
  if fd < 0:
    return 0

  var nread: int32 = syscall3(SYS_getdents64, fd, cast[int32](dent_buf), 8192)
  while nread > 0:
    var pos: int32 = 0
    while pos < nread:
      var reclen_ptr: ptr uint16 = cast[ptr uint16](cast[int32](dent_buf) + pos + 16)
      var reclen: int32 = cast[int32](reclen_ptr[0])
      var d_name: ptr uint8 = cast[ptr uint8](cast[int32](dent_buf) + pos + 19)

      # Check if name starts with prefix
      var matches: int32 = 1
      var i: int32 = 0
      while i < prefix_len:
        if d_name[i] != prefix[i]:
          matches = 0
          break
        if d_name[i] == cast[uint8](0):
          matches = 0
          break
        i = i + 1

      if matches != 0:
        # Found a match
        if match_count == 0:
          # First match - copy to single_match
          i = 0
          while d_name[i] != cast[uint8](0):
            single_match[i] = d_name[i]
            i = i + 1
          single_match[i] = cast[uint8](0)

        # Add to match_buf with space separator
        if match_pos > 0:
          match_buf[match_pos] = cast[uint8](32)  # space
          match_pos = match_pos + 1

        i = 0
        while d_name[i] != cast[uint8](0):
          match_buf[match_pos] = d_name[i]
          match_pos = match_pos + 1
          i = i + 1

        match_count = match_count + 1

      pos = pos + reclen
    nread = syscall3(SYS_getdents64, fd, cast[int32](dent_buf), 8192)

  discard syscall1(SYS_close, fd)
  match_buf[match_pos] = cast[uint8](0)
  return match_count

# Main REPL
proc main() =
  # Welcome banner
  print(cast[ptr uint8]("\n"))
  print(cast[ptr uint8]("╔════════════════════════════════════════════════╗\n"))
  print(cast[ptr uint8]("║  bsh - Brainshell - Type-Aware Data Shell    ║\n"))
  print(cast[ptr uint8]("║                                                ║\n"))
  print(cast[ptr uint8]("║  • Type-safe binary pipelines                 ║\n"))
  print(cast[ptr uint8]("║  • Automatic schema detection                 ║\n"))
  print(cast[ptr uint8]("║  • Pretty table formatting                    ║\n"))
  print(cast[ptr uint8]("║  • Tab completion for commands                ║\n"))
  print(cast[ptr uint8]("║                                                ║\n"))
  print(cast[ptr uint8]("║  Try: ps | ls -l                              ║\n"))
  print(cast[ptr uint8]("╚════════════════════════════════════════════════╝\n"))
  print(cast[ptr uint8]("\n"))

  # Allocate ALL memory upfront - never use brk again!
  var initial_brk: int32 = syscall1(SYS_brk, 0)
  var total_mem: int32 = initial_brk + 65536  # 64KB total
  discard syscall1(SYS_brk, total_mem)

  # Memory layout:
  # initial_brk + 0:     input buffer (1KB)
  # initial_brk + 1024:  g_cwd_buf (512 bytes)
  # initial_brk + 1536:  g_prev_dir (512 bytes)
  # initial_brk + 2048:  g_home_dir (512 bytes)
  # initial_brk + 2560:  g_history array (20 pointers * 4 = 80 bytes)
  # initial_brk + 2640:  g_history_storage (20 commands * 256 = 5120 bytes)
  # initial_brk + 7760:  prompt buffer (512 bytes)
  # initial_brk + 8272:  cmd_buf for parsing (256 bytes)
  # initial_brk + 8528:  orig_termios (64 bytes)
  # initial_brk + 8592:  raw_termios (64 bytes)
  # initial_brk + 8656:  reserved for future builtins (56KB)

  var input: ptr uint8 = cast[ptr uint8](initial_brk)
  g_cwd_buf = cast[ptr uint8](initial_brk + 1024)
  g_prev_dir = cast[ptr uint8](initial_brk + 1536)
  g_home_dir = cast[ptr uint8](initial_brk + 2048)
  g_history = cast[ptr int32](initial_brk + 2560)
  g_history_storage = cast[ptr uint8](initial_brk + 2640)
  var prompt_buf: ptr uint8 = cast[ptr uint8](initial_brk + 7760)
  var cmd_buf: ptr uint8 = cast[ptr uint8](initial_brk + 8272)
  g_orig_termios = cast[ptr uint8](initial_brk + 8528)
  g_raw_termios = cast[ptr uint8](initial_brk + 8592)

  # Save original terminal settings and set raw mode
  save_termios()
  set_raw_mode()

  # Save the brk limit - built-ins can use memory starting here
  var builtin_scratch: ptr uint8 = cast[ptr uint8](initial_brk + 8656)
  var pipeline_brk_start: int32 = initial_brk + 8656

  # Initialize previous directory to empty
  g_prev_dir[0] = cast[uint8](0)

  # Get HOME from environment (use /root as default)
  strcpy(g_home_dir, cast[ptr uint8]("/root"))

  # Try to read HOME from /proc/self/environ
  var env_fd: int32 = syscall3(SYS_open, cast[int32]("/proc/self/environ"), 0, 0)
  if env_fd >= 0:
    var env_buf_brk: int32 = syscall1(SYS_brk, 0)
    var env_buf_new: int32 = env_buf_brk + 4096
    discard syscall1(SYS_brk, env_buf_new)
    var env_buf: ptr uint8 = cast[ptr uint8](env_buf_brk)

    var env_n: int32 = syscall3(SYS_read, env_fd, cast[int32](env_buf), 4000)
    discard syscall1(SYS_close, env_fd)

    if env_n > 0:
      # Search for HOME= in environment
      var i: int32 = 0
      while i < env_n:
        # Check if this entry starts with "HOME="
        if i + 5 < env_n:
          if env_buf[i] == cast[uint8](72):      # 'H'
            if env_buf[i+1] == cast[uint8](79):  # 'O'
              if env_buf[i+2] == cast[uint8](77):  # 'M'
                if env_buf[i+3] == cast[uint8](69):  # 'E'
                  if env_buf[i+4] == cast[uint8](61):  # '='
                    # Found HOME=, copy the value
                    var j: int32 = 0
                    var k: int32 = i + 5
                    while k < env_n:
                      if env_buf[k] == cast[uint8](0):
                        break
                      g_home_dir[j] = env_buf[k]
                      j = j + 1
                      k = k + 1
                    g_home_dir[j] = cast[uint8](0)
        # Skip to next entry
        while i < env_n:
          if env_buf[i] == cast[uint8](0):
            i = i + 1
            break
          i = i + 1

  # REPL loop
  var running: int32 = 1
  while running != 0:
    # Build prompt with current directory (but keep it simple for now)
    print(cast[ptr uint8]("bsh> "))

    # Read command character by character until newline or EOF
    # Supports: tab completion, backspace
    var n: int32 = 0
    var c_buf: uint8 = cast[uint8](0)

    # Buffers for tab completion (reuse memory after prompt_buf)
    var match_buf: ptr uint8 = cast[ptr uint8](initial_brk + 9000)
    var single_match: ptr uint8 = cast[ptr uint8](initial_brk + 13000)

    while n < 1000:
      var r: int32 = syscall3(SYS_read, STDIN, cast[int32](addr(c_buf)), 1)
      if r <= 0:
        # EOF
        if n == 0:
          running = 0
        break
      if c_buf == cast[uint8](10):
        # Newline (LF) - end of line
        break
      if c_buf == cast[uint8](13):
        # Carriage return (CR) - end of line
        break

      if c_buf == cast[uint8](3):
        # Ctrl+C - cancel current line
        print(cast[ptr uint8]("^C\n"))
        n = 0  # Clear input
        break  # Go back to prompt

      if c_buf == cast[uint8](4):
        # Ctrl+D - EOF if line is empty
        if n == 0:
          print(cast[ptr uint8]("\n"))
          running = 0
          break

      if c_buf == cast[uint8](9):
        # Tab - do completion
        # Find word start (after last space or beginning)
        var word_start: int32 = n
        while word_start > 0:
          if input[word_start - 1] == cast[uint8](32):  # space
            break
          word_start = word_start - 1
        var word_len: int32 = n - word_start

        if word_len > 0:
          var prefix: ptr uint8 = cast[ptr uint8](cast[int32](input) + word_start)
          var matches: int32 = find_completions(prefix, word_len, match_buf, single_match)

          if matches == 1:
            # Single match - complete it
            var comp_len: int32 = strlen(single_match)
            # Erase current word from display
            var k: int32 = 0
            while k < word_len:
              discard syscall3(SYS_write, STDOUT, cast[int32]("\b \b"), 3)
              k = k + 1
            # Copy completion to input
            k = 0
            while k < comp_len:
              input[word_start + k] = single_match[k]
              k = k + 1
            n = word_start + comp_len
            # Print completed word
            discard syscall3(SYS_write, STDOUT, cast[int32](single_match), comp_len)
            # Add space after command
            input[n] = cast[uint8](32)
            n = n + 1
            discard syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
          else:
            if matches > 1:
              # Multiple matches - show them
              print(cast[ptr uint8]("\n"))
              print(match_buf)
              print(cast[ptr uint8]("\npsh> "))
              # Reprint current input
              input[n] = cast[uint8](0)
              print(input)
        discard 0  # Don't add tab to input
      else:
        if c_buf == cast[uint8](127):
          # Backspace (DEL)
          if n > 0:
            n = n - 1
            discard syscall3(SYS_write, STDOUT, cast[int32]("\b \b"), 3)
        else:
          # Regular character
          input[n] = c_buf
          n = n + 1
          # Echo character
          discard syscall3(SYS_write, STDOUT, cast[int32](addr(c_buf)), 1)

    input[n] = cast[uint8](0)
    print(cast[ptr uint8]("\n"))  # Newline after input

    if running != 0:

      # Check for empty input
      if n > 0:
        # Check for exit/quit
        if strcmp(input, cast[ptr uint8]("exit")) == 0:
          running = 0
        if strcmp(input, cast[ptr uint8]("quit")) == 0:
          running = 0

        # Execute command if not exiting
        if running != 0:
          # Add to history
          add_to_history(input)

          # Try built-in commands first
          var trimmed: ptr uint8 = trim_start(input)
          trim_end(trimmed)
          var is_builtin: int32 = try_builtin_impl(trimmed, cmd_buf)
          if is_builtin == 0:
            # Not a built-in, execute as pipeline
            exec_pipeline(input)

  # Restore terminal settings before exiting
  restore_termios()
  println(cast[ptr uint8]("Goodbye!"))
  discard syscall1(SYS_exit, 0)
