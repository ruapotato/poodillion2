# bhbuild - Brainhair Build Tool
# Compiles .bh files to native executables
#
# Usage: bhbuild <source.bh> [output]
#
# Pipeline:
#   1. python3 brainhair.py source.bh --asm-only > source.asm
#   2. nasm -f elf32 source.asm -o source.o
#   3. ld -m elf_i386 -o output source.o lib/syscalls.o

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(idx: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = 0
  while msg[len] != cast[uint8](0):
    len = len + 1
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Extract base name from path (remove directory and .bh extension)
def get_basename(path: *uint8, out: *uint8):
  len: int32 = strlen(path)

  # Find last /
  last_slash: int32 = -1
  i: int32 = 0
  while i < len:
    if path[i] == cast[uint8](47):  # '/'
      last_slash = i
    i = i + 1

  # Copy from after last slash
  start: int32 = last_slash + 1
  j: int32 = 0
  while path[start] != cast[uint8](0):
    # Stop at .bh
    if path[start] == cast[uint8](46):  # '.'
      if path[start + 1] == cast[uint8](98) and path[start + 2] == cast[uint8](104):  # 'bh'
        break
    out[j] = path[start]
    j = j + 1
    start = start + 1
  out[j] = cast[uint8](0)

# Run a command and wait for it to complete
def run_cmd(argv: *int32) -> int32:
  pid: int32 = syscall1(SYS_fork, 0)

  if pid == 0:
    # Child - exec the command
    envp: array[1, int32]
    envp[0] = 0
    _ = syscall3(SYS_execve, argv[0], cast[int32](argv), cast[int32](addr(envp)))
    # If exec fails
    print_err(cast[*uint8]("bhbuild: exec failed: "))
    print_err(cast[*uint8](argv[0]))
    print_err(cast[*uint8]("\n"))
    _ = syscall1(SYS_exit, 127)

  if pid < 0:
    print_err(cast[*uint8]("bhbuild: fork failed\n"))
    return 1

  # Parent - wait for child
  status: int32 = 0
  _ = syscall3(SYS_waitpid, pid, cast[int32](addr(status)), 0)

  # Extract exit code (bits 8-15)
  exit_code: int32 = (status >> 8) & 255
  return exit_code

# Run command with stdout redirected to a file
def run_cmd_stdout(argv: *int32, outfile: *uint8) -> int32:
  pid: int32 = syscall1(SYS_fork, 0)

  if pid == 0:
    # Child - redirect stdout and exec
    fd: int32 = syscall3(SYS_open, cast[int32](outfile), O_WRONLY | O_CREAT | O_TRUNC, 420)
    if fd < 0:
      print_err(cast[*uint8]("bhbuild: cannot create output file\n"))
      _ = syscall1(SYS_exit, 1)

    _ = syscall2(SYS_dup2, fd, STDOUT)
    _ = syscall1(SYS_close, fd)

    envp: array[1, int32]
    envp[0] = 0
    _ = syscall3(SYS_execve, argv[0], cast[int32](argv), cast[int32](addr(envp)))
    print_err(cast[*uint8]("bhbuild: exec failed\n"))
    _ = syscall1(SYS_exit, 127)

  if pid < 0:
    return 1

  status: int32 = 0
  _ = syscall3(SYS_waitpid, pid, cast[int32](addr(status)), 0)
  exit_code: int32 = (status >> 8) & 255
  return exit_code

def main() -> int32:
  argc: int32 = get_argc()

  println(cast[*uint8]("bhbuild - Brainhair Build Tool v1.0"))

  if argc < 2:
    println(cast[*uint8]("Usage: bhbuild <source.bh> [output]"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Compiles a Brainhair source file to a native executable."))
    return 1

  source: *uint8 = get_argv(1)

  # Allocate working memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  _ = syscall1(SYS_brk, new_brk)

  basename: *uint8 = cast[*uint8](old_brk)
  asm_file: *uint8 = cast[*uint8](old_brk + 256)
  obj_file: *uint8 = cast[*uint8](old_brk + 512)
  out_file: *uint8 = cast[*uint8](old_brk + 768)
  argv_buf: *int32 = cast[*int32](old_brk + 1024)
  str_buf: *uint8 = cast[*uint8](old_brk + 2048)

  # Get base name
  get_basename(source, basename)

  # Build file names
  strcpy(asm_file, cast[*uint8]("compiler/"))
  strcat(asm_file, basename)
  strcat(asm_file, cast[*uint8](".asm"))

  strcpy(obj_file, cast[*uint8]("compiler/"))
  strcat(obj_file, basename)
  strcat(obj_file, cast[*uint8](".o"))

  # Output file - use arg2 or default to bin/basename
  if argc >= 3:
    strcpy(out_file, get_argv(2))
  else:
    strcpy(out_file, cast[*uint8]("bin/"))
    strcat(out_file, basename)

  # Step 1: Run brainhair compiler
  print(cast[*uint8]("  [1/3] Compiling "))
  print(source)
  println(cast[*uint8]("..."))

  # argv: python3 compiler/brainhair.py source --asm-only
  p: int32 = 0
  strcpy(str_buf, cast[*uint8]("/usr/bin/python3"))
  argv_buf[0] = cast[int32](str_buf)
  p = p + 20
  strcpy(cast[*uint8](cast[int32](str_buf) + p), cast[*uint8]("compiler/brainhair.py"))
  argv_buf[1] = cast[int32](str_buf) + p
  p = p + 24
  strcpy(cast[*uint8](cast[int32](str_buf) + p), source)
  argv_buf[2] = cast[int32](str_buf) + p
  p = p + strlen(source) + 1
  strcpy(cast[*uint8](cast[int32](str_buf) + p), cast[*uint8]("--asm-only"))
  argv_buf[3] = cast[int32](str_buf) + p
  argv_buf[4] = 0

  result: int32 = run_cmd_stdout(argv_buf, asm_file)
  if result != 0:
    print_err(cast[*uint8]("bhbuild: compilation failed\n"))
    return 1

  # Step 2: Assemble with basm (native Brainhair assembler)
  print(cast[*uint8]("  [2/3] Assembling "))
  print(asm_file)
  println(cast[*uint8]("..."))

  # argv: bin/basm asm_file obj_file
  p = 0
  strcpy(str_buf, cast[*uint8]("bin/basm"))
  argv_buf[0] = cast[int32](str_buf)
  p = p + 12
  strcpy(cast[*uint8](cast[int32](str_buf) + p), asm_file)
  argv_buf[1] = cast[int32](str_buf) + p
  p = p + strlen(asm_file) + 1
  strcpy(cast[*uint8](cast[int32](str_buf) + p), obj_file)
  argv_buf[2] = cast[int32](str_buf) + p
  argv_buf[3] = 0

  result = run_cmd(argv_buf)
  if result != 0:
    print_err(cast[*uint8]("bhbuild: assembly failed\n"))
    return 1

  # Step 3: Link with bhlink (native Brainhair linker)
  print(cast[*uint8]("  [3/3] Linking "))
  print(out_file)
  println(cast[*uint8]("..."))

  # argv: bin/bhlink obj_file lib/syscalls.o -o out_file
  p = 0
  strcpy(str_buf, cast[*uint8]("bin/bhlink"))
  argv_buf[0] = cast[int32](str_buf)
  p = p + 12
  strcpy(cast[*uint8](cast[int32](str_buf) + p), obj_file)
  argv_buf[1] = cast[int32](str_buf) + p
  p = p + strlen(obj_file) + 1
  strcpy(cast[*uint8](cast[int32](str_buf) + p), cast[*uint8]("lib/syscalls.o"))
  argv_buf[2] = cast[int32](str_buf) + p
  p = p + 16
  strcpy(cast[*uint8](cast[int32](str_buf) + p), cast[*uint8]("-o"))
  argv_buf[3] = cast[int32](str_buf) + p
  p = p + 4
  strcpy(cast[*uint8](cast[int32](str_buf) + p), out_file)
  argv_buf[4] = cast[int32](str_buf) + p
  argv_buf[5] = 0

  result = run_cmd(argv_buf)
  if result != 0:
    print_err(cast[*uint8]("bhbuild: linking failed\n"))
    return 1

  println(cast[*uint8](""))
  print(cast[*uint8]("Build successful: "))
  println(out_file)

  return 0
