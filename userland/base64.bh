# base64.bh - Base64 encoding/decoding utility
# Usage: base64 [-d] [file]
#        base64 [-d] < input
#
# Options:
#   -d    Decode mode (default is encode)
#   -w N  Wrap output at N columns (default 76, 0 = no wrap)
#
# Examples:
#   base64 file.txt              Encode file
#   base64 -d encoded.txt        Decode file
#   echo "hello" | base64        Encode from stdin
#   echo "aGVsbG8K" | base64 -d  Decode from stdin

from lib.syscalls import *
from lib.base64 import *

# Options
opt_decode: int32 = 0
opt_wrap: int32 = 76
opt_file: Array[256, uint8]
opt_has_file: int32 = 0

# Buffers
INPUT_BUF_SIZE: int32 = 4096
OUTPUT_BUF_SIZE: int32 = 8192

def show_usage():
    println(cast[*uint8]("Usage: base64 [-d] [-w cols] [file]"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Base64 encode or decode FILE, or stdin."))
    println(cast[*uint8](""))
    println(cast[*uint8]("Options:"))
    println(cast[*uint8]("  -d         Decode data"))
    println(cast[*uint8]("  -w COLS    Wrap encoded lines at COLS (default 76, 0=no wrap)"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Examples:"))
    println(cast[*uint8]("  base64 file.txt"))
    println(cast[*uint8]("  base64 -d encoded.txt"))
    println(cast[*uint8]("  echo 'hello' | base64"))

def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    while s[i] >= 48 and s[i] <= 57:
        result = result * 10 + (cast[int32](s[i]) - 48)
        i = i + 1
    return result

def parse_args(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
    i: int32 = 1

    while i < argc:
        arg: *uint8 = argv[i]

        if arg[0] == 45:  # '-'
            if arg[1] == 100 and arg[2] == 0:  # -d
                opt_decode = 1
            elif arg[1] == 119 and arg[2] == 0:  # -w
                i = i + 1
                if i >= argc:
                    println(cast[*uint8]("base64: -w requires argument"))
                    return -1
                opt_wrap = parse_int(argv[i])
            elif arg[1] == 104 and arg[2] == 0:  # -h
                show_usage()
                return -2
            else:
                print(cast[*uint8]("base64: invalid option -- '"))
                print(arg)
                println(cast[*uint8]("'"))
                return -1
        else:
            # File argument
            j: int32 = 0
            while arg[j] != 0 and j < 255:
                opt_file[j] = arg[j]
                j = j + 1
            opt_file[j] = 0
            opt_has_file = 1

        i = i + 1

    return 0

# Write output with optional line wrapping
def write_wrapped(data: *uint8, len: int32):
    if opt_wrap <= 0:
        _ = write(STDOUT, data, len)
        return

    i: int32 = 0
    col: int32 = 0
    newline_char: uint8 = 10

    while i < len:
        _ = write(STDOUT, addr(data[i]), 1)
        col = col + 1
        if col >= opt_wrap:
            _ = write(STDOUT, addr(newline_char), 1)
            col = 0
        i = i + 1

    # Final newline if not already at start of line
    if col > 0:
        _ = write(STDOUT, addr(newline_char), 1)

def encode_stream(fd: int32):
    input: Array[4096, uint8]
    output: Array[8192, uint8]
    total_out: int32 = 0

    while 1:
        # Read up to 3072 bytes (multiple of 3 for clean encoding)
        n: int32 = read(fd, addr(input[0]), 3072)
        if n <= 0:
            break

        # Encode
        out_len: int32 = base64_encode(addr(input[0]), n, addr(output[0]))

        # Write with wrapping
        if opt_wrap <= 0:
            _ = write(STDOUT, addr(output[0]), out_len)
        else:
            i: int32 = 0
            while i < out_len:
                chunk: int32 = opt_wrap
                if i + chunk > out_len:
                    chunk = out_len - i
                _ = write(STDOUT, addr(output[i]), chunk)
                nl: uint8 = 10
                _ = write(STDOUT, addr(nl), 1)
                i = i + opt_wrap

    # Final newline if no wrapping
    if opt_wrap <= 0:
        nl: uint8 = 10
        _ = write(STDOUT, addr(nl), 1)

def decode_stream(fd: int32):
    input: Array[4096, uint8]
    clean_input: Array[4096, uint8]
    output: Array[4096, uint8]

    while 1:
        n: int32 = read(fd, addr(input[0]), 4096)
        if n <= 0:
            break

        # Remove whitespace from input
        clean_len: int32 = 0
        i: int32 = 0
        while i < n:
            c: uint8 = input[i]
            # Keep only base64 characters
            if (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or (c >= 48 and c <= 57) or c == 43 or c == 47 or c == 61:
                clean_input[clean_len] = c
                clean_len = clean_len + 1
            i = i + 1

        if clean_len > 0:
            out_len: int32 = base64_decode(addr(clean_input[0]), clean_len, addr(output[0]))
            if out_len < 0:
                println(cast[*uint8]("base64: invalid input"))
                return
            _ = write(STDOUT, addr(output[0]), out_len)

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
    result: int32 = parse_args(argc, argv)
    if result == -2:
        return 0
    if result < 0:
        return 1

    # Initialize base64 tables
    base64_init()

    # Open input
    fd: int32 = STDIN
    if opt_has_file != 0:
        fd = open(addr(opt_file[0]), O_RDONLY)
        if fd < 0:
            print(cast[*uint8]("base64: "))
            print(addr(opt_file[0]))
            println(cast[*uint8](": No such file"))
            return 1

    # Encode or decode
    if opt_decode != 0:
        decode_stream(fd)
    else:
        encode_stream(fd)

    # Close file
    if fd != STDIN:
        close(fd)

    return 0
