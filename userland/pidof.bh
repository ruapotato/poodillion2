# pidof - Find PID by process name
# Usage: pidof processname
# Scans /proc/*/comm files and matches process names

from lib.syscalls import *

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if string is all digits
def is_numeric(s: *uint8) -> int32:
  i: int32 = 0
  if s[0] == cast[uint8](0):
    return 0
  while s[i] != cast[uint8](0):
    if s[i] < cast[uint8](48):  # '0'
      return 0
    if s[i] > cast[uint8](57):  # '9'
      return 0
    i = i + 1
  return 1

# Compare two strings
# Copy string
# Build path: /proc/PID/comm
def build_comm_path(path: *uint8, pid_str: *uint8):
  path[0] = cast[uint8](47)   # /
  path[1] = cast[uint8](112)  # p
  path[2] = cast[uint8](114)  # r
  path[3] = cast[uint8](111)  # o
  path[4] = cast[uint8](99)   # c
  path[5] = cast[uint8](47)   # /
  pos: int32 = 6
  # Copy PID
  i: int32 = 0
  while pid_str[i] != cast[uint8](0):
    path[pos] = pid_str[i]
    pos = pos + 1
    i = i + 1
  # /comm
  path[pos] = cast[uint8](47)      # /
  path[pos + 1] = cast[uint8](99)  # c
  path[pos + 2] = cast[uint8](111) # o
  path[pos + 3] = cast[uint8](109) # m
  path[pos + 4] = cast[uint8](109) # m
  path[pos + 5] = cast[uint8](0)

# Print integer as string
# Parse integer from string
def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

def main():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 32768
  _ = syscall1(SYS_brk, new_brk)

  # Memory layout:
  # +0: dent buffer (8KB)
  # +8192: comm buffer (256 bytes)
  # +8448: path buffer (256 bytes)
  # +8704: search name buffer (256 bytes)
  dent_buf: *uint8 = cast[*uint8](old_brk)
  comm_buf: *uint8 = cast[*uint8](old_brk + 8192)
  path_buf: *uint8 = cast[*uint8](old_brk + 8448)
  search_name: *uint8 = cast[*uint8](old_brk + 8704)

  # For now, search for "init" as an example
  # In a real implementation, this would come from argv[1]
  search_name[0] = cast[uint8](105)  # i
  search_name[1] = cast[uint8](110)  # n
  search_name[2] = cast[uint8](105)  # i
  search_name[3] = cast[uint8](116)  # t
  search_name[4] = cast[uint8](0)

  print_err(cast[*uint8]("Searching for process: init\n"))

  # Open /proc
  path_buf[0] = cast[uint8](47)   # /
  path_buf[1] = cast[uint8](112)  # p
  path_buf[2] = cast[uint8](114)  # r
  path_buf[3] = cast[uint8](111)  # o
  path_buf[4] = cast[uint8](99)   # c
  path_buf[5] = cast[uint8](0)

  proc_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY | O_DIRECTORY, 0)
  if proc_fd < 0:
    print_err(cast[*uint8]("Error: cannot open /proc\n"))
    _ = syscall1(SYS_exit, 1)

  found_count: int32 = 0

  # Read /proc directory
  nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  while nread > 0:
    pos: int32 = 0
    while pos < nread:
      # Parse dirent64
      reclen_ptr: *uint16 = cast[*uint16](cast[int32](dent_buf) + pos + 16)
      reclen: int32 = cast[int32](reclen_ptr[0])
      d_name: *uint8 = cast[*uint8](cast[int32](dent_buf) + pos + 19)

      # Check if this is a PID directory (all numeric)
      if is_numeric(d_name) == 1:
        # Build path to /proc/PID/comm
        build_comm_path(path_buf, d_name)

        # Open and read comm file
        comm_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
        if comm_fd >= 0:
          comm_len: int32 = syscall3(SYS_read, comm_fd, cast[int32](comm_buf), 255)
          _ = syscall1(SYS_close, comm_fd)

          if comm_len > 0:
            # Remove trailing newline
            if comm_buf[comm_len - 1] == cast[uint8](10):
              comm_len = comm_len - 1
            comm_buf[comm_len] = cast[uint8](0)

            # Compare with search name
            if strcmp(comm_buf, search_name) == 0:
              # Found a match!
              pid: int32 = parse_int(d_name)
              if found_count > 0:
                _ = syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
              print_int(pid)
              found_count = found_count + 1

      pos = pos + reclen

    nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  _ = syscall1(SYS_close, proc_fd)

  if found_count > 0:
    _ = syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
    _ = syscall1(SYS_exit, 0)

  print_err(cast[*uint8]("No processes found\n"))
  _ = syscall1(SYS_exit, 1)
