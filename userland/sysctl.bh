# sysctl - Read and write kernel parameters
# Usage: sysctl -a (list all), sysctl NAME (read), sysctl NAME=VALUE (write)
# Part of BrainhairOS kernel utilities

from lib.syscalls import *

def print_error(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

def strchr(s: *uint8, ch: uint8) -> int32:
  i: int32 = 0
  while s[i] != cast[uint8](0):
    if s[i] == ch:
      return i
    i = i + 1
  return -1

def convert_path(name: *uint8, path: *uint8):
  # Convert sysctl name (e.g., "kernel.hostname") to path ("/proc/sys/kernel/hostname")
  base: *uint8 = cast[*uint8]("/proc/sys/")
  strcpy(path, base)

  offset: int32 = strlen(path)
  i: int32 = 0

  # Copy name, converting dots to slashes
  while name[i] != cast[uint8](0):
    if name[i] == cast[uint8](46):  # dot
      path[offset] = cast[uint8](47)  # slash
    else:
      path[offset] = name[i]
    offset = offset + 1
    i = i + 1

  path[offset] = cast[uint8](0)

def read_sysctl(name: *uint8, buffer: *uint8, bufsize: int32) -> int32:
  path: *uint8 = cast[*uint8](cast[int32](buffer) + bufsize)
  convert_path(name, path)

  fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return -1

  nread: int32 = syscall3(SYS_read, fd, cast[int32](buffer), bufsize)
  _ = syscall1(SYS_close, fd)

  # Remove trailing newline
  if nread > 0:
    if buffer[nread - 1] == cast[uint8](10):
      nread = nread - 1
    buffer[nread] = cast[uint8](0)

  return nread

def write_sysctl(name: *uint8, value: *uint8, path_buf: *uint8) -> int32:
  convert_path(name, path_buf)

  fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_WRONLY, 0)
  if fd < 0:
    return -1

  value_len: int32 = strlen(value)
  nwritten: int32 = syscall3(SYS_write, fd, cast[int32](value), value_len)
  _ = syscall1(SYS_close, fd)

  return nwritten

def main():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16384  # 16KB
  _ = syscall1(SYS_brk, new_brk)

  buffer: *uint8 = cast[*uint8](old_brk)
  path: *uint8 = cast[*uint8](old_brk + 4096)
  name: *uint8 = cast[*uint8](old_brk + 8192)
  value: *uint8 = cast[*uint8](old_brk + 12288)
  flag_a: *uint8 = cast[*uint8](old_brk + 14336)

  # Build -a flag
  flag_a[0] = cast[uint8](45)  # -
  flag_a[1] = cast[uint8](97)  # a
  flag_a[2] = cast[uint8](0)

  # For now, just read a single parameter
  # Full implementation would need argument parsing

  # Simple example: read kernel.hostname
  name[0] = cast[uint8](107)  # k
  name[1] = cast[uint8](101)  # e
  name[2] = cast[uint8](114)  # r
  name[3] = cast[uint8](110)  # n
  name[4] = cast[uint8](101)  # e
  name[5] = cast[uint8](108)  # l
  name[6] = cast[uint8](46)   # .
  name[7] = cast[uint8](104)  # h
  name[8] = cast[uint8](111)  # o
  name[9] = cast[uint8](115)  # s
  name[10] = cast[uint8](116) # t
  name[11] = cast[uint8](110) # n
  name[12] = cast[uint8](97)  # a
  name[13] = cast[uint8](109) # m
  name[14] = cast[uint8](101) # e
  name[15] = cast[uint8](0)

  nread: int32 = read_sysctl(name, buffer, 4096)

  if nread < 0:
    print_error(cast[*uint8]("sysctl: cannot read "))
    print_error(name)
    print_error(cast[*uint8]("\n"))
    _ = syscall1(SYS_exit, 1)

  # Print in sysctl format: name = value
  print(name)
  print(cast[*uint8](" = "))
  print(buffer)
  print(cast[*uint8]("\n"))

  _ = syscall1(SYS_exit, 0)
