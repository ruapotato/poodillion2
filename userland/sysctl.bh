# sysctl - Read and write kernel parameters
# Usage: sysctl -a (list all), sysctl NAME (read), sysctl NAME=VALUE (write)
# Part of BrainhairOS kernel utilities

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_getdents: int32 = 141

const STDIN: int32 = 0
const STDOUT: int32 = 1
const STDERR: int32 = 2
const O_RDONLY: int32 = 0
const O_WRONLY: int32 = 1
const O_RDWR: int32 = 2

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32

proc strlen(s: ptr uint8): int32 =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  return len

proc print(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDOUT, cast[int32](msg), len)

proc print_error(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

proc strcmp(s1: ptr uint8, s2: ptr uint8): int32 =
  var i: int32 = 0
  while s1[i] != cast[uint8](0):
    if s1[i] != s2[i]:
      return 1
    i = i + 1
  if s2[i] != cast[uint8](0):
    return 1
  return 0

proc strcpy(dst: ptr uint8, src: ptr uint8) =
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dst[i] = src[i]
    i = i + 1
  dst[i] = cast[uint8](0)

proc strcat(dst: ptr uint8, src: ptr uint8) =
  var dst_len: int32 = strlen(dst)
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dst[dst_len + i] = src[i]
    i = i + 1
  dst[dst_len + i] = cast[uint8](0)

proc strchr(s: ptr uint8, ch: uint8): int32 =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    if s[i] == ch:
      return i
    i = i + 1
  return -1

proc convert_path(name: ptr uint8, path: ptr uint8) =
  # Convert sysctl name (e.g., "kernel.hostname") to path ("/proc/sys/kernel/hostname")
  var base: ptr uint8 = cast[ptr uint8]("/proc/sys/")
  strcpy(path, base)

  var offset: int32 = strlen(path)
  var i: int32 = 0

  # Copy name, converting dots to slashes
  while name[i] != cast[uint8](0):
    if name[i] == cast[uint8](46):  # dot
      path[offset] = cast[uint8](47)  # slash
    else:
      path[offset] = name[i]
    offset = offset + 1
    i = i + 1

  path[offset] = cast[uint8](0)

proc read_sysctl(name: ptr uint8, buffer: ptr uint8, bufsize: int32): int32 =
  var path: ptr uint8 = cast[ptr uint8](cast[int32](buffer) + bufsize)
  convert_path(name, path)

  var fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return -1

  var nread: int32 = syscall3(SYS_read, fd, cast[int32](buffer), bufsize)
  discard syscall1(SYS_close, fd)

  # Remove trailing newline
  if nread > 0:
    if buffer[nread - 1] == cast[uint8](10):
      nread = nread - 1
    buffer[nread] = cast[uint8](0)

  return nread

proc write_sysctl(name: ptr uint8, value: ptr uint8, path_buf: ptr uint8): int32 =
  convert_path(name, path_buf)

  var fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_WRONLY, 0)
  if fd < 0:
    return -1

  var value_len: int32 = strlen(value)
  var nwritten: int32 = syscall3(SYS_write, fd, cast[int32](value), value_len)
  discard syscall1(SYS_close, fd)

  return nwritten

proc main() =
  # Allocate memory
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 16384  # 16KB
  discard syscall1(SYS_brk, new_brk)

  var buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var path: ptr uint8 = cast[ptr uint8](old_brk + 4096)
  var name: ptr uint8 = cast[ptr uint8](old_brk + 8192)
  var value: ptr uint8 = cast[ptr uint8](old_brk + 12288)
  var flag_a: ptr uint8 = cast[ptr uint8](old_brk + 14336)

  # Build -a flag
  flag_a[0] = cast[uint8](45)  # -
  flag_a[1] = cast[uint8](97)  # a
  flag_a[2] = cast[uint8](0)

  # For now, just read a single parameter
  # Full implementation would need argument parsing

  # Simple example: read kernel.hostname
  name[0] = cast[uint8](107)  # k
  name[1] = cast[uint8](101)  # e
  name[2] = cast[uint8](114)  # r
  name[3] = cast[uint8](110)  # n
  name[4] = cast[uint8](101)  # e
  name[5] = cast[uint8](108)  # l
  name[6] = cast[uint8](46)   # .
  name[7] = cast[uint8](104)  # h
  name[8] = cast[uint8](111)  # o
  name[9] = cast[uint8](115)  # s
  name[10] = cast[uint8](116) # t
  name[11] = cast[uint8](110) # n
  name[12] = cast[uint8](97)  # a
  name[13] = cast[uint8](109) # m
  name[14] = cast[uint8](101) # e
  name[15] = cast[uint8](0)

  var nread: int32 = read_sysctl(name, buffer, 4096)

  if nread < 0:
    print_error(cast[ptr uint8]("sysctl: cannot read "))
    print_error(name)
    print_error(cast[ptr uint8]("\n"))
    discard syscall1(SYS_exit, 1)

  # Print in sysctl format: name = value
  print(name)
  print(cast[ptr uint8](" = "))
  print(buffer)
  print(cast[ptr uint8]("\n"))

  discard syscall1(SYS_exit, 0)
