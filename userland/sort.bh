# sort - sort structured data by field
# Usage: ps | sort FIELD_INDEX [desc]
# Example: ps | sort 3 desc  (sort by RSS descending)

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

# Check if string starts with "desc"
def is_desc(s: *uint8) -> int32:
  if s[0] == cast[uint8](100):  # 'd'
    if s[1] == cast[uint8](101):  # 'e'
      if s[2] == cast[uint8](115):  # 's'
        if s[3] == cast[uint8](99):  # 'c'
          return 1
  return 0

# Swap two records in buffer
def swap_records(buf: *uint8, i: int32, j: int32, rec_size: int32):
  a_offset: int32 = i * rec_size
  b_offset: int32 = j * rec_size
  k: int32 = 0
  while k < rec_size:
    tmp: uint8 = buf[a_offset + k]
    buf[a_offset + k] = buf[b_offset + k]
    buf[b_offset + k] = tmp
    k = k + 1

# Get field value from record
def get_field(buf: *uint8, rec_idx: int32, rec_size: int32, field_idx: int32) -> int32:
  offset: int32 = rec_idx * rec_size + field_idx * 4
  field_ptr: *int32 = cast[*int32](cast[int32](buf) + offset)
  return field_ptr[0]

# Simple bubble sort (good enough for small datasets)
def bubble_sort(buf: *uint8, count: int32, rec_size: int32, field_idx: int32, descending: int32):
  i: int32 = 0
  while i < count - 1:
    j: int32 = 0
    while j < count - 1 - i:
      val_j: int32 = get_field(buf, j, rec_size, field_idx)
      val_j1: int32 = get_field(buf, j + 1, rec_size, field_idx)

      should_swap: int32 = 0
      if descending == 1:
        # Descending: swap if j < j+1
        if val_j < val_j1:
          should_swap = 1
      else:
        # Ascending: swap if j > j+1
        if val_j > val_j1:
          should_swap = 1

      if should_swap == 1:
        swap_records(buf, j, j + 1, rec_size)

      j = j + 1
    i = i + 1

def main():
  argc: int32 = get_argc()

  # Default: sort by field 0, ascending
  sort_field: int32 = 0
  descending: int32 = 0

  if argc >= 2:
    arg1: *uint8 = get_argv(1)
    sort_field = parse_int(arg1)

  if argc >= 3:
    arg2: *uint8 = get_argv(2)
    descending = is_desc(arg2)

  # Allocate buffer (256KB for up to ~5000 records)
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 262144
  syscall1(SYS_brk, new_brk)
  header_buf: *uint8 = cast[*uint8](old_brk)
  data_buf: *uint8 = cast[*uint8](old_brk + 64)

  # Read schema header (8 bytes)
  n: int32 = syscall3(SYS_read, STDIN, cast[int32](header_buf), 8)
  if n != 8:
    print_err(cast[*uint8]("Error: No schema header\n"))
    syscall1(SYS_exit, 1)

  rec_size_ptr: *uint16 = cast[*uint16](header_buf + 6)
  rec_size: int32 = cast[int32](rec_size_ptr[0])

  # Read record count
  n = syscall3(SYS_read, STDIN, cast[int32](header_buf + 8), 4)
  rec_count_ptr: *int32 = cast[*int32](header_buf + 8)
  rec_count: int32 = rec_count_ptr[0]

  # Read all records into buffer
  total_data: int32 = rec_count * rec_size
  bytes_read: int32 = 0
  while bytes_read < total_data:
    n = syscall3(SYS_read, STDIN, cast[int32](data_buf) + bytes_read, total_data - bytes_read)
    if n <= 0:
      break
    bytes_read = bytes_read + n

  # Sort the records
  bubble_sort(data_buf, rec_count, rec_size, sort_field, descending)

  # Output header
  syscall3(SYS_write, STDOUT, cast[int32](header_buf), 8)

  # Output record count
  syscall3(SYS_write, STDOUT, cast[int32](header_buf + 8), 4)

  # Output sorted records
  syscall3(SYS_write, STDOUT, cast[int32](data_buf), bytes_read)

  syscall1(SYS_exit, 0)
