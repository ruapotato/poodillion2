# tetris - Classic Tetris Game
# Use arrow keys or A/D to move, W/Up to rotate, S/Down to drop

from lib.syscalls import *

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const BOARD_WIDTH: int32 = 10
const BOARD_HEIGHT: int32 = 20
const CELL_SIZE: int32 = 25

# Piece types
const PIECE_I: int32 = 0
const PIECE_O: int32 = 1
const PIECE_T: int32 = 2
const PIECE_S: int32 = 3
const PIECE_Z: int32 = 4
const PIECE_J: int32 = 5
const PIECE_L: int32 = 6

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Game state
g_board: array[200, int32]        # 10x20 board, 0 = empty, 1-7 = piece colors
g_current_piece: int32 = 0
g_current_rot: int32 = 0
g_piece_x: int32 = 4
g_piece_y: int32 = 0
g_next_piece: int32 = 0
g_score: int32 = 0
g_lines: int32 = 0
g_level: int32 = 1
g_game_over: int32 = 0
g_running: int32 = 1

# Board position on screen
g_board_x: int32 = 0
g_board_y: int32 = 0

# Timing
g_drop_timer: int32 = 0
g_drop_delay: int32 = 500  # ms between drops

# Random state
g_rand_state: int32 = 12345

# Colors for pieces (0=empty, 1-7=piece types)
g_colors: array[8, int32]

# Piece shapes (4x4 grid for each rotation of each piece)
# Each piece has 4 rotations, each rotation is 4 cells (x,y pairs)
g_pieces: array[224, int32]  # 7 pieces * 4 rotations * 4 cells * 2 coords

def print_str(s: *uint8):
  len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  syscall3(SYS_write, STDOUT, cast[int32](s), len)

def print_num(n: int32):
  buf: array[16, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(cast[*uint8](buf))
    return
  tmp: int32 = n
  i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  j: int32 = 0
  k: int32 = i - 1
  while j < k:
    t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(cast[*uint8](buf))

def sleep_ms(ms: int32):
  old_brk: int32 = syscall1(SYS_brk, 0)
  syscall1(SYS_brk, old_brk + 16)
  ts: *int32 = cast[*int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  syscall2(SYS_nanosleep, cast[int32](ts), 0)

def random() -> int32:
  g_rand_state = g_rand_state * 1103515245 + 12345
  r: int32 = g_rand_state / 65536
  if r < 0:
    r = 0 - r
  return r

def init_colors():
  g_colors[0] = 0x1A1A2E   # Empty (dark)
  g_colors[1] = 0x00FFFF   # I - Cyan
  g_colors[2] = 0xFFFF00   # O - Yellow
  g_colors[3] = 0x800080   # T - Purple
  g_colors[4] = 0x00FF00   # S - Green
  g_colors[5] = 0xFF0000   # Z - Red
  g_colors[6] = 0x0000FF   # J - Blue
  g_colors[7] = 0xFF8000   # L - Orange

def init_pieces():
  # I piece (index 0)
  # Rotation 0
  g_pieces[0] = 0
  g_pieces[1] = 1
  g_pieces[2] = 1
  g_pieces[3] = 1
  g_pieces[4] = 2
  g_pieces[5] = 1
  g_pieces[6] = 3
  g_pieces[7] = 1
  # Rotation 1
  g_pieces[8] = 2
  g_pieces[9] = 0
  g_pieces[10] = 2
  g_pieces[11] = 1
  g_pieces[12] = 2
  g_pieces[13] = 2
  g_pieces[14] = 2
  g_pieces[15] = 3
  # Rotation 2
  g_pieces[16] = 0
  g_pieces[17] = 2
  g_pieces[18] = 1
  g_pieces[19] = 2
  g_pieces[20] = 2
  g_pieces[21] = 2
  g_pieces[22] = 3
  g_pieces[23] = 2
  # Rotation 3
  g_pieces[24] = 1
  g_pieces[25] = 0
  g_pieces[26] = 1
  g_pieces[27] = 1
  g_pieces[28] = 1
  g_pieces[29] = 2
  g_pieces[30] = 1
  g_pieces[31] = 3

  # O piece (index 1)
  i: int32 = 32
  while i < 64:
    g_pieces[i] = 1
    g_pieces[i + 1] = 1
    g_pieces[i + 2] = 2
    g_pieces[i + 3] = 1
    g_pieces[i + 4] = 1
    g_pieces[i + 5] = 2
    g_pieces[i + 6] = 2
    g_pieces[i + 7] = 2
    i = i + 8

  # T piece (index 2)
  g_pieces[64] = 1
  g_pieces[65] = 0
  g_pieces[66] = 0
  g_pieces[67] = 1
  g_pieces[68] = 1
  g_pieces[69] = 1
  g_pieces[70] = 2
  g_pieces[71] = 1

  g_pieces[72] = 1
  g_pieces[73] = 0
  g_pieces[74] = 1
  g_pieces[75] = 1
  g_pieces[76] = 2
  g_pieces[77] = 1
  g_pieces[78] = 1
  g_pieces[79] = 2

  g_pieces[80] = 0
  g_pieces[81] = 1
  g_pieces[82] = 1
  g_pieces[83] = 1
  g_pieces[84] = 2
  g_pieces[85] = 1
  g_pieces[86] = 1
  g_pieces[87] = 2

  g_pieces[88] = 1
  g_pieces[89] = 0
  g_pieces[90] = 0
  g_pieces[91] = 1
  g_pieces[92] = 1
  g_pieces[93] = 1
  g_pieces[94] = 1
  g_pieces[95] = 2

  # S piece (index 3)
  g_pieces[96] = 1
  g_pieces[97] = 0
  g_pieces[98] = 2
  g_pieces[99] = 0
  g_pieces[100] = 0
  g_pieces[101] = 1
  g_pieces[102] = 1
  g_pieces[103] = 1

  g_pieces[104] = 0
  g_pieces[105] = 0
  g_pieces[106] = 0
  g_pieces[107] = 1
  g_pieces[108] = 1
  g_pieces[109] = 1
  g_pieces[110] = 1
  g_pieces[111] = 2

  g_pieces[112] = 1
  g_pieces[113] = 1
  g_pieces[114] = 2
  g_pieces[115] = 1
  g_pieces[116] = 0
  g_pieces[117] = 2
  g_pieces[118] = 1
  g_pieces[119] = 2

  g_pieces[120] = 0
  g_pieces[121] = 0
  g_pieces[122] = 0
  g_pieces[123] = 1
  g_pieces[124] = 1
  g_pieces[125] = 1
  g_pieces[126] = 1
  g_pieces[127] = 2

  # Z piece (index 4)
  g_pieces[128] = 0
  g_pieces[129] = 0
  g_pieces[130] = 1
  g_pieces[131] = 0
  g_pieces[132] = 1
  g_pieces[133] = 1
  g_pieces[134] = 2
  g_pieces[135] = 1

  g_pieces[136] = 1
  g_pieces[137] = 0
  g_pieces[138] = 0
  g_pieces[139] = 1
  g_pieces[140] = 1
  g_pieces[141] = 1
  g_pieces[142] = 0
  g_pieces[143] = 2

  g_pieces[144] = 0
  g_pieces[145] = 1
  g_pieces[146] = 1
  g_pieces[147] = 1
  g_pieces[148] = 1
  g_pieces[149] = 2
  g_pieces[150] = 2
  g_pieces[151] = 2

  g_pieces[152] = 1
  g_pieces[153] = 0
  g_pieces[154] = 0
  g_pieces[155] = 1
  g_pieces[156] = 1
  g_pieces[157] = 1
  g_pieces[158] = 0
  g_pieces[159] = 2

  # J piece (index 5)
  g_pieces[160] = 0
  g_pieces[161] = 0
  g_pieces[162] = 0
  g_pieces[163] = 1
  g_pieces[164] = 1
  g_pieces[165] = 1
  g_pieces[166] = 2
  g_pieces[167] = 1

  g_pieces[168] = 1
  g_pieces[169] = 0
  g_pieces[170] = 2
  g_pieces[171] = 0
  g_pieces[172] = 1
  g_pieces[173] = 1
  g_pieces[174] = 1
  g_pieces[175] = 2

  g_pieces[176] = 0
  g_pieces[177] = 1
  g_pieces[178] = 1
  g_pieces[179] = 1
  g_pieces[180] = 2
  g_pieces[181] = 1
  g_pieces[182] = 2
  g_pieces[183] = 2

  g_pieces[184] = 1
  g_pieces[185] = 0
  g_pieces[186] = 1
  g_pieces[187] = 1
  g_pieces[188] = 1
  g_pieces[189] = 2
  g_pieces[190] = 0
  g_pieces[191] = 2

  # L piece (index 6)
  g_pieces[192] = 2
  g_pieces[193] = 0
  g_pieces[194] = 0
  g_pieces[195] = 1
  g_pieces[196] = 1
  g_pieces[197] = 1
  g_pieces[198] = 2
  g_pieces[199] = 1

  g_pieces[200] = 1
  g_pieces[201] = 0
  g_pieces[202] = 1
  g_pieces[203] = 1
  g_pieces[204] = 1
  g_pieces[205] = 2
  g_pieces[206] = 2
  g_pieces[207] = 2

  g_pieces[208] = 0
  g_pieces[209] = 1
  g_pieces[210] = 1
  g_pieces[211] = 1
  g_pieces[212] = 2
  g_pieces[213] = 1
  g_pieces[214] = 0
  g_pieces[215] = 2

  g_pieces[216] = 0
  g_pieces[217] = 0
  g_pieces[218] = 1
  g_pieces[219] = 0
  g_pieces[220] = 1
  g_pieces[221] = 1
  g_pieces[222] = 1
  g_pieces[223] = 2

# ============ Drawing ============

def fb_pixel(x: int32, y: int32, color: int32):
  if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
    g_fb[y * g_xres + x] = cast[uint32](color)

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
  cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < g_yres:
      cx: int32 = x
      while cx < x + w:
        if cx >= 0 and cx < g_xres:
          g_fb[cy * g_xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

def draw_cell(x: int32, y: int32, color_idx: int32):
  px: int32 = g_board_x + x * CELL_SIZE
  py: int32 = g_board_y + y * CELL_SIZE
  color: int32 = g_colors[color_idx]

  # Main cell
  fill_rect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2, color)

  # Highlight (top-left)
  if color_idx > 0:
    bright: int32 = color + 0x303030
    if bright > 0xFFFFFF:
      bright = 0xFFFFFF
    fill_rect(px + 1, py + 1, CELL_SIZE - 2, 2, bright)
    fill_rect(px + 1, py + 1, 2, CELL_SIZE - 2, bright)

# Simple font for score display
font: array[768, uint8]

def init_font():
  i: int32 = 0
  while i < 768:
    font[i] = cast[uint8](0)
    i = i + 1

  # Digits 0-9
  font[384] = cast[uint8](0x3C)
  font[385] = cast[uint8](0x66)
  font[386] = cast[uint8](0x6E)
  font[387] = cast[uint8](0x7E)
  font[388] = cast[uint8](0x76)
  font[389] = cast[uint8](0x66)
  font[390] = cast[uint8](0x3C)
  font[391] = cast[uint8](0x00)

  font[392] = cast[uint8](0x18)
  font[393] = cast[uint8](0x38)
  font[394] = cast[uint8](0x18)
  font[395] = cast[uint8](0x18)
  font[396] = cast[uint8](0x18)
  font[397] = cast[uint8](0x18)
  font[398] = cast[uint8](0x7E)
  font[399] = cast[uint8](0x00)

  font[400] = cast[uint8](0x3C)
  font[401] = cast[uint8](0x66)
  font[402] = cast[uint8](0x06)
  font[403] = cast[uint8](0x0C)
  font[404] = cast[uint8](0x18)
  font[405] = cast[uint8](0x30)
  font[406] = cast[uint8](0x7E)
  font[407] = cast[uint8](0x00)

  font[408] = cast[uint8](0x3C)
  font[409] = cast[uint8](0x66)
  font[410] = cast[uint8](0x06)
  font[411] = cast[uint8](0x1C)
  font[412] = cast[uint8](0x06)
  font[413] = cast[uint8](0x66)
  font[414] = cast[uint8](0x3C)
  font[415] = cast[uint8](0x00)

  font[416] = cast[uint8](0x0C)
  font[417] = cast[uint8](0x1C)
  font[418] = cast[uint8](0x3C)
  font[419] = cast[uint8](0x6C)
  font[420] = cast[uint8](0x7E)
  font[421] = cast[uint8](0x0C)
  font[422] = cast[uint8](0x0C)
  font[423] = cast[uint8](0x00)

  font[424] = cast[uint8](0x7E)
  font[425] = cast[uint8](0x60)
  font[426] = cast[uint8](0x7C)
  font[427] = cast[uint8](0x06)
  font[428] = cast[uint8](0x06)
  font[429] = cast[uint8](0x66)
  font[430] = cast[uint8](0x3C)
  font[431] = cast[uint8](0x00)

  font[432] = cast[uint8](0x1C)
  font[433] = cast[uint8](0x30)
  font[434] = cast[uint8](0x60)
  font[435] = cast[uint8](0x7C)
  font[436] = cast[uint8](0x66)
  font[437] = cast[uint8](0x66)
  font[438] = cast[uint8](0x3C)
  font[439] = cast[uint8](0x00)

  font[440] = cast[uint8](0x7E)
  font[441] = cast[uint8](0x06)
  font[442] = cast[uint8](0x0C)
  font[443] = cast[uint8](0x18)
  font[444] = cast[uint8](0x30)
  font[445] = cast[uint8](0x30)
  font[446] = cast[uint8](0x30)
  font[447] = cast[uint8](0x00)

  font[448] = cast[uint8](0x3C)
  font[449] = cast[uint8](0x66)
  font[450] = cast[uint8](0x66)
  font[451] = cast[uint8](0x3C)
  font[452] = cast[uint8](0x66)
  font[453] = cast[uint8](0x66)
  font[454] = cast[uint8](0x3C)
  font[455] = cast[uint8](0x00)

  font[456] = cast[uint8](0x3C)
  font[457] = cast[uint8](0x66)
  font[458] = cast[uint8](0x66)
  font[459] = cast[uint8](0x3E)
  font[460] = cast[uint8](0x06)
  font[461] = cast[uint8](0x0C)
  font[462] = cast[uint8](0x38)
  font[463] = cast[uint8](0x00)

def draw_char(x: int32, y: int32, c: uint8, color: int32):
  idx: int32 = cast[int32](c) * 8
  if idx < 0 or idx >= 760:
    return
  row: int32 = 0
  while row < 8:
    bits: uint8 = font[idx + row]
    col: int32 = 0
    while col < 8:
      mask: int32 = 128
      shift: int32 = col
      while shift > 0:
        mask = mask / 2
        shift = shift - 1
      if (cast[int32](bits) & mask) != 0:
        fb_pixel(x + col, y + row, color)
      col = col + 1
    row = row + 1

def draw_number(x: int32, y: int32, n: int32, color: int32):
  buf: array[12, uint8]
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    draw_char(x, y, buf[0], color)
    return
  tmp: int32 = n
  i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  j: int32 = 0
  k: int32 = i - 1
  while j < k:
    t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  j = 0
  while j < i:
    draw_char(x + j * 8, y, buf[j], color)
    j = j + 1

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  syscall1(SYS_brk, old_brk + 512)
  path: *uint8 = cast[*uint8](old_brk)
  path[0] = cast[uint8](47)
  path[1] = cast[uint8](100)
  path[2] = cast[uint8](101)
  path[3] = cast[uint8](118)
  path[4] = cast[uint8](47)
  path[5] = cast[uint8](102)
  path[6] = cast[uint8](98)
  path[7] = cast[uint8](48)
  path[8] = cast[uint8](0)

  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  vinfo: *int32 = cast[*int32](old_brk + 32)
  i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  fb_size: int32 = g_xres * g_yres * 4
  g_fb = cast[*uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

  if cast[int32](g_fb) < 0:
    return 1

  # Center board
  g_board_x = (g_xres - BOARD_WIDTH * CELL_SIZE) / 2
  g_board_y = (g_yres - BOARD_HEIGHT * CELL_SIZE) / 2

  # Set stdin non-blocking
  flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

  return 0

# ============ Game Logic ============

def get_piece_cell(piece: int32, rot: int32, idx: int32) -> int32:
  # Returns x or y coordinate of piece cell
  base: int32 = piece * 32 + rot * 8 + idx
  return g_pieces[base]

def check_collision(piece: int32, rot: int32, px: int32, py: int32) -> int32:
  i: int32 = 0
  while i < 4:
    cx: int32 = px + get_piece_cell(piece, rot, i * 2)
    cy: int32 = py + get_piece_cell(piece, rot, i * 2 + 1)

    # Check bounds
    if cx < 0 or cx >= BOARD_WIDTH or cy >= BOARD_HEIGHT:
      return 1

    # Check board collision (only if on board)
    if cy >= 0:
      if g_board[cy * BOARD_WIDTH + cx] != 0:
        return 1

    i = i + 1
  return 0

def lock_piece():
  i: int32 = 0
  while i < 4:
    cx: int32 = g_piece_x + get_piece_cell(g_current_piece, g_current_rot, i * 2)
    cy: int32 = g_piece_y + get_piece_cell(g_current_piece, g_current_rot, i * 2 + 1)
    if cy >= 0 and cy < BOARD_HEIGHT and cx >= 0 and cx < BOARD_WIDTH:
      g_board[cy * BOARD_WIDTH + cx] = g_current_piece + 1
    i = i + 1

def clear_lines():
  lines_cleared: int32 = 0
  y: int32 = BOARD_HEIGHT - 1
  while y >= 0:
    # Check if line is full
    full: int32 = 1
    x: int32 = 0
    while x < BOARD_WIDTH:
      if g_board[y * BOARD_WIDTH + x] == 0:
        full = 0
      x = x + 1

    if full != 0:
      # Shift everything down
      ty: int32 = y
      while ty > 0:
        x = 0
        while x < BOARD_WIDTH:
          g_board[ty * BOARD_WIDTH + x] = g_board[(ty - 1) * BOARD_WIDTH + x]
          x = x + 1
        ty = ty - 1
      # Clear top row
      x = 0
      while x < BOARD_WIDTH:
        g_board[x] = 0
        x = x + 1
      lines_cleared = lines_cleared + 1
      # Don't decrement y, check same row again
    else:
      y = y - 1

  # Update score
  if lines_cleared == 1:
    g_score = g_score + 100 * g_level
  else:
    if lines_cleared == 2:
      g_score = g_score + 300 * g_level
    else:
      if lines_cleared == 3:
        g_score = g_score + 500 * g_level
      else:
        if lines_cleared == 4:
          g_score = g_score + 800 * g_level

  g_lines = g_lines + lines_cleared

  # Level up every 10 lines
  g_level = 1 + g_lines / 10
  g_drop_delay = 500 - g_level * 40
  if g_drop_delay < 50:
    g_drop_delay = 50

def spawn_piece():
  g_current_piece = g_next_piece
  g_next_piece = random() % 7
  g_current_rot = 0
  g_piece_x = 3
  g_piece_y = 0

  # Check for game over
  if check_collision(g_current_piece, g_current_rot, g_piece_x, g_piece_y) != 0:
    g_game_over = 1

def init_game():
  # Clear board
  i: int32 = 0
  while i < 200:
    g_board[i] = 0
    i = i + 1

  g_score = 0
  g_lines = 0
  g_level = 1
  g_drop_delay = 500
  g_game_over = 0

  # Initialize random seed
  g_rand_state = syscall1(SYS_time, 0)
  if g_rand_state == 0:
    g_rand_state = 12345

  g_next_piece = random() % 7
  spawn_piece()

def move_left():
  if check_collision(g_current_piece, g_current_rot, g_piece_x - 1, g_piece_y) == 0:
    g_piece_x = g_piece_x - 1

def move_right():
  if check_collision(g_current_piece, g_current_rot, g_piece_x + 1, g_piece_y) == 0:
    g_piece_x = g_piece_x + 1

def rotate_piece():
  new_rot: int32 = (g_current_rot + 1) % 4
  if check_collision(g_current_piece, new_rot, g_piece_x, g_piece_y) == 0:
    g_current_rot = new_rot

def drop_piece():
  if check_collision(g_current_piece, g_current_rot, g_piece_x, g_piece_y + 1) == 0:
    g_piece_y = g_piece_y + 1
  else:
    lock_piece()
    clear_lines()
    spawn_piece()

def hard_drop():
  while check_collision(g_current_piece, g_current_rot, g_piece_x, g_piece_y + 1) == 0:
    g_piece_y = g_piece_y + 1
  lock_piece()
  clear_lines()
  spawn_piece()

# ============ Input ============

def handle_input():
  buf: array[8, uint8]
  n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  c: uint8 = buf[0]

  if g_game_over != 0:
    if c == cast[uint8](114) or c == cast[uint8](82):  # r/R - restart
      init_game()
    if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q - quit
      g_running = 0
    return

  # Regular controls
  if c == cast[uint8](97) or c == cast[uint8](65):  # a/A - left
    move_left()
  else:
    if c == cast[uint8](100) or c == cast[uint8](68):  # d/D - right
      move_right()
    else:
      if c == cast[uint8](119) or c == cast[uint8](87):  # w/W - rotate
        rotate_piece()
      else:
        if c == cast[uint8](115) or c == cast[uint8](83):  # s/S - drop
          drop_piece()
        else:
          if c == cast[uint8](32):  # Space - hard drop
            hard_drop()
          else:
            if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q - quit
              g_running = 0

  # Arrow keys
  if n >= 3 and buf[0] == cast[uint8](27) and buf[1] == cast[uint8](91):
    if buf[2] == cast[uint8](68):       # Left
      move_left()
    else:
      if buf[2] == cast[uint8](67):     # Right
        move_right()
      else:
        if buf[2] == cast[uint8](65):   # Up
          rotate_piece()
        else:
          if buf[2] == cast[uint8](66): # Down
            drop_piece()

# ============ Rendering ============

def render():
  # Clear background
  i: int32 = 0
  total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0x0F0F1A)
    i = i + 1

  # Draw board border
  fill_rect(g_board_x - 3, g_board_y - 3, BOARD_WIDTH * CELL_SIZE + 6, BOARD_HEIGHT * CELL_SIZE + 6, 0x303050)

  # Draw board cells
  y: int32 = 0
  while y < BOARD_HEIGHT:
    x: int32 = 0
    while x < BOARD_WIDTH:
      draw_cell(x, y, g_board[y * BOARD_WIDTH + x])
      x = x + 1
    y = y + 1

  # Draw current piece
  if g_game_over == 0:
    i = 0
    while i < 4:
      cx: int32 = g_piece_x + get_piece_cell(g_current_piece, g_current_rot, i * 2)
      cy: int32 = g_piece_y + get_piece_cell(g_current_piece, g_current_rot, i * 2 + 1)
      if cy >= 0:
        draw_cell(cx, cy, g_current_piece + 1)
      i = i + 1

  # Draw score
  score_x: int32 = g_board_x + BOARD_WIDTH * CELL_SIZE + 20
  draw_number(score_x, g_board_y + 10, g_score, 0xFFFFFF)
  draw_number(score_x, g_board_y + 30, g_lines, 0xCCCCCC)
  draw_number(score_x, g_board_y + 50, g_level, 0xAAAAFF)

  # Draw next piece preview
  next_x: int32 = score_x
  next_y: int32 = g_board_y + 80
  i = 0
  while i < 4:
    cx: int32 = get_piece_cell(g_next_piece, 0, i * 2)
    cy: int32 = get_piece_cell(g_next_piece, 0, i * 2 + 1)
    px: int32 = next_x + cx * 15
    py: int32 = next_y + cy * 15
    fill_rect(px, py, 14, 14, g_colors[g_next_piece + 1])
    i = i + 1

# ============ Main ============

def main() -> int32:
  print_str(cast[*uint8]("Tetris - A/D or arrows to move, W/Up to rotate, S/Down to drop, Space for hard drop, Q to quit\n"))

  if init_framebuffer() != 0:
    return 1

  init_font()
  init_colors()
  init_pieces()
  init_game()

  last_time: int32 = 0

  while g_running != 0:
    handle_input()

    # Auto drop
    if g_game_over == 0:
      g_drop_timer = g_drop_timer + 16
      if g_drop_timer >= g_drop_delay:
        g_drop_timer = 0
        drop_piece()

    render()
    sleep_ms(16)

  # Clear screen
  i: int32 = 0
  total: int32 = g_xres * g_yres
  while i < total:
    g_fb[i] = cast[uint32](0)
    i = i + 1

  syscall1(SYS_close, g_fb_fd)
  print_str(cast[*uint8]("Final Score: "))
  print_num(g_score)
  print_str(cast[*uint8]("\n"))

  return 0

main()
