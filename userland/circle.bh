# circle - Draw a circle
# Usage: circle <cx> <cy> <radius> <color> [fill]
# Uses midpoint circle algorithm

from lib.syscalls import *

FBIOGET_VSCREENINFO: int32 = 0x4600

def plot_pixel(fd: int32, x: int32, y: int32, xres: int32, yres: int32, color: int32, pixel_buf: *uint32):
    if x < 0 or x >= xres or y < 0 or y >= yres:
        return

    offset: int32 = (y * xres + x) * 4
    _ = syscall3(SYS_lseek, fd, offset, SEEK_SET)
    pixel_buf[0] = color
    _ = syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

def draw_circle_points(fd: int32, cx: int32, cy: int32, x: int32, y: int32, xres: int32, yres: int32, color: int32, pixel: *uint32):
    plot_pixel(fd, cx + x, cy + y, xres, yres, color, pixel)
    plot_pixel(fd, cx - x, cy + y, xres, yres, color, pixel)
    plot_pixel(fd, cx + x, cy - y, xres, yres, color, pixel)
    plot_pixel(fd, cx - x, cy - y, xres, yres, color, pixel)
    plot_pixel(fd, cx + y, cy + x, xres, yres, color, pixel)
    plot_pixel(fd, cx - y, cy + x, xres, yres, color, pixel)
    plot_pixel(fd, cx + y, cy - x, xres, yres, color, pixel)
    plot_pixel(fd, cx - y, cy - x, xres, yres, color, pixel)

def main():
    # For testing: Draw yellow circle at (400, 300), radius 50
    cx: int32 = 400
    cy: int32 = 300
    radius: int32 = 50
    color: int32 = 0xFFFF00  # Yellow

    fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fd < 0:
        print(cast[*uint8]("Error: Cannot open /dev/fb0\n"), 29)
        _ = syscall1(SYS_exit, 1)

    # Get screen info
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 160
    _ = syscall1(SYS_brk, new_brk)
    vinfo: *uint32 = cast[*uint32](old_brk)

    result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    if result < 0:
        print(cast[*uint8]("Error: Cannot get screen info\n"), 31)
        _ = syscall1(SYS_close, fd)
        _ = syscall1(SYS_exit, 1)

    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    # Allocate pixel buffer
    pixel_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, pixel_brk + 4)
    pixel: *uint32 = cast[*uint32](pixel_brk)

    # Midpoint circle algorithm
    x: int32 = 0
    y: int32 = radius
    d: int32 = 1 - radius

    while x <= y:
        draw_circle_points(fd, cx, cy, x, y, xres, yres, color, pixel)

        x = x + 1
        if d < 0:
            d = d + 2 * x + 1
        else:
            y = y - 1
            d = d + 2 * (x - y) + 1

    _ = syscall1(SYS_close, fd)
    _ = syscall1(SYS_exit, 0)

main()
