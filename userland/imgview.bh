# imgview.bh - Simple PPM/BMP Image Viewer for PoodillionOS
# Displays P6 PPM (binary RGB) images using the framebuffer
# Usage: imgview <image.ppm>

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_mmap2: int32 = 192
const SYS_lseek: int32 = 19

const STDOUT: int32 = 1
const STDERR: int32 = 2
const O_RDONLY: int32 = 0
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

const SEEK_SET: int32 = 0
const SEEK_CUR: int32 = 1

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_err(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDERR, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

proc atoi(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  while s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

# Skip whitespace and comments in PPM header
proc skip_ws_and_comments(fd: int32, buf: ptr uint8, pos: ptr int32, buf_end: ptr int32) =
  while true:
    # Refill buffer if needed
    if pos[0] >= buf_end[0]:
      var bytes: int32 = syscall3(SYS_read, fd, cast[int32](buf), 1024)
      if bytes <= 0:
        return
      pos[0] = 0
      buf_end[0] = bytes

    var c: uint8 = buf[pos[0]]

    # Skip whitespace
    if c == cast[uint8](32) or c == cast[uint8](9) or c == cast[uint8](10) or c == cast[uint8](13):
      pos[0] = pos[0] + 1
      continue

    # Skip comments (# to end of line)
    if c == cast[uint8](35):  # '#'
      pos[0] = pos[0] + 1
      # Skip until newline
      while pos[0] < buf_end[0]:
        if buf[pos[0]] == cast[uint8](10):  # newline
          pos[0] = pos[0] + 1
          break
        pos[0] = pos[0] + 1
      continue

    # Non-whitespace, non-comment found
    return

# Read a number from PPM header
proc read_ppm_number(fd: int32, buf: ptr uint8, pos: ptr int32, buf_end: ptr int32): int32 =
  skip_ws_and_comments(fd, buf, pos, buf_end)

  var result: int32 = 0
  while pos[0] < buf_end[0]:
    var c: uint8 = buf[pos[0]]
    if c >= cast[uint8](48) and c <= cast[uint8](57):
      result = result * 10 + cast[int32](c) - 48
      pos[0] = pos[0] + 1
    else:
      break

  return result

# Parse PPM P6 header
proc parse_ppm_header(fd: int32, width: ptr int32, height: ptr int32): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 2048)
  var header_buf: ptr uint8 = cast[ptr uint8](old_brk)
  var pos: ptr int32 = cast[ptr int32](old_brk + 1024)
  var buf_end: ptr int32 = cast[ptr int32](old_brk + 1024 + 4)

  # Read initial chunk
  var bytes: int32 = syscall3(SYS_read, fd, cast[int32](header_buf), 1024)
  if bytes < 3:
    print_err(cast[ptr uint8]("Error: File too small\n"))
    return -1

  pos[0] = 0
  buf_end[0] = bytes

  # Check magic number "P6"
  if header_buf[0] != cast[uint8](80) or header_buf[1] != cast[uint8](54):  # 'P' '6'
    print_err(cast[ptr uint8]("Error: Not a P6 PPM file (expected 'P6' magic)\n"))
    return -1

  pos[0] = 2

  # Read width
  width[0] = read_ppm_number(fd, header_buf, pos, buf_end)
  if width[0] <= 0:
    print_err(cast[ptr uint8]("Error: Invalid width\n"))
    return -1

  # Read height
  height[0] = read_ppm_number(fd, header_buf, pos, buf_end)
  if height[0] <= 0:
    print_err(cast[ptr uint8]("Error: Invalid height\n"))
    return -1

  # Read max value (should be 255)
  var maxval: int32 = read_ppm_number(fd, header_buf, pos, buf_end)
  if maxval != 255:
    print_err(cast[ptr uint8]("Error: Only 255 maxval supported\n"))
    return -1

  # Skip one whitespace after maxval
  if pos[0] < buf_end[0]:
    pos[0] = pos[0] + 1

  # Calculate how many header bytes we've consumed
  var header_consumed: int32 = pos[0]

  # Seek to start of pixel data
  discard syscall3(SYS_lseek, fd, header_consumed, SEEK_SET)

  return 0

# Fill screen with background color
proc clear_screen(fb: ptr uint32, xres: int32, yres: int32, color: uint32) =
  var total: int32 = xres * yres
  var i: int32 = 0
  while i < total:
    fb[i] = color
    i = i + 1

# Display the image centered on screen
proc display_image(fb: ptr uint32, img_data: ptr uint8, img_w: int32, img_h: int32, screen_w: int32, screen_h: int32) =
  # Calculate centering offset
  var offset_x: int32 = 0
  var offset_y: int32 = 0

  if img_w < screen_w:
    offset_x = (screen_w - img_w) / 2
  if img_h < screen_h:
    offset_y = (screen_h - img_h) / 2

  # Copy pixels
  var y: int32 = 0
  while y < img_h:
    var screen_y: int32 = y + offset_y
    if screen_y >= 0 and screen_y < screen_h:
      var x: int32 = 0
      while x < img_w:
        var screen_x: int32 = x + offset_x
        if screen_x >= 0 and screen_x < screen_w:
          # PPM is RGB, framebuffer is ARGB (or XRGB)
          var pixel_idx: int32 = (y * img_w + x) * 3
          var r: uint32 = cast[uint32](img_data[pixel_idx + 0])
          var g: uint32 = cast[uint32](img_data[pixel_idx + 1])
          var b: uint32 = cast[uint32](img_data[pixel_idx + 2])

          var pixel: uint32 = (r << 16) | (g << 8) | b
          fb[screen_y * screen_w + screen_x] = pixel
        x = x + 1
    y = y + 1

# Wait for key press or mouse click
proc wait_for_input(mouse_fd: int32): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var input_buf: ptr uint8 = cast[ptr uint8](old_brk)

  # Try to read from stdin (keyboard)
  var stdin_bytes: int32 = syscall3(SYS_read, 0, cast[int32](input_buf), 1)
  if stdin_bytes > 0:
    return 1

  # Try to read from mouse
  if mouse_fd >= 0:
    var mouse_bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](input_buf), 4)
    if mouse_bytes > 0:
      # Check for button press
      var btns: int32 = cast[int32](input_buf[0]) & 0x07
      if btns != 0:
        return 1

  return 0

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("Usage: imgview <image.ppm>\n"))
    print_err(cast[ptr uint8]("Supports PPM P6 format (binary RGB)\n"))
    discard syscall1(SYS_exit, 1)

  var filename: ptr uint8 = get_argv(1)

  print_str(cast[ptr uint8]("Opening image: "))
  print_str(filename)
  print_str(cast[ptr uint8]("\n"))

  # Open image file
  var img_fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
  if img_fd < 0:
    print_err(cast[ptr uint8]("Error: Cannot open image file\n"))
    discard syscall1(SYS_exit, 1)

  # Parse PPM header
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var img_width: ptr int32 = cast[ptr int32](old_brk)
  var img_height: ptr int32 = cast[ptr int32](old_brk + 4)

  if parse_ppm_header(img_fd, img_width, img_height) < 0:
    discard syscall1(SYS_close, img_fd)
    discard syscall1(SYS_exit, 1)

  print_str(cast[ptr uint8]("Image size: "))
  print_num(img_width[0])
  print_str(cast[ptr uint8]("x"))
  print_num(img_height[0])
  print_str(cast[ptr uint8]("\n"))

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_err(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_close, img_fd)
    discard syscall1(SYS_exit, 1)

  # Get screen info
  old_brk = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # mmap framebuffer
  var fb_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    print_err(cast[ptr uint8]("Error: mmap failed\n"))
    discard syscall1(SYS_close, img_fd)
    discard syscall1(SYS_close, fb_fd)
    discard syscall1(SYS_exit, 1)

  # Allocate buffer for image data
  var img_data_size: int32 = img_width[0] * img_height[0] * 3
  old_brk = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + img_data_size)
  var img_data: ptr uint8 = cast[ptr uint8](old_brk)

  # Read image data
  print_str(cast[ptr uint8]("Loading image data...\n"))
  var total_read: int32 = 0
  while total_read < img_data_size:
    var bytes: int32 = syscall3(SYS_read, img_fd, cast[int32](img_data) + total_read, img_data_size - total_read)
    if bytes <= 0:
      break
    total_read = total_read + bytes

  if total_read < img_data_size:
    print_err(cast[ptr uint8]("Warning: Incomplete image data\n"))

  discard syscall1(SYS_close, img_fd)

  # Clear screen to black
  clear_screen(framebuffer, xres, yres, cast[uint32](0))

  # Display the image
  print_str(cast[ptr uint8]("Displaying image...\n"))
  display_image(framebuffer, img_data, img_width[0], img_height[0], xres, yres)

  print_str(cast[ptr uint8]("Press any key or click mouse to exit\n"))

  # Open mouse for input
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd >= 0:
    var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
    discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Wait for input
  while wait_for_input(mouse_fd) == 0:
    # Sleep a bit to avoid busy-waiting
    var sleep_count: int32 = 0
    while sleep_count < 100000:
      sleep_count = sleep_count + 1

  print_str(cast[ptr uint8]("Exiting...\n"))

  # Clean up
  if mouse_fd >= 0:
    discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_exit, 0)

main()
