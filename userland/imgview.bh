# imgview.bh - Simple PPM/BMP Image Viewer for PoodillionOS
# Displays P6 PPM (binary RGB) images using the framebuffer
# Usage: imgview <image.ppm>

from lib.syscalls import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3

PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_SHARED: Final[int32] = 1

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def print_err(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDERR, cast[int32](s), len)

def print_num(n: int32):
    buf: *uint8 = cast[*uint8](0)
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    buf = cast[*uint8](old_brk)
    if n == 0:
        buf[0] = cast[uint8](48)
        buf[1] = cast[uint8](0)
        print_str(buf)
        return
    neg: int32 = 0
    tmp: int32 = n
    if n < 0:
        neg = 1
        tmp = 0 - n
    i: int32 = 0
    while tmp > 0:
        buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
        tmp = tmp / 10
        i = i + 1
    if neg != 0:
        buf[i] = cast[uint8](45)
        i = i + 1
    buf[i] = cast[uint8](0)
    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        t: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = t
        j = j + 1
        k = k - 1
    print_str(buf)

# Skip whitespace and comments in PPM header
def skip_ws_and_comments(fd: int32, buf: *uint8, pos: *int32, buf_end: *int32):
    while true:
        # Refill buffer if needed
        if pos[0] >= buf_end[0]:
            bytes: int32 = syscall3(SYS_read, fd, cast[int32](buf), 1024)
            if bytes <= 0:
                return
            pos[0] = 0
            buf_end[0] = bytes

        c: uint8 = buf[pos[0]]

        # Skip whitespace
        if c == cast[uint8](32) or c == cast[uint8](9) or c == cast[uint8](10) or c == cast[uint8](13):
            pos[0] = pos[0] + 1
            continue

        # Skip comments (# to end of line)
        if c == cast[uint8](35):  # '#'
            pos[0] = pos[0] + 1
            # Skip until newline
            while pos[0] < buf_end[0]:
                if buf[pos[0]] == cast[uint8](10):  # newline
                    pos[0] = pos[0] + 1
                    break
                pos[0] = pos[0] + 1
            continue

        # Non-whitespace, non-comment found
        return

# Read a number from PPM header
def read_ppm_number(fd: int32, buf: *uint8, pos: *int32, buf_end: *int32) -> int32:
    skip_ws_and_comments(fd, buf, pos, buf_end)

    result: int32 = 0
    while pos[0] < buf_end[0]:
        c: uint8 = buf[pos[0]]
        if c >= cast[uint8](48) and c <= cast[uint8](57):
            result = result * 10 + cast[int32](c) - 48
            pos[0] = pos[0] + 1
        else:
            break

    return result

# Parse PPM P6 header
def parse_ppm_header(fd: int32, width: *int32, height: *int32) -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 2048)
    header_buf: *uint8 = cast[*uint8](old_brk)
    pos: *int32 = cast[*int32](old_brk + 1024)
    buf_end: *int32 = cast[*int32](old_brk + 1024 + 4)

    # Read initial chunk
    bytes: int32 = syscall3(SYS_read, fd, cast[int32](header_buf), 1024)
    if bytes < 3:
        print_err(cast[*uint8]("Error: File too small\n"))
        return -1

    pos[0] = 0
    buf_end[0] = bytes

    # Check magic number "P6"
    if header_buf[0] != cast[uint8](80) or header_buf[1] != cast[uint8](54):  # 'P' '6'
        print_err(cast[*uint8]("Error: Not a P6 PPM file (expected 'P6' magic)\n"))
        return -1

    pos[0] = 2

    # Read width
    width[0] = read_ppm_number(fd, header_buf, pos, buf_end)
    if width[0] <= 0:
        print_err(cast[*uint8]("Error: Invalid width\n"))
        return -1

    # Read height
    height[0] = read_ppm_number(fd, header_buf, pos, buf_end)
    if height[0] <= 0:
        print_err(cast[*uint8]("Error: Invalid height\n"))
        return -1

    # Read max value (should be 255)
    maxval: int32 = read_ppm_number(fd, header_buf, pos, buf_end)
    if maxval != 255:
        print_err(cast[*uint8]("Error: Only 255 maxval supported\n"))
        return -1

    # Skip one whitespace after maxval
    if pos[0] < buf_end[0]:
        pos[0] = pos[0] + 1

    # Calculate how many header bytes we've consumed
    header_consumed: int32 = pos[0]

    # Seek to start of pixel data
    _ = syscall3(SYS_lseek, fd, header_consumed, SEEK_SET)

    return 0

# Fill screen with background color
def clear_screen(fb: *uint32, xres: int32, yres: int32, color: uint32):
    total: int32 = xres * yres
    i: int32 = 0
    while i < total:
        fb[i] = color
        i = i + 1

# Display the image centered on screen
def display_image(fb: *uint32, img_data: *uint8, img_w: int32, img_h: int32, screen_w: int32, screen_h: int32):
    # Calculate centering offset
    offset_x: int32 = 0
    offset_y: int32 = 0

    if img_w < screen_w:
        offset_x = (screen_w - img_w) / 2
    if img_h < screen_h:
        offset_y = (screen_h - img_h) / 2

    # Copy pixels
    y: int32 = 0
    while y < img_h:
        screen_y: int32 = y + offset_y
        if screen_y >= 0 and screen_y < screen_h:
            x: int32 = 0
            while x < img_w:
                screen_x: int32 = x + offset_x
                if screen_x >= 0 and screen_x < screen_w:
                    # PPM is RGB, framebuffer is ARGB (or XRGB)
                    pixel_idx: int32 = (y * img_w + x) * 3
                    r: uint32 = cast[uint32](img_data[pixel_idx + 0])
                    g: uint32 = cast[uint32](img_data[pixel_idx + 1])
                    b: uint32 = cast[uint32](img_data[pixel_idx + 2])

                    pixel: uint32 = (r << 16) | (g << 8) | b
                    fb[screen_y * screen_w + screen_x] = pixel
                x = x + 1
        y = y + 1

# Wait for key press or mouse click
def wait_for_input(mouse_fd: int32) -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    input_buf: *uint8 = cast[*uint8](old_brk)

    # Try to read from stdin (keyboard)
    stdin_bytes: int32 = syscall3(SYS_read, 0, cast[int32](input_buf), 1)
    if stdin_bytes > 0:
        return 1

    # Try to read from mouse
    if mouse_fd >= 0:
        mouse_bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](input_buf), 4)
        if mouse_bytes > 0:
            # Check for button press
            btns: int32 = cast[int32](input_buf[0]) & 0x07
            if btns != 0:
                return 1

    return 0

def main():
    argc: int32 = get_argc()

    if argc < 2:
        print_err(cast[*uint8]("Usage: imgview <image.ppm>\n"))
        print_err(cast[*uint8]("Supports PPM P6 format (binary RGB)\n"))
        _ = syscall1(SYS_exit, 1)

    filename: *uint8 = get_argv(1)

    print_str(cast[*uint8]("Opening image: "))
    print_str(filename)
    print_str(cast[*uint8]("\n"))

    # Open image file
    img_fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
    if img_fd < 0:
        print_err(cast[*uint8]("Error: Cannot open image file\n"))
        _ = syscall1(SYS_exit, 1)

    # Parse PPM header
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    img_width: *int32 = cast[*int32](old_brk)
    img_height: *int32 = cast[*int32](old_brk + 4)

    if parse_ppm_header(img_fd, img_width, img_height) < 0:
        _ = syscall1(SYS_close, img_fd)
        _ = syscall1(SYS_exit, 1)

    print_str(cast[*uint8]("Image size: "))
    print_num(img_width[0])
    print_str(cast[*uint8]("x"))
    print_num(img_height[0])
    print_str(cast[*uint8]("\n"))

    # Open framebuffer
    fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fb_fd < 0:
        print_err(cast[*uint8]("Error: Cannot open /dev/fb0\n"))
        _ = syscall1(SYS_close, img_fd)
        _ = syscall1(SYS_exit, 1)

    # Get screen info
    old_brk = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 256)
    vinfo: *uint32 = cast[*uint32](old_brk)

    FBIOGET_VSCREENINFO: Final[int32] = 0x4600
    _ = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    print_str(cast[*uint8]("Screen: "))
    print_num(xres)
    print_str(cast[*uint8]("x"))
    print_num(yres)
    print_str(cast[*uint8]("\n"))

    # mmap framebuffer
    fb_size: int32 = xres * yres * 4
    mmap_result: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
    framebuffer: *uint32 = cast[*uint32](0)

    mmap_unsigned: uint32 = cast[uint32](mmap_result)
    if mmap_unsigned < cast[uint32](0xFFFFF000):
        framebuffer = cast[*uint32](mmap_result)
    else:
        print_err(cast[*uint8]("Error: mmap failed\n"))
        _ = syscall1(SYS_close, img_fd)
        _ = syscall1(SYS_close, fb_fd)
        _ = syscall1(SYS_exit, 1)

    # Allocate buffer for image data
    img_data_size: int32 = img_width[0] * img_height[0] * 3
    old_brk = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + img_data_size)
    img_data: *uint8 = cast[*uint8](old_brk)

    # Read image data
    print_str(cast[*uint8]("Loading image data...\n"))
    total_read: int32 = 0
    while total_read < img_data_size:
        bytes: int32 = syscall3(SYS_read, img_fd, cast[int32](img_data) + total_read, img_data_size - total_read)
        if bytes <= 0:
            break
        total_read = total_read + bytes

    if total_read < img_data_size:
        print_err(cast[*uint8]("Warning: Incomplete image data\n"))

    _ = syscall1(SYS_close, img_fd)

    # Clear screen to black
    clear_screen(framebuffer, xres, yres, cast[uint32](0))

    # Display the image
    print_str(cast[*uint8]("Displaying image...\n"))
    display_image(framebuffer, img_data, img_width[0], img_height[0], xres, yres)

    print_str(cast[*uint8]("Press any key or click mouse to exit\n"))

    # Open mouse for input
    mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
    if mouse_fd >= 0:
        flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
        _ = syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

    # Wait for input
    while wait_for_input(mouse_fd) == 0:
        # Sleep a bit to avoid busy-waiting
        sleep_count: int32 = 0
        while sleep_count < 100000:
            sleep_count = sleep_count + 1

    print_str(cast[*uint8]("Exiting...\n"))

    # Clean up
    if mouse_fd >= 0:
        _ = syscall1(SYS_close, mouse_fd)
    _ = syscall1(SYS_close, fb_fd)
    _ = syscall1(SYS_exit, 0)

main()
