# chown - Change file ownership
# Usage: chown UID:GID FILE
# Uses numeric IDs for simplicity

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if character is digit
def is_digit(c: uint8) -> int32:
    if c >= cast[uint8](48):
        if c <= cast[uint8](57):
            return 1
    return 0

# Parse integer from string
def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0

    while s[i] != cast[uint8](0):
        is_dig: int32 = is_digit(s[i])
        if is_dig == 0:
            return -1

        digit: int32 = cast[int32](s[i]) - 48
        result = result * 10 + digit
        i = i + 1

    return result

# Parse UID:GID format
# Returns: uid in high 16 bits, gid in low 16 bits, or -1 on error
def parse_owner(owner_str: *uint8) -> int32:
    i: int32 = 0
    colon_pos: int32 = -1

    # Find colon position
    while owner_str[i] != cast[uint8](0):
        if owner_str[i] == cast[uint8](58):  # ':'
            colon_pos = i
            break
        i = i + 1

    if colon_pos < 0:
        return -1

    # Allocate buffers for uid and gid strings
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 128
    _ = syscall1(SYS_brk, new_brk)

    uid_str: *uint8 = cast[*uint8](old_brk)
    gid_str: *uint8 = cast[*uint8](old_brk + 64)

    # Copy UID string
    j: int32 = 0
    while j < colon_pos:
        uid_str[j] = owner_str[j]
        j = j + 1
    uid_str[j] = cast[uint8](0)

    # Copy GID string
    j = 0
    i = colon_pos + 1
    while owner_str[i] != cast[uint8](0):
        gid_str[j] = owner_str[i]
        j = j + 1
        i = i + 1
    gid_str[j] = cast[uint8](0)

    # Parse both
    uid: int32 = parse_int(uid_str)
    gid: int32 = parse_int(gid_str)

    if uid < 0:
        return -1
    if gid < 0:
        return -1

    # Return combined value (we'll extract them later)
    # Since we can't return both, we'll use global approach
    return (uid << 16) | (gid & 65535)

def main():
    argc: int32 = get_argc()
    if argc < 3:
        print_err(cast[*uint8]("Usage: chown UID:GID FILE\n"))
        print_err(cast[*uint8]("  Example: chown 1000:1000 myfile.txt\n"))
        _ = syscall1(SYS_exit, 1)

    owner_str: *uint8 = get_argv(1)
    filename: *uint8 = get_argv(2)

    # Parse UID:GID
    combined: int32 = parse_owner(owner_str)

    if combined < 0:
        print_err(cast[*uint8]("chown: invalid format '"))
        print_err(owner_str)
        print_err(cast[*uint8]("'\n"))
        print_err(cast[*uint8]("  Use format UID:GID (e.g., 1000:1000)\n"))
        _ = syscall1(SYS_exit, 1)

    uid: int32 = combined >> 16
    gid: int32 = combined & 65535

    # Call chown syscall
    ret: int32 = syscall3(SYS_chown, cast[int32](filename), uid, gid)

    if ret < 0:
        print_err(cast[*uint8]("chown: cannot change ownership of '"))
        print_err(filename)
        print_err(cast[*uint8]("'\n"))
        _ = syscall1(SYS_exit, 1)

    _ = syscall1(SYS_exit, 0)
