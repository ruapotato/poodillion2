# test - Evaluate conditional expressions
# Returns 0 for true, 1 for false
# Usage: test EXPRESSION or [ EXPRESSION ]

from lib.syscalls import *

const R_OK: int32 = 4
const W_OK: int32 = 2
const X_OK: int32 = 1
const F_OK: int32 = 0

# File mode flags (from stat.h)

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

# String length
# String compare
# String to integer (simple atoi)
# Print error message
def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Test file exists
def test_file_exists(path: *uint8) -> int32:
  # Allocate stat buffer (144 bytes for struct stat)
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 256
  syscall1(SYS_brk, new_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk)

  ret: int32 = syscall2(SYS_lstat, cast[int32](path), cast[int32](stat_buf))
  if ret >= 0:
    return 0  # exists
  return 1  # does not exist

# Test regular file
def test_regular_file(path: *uint8) -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 256
  syscall1(SYS_brk, new_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk)

  ret: int32 = syscall2(SYS_lstat, cast[int32](path), cast[int32](stat_buf))
  if ret < 0:
    return 1  # does not exist

  # st_mode is at offset 16 (uint32)
  mode_ptr: *uint32 = cast[*uint32](old_brk + 16)
  mode: uint32 = mode_ptr[0]

  if (mode and S_IFMT) == S_IFREG:
    return 0  # is regular file
  return 1

# Test directory
def test_directory(path: *uint8) -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 256
  syscall1(SYS_brk, new_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk)

  ret: int32 = syscall2(SYS_lstat, cast[int32](path), cast[int32](stat_buf))
  if ret < 0:
    return 1

  mode_ptr: *uint32 = cast[*uint32](old_brk + 16)
  mode: uint32 = mode_ptr[0]

  if (mode and S_IFMT) == S_IFDIR:
    return 0  # is directory
  return 1

# Test readable
def test_readable(path: *uint8) -> int32:
  ret: int32 = syscall2(SYS_access, cast[int32](path), R_OK)
  if ret >= 0:
    return 0
  return 1

# Test writable
def test_writable(path: *uint8) -> int32:
  ret: int32 = syscall2(SYS_access, cast[int32](path), W_OK)
  if ret >= 0:
    return 0
  return 1

# Test executable
def test_executable(path: *uint8) -> int32:
  ret: int32 = syscall2(SYS_access, cast[int32](path), X_OK)
  if ret >= 0:
    return 0
  return 1

# Test file size > 0
def test_file_size(path: *uint8) -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 256
  syscall1(SYS_brk, new_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk)

  ret: int32 = syscall2(SYS_lstat, cast[int32](path), cast[int32](stat_buf))
  if ret < 0:
    return 1

  # st_size is at offset 44 (int32) for 32-bit systems
  size_ptr: *int32 = cast[*int32](old_brk + 44)
  size: int32 = size_ptr[0]

  if size > 0:
    return 0
  return 1

def main():
  argc: int32 = get_argc()

  # If invoked as '[', last argument must be ']'
  prog: *uint8 = get_argv(0)
  is_bracket: int32 = 0

  # Check if program name is '['
  plen: int32 = strlen(prog)
  if plen > 0:
    if prog[plen - 1] == cast[uint8](91):  # '['
      is_bracket = 1

  if is_bracket != 0:
    if argc < 2:
      syscall1(SYS_exit, 1)
    last_arg: *uint8 = get_argv(argc - 1)
    if strcmp(last_arg, cast[*uint8]("]")) != 0:
      print_err(cast[*uint8]("[: missing ']'\n"))
      syscall1(SYS_exit, 2)
    argc = argc - 1  # ignore last ']'

  # Need at least 2 args (test EXPRESSION)
  if argc < 2:
    syscall1(SYS_exit, 1)

  arg1: *uint8 = get_argv(1)

  # Unary operators (need 2 args: test -f file)
  if argc == 3:
    arg2: *uint8 = get_argv(2)

    # File tests
    if strcmp(arg1, cast[*uint8]("-e")) == 0:
      syscall1(SYS_exit, test_file_exists(arg2))

    if strcmp(arg1, cast[*uint8]("-f")) == 0:
      syscall1(SYS_exit, test_regular_file(arg2))

    if strcmp(arg1, cast[*uint8]("-d")) == 0:
      syscall1(SYS_exit, test_directory(arg2))

    if strcmp(arg1, cast[*uint8]("-r")) == 0:
      syscall1(SYS_exit, test_readable(arg2))

    if strcmp(arg1, cast[*uint8]("-w")) == 0:
      syscall1(SYS_exit, test_writable(arg2))

    if strcmp(arg1, cast[*uint8]("-x")) == 0:
      syscall1(SYS_exit, test_executable(arg2))

    if strcmp(arg1, cast[*uint8]("-s")) == 0:
      syscall1(SYS_exit, test_file_size(arg2))

    # String tests
    if strcmp(arg1, cast[*uint8]("-z")) == 0:
      # empty string
      if strlen(arg2) == 0:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg1, cast[*uint8]("-n")) == 0:
      # non-empty string
      if strlen(arg2) > 0:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

  # Binary operators (need 3 args: test str1 = str2)
  if argc == 4:
    arg2: *uint8 = get_argv(2)
    arg3: *uint8 = get_argv(3)

    # String comparison
    if strcmp(arg2, cast[*uint8]("=")) == 0:
      if strcmp(arg1, arg3) == 0:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("!=")) == 0:
      if strcmp(arg1, arg3) != 0:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    # Integer comparison
    val1: int32 = atoi(arg1)
    val3: int32 = atoi(arg3)

    if strcmp(arg2, cast[*uint8]("-eq")) == 0:
      if val1 == val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("-ne")) == 0:
      if val1 != val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("-lt")) == 0:
      if val1 < val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("-le")) == 0:
      if val1 <= val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("-gt")) == 0:
      if val1 > val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

    if strcmp(arg2, cast[*uint8]("-ge")) == 0:
      if val1 >= val3:
        syscall1(SYS_exit, 0)
      else:
        syscall1(SYS_exit, 1)

  # Unknown or unsupported test
  syscall1(SYS_exit, 1)
