# clear - Clear screen to a color
# Usage: clear [color]
# Color format: 0xRRGGBB hex (e.g., 0xFF0000 for red)
# Default: 0x000000 (black)

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

FBIOGET_VSCREENINFO: int32 = 0x4600

def parse_hex(s: *uint8) -> int32:
    n: int32 = 0
    i: int32 = 0

    # Handle hex prefix
    if s[0] == cast[uint8](48) and s[1] == cast[uint8](120):  # "0x"
        i = 2
        while s[i] != cast[uint8](0):
            c: uint8 = s[i]
            n = n * 16
            if c >= cast[uint8](48) and c <= cast[uint8](57):
                n = n + cast[int32](c) - 48
            if c >= cast[uint8](97) and c <= cast[uint8](102):  # a-f
                n = n + cast[int32](c) - 87
            if c >= cast[uint8](65) and c <= cast[uint8](70):  # A-F
                n = n + cast[int32](c) - 55
            i = i + 1
        return n

    # Parse decimal
    while s[i] != cast[uint8](0):
        if s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
            n = n * 10 + cast[int32](s[i]) - 48
        i = i + 1

    return n

def main() -> int32:
    argc: int32 = get_argc()

    # Default color: black
    color: int32 = 0x000000

    # Parse color argument if provided
    if argc > 1:
        color = parse_hex(get_argv(1))

    fd: int32 = open("/dev/fb0", O_RDWR, 0)
    if fd < 0:
        perror("Error: Cannot open /dev/fb0")
        return 1

    # Get screen info
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 160
    _ = syscall1(SYS_brk, new_brk)
    vinfo: *uint32 = cast[*uint32](old_brk)

    result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    if result < 0:
        perror("Error: Cannot get screen info")
        _ = close(fd)
        return 1

    # Extract screen parameters
    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])
    bpp: int32 = cast[int32](vinfo[6])
    bytes_per_pixel: int32 = bpp / 8
    screen_size: int32 = xres * yres * bytes_per_pixel

    # Allocate buffer (4KB)
    buffer_brk: int32 = syscall1(SYS_brk, 0)
    buffer_size: int32 = 4096
    _ = syscall1(SYS_brk, buffer_brk + buffer_size)
    buffer: *uint32 = cast[*uint32](buffer_brk)

    # Fill buffer with color
    i: int32 = 0
    while i < buffer_size / 4:
        buffer[i] = cast[uint32](color)
        i = i + 1

    # Seek to start of framebuffer
    _ = lseek(fd, 0, SEEK_SET)

    # Write buffer repeatedly to fill screen
    written: int32 = 0
    while written < screen_size:
        to_write: int32 = buffer_size
        if written + to_write > screen_size:
            to_write = screen_size - written

        bytes_written: int32 = write(fd, cast[*uint8](buffer), to_write)
        if bytes_written > 0:
            written = written + bytes_written
        else:
            written = screen_size

    _ = close(fd)
    return 0
