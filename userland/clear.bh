# clear - Clear screen to a color
# Usage: clear [color]
# Color format: 0xRRGGBB hex (e.g., 0xFF0000 for red)
# Default: 0x000000 (black)

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

const FBIOGET_VSCREENINFO: int32 = 0x4600

proc parse_hex(s: ptr uint8): int32 =
  var n: int32 = 0
  var i: int32 = 0

  # Handle hex prefix
  if s[0] == cast[uint8](48) and s[1] == cast[uint8](120):  # "0x"
    i = 2
    while s[i] != cast[uint8](0):
      var c: uint8 = s[i]
      n = n * 16
      if c >= cast[uint8](48) and c <= cast[uint8](57):
        n = n + cast[int32](c) - 48
      if c >= cast[uint8](97) and c <= cast[uint8](102):  # a-f
        n = n + cast[int32](c) - 87
      if c >= cast[uint8](65) and c <= cast[uint8](70):  # A-F
        n = n + cast[int32](c) - 55
      i = i + 1
    return n

  # Parse decimal
  while s[i] != cast[uint8](0):
    if s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
      n = n * 10 + cast[int32](s[i]) - 48
    i = i + 1

  return n

proc main(): int32 =
  var argc: int32 = get_argc()

  # Default color: black
  var color: int32 = 0x000000

  # Parse color argument if provided
  if argc > 1:
    color = parse_hex(get_argv(1))

  var fd: int32 = open("/dev/fb0", O_RDWR, 0)
  if fd < 0:
    perror("Error: Cannot open /dev/fb0")
    return 1

  # Get screen info
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 160
  discard syscall1(SYS_brk, new_brk)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)

  var result: int32 = syscall3(SYS_ioctl, fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if result < 0:
    perror("Error: Cannot get screen info")
    discard close(fd)
    return 1

  # Extract screen parameters
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])
  var bpp: int32 = cast[int32](vinfo[6])
  var bytes_per_pixel: int32 = bpp / 8
  var screen_size: int32 = xres * yres * bytes_per_pixel

  # Allocate buffer (4KB)
  var buffer_brk: int32 = syscall1(SYS_brk, 0)
  var buffer_size: int32 = 4096
  discard syscall1(SYS_brk, buffer_brk + buffer_size)
  var buffer: ptr uint32 = cast[ptr uint32](buffer_brk)

  # Fill buffer with color
  var i: int32 = 0
  while i < buffer_size / 4:
    buffer[i] = cast[uint32](color)
    i = i + 1

  # Seek to start of framebuffer
  discard lseek(fd, 0, SEEK_SET)

  # Write buffer repeatedly to fill screen
  var written: int32 = 0
  while written < screen_size:
    var to_write: int32 = buffer_size
    if written + to_write > screen_size:
      to_write = screen_size - written

    var bytes_written: int32 = write(fd, cast[ptr uint8](buffer), to_write)
    if bytes_written > 0:
      written = written + bytes_written
    else:
      written = screen_size

  discard close(fd)
  return 0
