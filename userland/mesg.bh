# mesg - Control message receiving on terminal
# Usage: mesg [y|n]
#   mesg     - Show current state
#   mesg y   - Allow messages (make tty writable by group)
#   mesg n   - Deny messages (make tty not writable by group)
# Uses SYS_fstat and SYS_chmod on /dev/tty

from lib.syscalls import *

# File mode bits
const S_IWGRP: int32 = 0x0010  # Group write permission

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

def main():
    # Allocate memory for stat buffer and tty path
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    _ = syscall1(SYS_brk, new_brk)

    tty_path: *uint8 = cast[*uint8](old_brk)
    link_path: *uint8 = cast[*uint8](old_brk + 256)
    statbuf: *int32 = cast[*int32](old_brk + 512)

    # Build /proc/self/fd/0 path
    link_path[0] = cast[uint8](47)   # /
    link_path[1] = cast[uint8](112)  # p
    link_path[2] = cast[uint8](114)  # r
    link_path[3] = cast[uint8](111)  # o
    link_path[4] = cast[uint8](99)   # c
    link_path[5] = cast[uint8](47)   # /
    link_path[6] = cast[uint8](115)  # s
    link_path[7] = cast[uint8](101)  # e
    link_path[8] = cast[uint8](108)  # l
    link_path[9] = cast[uint8](102)  # f
    link_path[10] = cast[uint8](47)  # /
    link_path[11] = cast[uint8](102) # f
    link_path[12] = cast[uint8](100) # d
    link_path[13] = cast[uint8](47)  # /
    link_path[14] = cast[uint8](48)  # 0
    link_path[15] = cast[uint8](0)

    # Read tty path
    ret: int32 = syscall3(SYS_readlink, cast[int32](link_path), cast[int32](tty_path), 255)
    if ret < 0:
        print_err(cast[*uint8]("mesg: not a tty\n"))
        _ = syscall1(SYS_exit, 2)

    # Null-terminate tty path
    tty_path[ret] = cast[uint8](0)

    # Open tty device
    fd: int32 = syscall2(SYS_open, cast[int32](tty_path), O_RDWR)
    if fd < 0:
        print_err(cast[*uint8]("mesg: cannot open tty\n"))
        _ = syscall1(SYS_exit, 2)

    # Get file stats
    ret = syscall2(SYS_fstat, fd, cast[int32](statbuf))
    if ret < 0:
        print_err(cast[*uint8]("mesg: cannot stat tty\n"))
        _ = syscall1(SYS_close, fd)
        _ = syscall1(SYS_exit, 2)

    # stat struct: st_mode is at offset 16 (4 + 8 + 4)
    mode_ptr: *uint8 = cast[*uint8](statbuf)
    b0: int32 = cast[int32](mode_ptr[16])
    b1: int32 = cast[int32](mode_ptr[17]) << 8
    b2: int32 = cast[int32](mode_ptr[18]) << 16
    b3: int32 = cast[int32](mode_ptr[19]) << 24
    mode: int32 = b0 + b1 + b2 + b3

    argc: int32 = get_argc()

    # No arguments - show current state
    if argc == 1:
        has_write: int32 = mode & S_IWGRP
        if has_write != 0:
            print(cast[*uint8]("is y\n"))
            _ = syscall1(SYS_close, fd)
            _ = syscall1(SYS_exit, 0)
        if has_write == 0:
            print(cast[*uint8]("is n\n"))
            _ = syscall1(SYS_close, fd)
            _ = syscall1(SYS_exit, 1)

    arg: *uint8 = get_argv(1)

    # mesg y - enable messages
    cmp_y: int32 = strcmp(arg, cast[*uint8]("y"))
    if cmp_y == 0:
        new_mode: int32 = mode | S_IWGRP
        ret = syscall2(SYS_chmod, cast[int32](tty_path), new_mode)
        if ret < 0:
            print_err(cast[*uint8]("mesg: cannot change tty mode\n"))
            _ = syscall1(SYS_close, fd)
            _ = syscall1(SYS_exit, 2)
        _ = syscall1(SYS_close, fd)
        _ = syscall1(SYS_exit, 0)

    # mesg n - disable messages
    cmp_n: int32 = strcmp(arg, cast[*uint8]("n"))
    if cmp_n == 0:
        new_mode: int32 = mode & (S_IWGRP ^ -1)
        ret = syscall2(SYS_chmod, cast[int32](tty_path), new_mode)
        if ret < 0:
            print_err(cast[*uint8]("mesg: cannot change tty mode\n"))
            _ = syscall1(SYS_close, fd)
            _ = syscall1(SYS_exit, 2)
        _ = syscall1(SYS_close, fd)
        _ = syscall1(SYS_exit, 0)

    # Invalid argument
    print_err(cast[*uint8]("Usage: mesg [y|n]\n"))
    _ = syscall1(SYS_close, fd)
    _ = syscall1(SYS_exit, 2)
