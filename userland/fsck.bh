from lib.syscalls import *

BRFS_BLOCK_SIZE: Final[int32] = 1024
BRFS_MAGIC: Final[int32] = 1112560962
BRFS_INODE_SIZE: Final[int32] = 32
BRFS_INODES_PER_BLOCK: Final[int32] = 32
BRFS_ROOT_INODE: Final[int32] = 1
BRFS_DIRENTRY_SIZE: Final[int32] = 32
BRFS_S_IFREG: Final[int32] = 32768
BRFS_S_IFDIR: Final[int32] = 16384
BRFS_S_IFLNK: Final[int32] = 40960
BRFS_JOURNAL_MAGIC: Final[int32] = 4870734
BRFS_JOURNAL_BLOCKS: Final[int32] = 32
BRFS_JOURNAL_START: Final[int32] = 1
BRFS_JRN_COMMIT: Final[int32] = 1
BRFS_JRN_BLOCK: Final[int32] = 2

extern def get_argc() -> int32

extern def get_argv(i: int32) -> Ptr[uint8]

fd: int32 = -1

readonly_mode: int32 = 0

auto_yes: int32 = 0

force_check: int32 = 0

errors_found: int32 = 0

errors_fixed: int32 = 0

sb_magic: int32 = 0

sb_version: int32 = 0

sb_total_blocks: int32 = 0

sb_total_inodes: int32 = 0

sb_free_blocks: int32 = 0

sb_free_inodes: int32 = 0

sb_block_bitmap_start: int32 = 0

sb_inode_bitmap_start: int32 = 0

sb_inode_table_start: int32 = 0

sb_data_start: int32 = 0

block_buf: Ptr[uint8] = Ptr[uint8](0)

inode_bitmap: Ptr[uint8] = Ptr[uint8](0)

block_bitmap: Ptr[uint8] = Ptr[uint8](0)

computed_inode_bitmap: Ptr[uint8] = Ptr[uint8](0)

computed_block_bitmap: Ptr[uint8] = Ptr[uint8](0)

link_counts: Ptr[int32] = Ptr[int32](0)

def print_err(msg: Ptr[uint8]):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDERR, cast[int32](msg), len)

def print_out(msg: Ptr[uint8]):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDOUT, cast[int32](msg), len)

def print_num(n: int32):
    if (n == 0):

        syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
        return
    num: int32 = n
    neg: int32 = 0
    if (num < 0):
        neg = 1
        num = (0 - num)

        syscall3(SYS_write, STDOUT, cast[int32]("-"), 1)
    buf: Array[12, uint8]
    i: int32 = 0
    while (num > 0):
        buf[i] = cast[uint8]((48 + (num % 10)))
        num = (num / 10)
        i = (i + 1)
    j: int32 = 0
    while (j < (i / 2)):
        tmp: uint8 = buf[j]
        buf[j] = buf[((i - 1) - j)]
        buf[((i - 1) - j)] = tmp
        j = (j + 1)
    syscall3(SYS_write, STDOUT, cast[int32](addr(buf[0])), i)

def read_block(blk: int32, buf: Ptr[uint8]) -> int32:
    offset: int32 = (blk * BRFS_BLOCK_SIZE)
    ret: int32 = syscall3(SYS_lseek, fd, offset, SEEK_SET)
    if (ret < 0):
        return -1
    ret = syscall3(SYS_read, fd, cast[int32](buf), BRFS_BLOCK_SIZE)
    if (ret != BRFS_BLOCK_SIZE):
        return -1
    return 0

def write_block(blk: int32, buf: Ptr[uint8]) -> int32:
    if (readonly_mode != 0):
        return -1
    offset: int32 = (blk * BRFS_BLOCK_SIZE)
    ret: int32 = syscall3(SYS_lseek, fd, offset, SEEK_SET)
    if (ret < 0):
        return -1
    ret = syscall3(SYS_write, fd, cast[int32](buf), BRFS_BLOCK_SIZE)
    if (ret != BRFS_BLOCK_SIZE):
        return -1
    return 0

def read32(buf: Ptr[uint8]) -> int32:
    p: Ptr[int32] = Ptr[int32](buf)
    return p[0]

def write32(buf: Ptr[uint8], val: int32):
    p: Ptr[int32] = Ptr[int32](buf)
    p[0] = val

def read16(buf: Ptr[uint8]) -> int32:
    p: Ptr[int16] = Ptr[int16](buf)
    return cast[int32](p[0])

def bitmap_get(bm: Ptr[uint8], bit: int32) -> int32:
    byte_idx: int32 = (bit / 8)
    bit_idx: int32 = (bit % 8)
    b: uint8 = bm[byte_idx]
    if ((cast[int32](b) & (1 << bit_idx)) != 0):
        return 1
    return 0

def bitmap_set(bm: Ptr[uint8], bit: int32):
    byte_idx: int32 = (bit / 8)
    bit_idx: int32 = (bit % 8)
    bm[byte_idx] = cast[uint8]((cast[int32](bm[byte_idx]) | (1 << bit_idx)))

def bitmap_clear(bm: Ptr[uint8], bit: int32):
    byte_idx: int32 = (bit / 8)
    bit_idx: int32 = (bit % 8)
    bm[byte_idx] = cast[uint8]((cast[int32](bm[byte_idx]) & (255 - (1 << bit_idx))))

def ask_fix(msg: Ptr[uint8]) -> int32:
    if (readonly_mode != 0):
        return 0
    if (auto_yes != 0):
        print_out(msg)
        print_out(Ptr[uint8](" (auto-fixed)\n"))
        return 1
    print_out(msg)
    print_out(Ptr[uint8](" Fix? [y/n] "))
    print_out(Ptr[uint8]("(skipped - use -y for auto-fix)\n"))
    return 0

def check_superblock() -> int32:
    print_out(Ptr[uint8]("Phase 1: Checking superblock...\n"))
    if (read_block(0, block_buf) != 0):
        print_err(Ptr[uint8]("fsck: cannot read superblock\n"))
        return -1
    sb_magic = read32(block_buf)
    if (sb_magic != BRFS_MAGIC):
        print_err(Ptr[uint8]("fsck: bad magic number - not a BrainFS filesystem\n"))
        errors_found = (errors_found + 1)
        return -1
    sb_version = read32(addr(block_buf[4]))
    sb_total_blocks = read32(addr(block_buf[8]))
    sb_total_inodes = read32(addr(block_buf[12]))
    sb_free_blocks = read32(addr(block_buf[16]))
    sb_free_inodes = read32(addr(block_buf[20]))
    sb_block_bitmap_start = read32(addr(block_buf[24]))
    sb_inode_bitmap_start = read32(addr(block_buf[28]))
    sb_inode_table_start = read32(addr(block_buf[32]))
    sb_data_start = read32(addr(block_buf[36]))
    print_out(Ptr[uint8]("  Version: "))
    print_num(sb_version)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Total blocks: "))
    print_num(sb_total_blocks)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Total inodes: "))
    print_num(sb_total_inodes)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Free blocks: "))
    print_num(sb_free_blocks)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Free inodes: "))
    print_num(sb_free_inodes)
    print_out(Ptr[uint8]("\n"))
    if (sb_block_bitmap_start < 1):
        print_err(Ptr[uint8]("  ERROR: Invalid block bitmap start\n"))
        errors_found = (errors_found + 1)
    if (sb_inode_table_start <= sb_inode_bitmap_start):
        print_err(Ptr[uint8]("  ERROR: Invalid inode table layout\n"))
        errors_found = (errors_found + 1)
    if (sb_data_start <= sb_inode_table_start):
        print_err(Ptr[uint8]("  ERROR: Invalid data area layout\n"))
        errors_found = (errors_found + 1)
    return 0

def check_journal() -> int32:
    print_out(Ptr[uint8]("Phase 2: Checking journal...\n"))
    if (sb_version < 2):
        print_out(Ptr[uint8]("  No journal (version 1 filesystem)\n"))
        return 0
    if (read_block(BRFS_JOURNAL_START, block_buf) != 0):
        print_err(Ptr[uint8]("  ERROR: Cannot read journal superblock\n"))
        errors_found = (errors_found + 1)
        return -1
    jrn_magic: int32 = read32(block_buf)
    if (jrn_magic != BRFS_JOURNAL_MAGIC):
        print_out(Ptr[uint8]("  Journal not initialized or corrupt\n"))
        return 0
    jrn_seq: int32 = read32(addr(block_buf[4]))
    jrn_head: int32 = read32(addr(block_buf[8]))
    jrn_tail: int32 = read32(addr(block_buf[12]))
    print_out(Ptr[uint8]("  Journal sequence: "))
    print_num(jrn_seq)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Head: "))
    print_num(jrn_head)
    print_out(Ptr[uint8](", Tail: "))
    print_num(jrn_tail)
    print_out(Ptr[uint8]("\n"))
    if (jrn_head != jrn_tail):
        print_out(Ptr[uint8]("  WARNING: Uncommitted journal entries found\n"))
        if (ask_fix(Ptr[uint8]("  Replay journal?")) != 0):
            print_out(Ptr[uint8]("  Journal replay not yet implemented\n"))
    else:
        print_out(Ptr[uint8]("  Journal is clean\n"))
    return 0

def load_bitmaps() -> int32:
    print_out(Ptr[uint8]("Phase 3: Loading bitmaps...\n"))
    if (read_block(sb_inode_bitmap_start, inode_bitmap) != 0):
        print_err(Ptr[uint8]("  ERROR: Cannot read inode bitmap\n"))
        return -1
    if (read_block(sb_block_bitmap_start, block_bitmap) != 0):
        print_err(Ptr[uint8]("  ERROR: Cannot read block bitmap\n"))
        return -1
    i: int32 = 0
    while (i < BRFS_BLOCK_SIZE):
        computed_inode_bitmap[i] = cast[uint8](0)
        computed_block_bitmap[i] = cast[uint8](0)
        i = (i + 1)
    i = 0
    while (i < sb_data_start):
        bitmap_set(computed_block_bitmap, i)
        i = (i + 1)
    print_out(Ptr[uint8]("  Bitmaps loaded\n"))
    return 0

def check_inode(ino: int32) -> int32:
    inodes_per_block: int32 = BRFS_INODES_PER_BLOCK
    block_idx: int32 = (ino / inodes_per_block)
    offset_in_block: int32 = ((ino % inodes_per_block) * BRFS_INODE_SIZE)
    if (read_block((sb_inode_table_start + block_idx), block_buf) != 0):
        return -1
    inode_ptr: Ptr[uint8] = addr(block_buf[offset_in_block])
    mode: int32 = read16(inode_ptr)
    nlink: int32 = read16(addr(inode_ptr[2]))
    size: int32 = read32(addr(inode_ptr[8]))
    block0: int32 = read32(addr(inode_ptr[12]))
    block1: int32 = read32(addr(inode_ptr[16]))
    block2: int32 = read32(addr(inode_ptr[20]))
    if (mode == 0):
        return 0
    bitmap_set(computed_inode_bitmap, ino)
    file_type: int32 = (mode & 61440)
    if (((file_type != BRFS_S_IFREG) and (file_type != BRFS_S_IFDIR)) and (file_type != BRFS_S_IFLNK)):
        print_out(Ptr[uint8]("  Inode "))
        print_num(ino)
        print_out(Ptr[uint8](": Invalid mode "))
        print_num(mode)
        print_out(Ptr[uint8]("\n"))
        errors_found = (errors_found + 1)
    if ((block0 > 0) and (block0 < sb_total_blocks)):
        if (block0 >= sb_data_start):
            bitmap_set(computed_block_bitmap, block0)
    else:
        if (block0 != 0):
            print_out(Ptr[uint8]("  Inode "))
            print_num(ino)
            print_out(Ptr[uint8](": Invalid block pointer "))
            print_num(block0)
            print_out(Ptr[uint8]("\n"))
            errors_found = (errors_found + 1)
    if ((block1 > 0) and (block1 < sb_total_blocks)):
        if (block1 >= sb_data_start):
            bitmap_set(computed_block_bitmap, block1)
    if ((block2 > 0) and (block2 < sb_total_blocks)):
        if (block2 >= sb_data_start):
            bitmap_set(computed_block_bitmap, block2)
    link_counts[ino] = nlink
    return 0

def check_inodes() -> int32:
    print_out(Ptr[uint8]("Phase 4: Checking inodes...\n"))
    used_count: int32 = 0
    i: int32 = 1
    while (i < sb_total_inodes):
        if (check_inode(i) != 0):
            print_err(Ptr[uint8]("  ERROR: Cannot read inode "))
            print_num(i)
            print_err(Ptr[uint8]("\n"))
        if (bitmap_get(computed_inode_bitmap, i) != 0):
            used_count = (used_count + 1)
        i = (i + 1)
    print_out(Ptr[uint8]("  Found "))
    print_num(used_count)
    print_out(Ptr[uint8](" used inodes\n"))
    if (bitmap_get(computed_inode_bitmap, BRFS_ROOT_INODE) == 0):
        print_err(Ptr[uint8]("  ERROR: Root inode not allocated!\n"))
        errors_found = (errors_found + 1)
    return 0

def check_directory(ino: int32, parent_ino: int32) -> int32:
    inodes_per_block: int32 = BRFS_INODES_PER_BLOCK
    block_idx: int32 = (ino / inodes_per_block)
    offset_in_block: int32 = ((ino % inodes_per_block) * BRFS_INODE_SIZE)
    if (read_block((sb_inode_table_start + block_idx), block_buf) != 0):
        return -1
    inode_ptr: Ptr[uint8] = addr(block_buf[offset_in_block])
    mode: int32 = read16(inode_ptr)
    size: int32 = read32(addr(inode_ptr[8]))
    block0: int32 = read32(addr(inode_ptr[12]))
    if ((mode & 61440) != BRFS_S_IFDIR):
        return 0
    if (block0 == 0):
        return 0
    dir_buf: Ptr[uint8] = computed_inode_bitmap
    if (read_block(block0, dir_buf) != 0):
        return -1
    has_dot: int32 = 0
    has_dotdot: int32 = 0
    entries: int32 = (size / BRFS_DIRENTRY_SIZE)
    i: int32 = 0
    while (i < entries):
        entry_ptr: Ptr[uint8] = addr(dir_buf[(i * BRFS_DIRENTRY_SIZE)])
        entry_ino: int32 = read32(entry_ptr)
        name_ptr: Ptr[uint8] = addr(entry_ptr[4])
        if (entry_ino > 0):
            if (entry_ino >= sb_total_inodes):
                print_out(Ptr[uint8]("  Dir entry '"))
                print_out(name_ptr)
                print_out(Ptr[uint8]("' points to invalid inode "))
                print_num(entry_ino)
                print_out(Ptr[uint8]("\n"))
                errors_found = (errors_found + 1)
            else:
                if (bitmap_get(computed_inode_bitmap, entry_ino) == 0):
                    print_out(Ptr[uint8]("  Dir entry '"))
                    print_out(name_ptr)
                    print_out(Ptr[uint8]("' points to unallocated inode "))
                    print_num(entry_ino)
                    print_out(Ptr[uint8]("\n"))
                    errors_found = (errors_found + 1)
            if (name_ptr[0] == cast[uint8](46)):
                if (name_ptr[1] == cast[uint8](0)):
                    has_dot = 1
                    if (entry_ino != ino):
                        print_out(Ptr[uint8]("  '.' entry points to wrong inode\n"))
                        errors_found = (errors_found + 1)
                else:
                    if ((name_ptr[1] == cast[uint8](46)) and (name_ptr[2] == cast[uint8](0))):
                        has_dotdot = 1
                        if (entry_ino != parent_ino):
                            print_out(Ptr[uint8]("  '..' entry points to wrong inode\n"))
                            errors_found = (errors_found + 1)
        i = (i + 1)
    if (has_dot == 0):
        print_out(Ptr[uint8]("  Directory inode "))
        print_num(ino)
        print_out(Ptr[uint8](" missing '.' entry\n"))
        errors_found = (errors_found + 1)
    if (has_dotdot == 0):
        print_out(Ptr[uint8]("  Directory inode "))
        print_num(ino)
        print_out(Ptr[uint8](" missing '..' entry\n"))
        errors_found = (errors_found + 1)
    return 0

def check_directories() -> int32:
    print_out(Ptr[uint8]("Phase 5: Checking directories...\n"))
    check_directory(BRFS_ROOT_INODE, BRFS_ROOT_INODE)
    print_out(Ptr[uint8]("  Root directory checked\n"))
    return 0

def compare_bitmaps() -> int32:
    print_out(Ptr[uint8]("Phase 6: Comparing bitmaps...\n"))
    inode_mismatches: int32 = 0
    block_mismatches: int32 = 0
    i: int32 = 1
    while (i < sb_total_inodes):
        stored: int32 = bitmap_get(inode_bitmap, i)
        computed: int32 = bitmap_get(computed_inode_bitmap, i)
        if (stored != computed):
            if (inode_mismatches < 5):
                print_out(Ptr[uint8]("  Inode "))
                print_num(i)
                if (stored != 0):
                    print_out(Ptr[uint8](": marked used but is free\n"))
                else:
                    print_out(Ptr[uint8](": marked free but is used\n"))
            inode_mismatches = (inode_mismatches + 1)
        i = (i + 1)
    if (inode_mismatches > 0):
        print_out(Ptr[uint8]("  Found "))
        print_num(inode_mismatches)
        print_out(Ptr[uint8](" inode bitmap mismatches\n"))
        errors_found = (errors_found + inode_mismatches)
        if (ask_fix(Ptr[uint8]("  Fix inode bitmap?")) != 0):
            if (write_block(sb_inode_bitmap_start, computed_inode_bitmap) == 0):
                print_out(Ptr[uint8]("  Inode bitmap fixed\n"))
                errors_fixed = (errors_fixed + inode_mismatches)
    i = sb_data_start
    while (i < sb_total_blocks):
        stored: int32 = bitmap_get(block_bitmap, i)
        computed: int32 = bitmap_get(computed_block_bitmap, i)
        if (stored != computed):
            if (block_mismatches < 5):
                print_out(Ptr[uint8]("  Block "))
                print_num(i)
                if (stored != 0):
                    print_out(Ptr[uint8](": marked used but is free\n"))
                else:
                    print_out(Ptr[uint8](": marked free but is used\n"))
            block_mismatches = (block_mismatches + 1)
        i = (i + 1)
    if (block_mismatches > 0):
        print_out(Ptr[uint8]("  Found "))
        print_num(block_mismatches)
        print_out(Ptr[uint8](" block bitmap mismatches\n"))
        errors_found = (errors_found + block_mismatches)
        if (ask_fix(Ptr[uint8]("  Fix block bitmap?")) != 0):
            if (write_block(sb_block_bitmap_start, computed_block_bitmap) == 0):
                print_out(Ptr[uint8]("  Block bitmap fixed\n"))
                errors_fixed = (errors_fixed + block_mismatches)
    if ((inode_mismatches == 0) and (block_mismatches == 0)):
        print_out(Ptr[uint8]("  Bitmaps are consistent\n"))
    return 0

def update_free_counts() -> int32:
    free_inodes: int32 = 0
    free_blocks: int32 = 0
    i: int32 = 1
    while (i < sb_total_inodes):
        if (bitmap_get(computed_inode_bitmap, i) == 0):
            free_inodes = (free_inodes + 1)
        i = (i + 1)
    i = sb_data_start
    while (i < sb_total_blocks):
        if (bitmap_get(computed_block_bitmap, i) == 0):
            free_blocks = (free_blocks + 1)
        i = (i + 1)
    if ((free_inodes != sb_free_inodes) or (free_blocks != sb_free_blocks)):
        print_out(Ptr[uint8]("  Free counts mismatch:\n"))
        print_out(Ptr[uint8]("    Stored: "))
        print_num(sb_free_inodes)
        print_out(Ptr[uint8](" inodes, "))
        print_num(sb_free_blocks)
        print_out(Ptr[uint8](" blocks\n"))
        print_out(Ptr[uint8]("    Actual: "))
        print_num(free_inodes)
        print_out(Ptr[uint8](" inodes, "))
        print_num(free_blocks)
        print_out(Ptr[uint8](" blocks\n"))
        errors_found = (errors_found + 1)
        if (ask_fix(Ptr[uint8]("  Update superblock?")) != 0):
            if (read_block(0, block_buf) == 0):
                write32(addr(block_buf[16]), free_blocks)
                write32(addr(block_buf[20]), free_inodes)
                if (write_block(0, block_buf) == 0):
                    print_out(Ptr[uint8]("  Superblock updated\n"))
                    errors_fixed = (errors_fixed + 1)
    return 0

def alloc_buffers() -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    need: int32 = ((1024 * 5) + 4096)
    new_brk: int32 = (old_brk + need)
    if (syscall1(SYS_brk, new_brk) < new_brk):
        return -1
    block_buf = Ptr[uint8](old_brk)
    inode_bitmap = Ptr[uint8]((old_brk + 1024))
    block_bitmap = Ptr[uint8]((old_brk + 2048))
    computed_inode_bitmap = Ptr[uint8]((old_brk + 3072))
    computed_block_bitmap = Ptr[uint8]((old_brk + 4096))
    link_counts = Ptr[int32]((old_brk + 5120))
    return 0

def main():
    argc: int32 = get_argc()
    if (argc < 2):
        print_err(Ptr[uint8]("Usage: fsck [-n] [-y] [-f] device\n"))
        print_err(Ptr[uint8]("  -n  No changes (read-only check)\n"))
        print_err(Ptr[uint8]("  -y  Assume yes to all repairs\n"))
        print_err(Ptr[uint8]("  -f  Force check even if clean\n"))

        syscall1(SYS_exit, 1)
    device: Ptr[uint8] = Ptr[uint8](0)
    i: int32 = 1
    while (i < argc):
        arg: Ptr[uint8] = get_argv(i)
        if (arg[0] == cast[uint8](45)):
            if (arg[1] == cast[uint8](110)):
                readonly_mode = 1
            if (arg[1] == cast[uint8](121)):
                auto_yes = 1
            if (arg[1] == cast[uint8](102)):
                force_check = 1
        else:
            device = arg
        i = (i + 1)
    if (cast[int32](device) == 0):
        print_err(Ptr[uint8]("fsck: no device specified\n"))

        syscall1(SYS_exit, 1)
    print_out(Ptr[uint8]("fsck - BrainFS filesystem check\n"))
    print_out(Ptr[uint8]("Device: "))
    print_out(device)
    print_out(Ptr[uint8]("\n"))
    if (readonly_mode != 0):
        print_out(Ptr[uint8]("(read-only mode)\n"))
    if (alloc_buffers() != 0):
        print_err(Ptr[uint8]("fsck: cannot allocate memory\n"))

        syscall1(SYS_exit, 1)
    flags: int32 = O_RDONLY
    if (readonly_mode == 0):
        flags = O_RDWR
    fd = syscall2(SYS_open, cast[int32](device), flags)
    if (fd < 0):
        print_err(Ptr[uint8]("fsck: cannot open device\n"))

        syscall1(SYS_exit, 1)
    print_out(Ptr[uint8]("\n"))
    if (check_superblock() != 0):

        syscall1(SYS_close, fd)

        syscall1(SYS_exit, 1)
    check_journal()
    if (load_bitmaps() != 0):

        syscall1(SYS_close, fd)

        syscall1(SYS_exit, 1)
    check_inodes()
    check_directories()
    compare_bitmaps()
    update_free_counts()
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("Summary:\n"))
    print_out(Ptr[uint8]("  Errors found: "))
    print_num(errors_found)
    print_out(Ptr[uint8]("\n"))
    print_out(Ptr[uint8]("  Errors fixed: "))
    print_num(errors_fixed)
    print_out(Ptr[uint8]("\n"))
    syscall1(SYS_close, fd)
    if ((errors_found > 0) and (errors_fixed < errors_found)):
        print_out(Ptr[uint8]("\nFilesystem has errors!\n"))

        syscall1(SYS_exit, 1)
    if (errors_found == 0):
        print_out(Ptr[uint8]("\nFilesystem is clean.\n"))
    else:
        print_out(Ptr[uint8]("\nFilesystem repaired.\n"))
    syscall1(SYS_exit, 0)