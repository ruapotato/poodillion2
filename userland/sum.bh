# sum - Checksum and count blocks
# Usage: sum FILE
# BSD checksum: rotate and add bytes
# Print: checksum blocks filename
# Part of BrainhairOS math utilities

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45

const STDIN: int32 = 0
const STDOUT: int32 = 1
const STDERR: int32 = 2

const O_RDONLY: int32 = 0

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

# String length
proc strlen(s: ptr uint8): int32 =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    i = i + 1
  return i

# Print string
proc print(s: ptr uint8) =
  var len: int32 = strlen(s)
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

# Print error
proc print_err(s: ptr uint8) =
  var len: int32 = strlen(s)
  discard syscall3(SYS_write, STDERR, cast[int32](s), len)

# Print unsigned integer
proc print_uint(n: uint32) =
  if n == cast[uint32](0):
    discard syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
    return

  # Allocate buffer for digits
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 32
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)

  var i: int32 = 0
  var num: uint32 = n

  # Build string in reverse
  while num > cast[uint32](0):
    var digit: uint32 = num % cast[uint32](10)
    buffer[i] = cast[uint8](48 + cast[int32](digit))
    num = num / cast[uint32](10)
    i = i + 1

  # Print in reverse order
  var j: int32 = i - 1
  while j >= 0:
    discard syscall3(SYS_write, STDOUT, cast[int32](buffer + j), 1)
    j = j - 1

# BSD checksum algorithm
# Rotate right by 1 and add byte
proc bsd_checksum(fd: int32, byte_count: ptr uint32): uint32 =
  var checksum: uint32 = cast[uint32](0)
  var total_bytes: uint32 = cast[uint32](0)

  # Allocate buffer (4096 bytes)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)

  var running: int32 = 1
  while running != 0:
    var n: int32 = syscall3(SYS_read, fd, cast[int32](buffer), 4096)

    if n <= 0:
      running = 0
    else:
      var i: int32 = 0
      while i < n:
        # Rotate checksum right by 1 bit (within 16 bits)
        var bit: uint32 = checksum & cast[uint32](1)
        checksum = checksum / cast[uint32](2)
        if bit != cast[uint32](0):
          checksum = checksum | cast[uint32](32768)  # Set bit 15

        # Add byte
        checksum = checksum + cast[uint32](cast[int32](buffer[i]))
        checksum = checksum & cast[uint32](65535)  # Keep in 16 bits

        i = i + 1

      total_bytes = total_bytes + cast[uint32](n)

  byte_count[0] = total_bytes
  return checksum

proc main() =
  var argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[ptr uint8]("Usage: sum FILE\n"))
    discard syscall1(SYS_exit, 1)

  var filename: ptr uint8 = get_argv(1)

  # Open file
  var fd: int32 = syscall2(SYS_open, cast[int32](filename), O_RDONLY)
  if fd < 0:
    print_err(cast[ptr uint8]("sum: cannot open file\n"))
    discard syscall1(SYS_exit, 1)

  # Allocate space for byte count
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 16
  discard syscall1(SYS_brk, new_brk)
  var byte_count_ptr: ptr uint32 = cast[ptr uint32](old_brk)

  # Compute checksum
  var checksum: uint32 = bsd_checksum(fd, byte_count_ptr)

  # Close file
  discard syscall1(SYS_close, fd)

  # Calculate blocks (512-byte blocks, rounded up)
  var blocks: uint32 = (byte_count_ptr[0] + cast[uint32](511)) / cast[uint32](512)

  # Print: checksum blocks filename
  print_uint(checksum)
  discard syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
  print_uint(blocks)
  discard syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
  print(filename)
  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

  discard syscall1(SYS_exit, 0)
