# cut - extract columns/fields from text
# Usage: cut -d DELIM -f FIELDS [file]
#        cut -c CHARS [file]
# Part of BrainhairOS text utilities

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDERR, cast[int32](msg), len)

def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    while s[i] >= cast[uint8](48):
        if s[i] > cast[uint8](57):
            break
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
    return result

def main():
    argc: int32 = get_argc()

    # Allocate buffers
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 16384
    syscall1(SYS_brk, new_brk)

    line_buffer: *uint8 = cast[*uint8](old_brk)
    field_buffer: *uint8 = cast[*uint8](old_brk + 8192)

    # Parse arguments
    delimiter: uint8 = cast[uint8](9)  # tab by default
    field_num: int32 = 1
    char_mode: int32 = 0
    char_start: int32 = 1
    char_end: int32 = -1
    input_fd: int32 = STDIN

    i: int32 = 1
    while i < argc:
        arg: *uint8 = get_argv(i)
        if strcmp(arg, cast[*uint8]("-d")) == 0:
            i = i + 1
            if i >= argc:
                print_err(cast[*uint8]("cut: -d requires delimiter\n"))
                syscall1(SYS_exit, 1)
            delim_arg: *uint8 = get_argv(i)
            delimiter = delim_arg[0]
        if strcmp(arg, cast[*uint8]("-f")) == 0:
            i = i + 1
            if i >= argc:
                print_err(cast[*uint8]("cut: -f requires field number\n"))
                syscall1(SYS_exit, 1)
            field_arg: *uint8 = get_argv(i)
            field_num = parse_int(field_arg)
            if field_num <= 0:
                field_num = 1
        if strcmp(arg, cast[*uint8]("-c")) == 0:
            i = i + 1
            if i >= argc:
                print_err(cast[*uint8]("cut: -c requires char range\n"))
                syscall1(SYS_exit, 1)
            char_arg: *uint8 = get_argv(i)
            char_mode = 1
            char_start = parse_int(char_arg)
            if char_start <= 0:
                char_start = 1
            # Look for dash for range (simplified - just takes first number for now)
        if arg[0] != cast[uint8](45):  # not a flag
            if i == argc - 1:  # last arg is filename
                input_fd = syscall2(SYS_open, cast[int32](arg), O_RDONLY)
                if input_fd < 0:
                    print_err(cast[*uint8]("cut: cannot open file\n"))
                    syscall1(SYS_exit, 1)
        i = i + 1

    # Process input line by line
    line_len: int32 = 0
    running: int32 = 1

    while running != 0:
        c: uint8 = 0
        n: int32 = syscall3(SYS_read, input_fd, cast[int32](addr(c)), 1)

        if n <= 0:
            # Output remaining line if any
            if line_len > 0:
                if char_mode != 0:
                    # Character mode
                    j: int32 = char_start - 1
                    if j >= 0:
                        if j < line_len:
                            syscall3(SYS_write, STDOUT, cast[int32](line_buffer + j), 1)
                    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                else:
                    # Field mode
                    current_field: int32 = 1
                    field_start: int32 = 0
                    field_len: int32 = 0
                    k: int32 = 0
                    while k <= line_len:
                        if k == line_len:
                            if current_field == field_num:
                                syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                                syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                        else:
                            if line_buffer[k] == delimiter:
                                if current_field == field_num:
                                    syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                                    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                                    break
                                current_field = current_field + 1
                                field_start = k + 1
                                field_len = 0
                            else:
                                field_len = field_len + 1
                        k = k + 1
            running = 0
            break

        if c == cast[uint8](10):  # newline
            # Process current line
            if char_mode != 0:
                # Character mode - extract specific character
                j: int32 = char_start - 1
                if j >= 0:
                    if j < line_len:
                        syscall3(SYS_write, STDOUT, cast[int32](line_buffer + j), 1)
                syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
            else:
                # Field mode - extract specific field
                current_field: int32 = 1
                field_start: int32 = 0
                field_len: int32 = 0
                k: int32 = 0
                while k <= line_len:
                    if k == line_len:
                        if current_field == field_num:
                            syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                            syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                    else:
                        if line_buffer[k] == delimiter:
                            if current_field == field_num:
                                syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                                syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                                break
                            current_field = current_field + 1
                            field_start = k + 1
                            field_len = 0
                        else:
                            field_len = field_len + 1
                    k = k + 1

            line_len = 0
        else:
            # Add character to line buffer
            if line_len < 8192:
                line_buffer[line_len] = c
                line_len = line_len + 1

    if input_fd != STDIN:
        syscall1(SYS_close, input_fd)

    syscall1(SYS_exit, 0)
