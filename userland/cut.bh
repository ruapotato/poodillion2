# cut - extract columns/fields from text
# Usage: cut -d DELIM -f FIELDS [file]
#        cut -c CHARS [file]
# Part of BrainhairOS text utilities

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  while s[i] >= cast[uint8](48):
    if s[i] > cast[uint8](57):
      break
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

proc main() =
  var argc: int32 = get_argc()

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 16384
  discard syscall1(SYS_brk, new_brk)

  var line_buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var field_buffer: ptr uint8 = cast[ptr uint8](old_brk + 8192)

  # Parse arguments
  var delimiter: uint8 = cast[uint8](9)  # tab by default
  var field_num: int32 = 1
  var char_mode: int32 = 0
  var char_start: int32 = 1
  var char_end: int32 = -1
  var input_fd: int32 = STDIN

  var i: int32 = 1
  while i < argc:
    var arg: ptr uint8 = get_argv(i)
    if strcmp(arg, cast[ptr uint8]("-d")) == 0:
      i = i + 1
      if i >= argc:
        print_err(cast[ptr uint8]("cut: -d requires delimiter\n"))
        discard syscall1(SYS_exit, 1)
      var delim_arg: ptr uint8 = get_argv(i)
      delimiter = delim_arg[0]
    if strcmp(arg, cast[ptr uint8]("-f")) == 0:
      i = i + 1
      if i >= argc:
        print_err(cast[ptr uint8]("cut: -f requires field number\n"))
        discard syscall1(SYS_exit, 1)
      var field_arg: ptr uint8 = get_argv(i)
      field_num = parse_int(field_arg)
      if field_num <= 0:
        field_num = 1
    if strcmp(arg, cast[ptr uint8]("-c")) == 0:
      i = i + 1
      if i >= argc:
        print_err(cast[ptr uint8]("cut: -c requires char range\n"))
        discard syscall1(SYS_exit, 1)
      var char_arg: ptr uint8 = get_argv(i)
      char_mode = 1
      char_start = parse_int(char_arg)
      if char_start <= 0:
        char_start = 1
      # Look for dash for range (simplified - just takes first number for now)
    if arg[0] != cast[uint8](45):  # not a flag
      if i == argc - 1:  # last arg is filename
        input_fd = syscall2(SYS_open, cast[int32](arg), O_RDONLY)
        if input_fd < 0:
          print_err(cast[ptr uint8]("cut: cannot open file\n"))
          discard syscall1(SYS_exit, 1)
    i = i + 1

  # Process input line by line
  var line_len: int32 = 0
  var running: int32 = 1

  while running != 0:
    var c: uint8 = 0
    var n: int32 = syscall3(SYS_read, input_fd, cast[int32](addr(c)), 1)

    if n <= 0:
      # Output remaining line if any
      if line_len > 0:
        if char_mode != 0:
          # Character mode
          var j: int32 = char_start - 1
          if j >= 0:
            if j < line_len:
              discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + j), 1)
          discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
        else:
          # Field mode
          var current_field: int32 = 1
          var field_start: int32 = 0
          var field_len: int32 = 0
          var k: int32 = 0
          while k <= line_len:
            if k == line_len:
              if current_field == field_num:
                discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
            else:
              if line_buffer[k] == delimiter:
                if current_field == field_num:
                  discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                  discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                  break
                current_field = current_field + 1
                field_start = k + 1
                field_len = 0
              else:
                field_len = field_len + 1
            k = k + 1
      running = 0
      break

    if c == cast[uint8](10):  # newline
      # Process current line
      if char_mode != 0:
        # Character mode - extract specific character
        var j: int32 = char_start - 1
        if j >= 0:
          if j < line_len:
            discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + j), 1)
        discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
      else:
        # Field mode - extract specific field
        var current_field: int32 = 1
        var field_start: int32 = 0
        var field_len: int32 = 0
        var k: int32 = 0
        while k <= line_len:
          if k == line_len:
            if current_field == field_num:
              discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
              discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
          else:
            if line_buffer[k] == delimiter:
              if current_field == field_num:
                discard syscall3(SYS_write, STDOUT, cast[int32](line_buffer + field_start), field_len)
                discard syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)
                break
              current_field = current_field + 1
              field_start = k + 1
              field_len = 0
            else:
              field_len = field_len + 1
          k = k + 1

      line_len = 0
    else:
      # Add character to line buffer
      if line_len < 8192:
        line_buffer[line_len] = c
        line_len = line_len + 1

  if input_fd != STDIN:
    discard syscall1(SYS_close, input_fd)

  discard syscall1(SYS_exit, 0)
