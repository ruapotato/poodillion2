# bds_drm - Brainhair Display Server with DRM
# Uses hardware cursor for smooth mouse movement

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_mmap2: int32 = 192
const SYS_time: int32 = 13
const SYS_nanosleep: int32 = 162

const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Console mode
const KDSETMODE: int32 = 0x4B3A
const KD_TEXT: int32 = 0
const KD_GRAPHICS: int32 = 1

# VT switching
const VT_SETMODE: int32 = 0x5602
const VT_RELDISP: int32 = 0x5605
const VT_ACKACQ: int32 = 0x02
const VT_AUTO: int32 = 0
const VT_PROCESS: int32 = 1

# DRM ioctl numbers (from drm.h and drm_mode.h)
# Base: 'd' << 8 = 0x6400
const DRM_IOCTL_BASE: int32 = 0x6400

# DRM_IOCTL_MODE_GETRESOURCES = _IOWR('d', 0xA0, ...)
const DRM_IOCTL_MODE_GETRESOURCES: int32 = 0xC04064A0
# DRM_IOCTL_MODE_GETCRTC = _IOWR('d', 0xA1, ...)
const DRM_IOCTL_MODE_GETCRTC: int32 = 0xC06864A1
# DRM_IOCTL_MODE_SETCRTC = _IOWR('d', 0xA2, ...)
const DRM_IOCTL_MODE_SETCRTC: int32 = 0xC06864A2
# DRM_IOCTL_MODE_CURSOR = _IOWR('d', 0xA3, ...)
const DRM_IOCTL_MODE_CURSOR: int32 = 0xC01C64A3
# DRM_IOCTL_MODE_ADDFB = _IOWR('d', 0xAE, ...)
const DRM_IOCTL_MODE_ADDFB: int32 = 0xC01C64AE
# DRM_IOCTL_MODE_RMFB = _IOWR('d', 0xAF, ...)
const DRM_IOCTL_MODE_RMFB: int32 = 0xC00464AF
# DRM_IOCTL_MODE_CREATE_DUMB = _IOWR('d', 0xB2, ...)
const DRM_IOCTL_MODE_CREATE_DUMB: int32 = 0xC02064B2
# DRM_IOCTL_MODE_MAP_DUMB = _IOWR('d', 0xB3, ...)
const DRM_IOCTL_MODE_MAP_DUMB: int32 = 0xC01064B3
# DRM_IOCTL_MODE_DESTROY_DUMB = _IOWR('d', 0xB4, ...)
const DRM_IOCTL_MODE_DESTROY_DUMB: int32 = 0xC00464B4

# Cursor flags
const DRM_MODE_CURSOR_BO: int32 = 0x01
const DRM_MODE_CURSOR_MOVE: int32 = 0x02

# Window constants
const MAX_WINDOWS: int32 = 16
const WINDOW_STRUCT_SIZE: int32 = 128
const TITLE_HEIGHT: int32 = 24
const BORDER_SIZE: int32 = 3
const BUTTON_SIZE: int32 = 16
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8
const TASKBAR_HEIGHT: int32 = 32
const LAUNCHER_WIDTH: int32 = 80
const MENU_WIDTH: int32 = 120
const MENU_ITEM_HEIGHT: int32 = 28

# Window struct offsets
const WIN_ACTIVE: int32 = 0
const WIN_X: int32 = 1
const WIN_Y: int32 = 2
const WIN_WIDTH: int32 = 3
const WIN_HEIGHT: int32 = 4
const WIN_DECORATED: int32 = 5
const WIN_FOCUSED: int32 = 6
const WIN_MINIMIZED: int32 = 7
const WIN_TITLE_COLOR: int32 = 8
const WIN_BODY_COLOR: int32 = 9
const WIN_BORDER_COLOR: int32 = 10
const WIN_TYPE: int32 = 11

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32
extern proc fast_memcpy(dst: int32, src: int32, count_bytes: int32)
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

proc atoi(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  while s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

proc streq(a: ptr uint8, b: ptr uint8): int32 =
  var i: int32 = 0
  while a[i] != cast[uint8](0) and b[i] != cast[uint8](0):
    if a[i] != b[i]:
      return 0
    i = i + 1
  if a[i] == b[i]:
    return 1
  return 0

proc get_time(): int32 =
  return syscall1(SYS_time, 0)

# Global timespec buffer for sleep (avoid repeated brk calls)
var g_timespec: ptr int32 = cast[ptr int32](0)

proc sleep_ms(ms: int32) =
  if g_timespec == cast[ptr int32](0):
    var old_brk: int32 = syscall1(SYS_brk, 0)
    discard syscall1(SYS_brk, old_brk + 16)
    g_timespec = cast[ptr int32](old_brk)
  g_timespec[0] = 0              # seconds
  g_timespec[1] = ms * 1000000   # nanoseconds (ms * 1000000)
  discard syscall2(SYS_nanosleep, cast[int32](g_timespec), 0)

# ============ Drawing Primitives ============

proc buf_pixel(buf: ptr uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

proc fill_rect(buf: ptr uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      var cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc get_font_row(c: int32, row: int32): int32 =
  # 8x8 bitmap font - returns 8 bits for each row
  if c == 32: return 0  # space

  # Uppercase letters A-Z (65-90)
  if c == 65:  # A
    if row == 0: return 0x18
    if row == 1: return 0x3C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0
  if c == 67:  # C
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0
  if c == 69:  # E
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 70:  # F
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 71:  # G
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x6E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 72:  # H
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 73:  # I
    if row == 0: return 0x3C
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0
  if c == 74:  # J
    if row == 0: return 0x1E
    if row == 1: return 0x0C
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x6C
    if row == 6: return 0x38
    return 0
  if c == 75:  # K
    if row == 0: return 0x66
    if row == 1: return 0x6C
    if row == 2: return 0x78
    if row == 3: return 0x70
    if row == 4: return 0x78
    if row == 5: return 0x6C
    if row == 6: return 0x66
    return 0
  if c == 76:  # L
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 77:  # M
    if row == 0: return 0x63
    if row == 1: return 0x77
    if row == 2: return 0x7F
    if row == 3: return 0x6B
    if row == 4: return 0x63
    if row == 5: return 0x63
    if row == 6: return 0x63
    return 0
  if c == 78:  # N
    if row == 0: return 0x66
    if row == 1: return 0x76
    if row == 2: return 0x7E
    if row == 3: return 0x7E
    if row == 4: return 0x6E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 80:  # P
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 81:  # Q
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x6A
    if row == 5: return 0x6C
    if row == 6: return 0x36
    return 0
  if c == 82:  # R
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x6C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 83:  # S
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x3C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 84:  # T
    if row == 0: return 0x7E
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 85:  # U
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 86:  # V
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0
  if c == 87:  # W
    if row == 0: return 0x63
    if row == 1: return 0x63
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x7F
    if row == 5: return 0x77
    if row == 6: return 0x63
    return 0
  if c == 88:  # X
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 89:  # Y
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 90:  # Z
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  # Lowercase letters - use same as uppercase for simplicity
  if c >= 97 and c <= 122:
    return get_font_row(c - 32, row)

  # Numbers 0-9 (48-57)
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0
  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0
  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  return 0

proc draw_char(buf: ptr uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

proc draw_text(buf: ptr uint32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, yres: int32, max_chars: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0) and i < max_chars:
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

# ============ Hardware Cursor ============

proc create_cursor_bo(drm_fd: int32, cursor_buf: ptr int32): int32 =
  # Create a 64x64 ARGB cursor buffer
  # cursor_buf layout: [0]=width, [1]=height, [2]=handle, [3]=pitch, [4]=size, [5]=offset_lo, [6]=offset_hi
  cursor_buf[0] = 64  # width
  cursor_buf[1] = 64  # height
  cursor_buf[2] = 32  # bpp
  cursor_buf[3] = 0   # flags
  # handle, pitch, size filled by kernel

  var result: int32 = syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, cast[int32](cursor_buf))
  if result < 0:
    return -1
  return 0

proc draw_cursor_to_bo(cursor_ptr: ptr uint32) =
  # Draw a white arrow cursor with black outline on 64x64 ARGB buffer
  # Clear to transparent
  var i: int32 = 0
  while i < 64 * 64:
    cursor_ptr[i] = cast[uint32](0x00000000)  # Transparent
    i = i + 1

  # Draw arrow cursor (white with black outline)
  i = 0
  while i < 16:
    # Black outline
    var x: int32 = i + 1
    var y: int32 = i
    if y < 64 and x < 64:
      cursor_ptr[y * 64 + x] = cast[uint32](0xFF000000)
    # White fill
    x = i
    if y < 64 and x < 64:
      cursor_ptr[y * 64 + x] = cast[uint32](0xFFFFFFFF)
    # Diagonal part
    if i < 10:
      x = i
      y = i
      if y < 64 and x < 64:
        cursor_ptr[y * 64 + x] = cast[uint32](0xFFFFFFFF)
    i = i + 1

proc set_hardware_cursor(drm_fd: int32, crtc_id: int32, handle: int32, x: int32, y: int32) =
  # drm_mode_cursor struct: flags, crtc_id, x, y, width, height, handle
  var cursor_cmd: ptr int32 = cast[ptr int32](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 32)
  cursor_cmd = cast[ptr int32](old_brk)

  cursor_cmd[0] = DRM_MODE_CURSOR_BO | DRM_MODE_CURSOR_MOVE  # flags
  cursor_cmd[1] = crtc_id
  cursor_cmd[2] = x
  cursor_cmd[3] = y
  cursor_cmd[4] = 64  # width
  cursor_cmd[5] = 64  # height
  cursor_cmd[6] = handle

  discard syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CURSOR, cast[int32](cursor_cmd))

proc move_hardware_cursor(drm_fd: int32, crtc_id: int32, x: int32, y: int32) =
  var cursor_cmd: ptr int32 = cast[ptr int32](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 32)
  cursor_cmd = cast[ptr int32](old_brk)

  cursor_cmd[0] = DRM_MODE_CURSOR_MOVE  # flags - just move
  cursor_cmd[1] = crtc_id
  cursor_cmd[2] = x
  cursor_cmd[3] = y
  cursor_cmd[4] = 64  # width (ignored for move)
  cursor_cmd[5] = 64  # height (ignored for move)
  cursor_cmd[6] = 0   # handle (ignored for move)

  discard syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CURSOR, cast[int32](cursor_cmd))

# ============ Window Management ============

proc window_ptr(windows: ptr int32, idx: int32): ptr int32 =
  return cast[ptr int32](cast[int32](windows) + idx * WINDOW_STRUCT_SIZE)

proc win_get(win: ptr int32, field: int32): int32 =
  return win[field]

proc win_set(win: ptr int32, field: int32, val: int32) =
  win[field] = val

proc get_window_title(win_type: int32): ptr uint8 =
  if win_type == 1: return cast[ptr uint8]("Terminal")
  if win_type == 2: return cast[ptr uint8]("Files")
  if win_type == 3: return cast[ptr uint8]("Editor")
  return cast[ptr uint8]("Window")

proc create_window(windows: ptr int32, x: int32, y: int32, w: int32, h: int32, title_col: int32, body_col: int32, win_type: int32): int32 =
  var i: int32 = 0
  while i < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, i)
    if win_get(win, WIN_ACTIVE) == 0:
      win_set(win, WIN_ACTIVE, 1)
      win_set(win, WIN_X, x)
      win_set(win, WIN_Y, y)
      win_set(win, WIN_WIDTH, w)
      win_set(win, WIN_HEIGHT, h)
      win_set(win, WIN_DECORATED, 1)
      win_set(win, WIN_FOCUSED, 0)
      win_set(win, WIN_MINIMIZED, 0)
      win_set(win, WIN_TITLE_COLOR, title_col)
      win_set(win, WIN_BODY_COLOR, body_col)
      win_set(win, WIN_TYPE, win_type)
      return i
    i = i + 1
  return -1

proc destroy_window(windows: ptr int32, idx: int32) =
  if idx >= 0 and idx < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, idx)
    win_set(win, WIN_ACTIVE, 0)

# ============ Compositor ============

proc draw_decoration(buf: ptr uint32, win: ptr int32, focused: int32, xres: int32, yres: int32) =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  var h: int32 = win_get(win, WIN_HEIGHT)
  var title_col: int32 = win_get(win, WIN_TITLE_COLOR)

  var border_col: int32 = 0x606060
  if focused != 0:
    border_col = 0x0088FF
    title_col = title_col | 0x202020

  fill_rect(buf, x, y, w, BORDER_SIZE, border_col, xres, yres)
  fill_rect(buf, x, y + h - BORDER_SIZE, w, BORDER_SIZE, border_col, xres, yres)
  fill_rect(buf, x, y, BORDER_SIZE, h, border_col, xres, yres)
  fill_rect(buf, x + w - BORDER_SIZE, y, BORDER_SIZE, h, border_col, xres, yres)
  fill_rect(buf, x + BORDER_SIZE, y + BORDER_SIZE, w - BORDER_SIZE * 2, TITLE_HEIGHT, title_col, xres, yres)

  var title: ptr uint8 = get_window_title(win_get(win, WIN_TYPE))
  draw_text(buf, x + BORDER_SIZE + 8, y + BORDER_SIZE + 8, title, 0xFFFFFF, title_col, xres, yres, 20)

  fill_rect(buf, x + w - BORDER_SIZE - BUTTON_SIZE - 4, y + BORDER_SIZE + 4, BUTTON_SIZE, BUTTON_SIZE, 0xDD4444, xres, yres)
  fill_rect(buf, x + w - BORDER_SIZE - BUTTON_SIZE * 2 - 8, y + BORDER_SIZE + 4, BUTTON_SIZE, BUTTON_SIZE, 0xDDDD44, xres, yres)

proc draw_window_body(buf: ptr uint32, win: ptr int32, xres: int32, yres: int32) =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  var h: int32 = win_get(win, WIN_HEIGHT)
  var body_col: int32 = win_get(win, WIN_BODY_COLOR)
  var win_type: int32 = win_get(win, WIN_TYPE)

  var content_x: int32 = x + BORDER_SIZE
  var content_y: int32 = y + BORDER_SIZE + TITLE_HEIGHT
  var content_w: int32 = w - BORDER_SIZE * 2
  var content_h: int32 = h - BORDER_SIZE * 2 - TITLE_HEIGHT

  fill_rect(buf, content_x, content_y, content_w, content_h, body_col, xres, yres)

  # Draw content based on window type
  if win_type == 1:
    # Terminal - dark background with prompt
    fill_rect(buf, content_x + 4, content_y + 4, content_w - 8, content_h - 8, 0x1A1A1A, xres, yres)
    draw_text(buf, content_x + 8, content_y + 8, cast[ptr uint8]("Welcome to BDS Terminal"), 0x00FF00, 0x1A1A1A, xres, yres, 30)
    draw_text(buf, content_x + 8, content_y + 24, cast[ptr uint8]("Type commands here"), 0x888888, 0x1A1A1A, xres, yres, 30)
    draw_text(buf, content_x + 8, content_y + 48, cast[ptr uint8]("$ "), 0x00FF00, 0x1A1A1A, xres, yres, 30)
    # Blinking cursor (always on for now)
    fill_rect(buf, content_x + 8 + 16, content_y + 48, 8, 12, 0x00FF00, xres, yres)

  if win_type == 2:
    # Files - file list
    draw_text(buf, content_x + 8, content_y + 8, cast[ptr uint8]("Home"), 0x000000, body_col, xres, yres, 20)
    fill_rect(buf, content_x + 4, content_y + 24, content_w - 8, 1, 0xCCCCCC, xres, yres)
    # Folder icons (simple squares)
    fill_rect(buf, content_x + 12, content_y + 32, 16, 14, 0xE8C86A, xres, yres)
    draw_text(buf, content_x + 34, content_y + 34, cast[ptr uint8]("Documents"), 0x000000, body_col, xres, yres, 15)
    fill_rect(buf, content_x + 12, content_y + 52, 16, 14, 0xE8C86A, xres, yres)
    draw_text(buf, content_x + 34, content_y + 54, cast[ptr uint8]("Downloads"), 0x000000, body_col, xres, yres, 15)
    fill_rect(buf, content_x + 12, content_y + 72, 16, 14, 0xE8C86A, xres, yres)
    draw_text(buf, content_x + 34, content_y + 74, cast[ptr uint8]("Pictures"), 0x000000, body_col, xres, yres, 15)
    fill_rect(buf, content_x + 12, content_y + 92, 16, 14, 0x6A9BE8, xres, yres)
    draw_text(buf, content_x + 34, content_y + 94, cast[ptr uint8]("readme.txt"), 0x000000, body_col, xres, yres, 15)

  if win_type == 3:
    # Editor - text area with sample text
    fill_rect(buf, content_x + 4, content_y + 4, content_w - 8, content_h - 8, 0xFFFFFF, xres, yres)
    draw_text(buf, content_x + 8, content_y + 8, cast[ptr uint8]("Untitled Document"), 0x000000, 0xFFFFFF, xres, yres, 25)
    fill_rect(buf, content_x + 4, content_y + 24, content_w - 8, 1, 0xCCCCCC, xres, yres)
    draw_text(buf, content_x + 8, content_y + 32, cast[ptr uint8]("Hello World"), 0x000000, 0xFFFFFF, xres, yres, 30)
    draw_text(buf, content_x + 8, content_y + 48, cast[ptr uint8]("This is a text editor"), 0x000000, 0xFFFFFF, xres, yres, 30)
    draw_text(buf, content_x + 8, content_y + 64, cast[ptr uint8]("You can type here"), 0x888888, 0xFFFFFF, xres, yres, 30)

proc composite(buf: ptr uint32, windows: ptr int32, focused_idx: int32, xres: int32, yres: int32, bg_color: int32) =
  fill_rect(buf, 0, 0, xres, yres - TASKBAR_HEIGHT, bg_color, xres, yres)

  var i: int32 = 0
  while i < MAX_WINDOWS:
    if i != focused_idx:
      var win: ptr int32 = window_ptr(windows, i)
      if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
        if win_get(win, WIN_DECORATED) != 0:
          draw_decoration(buf, win, 0, xres, yres)
        draw_window_body(buf, win, xres, yres)
    i = i + 1

  if focused_idx >= 0 and focused_idx < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, focused_idx)
    if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
      if win_get(win, WIN_DECORATED) != 0:
        draw_decoration(buf, win, 1, xres, yres)
      draw_window_body(buf, win, xres, yres)

proc draw_taskbar(buf: ptr uint32, windows: ptr int32, xres: int32, yres: int32, menu_open: int32) =
  var taskbar_y: int32 = yres - TASKBAR_HEIGHT
  fill_rect(buf, 0, taskbar_y, xres, TASKBAR_HEIGHT, 0x2D2D2D, xres, yres)
  fill_rect(buf, 0, taskbar_y, xres, 1, 0x505050, xres, yres)
  # Menu button - highlight if menu is open
  var menu_color: int32 = 0x0066AA
  if menu_open != 0:
    menu_color = 0x0088DD
  fill_rect(buf, 4, taskbar_y + 4, LAUNCHER_WIDTH, TASKBAR_HEIGHT - 8, menu_color, xres, yres)
  draw_text(buf, 20, taskbar_y + 12, cast[ptr uint8]("Menu"), 0xFFFFFF, menu_color, xres, yres, 10)

proc draw_menu(buf: ptr uint32, xres: int32, yres: int32) =
  var menu_x: int32 = 4
  var menu_y: int32 = yres - TASKBAR_HEIGHT - MENU_ITEM_HEIGHT * 3 - 4
  # Menu background
  fill_rect(buf, menu_x, menu_y, MENU_WIDTH, MENU_ITEM_HEIGHT * 3 + 4, 0x3D3D3D, xres, yres)
  fill_rect(buf, menu_x + 1, menu_y + 1, MENU_WIDTH - 2, MENU_ITEM_HEIGHT * 3 + 2, 0x2D2D2D, xres, yres)
  # Menu items
  fill_rect(buf, menu_x + 2, menu_y + 2, MENU_WIDTH - 4, MENU_ITEM_HEIGHT, 0x404040, xres, yres)
  draw_text(buf, menu_x + 10, menu_y + 10, cast[ptr uint8]("Terminal"), 0xFFFFFF, 0x404040, xres, yres, 10)
  fill_rect(buf, menu_x + 2, menu_y + 2 + MENU_ITEM_HEIGHT, MENU_WIDTH - 4, MENU_ITEM_HEIGHT, 0x404040, xres, yres)
  draw_text(buf, menu_x + 10, menu_y + 10 + MENU_ITEM_HEIGHT, cast[ptr uint8]("Files"), 0xFFFFFF, 0x404040, xres, yres, 10)
  fill_rect(buf, menu_x + 2, menu_y + 2 + MENU_ITEM_HEIGHT * 2, MENU_WIDTH - 4, MENU_ITEM_HEIGHT, 0x404040, xres, yres)
  draw_text(buf, menu_x + 10, menu_y + 10 + MENU_ITEM_HEIGHT * 2, cast[ptr uint8]("Editor"), 0xFFFFFF, 0x404040, xres, yres, 10)

proc menu_item_at(px: int32, py: int32, xres: int32, yres: int32): int32 =
  var menu_x: int32 = 4
  var menu_y: int32 = yres - TASKBAR_HEIGHT - MENU_ITEM_HEIGHT * 3 - 4
  if px >= menu_x and px < menu_x + MENU_WIDTH:
    if py >= menu_y + 2 and py < menu_y + 2 + MENU_ITEM_HEIGHT:
      return 1  # Terminal
    if py >= menu_y + 2 + MENU_ITEM_HEIGHT and py < menu_y + 2 + MENU_ITEM_HEIGHT * 2:
      return 2  # Files
    if py >= menu_y + 2 + MENU_ITEM_HEIGHT * 2 and py < menu_y + 2 + MENU_ITEM_HEIGHT * 3:
      return 3  # Editor
  return 0

proc point_in_menu_button(px: int32, py: int32, yres: int32): int32 =
  var taskbar_y: int32 = yres - TASKBAR_HEIGHT
  if px >= 4 and px < 4 + LAUNCHER_WIDTH:
    if py >= taskbar_y + 4 and py < taskbar_y + TASKBAR_HEIGHT - 4:
      return 1
  return 0

proc draw_cursor(buf: ptr uint32, x: int32, y: int32, xres: int32, yres: int32) =
  # Draw arrow cursor - 12x16 pixels
  # Row 0: X
  buf_pixel(buf, x, y, 0x000000, xres, yres)
  # Row 1: XX
  buf_pixel(buf, x, y+1, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+1, 0x000000, xres, yres)
  # Row 2: XWX
  buf_pixel(buf, x, y+2, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+2, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+2, 0x000000, xres, yres)
  # Row 3: XWWX
  buf_pixel(buf, x, y+3, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+3, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+3, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+3, 0x000000, xres, yres)
  # Row 4: XWWWX
  buf_pixel(buf, x, y+4, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+4, 0x000000, xres, yres)
  # Row 5: XWWWWX
  buf_pixel(buf, x, y+5, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+5, 0x000000, xres, yres)
  # Row 6: XWWWWWX
  buf_pixel(buf, x, y+6, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+6, 0x000000, xres, yres)
  # Row 7: XWWWWWWX
  buf_pixel(buf, x, y+7, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+7, 0x000000, xres, yres)
  # Row 8: XWWWWWWWX
  buf_pixel(buf, x, y+8, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+8, 0x000000, xres, yres)
  # Row 9: XWWWWXXXXX
  buf_pixel(buf, x, y+9, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+9, 0x000000, xres, yres)
  # Row 10: XWWX XWX
  buf_pixel(buf, x, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+5, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+10, 0x000000, xres, yres)
  # Row 11: XWX  XWX
  buf_pixel(buf, x, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+11, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+7, y+11, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+11, 0x000000, xres, yres)
  # Row 12: XX   XWX
  buf_pixel(buf, x, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+7, y+12, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+12, 0x000000, xres, yres)
  # Row 13:       XX
  buf_pixel(buf, x+7, y+13, 0x000000, xres, yres)
  buf_pixel(buf, x+8, y+13, 0x000000, xres, yres)

proc point_in_titlebar(win: ptr int32, px: int32, py: int32): int32 =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  if px >= x + BORDER_SIZE and px < x + w - BORDER_SIZE:
    if py >= y + BORDER_SIZE and py < y + BORDER_SIZE + TITLE_HEIGHT:
      return 1
  return 0

proc point_in_window(win: ptr int32, px: int32, py: int32): int32 =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  var h: int32 = win_get(win, WIN_HEIGHT)
  if px >= x and px < x + w and py >= y and py < y + h:
    return 1
  return 0

proc find_window_at(windows: ptr int32, px: int32, py: int32, focused: int32): int32 =
  # Check focused window first (it's on top)
  if focused >= 0 and focused < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, focused)
    if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
      if point_in_window(win, px, py) != 0:
        return focused
  # Check other windows
  var i: int32 = MAX_WINDOWS - 1
  while i >= 0:
    if i != focused:
      var win: ptr int32 = window_ptr(windows, i)
      if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
        if point_in_window(win, px, py) != 0:
          return i
    i = i - 1
  return -1

# ============ Main ============

proc main() =
  # Parse command line arguments
  var timeout_seconds: int32 = 0
  var argc: int32 = get_argc()
  var i: int32 = 1
  while i < argc:
    var arg: ptr uint8 = get_argv(i)
    if streq(arg, cast[ptr uint8]("--timeout")) != 0:
      if i + 1 < argc:
        var timeout_arg: ptr uint8 = get_argv(i + 1)
        timeout_seconds = atoi(timeout_arg)
        i = i + 1
    i = i + 1

  var start_time: int32 = get_time()

  if timeout_seconds > 0:
    print_str(cast[ptr uint8]("BDS starting with timeout: "))
    print_num(timeout_seconds)
    print_str(cast[ptr uint8](" seconds\n"))

  # Redirect output to debug file to avoid console text on screen
  var debug_fd: int32 = syscall3(SYS_open, cast[int32]("/tmp/bds_drm.log"), 66, 420)
  # 66 = O_RDWR|O_CREAT, 420 = 0644

  # Open DRM device
  var drm_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/dri/card0"), O_RDWR)
  if drm_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/dri/card0\n"))
    print_str(cast[ptr uint8]("Falling back to fbdev...\n"))
    discard syscall1(SYS_exit, 1)

  print_str(cast[ptr uint8]("DRM device opened: fd="))
  print_num(drm_fd)
  print_str(cast[ptr uint8]("\n"))

  # For now, also open fbdev for the main display (hybrid approach)
  # We'll use DRM just for hardware cursor
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info from fbdev
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 8192)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 256)
  var windows: ptr int32 = cast[ptr int32](old_brk + 512)
  var cursor_bo: ptr int32 = cast[ptr int32](old_brk + 4096)

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # Try to set up hardware cursor
  var cursor_result: int32 = create_cursor_bo(drm_fd, cursor_bo)
  var use_hw_cursor: int32 = 0
  var cursor_handle: int32 = 0
  var crtc_id: int32 = 0

  if cursor_result >= 0:
    cursor_handle = cursor_bo[3]  # handle is at offset 3 after ioctl
    # Map and draw cursor - need DRM_IOCTL_MODE_MAP_DUMB
    # For now, try with crtc_id = 0 (first CRTC)
    crtc_id = 41  # Common CRTC ID, may need to query
    use_hw_cursor = 1

  # Open TTY but DON'T set KD_GRAPHICS - this blocks VT switching
  # Just leave console in text mode, the framebuffer will overwrite it
  var tty_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/tty"), O_RDWR)
  # Skip KD_GRAPHICS to allow VT switching with Ctrl+Alt+Fn

  # mmap framebuffer
  var buf_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    discard syscall1(SYS_exit, 1)

  # Allocate back buffer for double buffering (eliminates flicker)
  var back_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, back_brk + buf_size + 4096)
  var backbuffer: ptr uint32 = cast[ptr uint32](back_brk)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd < 0:
    discard syscall1(SYS_exit, 1)
  var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
  discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Init windows
  var i: int32 = 0
  while i < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, i)
    win_set(win, WIN_ACTIVE, 0)
    i = i + 1

  # Create demo windows
  discard create_window(windows, 80, 60, 350, 250, 0x2255AA, 0xE8E8E8, 1)
  discard create_window(windows, 250, 140, 380, 280, 0x22AA55, 0xF0F0F0, 2)
  var focused: int32 = create_window(windows, 450, 100, 320, 240, 0xAA5522, 0xEEEEEE, 3)

  var cursor_x: int32 = xres / 2
  var cursor_y: int32 = yres / 2
  var bg_color: int32 = 0x1A3A5A

  # Drag state
  var dragging: int32 = 0
  var drag_win: int32 = -1
  var drag_off_x: int32 = 0
  var drag_off_y: int32 = 0
  var mouse_btn: int32 = 0
  var prev_btn: int32 = 0

  # Menu state
  var menu_open: int32 = 0
  var next_win_x: int32 = 100
  var next_win_y: int32 = 80

  if focused >= 0:
    var fwin: ptr int32 = window_ptr(windows, focused)
    win_set(fwin, WIN_FOCUSED, 1)

  # Set initial cursor position
  if use_hw_cursor != 0:
    set_hardware_cursor(drm_fd, crtc_id, cursor_handle, cursor_x, cursor_y)

  # Draw initial scene to backbuffer, then copy to framebuffer
  composite(backbuffer, windows, focused, xres, yres, bg_color)
  draw_taskbar(backbuffer, windows, xres, yres, menu_open)
  draw_cursor(backbuffer, cursor_x, cursor_y, xres, yres)
  # Copy to screen
  fast_memcpy(cast[int32](framebuffer), cast[int32](backbuffer), buf_size)

  var running: int32 = 1
  var frame_count: int32 = 0
  while running != 0:
    frame_count = frame_count + 1

    # Check timeout
    if timeout_seconds > 0:
      var now: int32 = get_time()
      if now - start_time >= timeout_seconds:
        print_str(cast[ptr uint8]("Timeout reached, exiting...\n"))
        running = 0

    # Batch mouse events
    var total_dx: int32 = 0
    var total_dy: int32 = 0
    var got_mouse: int32 = 0
    prev_btn = mouse_btn

    var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
    while bytes >= 3:
      got_mouse = 1
      var btns: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      if (btns & 0x10) != 0: dx = dx - 256
      if (btns & 0x20) != 0: dy = dy - 256

      total_dx = total_dx + dx
      total_dy = total_dy + dy
      mouse_btn = btns & 0x07  # Lower 3 bits are buttons

      bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

    if got_mouse != 0:
      cursor_x = cursor_x + total_dx
      cursor_y = cursor_y - total_dy
      if cursor_x < 0: cursor_x = 0
      if cursor_x >= xres: cursor_x = xres - 1
      if cursor_y < 0: cursor_y = 0
      if cursor_y >= yres: cursor_y = yres - 1

      # Handle mouse button press (left button = bit 0)
      var left_pressed: int32 = (mouse_btn & 1) != 0 and (prev_btn & 1) == 0
      var left_released: int32 = (mouse_btn & 1) == 0 and (prev_btn & 1) != 0

      if left_pressed != 0:
        # Check if clicking menu button
        if point_in_menu_button(cursor_x, cursor_y, yres) != 0:
          menu_open = 1 - menu_open  # Toggle menu
        else:
          # Check if clicking on menu item
          if menu_open != 0:
            var item: int32 = menu_item_at(cursor_x, cursor_y, xres, yres)
            if item > 0:
              # Create new window based on menu item
              var new_win_idx: int32 = -1
              if item == 1:
                new_win_idx = create_window(windows, next_win_x, next_win_y, 400, 300, 0x2255AA, 0xE8E8E8, 1)
              if item == 2:
                new_win_idx = create_window(windows, next_win_x, next_win_y, 380, 280, 0x22AA55, 0xF0F0F0, 2)
              if item == 3:
                new_win_idx = create_window(windows, next_win_x, next_win_y, 450, 320, 0xAA5522, 0xEEEEEE, 3)
              if new_win_idx >= 0:
                # Focus new window
                if focused >= 0:
                  var old_win: ptr int32 = window_ptr(windows, focused)
                  win_set(old_win, WIN_FOCUSED, 0)
                focused = new_win_idx
                var nwin: ptr int32 = window_ptr(windows, new_win_idx)
                win_set(nwin, WIN_FOCUSED, 1)
                # Offset next window position
                next_win_x = next_win_x + 30
                next_win_y = next_win_y + 30
                if next_win_x > xres - 200:
                  next_win_x = 100
                if next_win_y > yres - 200:
                  next_win_y = 80
              menu_open = 0
            else:
              # Clicked outside menu - close it
              menu_open = 0

          # Check if clicking on a window
          var clicked_win: int32 = find_window_at(windows, cursor_x, cursor_y, focused)
          if clicked_win >= 0:
            # Focus this window
            if clicked_win != focused:
              if focused >= 0:
                var old_win: ptr int32 = window_ptr(windows, focused)
                win_set(old_win, WIN_FOCUSED, 0)
              focused = clicked_win
              var new_win: ptr int32 = window_ptr(windows, focused)
              win_set(new_win, WIN_FOCUSED, 1)

            # Check if clicking on title bar - start drag
            var win: ptr int32 = window_ptr(windows, clicked_win)
            if point_in_titlebar(win, cursor_x, cursor_y) != 0:
              dragging = 1
              drag_win = clicked_win
              drag_off_x = cursor_x - win_get(win, WIN_X)
              drag_off_y = cursor_y - win_get(win, WIN_Y)

      if left_released != 0:
        # Stop dragging
        dragging = 0
        drag_win = -1

      # Handle dragging
      if dragging != 0 and drag_win >= 0:
        var win: ptr int32 = window_ptr(windows, drag_win)
        win_set(win, WIN_X, cursor_x - drag_off_x)
        win_set(win, WIN_Y, cursor_y - drag_off_y)

    # Draw to backbuffer
    composite(backbuffer, windows, focused, xres, yres, bg_color)
    draw_taskbar(backbuffer, windows, xres, yres, menu_open)
    if menu_open != 0:
      draw_menu(backbuffer, xres, yres)
    draw_cursor(backbuffer, cursor_x, cursor_y, xres, yres)
    # Copy to screen in one fast operation (no flicker)
    fast_memcpy(cast[int32](framebuffer), cast[int32](backbuffer), buf_size)

  # Close TTY
  if tty_fd >= 0:
    discard syscall1(SYS_close, tty_fd)

  discard syscall1(SYS_close, drm_fd)
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_exit, 0)

main()
