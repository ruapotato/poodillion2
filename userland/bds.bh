# bds_drm - Brainhair Display Server with DRM
# Uses hardware cursor for smooth mouse movement

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_mmap2: int32 = 192

const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Console mode
const KDSETMODE: int32 = 0x4B3A
const KD_TEXT: int32 = 0
const KD_GRAPHICS: int32 = 1

# DRM ioctl numbers (from drm.h and drm_mode.h)
# Base: 'd' << 8 = 0x6400
const DRM_IOCTL_BASE: int32 = 0x6400

# DRM_IOCTL_MODE_GETRESOURCES = _IOWR('d', 0xA0, ...)
const DRM_IOCTL_MODE_GETRESOURCES: int32 = 0xC04064A0
# DRM_IOCTL_MODE_GETCRTC = _IOWR('d', 0xA1, ...)
const DRM_IOCTL_MODE_GETCRTC: int32 = 0xC06864A1
# DRM_IOCTL_MODE_SETCRTC = _IOWR('d', 0xA2, ...)
const DRM_IOCTL_MODE_SETCRTC: int32 = 0xC06864A2
# DRM_IOCTL_MODE_CURSOR = _IOWR('d', 0xA3, ...)
const DRM_IOCTL_MODE_CURSOR: int32 = 0xC01C64A3
# DRM_IOCTL_MODE_ADDFB = _IOWR('d', 0xAE, ...)
const DRM_IOCTL_MODE_ADDFB: int32 = 0xC01C64AE
# DRM_IOCTL_MODE_RMFB = _IOWR('d', 0xAF, ...)
const DRM_IOCTL_MODE_RMFB: int32 = 0xC00464AF
# DRM_IOCTL_MODE_CREATE_DUMB = _IOWR('d', 0xB2, ...)
const DRM_IOCTL_MODE_CREATE_DUMB: int32 = 0xC02064B2
# DRM_IOCTL_MODE_MAP_DUMB = _IOWR('d', 0xB3, ...)
const DRM_IOCTL_MODE_MAP_DUMB: int32 = 0xC01064B3
# DRM_IOCTL_MODE_DESTROY_DUMB = _IOWR('d', 0xB4, ...)
const DRM_IOCTL_MODE_DESTROY_DUMB: int32 = 0xC00464B4

# Cursor flags
const DRM_MODE_CURSOR_BO: int32 = 0x01
const DRM_MODE_CURSOR_MOVE: int32 = 0x02

# Window constants
const MAX_WINDOWS: int32 = 16
const WINDOW_STRUCT_SIZE: int32 = 128
const TITLE_HEIGHT: int32 = 24
const BORDER_SIZE: int32 = 3
const BUTTON_SIZE: int32 = 16
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8
const TASKBAR_HEIGHT: int32 = 32
const LAUNCHER_WIDTH: int32 = 80
const MENU_WIDTH: int32 = 120
const MENU_ITEM_HEIGHT: int32 = 28

# Window struct offsets
const WIN_ACTIVE: int32 = 0
const WIN_X: int32 = 1
const WIN_Y: int32 = 2
const WIN_WIDTH: int32 = 3
const WIN_HEIGHT: int32 = 4
const WIN_DECORATED: int32 = 5
const WIN_FOCUSED: int32 = 6
const WIN_MINIMIZED: int32 = 7
const WIN_TITLE_COLOR: int32 = 8
const WIN_BODY_COLOR: int32 = 9
const WIN_BORDER_COLOR: int32 = 10
const WIN_TYPE: int32 = 11

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32
extern proc fast_memcpy(dst: int32, src: int32, count_bytes: int32)

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

# ============ Drawing Primitives ============

proc buf_pixel(buf: ptr uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

proc fill_rect(buf: ptr uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      var cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc get_font_row(c: int32, row: int32): int32 =
  if c == 32: return 0
  # Simplified font - just uppercase letters for now
  if c >= 65 and c <= 90:
    # Basic block letters
    if row >= 1 and row <= 5: return 0x7E
    return 0
  if c >= 97 and c <= 122:
    if row >= 2 and row <= 6: return 0x7E
    return 0
  if c >= 48 and c <= 57:
    if row >= 0 and row <= 6: return 0x3C
    return 0
  return 0

proc draw_char(buf: ptr uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

proc draw_text(buf: ptr uint32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, yres: int32, max_chars: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0) and i < max_chars:
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

# ============ Hardware Cursor ============

proc create_cursor_bo(drm_fd: int32, cursor_buf: ptr int32): int32 =
  # Create a 64x64 ARGB cursor buffer
  # cursor_buf layout: [0]=width, [1]=height, [2]=handle, [3]=pitch, [4]=size, [5]=offset_lo, [6]=offset_hi
  cursor_buf[0] = 64  # width
  cursor_buf[1] = 64  # height
  cursor_buf[2] = 32  # bpp
  cursor_buf[3] = 0   # flags
  # handle, pitch, size filled by kernel

  var result: int32 = syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, cast[int32](cursor_buf))
  if result < 0:
    return -1
  return 0

proc draw_cursor_to_bo(cursor_ptr: ptr uint32) =
  # Draw a white arrow cursor with black outline on 64x64 ARGB buffer
  # Clear to transparent
  var i: int32 = 0
  while i < 64 * 64:
    cursor_ptr[i] = cast[uint32](0x00000000)  # Transparent
    i = i + 1

  # Draw arrow cursor (white with black outline)
  i = 0
  while i < 16:
    # Black outline
    var x: int32 = i + 1
    var y: int32 = i
    if y < 64 and x < 64:
      cursor_ptr[y * 64 + x] = cast[uint32](0xFF000000)
    # White fill
    x = i
    if y < 64 and x < 64:
      cursor_ptr[y * 64 + x] = cast[uint32](0xFFFFFFFF)
    # Diagonal part
    if i < 10:
      x = i
      y = i
      if y < 64 and x < 64:
        cursor_ptr[y * 64 + x] = cast[uint32](0xFFFFFFFF)
    i = i + 1

proc set_hardware_cursor(drm_fd: int32, crtc_id: int32, handle: int32, x: int32, y: int32) =
  # drm_mode_cursor struct: flags, crtc_id, x, y, width, height, handle
  var cursor_cmd: ptr int32 = cast[ptr int32](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 32)
  cursor_cmd = cast[ptr int32](old_brk)

  cursor_cmd[0] = DRM_MODE_CURSOR_BO | DRM_MODE_CURSOR_MOVE  # flags
  cursor_cmd[1] = crtc_id
  cursor_cmd[2] = x
  cursor_cmd[3] = y
  cursor_cmd[4] = 64  # width
  cursor_cmd[5] = 64  # height
  cursor_cmd[6] = handle

  discard syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CURSOR, cast[int32](cursor_cmd))

proc move_hardware_cursor(drm_fd: int32, crtc_id: int32, x: int32, y: int32) =
  var cursor_cmd: ptr int32 = cast[ptr int32](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 32)
  cursor_cmd = cast[ptr int32](old_brk)

  cursor_cmd[0] = DRM_MODE_CURSOR_MOVE  # flags - just move
  cursor_cmd[1] = crtc_id
  cursor_cmd[2] = x
  cursor_cmd[3] = y
  cursor_cmd[4] = 64  # width (ignored for move)
  cursor_cmd[5] = 64  # height (ignored for move)
  cursor_cmd[6] = 0   # handle (ignored for move)

  discard syscall3(SYS_ioctl, drm_fd, DRM_IOCTL_MODE_CURSOR, cast[int32](cursor_cmd))

# ============ Window Management ============

proc window_ptr(windows: ptr int32, idx: int32): ptr int32 =
  return cast[ptr int32](cast[int32](windows) + idx * WINDOW_STRUCT_SIZE)

proc win_get(win: ptr int32, field: int32): int32 =
  return win[field]

proc win_set(win: ptr int32, field: int32, val: int32) =
  win[field] = val

proc get_window_title(win_type: int32): ptr uint8 =
  if win_type == 1: return cast[ptr uint8]("Terminal")
  if win_type == 2: return cast[ptr uint8]("Files")
  if win_type == 3: return cast[ptr uint8]("Editor")
  return cast[ptr uint8]("Window")

proc create_window(windows: ptr int32, x: int32, y: int32, w: int32, h: int32, title_col: int32, body_col: int32, win_type: int32): int32 =
  var i: int32 = 0
  while i < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, i)
    if win_get(win, WIN_ACTIVE) == 0:
      win_set(win, WIN_ACTIVE, 1)
      win_set(win, WIN_X, x)
      win_set(win, WIN_Y, y)
      win_set(win, WIN_WIDTH, w)
      win_set(win, WIN_HEIGHT, h)
      win_set(win, WIN_DECORATED, 1)
      win_set(win, WIN_FOCUSED, 0)
      win_set(win, WIN_MINIMIZED, 0)
      win_set(win, WIN_TITLE_COLOR, title_col)
      win_set(win, WIN_BODY_COLOR, body_col)
      win_set(win, WIN_TYPE, win_type)
      return i
    i = i + 1
  return -1

proc destroy_window(windows: ptr int32, idx: int32) =
  if idx >= 0 and idx < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, idx)
    win_set(win, WIN_ACTIVE, 0)

# ============ Compositor ============

proc draw_decoration(buf: ptr uint32, win: ptr int32, focused: int32, xres: int32, yres: int32) =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  var h: int32 = win_get(win, WIN_HEIGHT)
  var title_col: int32 = win_get(win, WIN_TITLE_COLOR)

  var border_col: int32 = 0x606060
  if focused != 0:
    border_col = 0x0088FF
    title_col = title_col | 0x202020

  fill_rect(buf, x, y, w, BORDER_SIZE, border_col, xres, yres)
  fill_rect(buf, x, y + h - BORDER_SIZE, w, BORDER_SIZE, border_col, xres, yres)
  fill_rect(buf, x, y, BORDER_SIZE, h, border_col, xres, yres)
  fill_rect(buf, x + w - BORDER_SIZE, y, BORDER_SIZE, h, border_col, xres, yres)
  fill_rect(buf, x + BORDER_SIZE, y + BORDER_SIZE, w - BORDER_SIZE * 2, TITLE_HEIGHT, title_col, xres, yres)

  var title: ptr uint8 = get_window_title(win_get(win, WIN_TYPE))
  draw_text(buf, x + BORDER_SIZE + 8, y + BORDER_SIZE + 8, title, 0xFFFFFF, title_col, xres, yres, 20)

  fill_rect(buf, x + w - BORDER_SIZE - BUTTON_SIZE - 4, y + BORDER_SIZE + 4, BUTTON_SIZE, BUTTON_SIZE, 0xDD4444, xres, yres)
  fill_rect(buf, x + w - BORDER_SIZE - BUTTON_SIZE * 2 - 8, y + BORDER_SIZE + 4, BUTTON_SIZE, BUTTON_SIZE, 0xDDDD44, xres, yres)

proc draw_window_body(buf: ptr uint32, win: ptr int32, xres: int32, yres: int32) =
  var x: int32 = win_get(win, WIN_X)
  var y: int32 = win_get(win, WIN_Y)
  var w: int32 = win_get(win, WIN_WIDTH)
  var h: int32 = win_get(win, WIN_HEIGHT)
  var body_col: int32 = win_get(win, WIN_BODY_COLOR)

  fill_rect(buf, x + BORDER_SIZE, y + BORDER_SIZE + TITLE_HEIGHT, w - BORDER_SIZE * 2, h - BORDER_SIZE * 2 - TITLE_HEIGHT, body_col, xres, yres)

proc composite(buf: ptr uint32, windows: ptr int32, focused_idx: int32, xres: int32, yres: int32, bg_color: int32) =
  fill_rect(buf, 0, 0, xres, yres - TASKBAR_HEIGHT, bg_color, xres, yres)

  var i: int32 = 0
  while i < MAX_WINDOWS:
    if i != focused_idx:
      var win: ptr int32 = window_ptr(windows, i)
      if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
        if win_get(win, WIN_DECORATED) != 0:
          draw_decoration(buf, win, 0, xres, yres)
        draw_window_body(buf, win, xres, yres)
    i = i + 1

  if focused_idx >= 0 and focused_idx < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, focused_idx)
    if win_get(win, WIN_ACTIVE) != 0 and win_get(win, WIN_MINIMIZED) == 0:
      if win_get(win, WIN_DECORATED) != 0:
        draw_decoration(buf, win, 1, xres, yres)
      draw_window_body(buf, win, xres, yres)

proc draw_taskbar(buf: ptr uint32, windows: ptr int32, xres: int32, yres: int32) =
  var taskbar_y: int32 = yres - TASKBAR_HEIGHT
  fill_rect(buf, 0, taskbar_y, xres, TASKBAR_HEIGHT, 0x2D2D2D, xres, yres)
  fill_rect(buf, 0, taskbar_y, xres, 1, 0x505050, xres, yres)
  fill_rect(buf, 4, taskbar_y + 4, LAUNCHER_WIDTH, TASKBAR_HEIGHT - 8, 0x0066AA, xres, yres)
  draw_text(buf, 20, taskbar_y + 12, cast[ptr uint8]("Menu"), 0xFFFFFF, 0x0066AA, xres, yres, 10)

# ============ Main ============

proc main() =
  # Redirect output to debug file to avoid console text on screen
  var debug_fd: int32 = syscall3(SYS_open, cast[int32]("/tmp/bds_drm.log"), 66, 420)
  # 66 = O_RDWR|O_CREAT, 420 = 0644

  # Open DRM device
  var drm_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/dri/card0"), O_RDWR)
  if drm_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/dri/card0\n"))
    print_str(cast[ptr uint8]("Falling back to fbdev...\n"))
    discard syscall1(SYS_exit, 1)

  print_str(cast[ptr uint8]("DRM device opened: fd="))
  print_num(drm_fd)
  print_str(cast[ptr uint8]("\n"))

  # For now, also open fbdev for the main display (hybrid approach)
  # We'll use DRM just for hardware cursor
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info from fbdev
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 8192)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 256)
  var windows: ptr int32 = cast[ptr int32](old_brk + 512)
  var cursor_bo: ptr int32 = cast[ptr int32](old_brk + 4096)

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # Try to set up hardware cursor
  var cursor_result: int32 = create_cursor_bo(drm_fd, cursor_bo)
  var use_hw_cursor: int32 = 0
  var cursor_handle: int32 = 0
  var crtc_id: int32 = 0

  if cursor_result >= 0:
    cursor_handle = cursor_bo[3]  # handle is at offset 3 after ioctl
    # Map and draw cursor - need DRM_IOCTL_MODE_MAP_DUMB
    # For now, try with crtc_id = 0 (first CRTC)
    crtc_id = 41  # Common CRTC ID, may need to query
    use_hw_cursor = 1

  # Switch console to graphics mode (no text overlay)
  var tty_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/tty"), O_RDWR)
  if tty_fd >= 0:
    discard syscall3(SYS_ioctl, tty_fd, KDSETMODE, KD_GRAPHICS)

  # mmap framebuffer
  var buf_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    if tty_fd >= 0:
      discard syscall3(SYS_ioctl, tty_fd, KDSETMODE, KD_TEXT)
    discard syscall1(SYS_exit, 1)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd < 0:
    discard syscall1(SYS_exit, 1)
  var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
  discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Init windows
  var i: int32 = 0
  while i < MAX_WINDOWS:
    var win: ptr int32 = window_ptr(windows, i)
    win_set(win, WIN_ACTIVE, 0)
    i = i + 1

  # Create demo windows
  discard create_window(windows, 80, 60, 350, 250, 0x2255AA, 0xE8E8E8, 1)
  discard create_window(windows, 250, 140, 380, 280, 0x22AA55, 0xF0F0F0, 2)
  var focused: int32 = create_window(windows, 450, 100, 320, 240, 0xAA5522, 0xEEEEEE, 3)

  var cursor_x: int32 = xres / 2
  var cursor_y: int32 = yres / 2
  var bg_color: int32 = 0x1A3A5A

  if focused >= 0:
    var fwin: ptr int32 = window_ptr(windows, focused)
    win_set(fwin, WIN_FOCUSED, 1)

  # Initial scene render
  composite(framebuffer, windows, focused, xres, yres, bg_color)
  draw_taskbar(framebuffer, windows, xres, yres)

  # Set initial cursor position
  if use_hw_cursor != 0:
    set_hardware_cursor(drm_fd, crtc_id, cursor_handle, cursor_x, cursor_y)

  var running: int32 = 1
  while running != 0:
    # Batch mouse events
    var total_dx: int32 = 0
    var total_dy: int32 = 0
    var got_mouse: int32 = 0

    var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
    while bytes >= 3:
      got_mouse = 1
      var btns: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      if (btns & 0x10) != 0: dx = dx - 256
      if (btns & 0x20) != 0: dy = dy - 256

      total_dx = total_dx + dx
      total_dy = total_dy + dy

      bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

    if got_mouse != 0:
      cursor_x = cursor_x + total_dx
      cursor_y = cursor_y - total_dy
      if cursor_x < 0: cursor_x = 0
      if cursor_x >= xres: cursor_x = xres - 1
      if cursor_y < 0: cursor_y = 0
      if cursor_y >= yres: cursor_y = yres - 1

      if use_hw_cursor != 0:
        # Just one ioctl to move cursor - instant!
        move_hardware_cursor(drm_fd, crtc_id, cursor_x, cursor_y)

  # Restore text mode
  if tty_fd >= 0:
    discard syscall3(SYS_ioctl, tty_fd, KDSETMODE, KD_TEXT)
    discard syscall1(SYS_close, tty_fd)

  discard syscall1(SYS_close, drm_fd)
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_exit, 0)

main()
