from lib.syscalls import *
from lib.vtnext import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
SCREEN_WIDTH: Final[int32] = 1024
SCREEN_HEIGHT: Final[int32] = 768
GAME_LEFT: Final[int32] = 62
GAME_TOP: Final[int32] = 80
GAME_WIDTH: Final[int32] = 900
GAME_HEIGHT: Final[int32] = 600
GAME_RIGHT: Final[int32] = 962
GAME_BOTTOM: Final[int32] = 680
BRICK_ROWS: Final[int32] = 8
BRICK_COLS: Final[int32] = 14
BRICK_WIDTH: Final[int32] = 60
BRICK_HEIGHT: Final[int32] = 20
BRICK_GAP: Final[int32] = 4
BRICKS_LEFT: Final[int32] = 72
PADDLE_WIDTH: Final[int32] = 100
PADDLE_HEIGHT: Final[int32] = 15
PADDLE_Y: Final[int32] = 650
PADDLE_SPEED: Final[int32] = 12
BALL_SIZE: Final[int32] = 12
BALL_SPEED: Final[int32] = 6

brick_r: Array[8, int32]

brick_g: Array[8, int32]

brick_b: Array[8, int32]

bricks: Array[112, int32]

paddle_x: int32 = 450

ball_x: int32 = 500

ball_y: int32 = 400

ball_dx: int32 = 4

ball_dy: int32 = -5

running: int32 = 1

game_over: int32 = 0

game_won: int32 = 0

paused: int32 = 0

score: int32 = 0

lives: int32 = 3

bricks_left: int32 = 0

ball_launched: int32 = 0

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, (old_brk + 16))
    ts: Ptr[int32] = Ptr[int32](old_brk)
    ts[0] = 0
    ts[1] = (ms * 1000000)
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

def iabs(x: int32) -> int32:
    if (x < 0):
        return (0 - x)
    return x

def init_game():
    brick_r[0] = 255
    brick_g[0] = 80
    brick_b[0] = 80
    brick_r[1] = 255
    brick_g[1] = 140
    brick_b[1] = 60
    brick_r[2] = 255
    brick_g[2] = 200
    brick_b[2] = 60
    brick_r[3] = 120
    brick_g[3] = 220
    brick_b[3] = 80
    brick_r[4] = 60
    brick_g[4] = 200
    brick_b[4] = 180
    brick_r[5] = 80
    brick_g[5] = 160
    brick_b[5] = 255
    brick_r[6] = 140
    brick_g[6] = 100
    brick_b[6] = 255
    brick_r[7] = 200
    brick_g[7] = 80
    brick_b[7] = 200
    i: int32 = 0
    while (i < (BRICK_ROWS * BRICK_COLS)):
        bricks[i] = 1
        i = (i + 1)
    bricks_left = (BRICK_ROWS * BRICK_COLS)
    score = 0
    lives = 3
    game_over = 0
    game_won = 0
    paused = 0
    ball_launched = 0
    paddle_x = (((GAME_LEFT + GAME_RIGHT) / 2) - (PADDLE_WIDTH / 2))
    reset_ball()

def reset_ball():
    ball_x = (paddle_x + (PADDLE_WIDTH / 2))
    ball_y = ((PADDLE_Y - BALL_SIZE) - 5)
    ball_dx = 4
    ball_dy = -5
    ball_launched = 0

def launch_ball():
    if (ball_launched == 0):
        ball_launched = 1
        ball_dy = -5
        ball_dx = 4

def get_brick(row: int32, col: int32) -> int32:
    if ((row < 0) or (row >= BRICK_ROWS)):
        return 0
    if ((col < 0) or (col >= BRICK_COLS)):
        return 0
    return bricks[((row * BRICK_COLS) + col)]

def destroy_brick(row: int32, col: int32):
    if ((row < 0) or (row >= BRICK_ROWS)):
        return
    if ((col < 0) or (col >= BRICK_COLS)):
        return
    if (bricks[((row * BRICK_COLS) + col)] != 0):
        bricks[((row * BRICK_COLS) + col)] = 0
        bricks_left = (bricks_left - 1)
        score = (score + ((BRICK_ROWS - row) * 10))
        if (bricks_left == 0):
            game_won = 1
            game_over = 1

def check_brick_collision():
    row: int32 = 0
    while (row < BRICK_ROWS):
        col: int32 = 0
        while (col < BRICK_COLS):
            if (get_brick(row, col) != 0):
                bx: int32 = (BRICKS_LEFT + (col * (BRICK_WIDTH + BRICK_GAP)))
                by: int32 = ((GAME_TOP + 20) + (row * (BRICK_HEIGHT + BRICK_GAP)))
                bcx: int32 = (ball_x + (BALL_SIZE / 2))
                bcy: int32 = (ball_y + (BALL_SIZE / 2))
                if ((ball_x < (bx + BRICK_WIDTH)) and ((ball_x + BALL_SIZE) > bx)):
                    if ((ball_y < (by + BRICK_HEIGHT)) and ((ball_y + BALL_SIZE) > by)):
                        overlap_left: int32 = ((ball_x + BALL_SIZE) - bx)
                        overlap_right: int32 = ((bx + BRICK_WIDTH) - ball_x)
                        overlap_top: int32 = ((ball_y + BALL_SIZE) - by)
                        overlap_bottom: int32 = ((by + BRICK_HEIGHT) - ball_y)
                        min_overlap_x: int32 = overlap_left
                        if (overlap_right < min_overlap_x):
                            min_overlap_x = overlap_right
                        min_overlap_y: int32 = overlap_top
                        if (overlap_bottom < min_overlap_y):
                            min_overlap_y = overlap_bottom
                        if (min_overlap_x < min_overlap_y):
                            ball_dx = (0 - ball_dx)
                        else:
                            ball_dy = (0 - ball_dy)
                        destroy_brick(row, col)
                        return
            col = (col + 1)
        row = (row + 1)

def update_ball():
    if (ball_launched == 0):
        ball_x = ((paddle_x + (PADDLE_WIDTH / 2)) - (BALL_SIZE / 2))
        ball_y = ((PADDLE_Y - BALL_SIZE) - 5)
        return
    ball_x = (ball_x + ball_dx)
    ball_y = (ball_y + ball_dy)
    if (ball_x <= GAME_LEFT):
        ball_x = GAME_LEFT
        ball_dx = iabs(ball_dx)
    if ((ball_x + BALL_SIZE) >= GAME_RIGHT):
        ball_x = (GAME_RIGHT - BALL_SIZE)
        ball_dx = (0 - iabs(ball_dx))
    if (ball_y <= GAME_TOP):
        ball_y = GAME_TOP
        ball_dy = iabs(ball_dy)
    if ((ball_y + BALL_SIZE) >= GAME_BOTTOM):
        lives = (lives - 1)
        if (lives <= 0):
            game_over = 1
        else:
            reset_ball()
        return
    if (((ball_y + BALL_SIZE) >= PADDLE_Y) and (ball_y < (PADDLE_Y + PADDLE_HEIGHT))):
        if (((ball_x + BALL_SIZE) >= paddle_x) and (ball_x <= (paddle_x + PADDLE_WIDTH))):
            ball_y = (PADDLE_Y - BALL_SIZE)
            ball_dy = (0 - iabs(ball_dy))
            hit_pos: int32 = ((ball_x + (BALL_SIZE / 2)) - paddle_x)
            relative: int32 = (hit_pos - (PADDLE_WIDTH / 2))
            ball_dx = (relative / 8)
            if (ball_dx < -6):
                ball_dx = -6
            if (ball_dx > 6):
                ball_dx = 6
            if ((ball_dx > -2) and (ball_dx < 2)):
                if (ball_dx < 0):
                    ball_dx = -2
                else:
                    ball_dx = 2
    check_brick_collision()

def render():
    vtn_clear_color(20, 25, 35, 255)
    vtn_fill_rect((GAME_LEFT - 5), (GAME_TOP - 5), (GAME_WIDTH + 10), 5, 80, 90, 110, 255)
    vtn_fill_rect((GAME_LEFT - 5), (GAME_TOP - 5), 5, (GAME_HEIGHT + 10), 80, 90, 110, 255)
    vtn_fill_rect(GAME_RIGHT, (GAME_TOP - 5), 5, (GAME_HEIGHT + 10), 80, 90, 110, 255)
    vtn_text_simple(Ptr[uint8]("BREAKOUT"), ((SCREEN_WIDTH / 2) - 50), 25, 220, 230, 240)
    score_str: Array[20, uint8]
    pos: int32 = 0
    score_str[pos] = cast[uint8](83)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](99)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](111)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](114)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](101)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](58)
    pos = (pos + 1)
    score_str[pos] = cast[uint8](32)
    pos = (pos + 1)
    num: int32 = score
    digits: Array[10, uint8]
    dcount: int32 = 0
    if (num == 0):
        digits[0] = cast[uint8](48)
        dcount = 1
    else:
        while (num > 0):
            digits[dcount] = cast[uint8]((48 + (num - ((num / 10) * 10))))
            num = (num / 10)
            dcount = (dcount + 1)
    i: int32 = (dcount - 1)
    while (i >= 0):
        score_str[pos] = digits[i]
        pos = (pos + 1)
        i = (i - 1)
    score_str[pos] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(score_str)), 100, 50, 255, 220, 100)
    lives_str: Array[20, uint8]
    pos = 0
    lives_str[pos] = cast[uint8](76)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](105)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](118)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](101)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](115)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](58)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](32)
    pos = (pos + 1)
    lives_str[pos] = cast[uint8]((48 + lives))
    pos = (pos + 1)
    lives_str[pos] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(lives_str)), (SCREEN_WIDTH - 180), 50, 255, 100, 100)
    row: int32 = 0
    while (row < BRICK_ROWS):
        col: int32 = 0
        while (col < BRICK_COLS):
            if (get_brick(row, col) != 0):
                bx: int32 = (BRICKS_LEFT + (col * (BRICK_WIDTH + BRICK_GAP)))
                by: int32 = ((GAME_TOP + 20) + (row * (BRICK_HEIGHT + BRICK_GAP)))
                vtn_fill_rect(bx, by, BRICK_WIDTH, BRICK_HEIGHT, brick_r[row], brick_g[row], brick_b[row], 255)
                hr: int32 = (brick_r[row] + 40)
                hg: int32 = (brick_g[row] + 40)
                hb: int32 = (brick_b[row] + 40)
                if (hr > 255):
                    hr = 255
                if (hg > 255):
                    hg = 255
                if (hb > 255):
                    hb = 255
                vtn_fill_rect(bx, by, (BRICK_WIDTH - 2), 3, hr, hg, hb, 255)
                sr: int32 = (brick_r[row] - 40)
                sg: int32 = (brick_g[row] - 40)
                sb: int32 = (brick_b[row] - 40)
                if (sr < 0):
                    sr = 0
                if (sg < 0):
                    sg = 0
                if (sb < 0):
                    sb = 0
                vtn_fill_rect((bx + 2), ((by + BRICK_HEIGHT) - 3), (BRICK_WIDTH - 2), 3, sr, sg, sb, 255)
            col = (col + 1)
        row = (row + 1)
    vtn_fill_rect(paddle_x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT, 200, 210, 220, 255)
    vtn_fill_rect(paddle_x, PADDLE_Y, PADDLE_WIDTH, 3, 230, 240, 250, 255)
    vtn_fill_rect(paddle_x, ((PADDLE_Y + PADDLE_HEIGHT) - 3), PADDLE_WIDTH, 3, 140, 150, 160, 255)
    vtn_fill_circle((ball_x + (BALL_SIZE / 2)), (ball_y + (BALL_SIZE / 2)), (BALL_SIZE / 2), 255, 255, 255, 255)
    vtn_fill_circle(((ball_x + (BALL_SIZE / 2)) - 2), ((ball_y + (BALL_SIZE / 2)) - 2), 2, 255, 255, 220, 200)
    if (game_over != 0):
        if (game_won != 0):
            vtn_fill_rect(((SCREEN_WIDTH / 2) - 150), ((SCREEN_HEIGHT / 2) - 60), 300, 120, 50, 120, 50, 230)
            vtn_text_simple(Ptr[uint8]("YOU WIN!"), ((SCREEN_WIDTH / 2) - 50), ((SCREEN_HEIGHT / 2) - 30), 255, 255, 255)
            final_str: Array[30, uint8]
            pos = 0
            final_str[pos] = cast[uint8](70)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](105)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](110)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](97)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](108)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](32)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](83)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](99)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](111)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](114)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](101)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](58)
            pos = (pos + 1)
            final_str[pos] = cast[uint8](32)
            pos = (pos + 1)
            num = score
            dcount = 0
            if (num == 0):
                digits[0] = cast[uint8](48)
                dcount = 1
            else:
                while (num > 0):
                    digits[dcount] = cast[uint8]((48 + (num - ((num / 10) * 10))))
                    num = (num / 10)
                    dcount = (dcount + 1)
            i = (dcount - 1)
            while (i >= 0):
                final_str[pos] = digits[i]
                pos = (pos + 1)
                i = (i - 1)
            final_str[pos] = cast[uint8](0)
            vtn_text_simple(Ptr[uint8](addr(final_str)), ((SCREEN_WIDTH / 2) - 80), (SCREEN_HEIGHT / 2), 200, 255, 200)
            vtn_text_simple(Ptr[uint8]("Press R to play again"), ((SCREEN_WIDTH / 2) - 90), ((SCREEN_HEIGHT / 2) + 30), 180, 180, 180)
        else:
            vtn_fill_rect(((SCREEN_WIDTH / 2) - 150), ((SCREEN_HEIGHT / 2) - 60), 300, 120, 120, 50, 50, 230)
            vtn_text_simple(Ptr[uint8]("GAME OVER"), ((SCREEN_WIDTH / 2) - 55), ((SCREEN_HEIGHT / 2) - 30), 255, 255, 255)
            vtn_text_simple(Ptr[uint8]("Press R to play again"), ((SCREEN_WIDTH / 2) - 90), ((SCREEN_HEIGHT / 2) + 10), 180, 180, 180)
    if ((ball_launched == 0) and (game_over == 0)):
        vtn_text_simple(Ptr[uint8]("Press SPACE to launch ball"), ((SCREEN_WIDTH / 2) - 120), (SCREEN_HEIGHT - 60), 150, 200, 150)
    vtn_text_simple(Ptr[uint8]("Left/Right: Move   Space: Launch   R: Restart   Q: Quit"), 220, (SCREEN_HEIGHT - 30), 120, 130, 150)
    vtn_flush()

def handle_input():
    buf: Array[16, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 16)
    if (n <= 0):
        return
    i: int32 = 0
    while (i < n):
        c: int32 = cast[int32](buf[i])
        if ((c == 27) and ((i + 2) < n)):
            if (buf[(i + 1)] == cast[uint8](91)):
                code: int32 = cast[int32](buf[(i + 2)])
                if (game_over == 0):
                    if (code == 67):
                        paddle_x = (paddle_x + PADDLE_SPEED)
                        if ((paddle_x + PADDLE_WIDTH) > GAME_RIGHT):
                            paddle_x = (GAME_RIGHT - PADDLE_WIDTH)
                    elif (code == 68):
                        paddle_x = (paddle_x - PADDLE_SPEED)
                        if (paddle_x < GAME_LEFT):
                            paddle_x = GAME_LEFT
                i = (i + 3)
                continue
        if ((c == 113) or (c == 81)):
            running = 0
        elif (c == 17):
            running = 0
        elif ((c == 114) or (c == 82)):
            init_game()
        elif (c == 32):
            if (game_over == 0):
                launch_ball()
        elif ((c == 97) or (c == 65)):
            if (game_over == 0):
                paddle_x = (paddle_x - PADDLE_SPEED)
                if (paddle_x < GAME_LEFT):
                    paddle_x = GAME_LEFT
        elif ((c == 100) or (c == 68)):
            if (game_over == 0):
                paddle_x = (paddle_x + PADDLE_SPEED)
                if ((paddle_x + PADDLE_WIDTH) > GAME_RIGHT):
                    paddle_x = (GAME_RIGHT - PADDLE_WIDTH)
        i = (i + 1)

def main() -> int32:
    vtn_init_raw()
    vtn_cursor_hide()
    vtn_flush()
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, (flags | O_NONBLOCK))
    init_game()
    while (running != 0):
        handle_input()
        if ((game_over == 0) and (paused == 0)):
            update_ball()
        render()
        sleep_ms(16)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags)
    vtn_cursor_show()
    vtn_flush()
    return 0