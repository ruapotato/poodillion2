# 2048 - The classic sliding puzzle game
# Arrow keys or WASD to slide tiles, Q to quit, R to restart

from lib.syscalls import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3

PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_SHARED: Final[int32] = 1

# Game constants
GRID_SIZE: Final[int32] = 4
CELL_SIZE: Final[int32] = 100
CELL_GAP: Final[int32] = 10

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Game state - 4x4 grid of tile values (0, 2, 4, 8, 16, ... 2048)
g_board: array[16, int32]
g_score: int32 = 0
g_game_over: int32 = 0
g_won: int32 = 0
g_running: int32 = 1

# Board position on screen
g_board_x: int32 = 0
g_board_y: int32 = 0

# Random state
g_rand_state: int32 = 12345

# Color table for tile values
g_tile_colors: array[12, int32]    # bg colors for 2^1 to 2^11 + empty
g_text_colors: array[12, int32]    # text colors

def print_str(s: *uint8):
        len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
        _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
        old_brk: int32 = syscall1(SYS_brk, 0)
        _ = syscall1(SYS_brk, old_brk + 16)
        ts: *int32 = cast[*int32](old_brk)
    ts[0] = 0
    ts[1] = ms * 1000000
        _ = syscall2(SYS_nanosleep, cast[int32](ts), 0)

def random() -> int32:
    g_rand_state = g_rand_state * 1103515245 + 12345
        r: int32 = g_rand_state / 65536
    if r < 0:
        r = 0 - r
    return r

def init_colors():
    # Background colors for empty, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
    g_tile_colors[0] = 0xCDC1B4    # empty
    g_tile_colors[1] = 0xEEE4DA    # 2
    g_tile_colors[2] = 0xEDE0C8    # 4
    g_tile_colors[3] = 0xF2B179    # 8
    g_tile_colors[4] = 0xF59563    # 16
    g_tile_colors[5] = 0xF67C5F    # 32
    g_tile_colors[6] = 0xF65E3B    # 64
    g_tile_colors[7] = 0xEDCF72    # 128
    g_tile_colors[8] = 0xEDCC61    # 256
    g_tile_colors[9] = 0xEDC850    # 512
    g_tile_colors[10] = 0xEDC53F   # 1024
    g_tile_colors[11] = 0xEDC22E   # 2048

    # Text colors - dark for light tiles, white for dark tiles
    g_text_colors[0] = 0x776E65    # empty (not shown)
    g_text_colors[1] = 0x776E65    # 2
    g_text_colors[2] = 0x776E65    # 4
    g_text_colors[3] = 0xF9F6F2    # 8
    g_text_colors[4] = 0xF9F6F2    # 16
    g_text_colors[5] = 0xF9F6F2    # 32
    g_text_colors[6] = 0xF9F6F2    # 64
    g_text_colors[7] = 0xF9F6F2    # 128
    g_text_colors[8] = 0xF9F6F2    # 256
    g_text_colors[9] = 0xF9F6F2    # 512
    g_text_colors[10] = 0xF9F6F2   # 1024
    g_text_colors[11] = 0xF9F6F2   # 2048

# ============ Graphics ============

def set_pixel(x: int32, y: int32, color: int32):
    if x < 0 or x >= g_xres or y < 0 or y >= g_yres:
        return
    g_fb[y * g_xres + x] = cast[uint32](color)

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
        py: int32 = y
    while py < y + h:
        if py >= 0 and py < g_yres:
                        px: int32 = x
            while px < x + w:
                if px >= 0 and px < g_xres:
                    g_fb[py * g_xres + px] = cast[uint32](color)
                px = px + 1
        py = py + 1

def draw_rounded_rect(x: int32, y: int32, w: int32, h: int32, color: int32, radius: int32):
    # Draw main rectangle
    fill_rect(x + radius, y, w - radius * 2, h, color)
    fill_rect(x, y + radius, w, h - radius * 2, color)

    # Draw corner circles (simplified as filled rectangles for now)
    fill_rect(x, y, radius, radius, color)
    fill_rect(x + w - radius, y, radius, radius, color)
    fill_rect(x, y + h - radius, radius, radius, color)
    fill_rect(x + w - radius, y + h - radius, radius, radius, color)

# Simple 8x8 font - just digits for 2048
def draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32):
        pattern: array[10, int32]
    # Each digit is 5 wide x 7 tall, encoded as 7 rows of 5 bits
    pattern[0] = 0x0E11111E  # 0: 01110, 10001, 10001, 10001, 10001, 10001, 01110
    pattern[1] = 0x04060404  # 1: 00100, 00110, 00100, 00100, 00100, 00100, 01110
    pattern[2] = 0x0E01071E  # 2: 01110, 00001, 00001, 01110, 10000, 10000, 11111
    pattern[3] = 0x0E010E1E  # 3: 01110, 00001, 00001, 01110, 00001, 00001, 01110
    pattern[4] = 0x11111F01  # 4: 10001, 10001, 10001, 11111, 00001, 00001, 00001
    pattern[5] = 0x1F10071E  # 5: 11111, 10000, 10000, 01110, 00001, 00001, 01110
    pattern[6] = 0x0E101E0E  # 6: 01110, 10000, 10000, 11110, 10001, 10001, 01110
    pattern[7] = 0x1F010204  # 7: 11111, 00001, 00010, 00100, 01000, 01000, 01000
    pattern[8] = 0x0E110E0E  # 8: 01110, 10001, 10001, 01110, 10001, 10001, 01110
    pattern[9] = 0x0E110F0E  # 9: 01110, 10001, 10001, 01111, 00001, 00001, 01110

    if d < 0 or d > 9:
        return

    # Simplified digit rendering - 5x7 bitmap scaled
    # Row 0
    if d == 0:
        fill_rect(x + scale, y, scale * 3, scale, color)  # top
        fill_rect(x, y + scale, scale, scale * 5, color)  # left
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)  # right
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
    elif d == 1:
        fill_rect(x + scale * 2, y, scale, scale * 7, color)  # vertical
        fill_rect(x + scale, y + scale, scale, scale, color)  # top left hook
        fill_rect(x, y + scale * 6, scale * 5, scale, color)  # base
    elif d == 2:
        fill_rect(x + scale, y, scale * 3, scale, color)  # top
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
        fill_rect(x, y + scale * 4, scale, scale * 2, color)  # bottom left
        fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
    elif d == 3:
        fill_rect(x, y, scale * 5, scale, color)  # top
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
        fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
    elif d == 4:
        fill_rect(x, y, scale, scale * 4, color)  # top left
        fill_rect(x + scale * 4, y, scale, scale * 7, color)  # right
        fill_rect(x, y + scale * 3, scale * 5, scale, color)  # middle
    elif d == 5:
        fill_rect(x, y, scale * 5, scale, color)  # top
        fill_rect(x, y + scale, scale, scale * 2, color)  # top left
        fill_rect(x, y + scale * 3, scale * 4, scale, color)  # middle
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
        fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
    elif d == 6:
        fill_rect(x + scale, y, scale * 3, scale, color)  # top
        fill_rect(x, y + scale, scale, scale * 5, color)  # left
        fill_rect(x, y + scale * 3, scale * 4, scale, color)  # middle
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
    elif d == 7:
        fill_rect(x, y, scale * 5, scale, color)  # top
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
        fill_rect(x + scale * 3, y + scale * 3, scale, scale * 2, color)  # middle
        fill_rect(x + scale * 2, y + scale * 5, scale, scale * 2, color)  # bottom
    elif d == 8:
        fill_rect(x + scale, y, scale * 3, scale, color)  # top
        fill_rect(x, y + scale, scale, scale * 2, color)  # top left
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
        fill_rect(x, y + scale * 4, scale, scale * 2, color)  # bottom left
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
    elif d == 9:
        fill_rect(x + scale, y, scale * 3, scale, color)  # top
        fill_rect(x, y + scale, scale, scale * 2, color)  # top left
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)  # right
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom

def draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32):
    if num <= 0:
        return

    # Count digits
        n: int32 = num
        digits: int32 = 0
    while n > 0:
        digits = digits + 1
        n = n / 10

    # Extract digits in reverse order
        digit_arr: array[5, int32]
    n = num
        i: int32 = digits - 1
    while i >= 0:
        digit_arr[i] = n - (n / 10) * 10
        n = n / 10
        i = i - 1

    # Draw each digit
        dx: int32 = x
    i = 0
    while i < digits:
        draw_digit(digit_arr[i], dx, y, color, scale)
        dx = dx + scale * 6
        i = i + 1

# ============ Game Logic ============

def get_tile_color_index(value: int32) -> int32:
    if value == 0: return 0
    if value == 2: return 1
    if value == 4: return 2
    if value == 8: return 3
    if value == 16: return 4
    if value == 32: return 5
    if value == 64: return 6
    if value == 128: return 7
    if value == 256: return 8
    if value == 512: return 9
    if value == 1024: return 10
    return 11  # 2048 or higher

def init_game():
    g_score = 0
    g_game_over = 0
    g_won = 0

    # Clear board
        i: int32 = 0
    while i < 16:
        g_board[i] = 0
        i = i + 1

    # Seed random with time
        t: int32 = syscall1(SYS_time, 0)
    g_rand_state = t

def count_empty() -> int32:
        count: int32 = 0
        i: int32 = 0
    while i < 16:
        if g_board[i] == 0:
            count = count + 1
        i = i + 1
    return count

def add_random_tile():
        empty: int32 = count_empty()
    if empty == 0:
        return

        pos: int32 = random() - (random() / empty) * empty  # modulo

    # Find the pos-th empty cell
        i: int32 = 0
        found: int32 = 0
    while i < 16 and found == 0:
        if g_board[i] == 0:
            if pos == 0:
                # 90% chance of 2, 10% chance of 4
                if random() - (random() / 10) * 10 == 0:
                    g_board[i] = 4
                else:
                    g_board[i] = 2
                found = 1
            else:
                pos = pos - 1
        i = i + 1

def can_move() -> int32:
        i: int32 = 0

    # Check for empty cells
    while i < 16:
        if g_board[i] == 0:
            return 1
        i = i + 1

    # Check for adjacent matching tiles
        y: int32 = 0
    while y < 4:
                x: int32 = 0
        while x < 4:
                        val: int32 = g_board[y * 4 + x]
            # Check right
            if x < 3:
                if g_board[y * 4 + x + 1] == val:
                    return 1
            # Check down
            if y < 3:
                if g_board[(y + 1) * 4 + x] == val:
                    return 1
            x = x + 1
        y = y + 1

    return 0

def slide_left() -> int32:
        moved: int32 = 0
        y: int32 = 0

    while y < 4:
        # Slide tiles left, merge matching
                merged: array[4, int32]
        merged[0] = 0
        merged[1] = 0
        merged[2] = 0
        merged[3] = 0

                write_pos: int32 = 0
                x: int32 = 0

        while x < 4:
                        val: int32 = g_board[y * 4 + x]
            if val != 0:
                if write_pos > 0 and g_board[y * 4 + write_pos - 1] == val and merged[write_pos - 1] == 0:
                    # Merge
                    g_board[y * 4 + write_pos - 1] = val * 2
                    g_score = g_score + val * 2
                    merged[write_pos - 1] = 1
                    g_board[y * 4 + x] = 0
                    moved = 1
                    if val * 2 == 2048:
                        g_won = 1
                else:
                    if write_pos != x:
                        g_board[y * 4 + write_pos] = val
                        g_board[y * 4 + x] = 0
                        moved = 1
                    write_pos = write_pos + 1
            x = x + 1
        y = y + 1

    return moved

def slide_right() -> int32:
        moved: int32 = 0
        y: int32 = 0

    while y < 4:
                merged: array[4, int32]
        merged[0] = 0
        merged[1] = 0
        merged[2] = 0
        merged[3] = 0

                write_pos: int32 = 3
                x: int32 = 3

        while x >= 0:
                        val: int32 = g_board[y * 4 + x]
            if val != 0:
                if write_pos < 3 and g_board[y * 4 + write_pos + 1] == val and merged[write_pos + 1] == 0:
                    g_board[y * 4 + write_pos + 1] = val * 2
                    g_score = g_score + val * 2
                    merged[write_pos + 1] = 1
                    g_board[y * 4 + x] = 0
                    moved = 1
                    if val * 2 == 2048:
                        g_won = 1
                else:
                    if write_pos != x:
                        g_board[y * 4 + write_pos] = val
                        g_board[y * 4 + x] = 0
                        moved = 1
                    write_pos = write_pos - 1
            x = x - 1
        y = y + 1

    return moved

def slide_up() -> int32:
        moved: int32 = 0
        x: int32 = 0

    while x < 4:
                merged: array[4, int32]
        merged[0] = 0
        merged[1] = 0
        merged[2] = 0
        merged[3] = 0

                write_pos: int32 = 0
                y: int32 = 0

        while y < 4:
                        val: int32 = g_board[y * 4 + x]
            if val != 0:
                if write_pos > 0 and g_board[(write_pos - 1) * 4 + x] == val and merged[write_pos - 1] == 0:
                    g_board[(write_pos - 1) * 4 + x] = val * 2
                    g_score = g_score + val * 2
                    merged[write_pos - 1] = 1
                    g_board[y * 4 + x] = 0
                    moved = 1
                    if val * 2 == 2048:
                        g_won = 1
                else:
                    if write_pos != y:
                        g_board[write_pos * 4 + x] = val
                        g_board[y * 4 + x] = 0
                        moved = 1
                    write_pos = write_pos + 1
            y = y + 1
        x = x + 1

    return moved

def slide_down() -> int32:
        moved: int32 = 0
        x: int32 = 0

    while x < 4:
                merged: array[4, int32]
        merged[0] = 0
        merged[1] = 0
        merged[2] = 0
        merged[3] = 0

                write_pos: int32 = 3
                y: int32 = 3

        while y >= 0:
                        val: int32 = g_board[y * 4 + x]
            if val != 0:
                if write_pos < 3 and g_board[(write_pos + 1) * 4 + x] == val and merged[write_pos + 1] == 0:
                    g_board[(write_pos + 1) * 4 + x] = val * 2
                    g_score = g_score + val * 2
                    merged[write_pos + 1] = 1
                    g_board[y * 4 + x] = 0
                    moved = 1
                    if val * 2 == 2048:
                        g_won = 1
                else:
                    if write_pos != y:
                        g_board[write_pos * 4 + x] = val
                        g_board[y * 4 + x] = 0
                        moved = 1
                    write_pos = write_pos - 1
            y = y - 1
        x = x + 1

    return moved

# ============ Drawing ============

def draw_tile(x: int32, y: int32, value: int32):
        px: int32 = g_board_x + x * (CELL_SIZE + CELL_GAP)
        py: int32 = g_board_y + y * (CELL_SIZE + CELL_GAP)

        color_idx: int32 = get_tile_color_index(value)
        bg_color: int32 = g_tile_colors[color_idx]
        text_color: int32 = g_text_colors[color_idx]

    # Draw tile background
    draw_rounded_rect(px, py, CELL_SIZE, CELL_SIZE, bg_color, 6)

    # Draw number if not empty
    if value > 0:
        # Calculate number width and center it
                n: int32 = value
                digits: int32 = 0
        while n > 0:
            digits = digits + 1
            n = n / 10

        # Choose scale based on number of digits
                scale: int32 = 8
        if digits >= 4:
            scale = 5
        elif digits == 3:
            scale = 6

                num_width: int32 = digits * scale * 6 - scale
                num_x: int32 = px + (CELL_SIZE - num_width) / 2
                num_y: int32 = py + (CELL_SIZE - scale * 7) / 2

        draw_number(value, num_x, num_y, text_color, scale)

def draw_board():
    # Draw board background
        board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
    draw_rounded_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP, board_size, board_size, 0xBBADA0, 8)

    # Draw tiles
        y: int32 = 0
    while y < GRID_SIZE:
                x: int32 = 0
        while x < GRID_SIZE:
            draw_tile(x, y, g_board[y * GRID_SIZE + x])
            x = x + 1
        y = y + 1

def draw_header():
    # Title "2048"
        title_x: int32 = g_board_x
        title_y: int32 = 20
    draw_number(2048, title_x, title_y, 0x776E65, 10)

    # Score
        score_x: int32 = g_board_x + 300
    fill_rect(score_x, title_y, 100, 50, 0xBBADA0)

    # Draw "SCORE" label - simplified as just the number
    draw_number(g_score, score_x + 10, title_y + 20, 0xFFFFFF, 4)

def draw_game_over():
    if g_game_over != 0:
        # Semi-transparent overlay (just darker background)
                board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
        fill_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP + 150, board_size, 100, 0x000000)

        # "GAME OVER" - represented as numbers for simplicity
        # We'll show 0 for game over
        draw_number(0, g_board_x + 150, g_board_y + 180, 0xFF0000, 12)

def draw_won():
    if g_won != 0:
                board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
        fill_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP + 150, board_size, 100, 0x00AA00)

        # Show 2048 for winning
        draw_number(2048, g_board_x + 100, g_board_y + 180, 0xFFFFFF, 12)

def draw_screen():
    # Clear screen with background color
    fill_rect(0, 0, g_xres, g_yres, 0xFAF8EF)

    draw_header()
    draw_board()

    if g_game_over != 0:
        draw_game_over()
    elif g_won != 0:
        draw_won()

# ============ Input ============

def handle_input():
        buf: array[8, uint8]
        n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

    if n <= 0:
        return

        c: int32 = cast[int32](buf[0])
        moved: int32 = 0

    # Check for escape sequences (arrow keys)
    if c == 27 and n >= 3:
        if buf[1] == cast[uint8](91):
            if buf[2] == cast[uint8](65):      # Up arrow
                moved = slide_up()
            elif buf[2] == cast[uint8](66):    # Down arrow
                moved = slide_down()
            elif buf[2] == cast[uint8](67):    # Right arrow
                moved = slide_right()
            elif buf[2] == cast[uint8](68):    # Left arrow
                moved = slide_left()
    elif c == 119 or c == 87:  # w/W
        moved = slide_up()
    elif c == 115 or c == 83:  # s/S
        moved = slide_down()
    elif c == 100 or c == 68:  # d/D - but 68 is also 'D' which conflicts with arrow
        if n == 1:
            moved = slide_right()
    elif c == 97 or c == 65:   # a/A
        if n == 1:
            moved = slide_left()
    elif c == 113 or c == 81:  # q/Q
        g_running = 0
    elif c == 114 or c == 82:  # r/R - restart
        init_game()
        add_random_tile()
        add_random_tile()

    if moved != 0 and g_game_over == 0:
        add_random_tile()
        if can_move() == 0:
            g_game_over = 1

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
        old_brk: int32 = syscall1(SYS_brk, 0)
        _ = syscall1(SYS_brk, old_brk + 256)

        path: *uint8 = cast[*uint8]("/dev/fb0")
    g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
    if g_fb_fd < 0:
        print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
        return 1

        vinfo: *int32 = cast[*int32](old_brk + 32)
        i: int32 = 0
    while i < 40:
        vinfo[i] = 0
        i = i + 1

    const FBIOGET_VSCREENINFO: int32 = 0x4600
        _ = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

    g_xres = vinfo[0]
    g_yres = vinfo[1]

        fb_size: int32 = g_xres * g_yres * 4
        fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
    if fb_addr < 0:
        return 1

    g_fb = cast[*uint32](fb_addr)
    return 0

# ============ Main ============

def main() -> int32:
    if init_framebuffer() != 0:
        return 1

    init_colors()

    # Set stdin to non-blocking
        flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
        _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

    # Calculate board position (centered)
        board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
    g_board_x = (g_xres - board_size) / 2
    g_board_y = (g_yres - board_size) / 2 + 30

    # Initialize game
    init_game()
    add_random_tile()
    add_random_tile()

    # Main loop
    while g_running != 0:
        draw_screen()
        handle_input()
        sleep_ms(50)

    # Restore stdin
        _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

    # Clear screen
    fill_rect(0, 0, g_xres, g_yres, 0)

    return 0
