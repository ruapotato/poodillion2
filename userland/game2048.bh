# 2048 - The classic sliding puzzle game
# Arrow keys or WASD to slide tiles, Q to quit, R to restart

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192
const SYS_nanosleep: int32 = 162
const SYS_time: int32 = 13

const STDIN: int32 = 0
const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const GRID_SIZE: int32 = 4
const CELL_SIZE: int32 = 100
const CELL_GAP: int32 = 10

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Game state - 4x4 grid of tile values (0, 2, 4, 8, 16, ... 2048)
var g_board: array[16, int32]
var g_score: int32 = 0
var g_game_over: int32 = 0
var g_won: int32 = 0
var g_running: int32 = 1

# Board position on screen
var g_board_x: int32 = 0
var g_board_y: int32 = 0

# Random state
var g_rand_state: int32 = 12345

# Color table for tile values
var g_tile_colors: array[12, int32]    # bg colors for 2^1 to 2^11 + empty
var g_text_colors: array[12, int32]    # text colors

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

proc random(): int32 =
  g_rand_state = g_rand_state * 1103515245 + 12345
  var r: int32 = g_rand_state / 65536
  if r < 0:
    r = 0 - r
  return r

proc init_colors() =
  # Background colors for empty, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048
  g_tile_colors[0] = 0xCDC1B4    # empty
  g_tile_colors[1] = 0xEEE4DA    # 2
  g_tile_colors[2] = 0xEDE0C8    # 4
  g_tile_colors[3] = 0xF2B179    # 8
  g_tile_colors[4] = 0xF59563    # 16
  g_tile_colors[5] = 0xF67C5F    # 32
  g_tile_colors[6] = 0xF65E3B    # 64
  g_tile_colors[7] = 0xEDCF72    # 128
  g_tile_colors[8] = 0xEDCC61    # 256
  g_tile_colors[9] = 0xEDC850    # 512
  g_tile_colors[10] = 0xEDC53F   # 1024
  g_tile_colors[11] = 0xEDC22E   # 2048

  # Text colors - dark for light tiles, white for dark tiles
  g_text_colors[0] = 0x776E65    # empty (not shown)
  g_text_colors[1] = 0x776E65    # 2
  g_text_colors[2] = 0x776E65    # 4
  g_text_colors[3] = 0xF9F6F2    # 8
  g_text_colors[4] = 0xF9F6F2    # 16
  g_text_colors[5] = 0xF9F6F2    # 32
  g_text_colors[6] = 0xF9F6F2    # 64
  g_text_colors[7] = 0xF9F6F2    # 128
  g_text_colors[8] = 0xF9F6F2    # 256
  g_text_colors[9] = 0xF9F6F2    # 512
  g_text_colors[10] = 0xF9F6F2   # 1024
  g_text_colors[11] = 0xF9F6F2   # 2048

# ============ Graphics ============

proc set_pixel(x: int32, y: int32, color: int32) =
  if x < 0 or x >= g_xres or y < 0 or y >= g_yres:
    return
  g_fb[y * g_xres + x] = cast[uint32](color)

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var py: int32 = y
  while py < y + h:
    if py >= 0 and py < g_yres:
      var px: int32 = x
      while px < x + w:
        if px >= 0 and px < g_xres:
          g_fb[py * g_xres + px] = cast[uint32](color)
        px = px + 1
    py = py + 1

proc draw_rounded_rect(x: int32, y: int32, w: int32, h: int32, color: int32, radius: int32) =
  # Draw main rectangle
  fill_rect(x + radius, y, w - radius * 2, h, color)
  fill_rect(x, y + radius, w, h - radius * 2, color)

  # Draw corner circles (simplified as filled rectangles for now)
  fill_rect(x, y, radius, radius, color)
  fill_rect(x + w - radius, y, radius, radius, color)
  fill_rect(x, y + h - radius, radius, radius, color)
  fill_rect(x + w - radius, y + h - radius, radius, radius, color)

# Simple 8x8 font - just digits for 2048
proc draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32) =
  var pattern: array[10, int32]
  # Each digit is 5 wide x 7 tall, encoded as 7 rows of 5 bits
  pattern[0] = 0x0E11111E  # 0: 01110, 10001, 10001, 10001, 10001, 10001, 01110
  pattern[1] = 0x04060404  # 1: 00100, 00110, 00100, 00100, 00100, 00100, 01110
  pattern[2] = 0x0E01071E  # 2: 01110, 00001, 00001, 01110, 10000, 10000, 11111
  pattern[3] = 0x0E010E1E  # 3: 01110, 00001, 00001, 01110, 00001, 00001, 01110
  pattern[4] = 0x11111F01  # 4: 10001, 10001, 10001, 11111, 00001, 00001, 00001
  pattern[5] = 0x1F10071E  # 5: 11111, 10000, 10000, 01110, 00001, 00001, 01110
  pattern[6] = 0x0E101E0E  # 6: 01110, 10000, 10000, 11110, 10001, 10001, 01110
  pattern[7] = 0x1F010204  # 7: 11111, 00001, 00010, 00100, 01000, 01000, 01000
  pattern[8] = 0x0E110E0E  # 8: 01110, 10001, 10001, 01110, 10001, 10001, 01110
  pattern[9] = 0x0E110F0E  # 9: 01110, 10001, 10001, 01111, 00001, 00001, 01110

  if d < 0 or d > 9:
    return

  # Simplified digit rendering - 5x7 bitmap scaled
  # Row 0
  if d == 0:
    fill_rect(x + scale, y, scale * 3, scale, color)  # top
    fill_rect(x, y + scale, scale, scale * 5, color)  # left
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)  # right
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
  elif d == 1:
    fill_rect(x + scale * 2, y, scale, scale * 7, color)  # vertical
    fill_rect(x + scale, y + scale, scale, scale, color)  # top left hook
    fill_rect(x, y + scale * 6, scale * 5, scale, color)  # base
  elif d == 2:
    fill_rect(x + scale, y, scale * 3, scale, color)  # top
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
    fill_rect(x, y + scale * 4, scale, scale * 2, color)  # bottom left
    fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
  elif d == 3:
    fill_rect(x, y, scale * 5, scale, color)  # top
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
    fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
  elif d == 4:
    fill_rect(x, y, scale, scale * 4, color)  # top left
    fill_rect(x + scale * 4, y, scale, scale * 7, color)  # right
    fill_rect(x, y + scale * 3, scale * 5, scale, color)  # middle
  elif d == 5:
    fill_rect(x, y, scale * 5, scale, color)  # top
    fill_rect(x, y + scale, scale, scale * 2, color)  # top left
    fill_rect(x, y + scale * 3, scale * 4, scale, color)  # middle
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
    fill_rect(x, y + scale * 6, scale * 5, scale, color)  # bottom
  elif d == 6:
    fill_rect(x + scale, y, scale * 3, scale, color)  # top
    fill_rect(x, y + scale, scale, scale * 5, color)  # left
    fill_rect(x, y + scale * 3, scale * 4, scale, color)  # middle
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
  elif d == 7:
    fill_rect(x, y, scale * 5, scale, color)  # top
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
    fill_rect(x + scale * 3, y + scale * 3, scale, scale * 2, color)  # middle
    fill_rect(x + scale * 2, y + scale * 5, scale, scale * 2, color)  # bottom
  elif d == 8:
    fill_rect(x + scale, y, scale * 3, scale, color)  # top
    fill_rect(x, y + scale, scale, scale * 2, color)  # top left
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)  # top right
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
    fill_rect(x, y + scale * 4, scale, scale * 2, color)  # bottom left
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)  # bottom right
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom
  elif d == 9:
    fill_rect(x + scale, y, scale * 3, scale, color)  # top
    fill_rect(x, y + scale, scale, scale * 2, color)  # top left
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)  # right
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)  # middle
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)  # bottom

proc draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32) =
  if num <= 0:
    return

  # Count digits
  var n: int32 = num
  var digits: int32 = 0
  while n > 0:
    digits = digits + 1
    n = n / 10

  # Extract digits in reverse order
  var digit_arr: array[5, int32]
  n = num
  var i: int32 = digits - 1
  while i >= 0:
    digit_arr[i] = n - (n / 10) * 10
    n = n / 10
    i = i - 1

  # Draw each digit
  var dx: int32 = x
  i = 0
  while i < digits:
    draw_digit(digit_arr[i], dx, y, color, scale)
    dx = dx + scale * 6
    i = i + 1

# ============ Game Logic ============

proc get_tile_color_index(value: int32): int32 =
  if value == 0: return 0
  if value == 2: return 1
  if value == 4: return 2
  if value == 8: return 3
  if value == 16: return 4
  if value == 32: return 5
  if value == 64: return 6
  if value == 128: return 7
  if value == 256: return 8
  if value == 512: return 9
  if value == 1024: return 10
  return 11  # 2048 or higher

proc init_game() =
  g_score = 0
  g_game_over = 0
  g_won = 0

  # Clear board
  var i: int32 = 0
  while i < 16:
    g_board[i] = 0
    i = i + 1

  # Seed random with time
  var t: int32 = syscall1(SYS_time, 0)
  g_rand_state = t

proc count_empty(): int32 =
  var count: int32 = 0
  var i: int32 = 0
  while i < 16:
    if g_board[i] == 0:
      count = count + 1
    i = i + 1
  return count

proc add_random_tile() =
  var empty: int32 = count_empty()
  if empty == 0:
    return

  var pos: int32 = random() - (random() / empty) * empty  # modulo

  # Find the pos-th empty cell
  var i: int32 = 0
  var found: int32 = 0
  while i < 16 and found == 0:
    if g_board[i] == 0:
      if pos == 0:
        # 90% chance of 2, 10% chance of 4
        if random() - (random() / 10) * 10 == 0:
          g_board[i] = 4
        else:
          g_board[i] = 2
        found = 1
      else:
        pos = pos - 1
    i = i + 1

proc can_move(): int32 =
  var i: int32 = 0

  # Check for empty cells
  while i < 16:
    if g_board[i] == 0:
      return 1
    i = i + 1

  # Check for adjacent matching tiles
  var y: int32 = 0
  while y < 4:
    var x: int32 = 0
    while x < 4:
      var val: int32 = g_board[y * 4 + x]
      # Check right
      if x < 3:
        if g_board[y * 4 + x + 1] == val:
          return 1
      # Check down
      if y < 3:
        if g_board[(y + 1) * 4 + x] == val:
          return 1
      x = x + 1
    y = y + 1

  return 0

proc slide_left(): int32 =
  var moved: int32 = 0
  var y: int32 = 0

  while y < 4:
    # Slide tiles left, merge matching
    var merged: array[4, int32]
    merged[0] = 0
    merged[1] = 0
    merged[2] = 0
    merged[3] = 0

    var write_pos: int32 = 0
    var x: int32 = 0

    while x < 4:
      var val: int32 = g_board[y * 4 + x]
      if val != 0:
        if write_pos > 0 and g_board[y * 4 + write_pos - 1] == val and merged[write_pos - 1] == 0:
          # Merge
          g_board[y * 4 + write_pos - 1] = val * 2
          g_score = g_score + val * 2
          merged[write_pos - 1] = 1
          g_board[y * 4 + x] = 0
          moved = 1
          if val * 2 == 2048:
            g_won = 1
        else:
          if write_pos != x:
            g_board[y * 4 + write_pos] = val
            g_board[y * 4 + x] = 0
            moved = 1
          write_pos = write_pos + 1
      x = x + 1
    y = y + 1

  return moved

proc slide_right(): int32 =
  var moved: int32 = 0
  var y: int32 = 0

  while y < 4:
    var merged: array[4, int32]
    merged[0] = 0
    merged[1] = 0
    merged[2] = 0
    merged[3] = 0

    var write_pos: int32 = 3
    var x: int32 = 3

    while x >= 0:
      var val: int32 = g_board[y * 4 + x]
      if val != 0:
        if write_pos < 3 and g_board[y * 4 + write_pos + 1] == val and merged[write_pos + 1] == 0:
          g_board[y * 4 + write_pos + 1] = val * 2
          g_score = g_score + val * 2
          merged[write_pos + 1] = 1
          g_board[y * 4 + x] = 0
          moved = 1
          if val * 2 == 2048:
            g_won = 1
        else:
          if write_pos != x:
            g_board[y * 4 + write_pos] = val
            g_board[y * 4 + x] = 0
            moved = 1
          write_pos = write_pos - 1
      x = x - 1
    y = y + 1

  return moved

proc slide_up(): int32 =
  var moved: int32 = 0
  var x: int32 = 0

  while x < 4:
    var merged: array[4, int32]
    merged[0] = 0
    merged[1] = 0
    merged[2] = 0
    merged[3] = 0

    var write_pos: int32 = 0
    var y: int32 = 0

    while y < 4:
      var val: int32 = g_board[y * 4 + x]
      if val != 0:
        if write_pos > 0 and g_board[(write_pos - 1) * 4 + x] == val and merged[write_pos - 1] == 0:
          g_board[(write_pos - 1) * 4 + x] = val * 2
          g_score = g_score + val * 2
          merged[write_pos - 1] = 1
          g_board[y * 4 + x] = 0
          moved = 1
          if val * 2 == 2048:
            g_won = 1
        else:
          if write_pos != y:
            g_board[write_pos * 4 + x] = val
            g_board[y * 4 + x] = 0
            moved = 1
          write_pos = write_pos + 1
      y = y + 1
    x = x + 1

  return moved

proc slide_down(): int32 =
  var moved: int32 = 0
  var x: int32 = 0

  while x < 4:
    var merged: array[4, int32]
    merged[0] = 0
    merged[1] = 0
    merged[2] = 0
    merged[3] = 0

    var write_pos: int32 = 3
    var y: int32 = 3

    while y >= 0:
      var val: int32 = g_board[y * 4 + x]
      if val != 0:
        if write_pos < 3 and g_board[(write_pos + 1) * 4 + x] == val and merged[write_pos + 1] == 0:
          g_board[(write_pos + 1) * 4 + x] = val * 2
          g_score = g_score + val * 2
          merged[write_pos + 1] = 1
          g_board[y * 4 + x] = 0
          moved = 1
          if val * 2 == 2048:
            g_won = 1
        else:
          if write_pos != y:
            g_board[write_pos * 4 + x] = val
            g_board[y * 4 + x] = 0
            moved = 1
          write_pos = write_pos - 1
      y = y - 1
    x = x + 1

  return moved

# ============ Drawing ============

proc draw_tile(x: int32, y: int32, value: int32) =
  var px: int32 = g_board_x + x * (CELL_SIZE + CELL_GAP)
  var py: int32 = g_board_y + y * (CELL_SIZE + CELL_GAP)

  var color_idx: int32 = get_tile_color_index(value)
  var bg_color: int32 = g_tile_colors[color_idx]
  var text_color: int32 = g_text_colors[color_idx]

  # Draw tile background
  draw_rounded_rect(px, py, CELL_SIZE, CELL_SIZE, bg_color, 6)

  # Draw number if not empty
  if value > 0:
    # Calculate number width and center it
    var n: int32 = value
    var digits: int32 = 0
    while n > 0:
      digits = digits + 1
      n = n / 10

    # Choose scale based on number of digits
    var scale: int32 = 8
    if digits >= 4:
      scale = 5
    elif digits == 3:
      scale = 6

    var num_width: int32 = digits * scale * 6 - scale
    var num_x: int32 = px + (CELL_SIZE - num_width) / 2
    var num_y: int32 = py + (CELL_SIZE - scale * 7) / 2

    draw_number(value, num_x, num_y, text_color, scale)

proc draw_board() =
  # Draw board background
  var board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
  draw_rounded_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP, board_size, board_size, 0xBBADA0, 8)

  # Draw tiles
  var y: int32 = 0
  while y < GRID_SIZE:
    var x: int32 = 0
    while x < GRID_SIZE:
      draw_tile(x, y, g_board[y * GRID_SIZE + x])
      x = x + 1
    y = y + 1

proc draw_header() =
  # Title "2048"
  var title_x: int32 = g_board_x
  var title_y: int32 = 20
  draw_number(2048, title_x, title_y, 0x776E65, 10)

  # Score
  var score_x: int32 = g_board_x + 300
  fill_rect(score_x, title_y, 100, 50, 0xBBADA0)

  # Draw "SCORE" label - simplified as just the number
  draw_number(g_score, score_x + 10, title_y + 20, 0xFFFFFF, 4)

proc draw_game_over() =
  if g_game_over != 0:
    # Semi-transparent overlay (just darker background)
    var board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
    fill_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP + 150, board_size, 100, 0x000000)

    # "GAME OVER" - represented as numbers for simplicity
    # We'll show 0 for game over
    draw_number(0, g_board_x + 150, g_board_y + 180, 0xFF0000, 12)

proc draw_won() =
  if g_won != 0:
    var board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
    fill_rect(g_board_x - CELL_GAP, g_board_y - CELL_GAP + 150, board_size, 100, 0x00AA00)

    # Show 2048 for winning
    draw_number(2048, g_board_x + 100, g_board_y + 180, 0xFFFFFF, 12)

proc draw_screen() =
  # Clear screen with background color
  fill_rect(0, 0, g_xres, g_yres, 0xFAF8EF)

  draw_header()
  draw_board()

  if g_game_over != 0:
    draw_game_over()
  elif g_won != 0:
    draw_won()

# ============ Input ============

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  var c: int32 = cast[int32](buf[0])
  var moved: int32 = 0

  # Check for escape sequences (arrow keys)
  if c == 27 and n >= 3:
    if buf[1] == cast[uint8](91):
      if buf[2] == cast[uint8](65):      # Up arrow
        moved = slide_up()
      elif buf[2] == cast[uint8](66):    # Down arrow
        moved = slide_down()
      elif buf[2] == cast[uint8](67):    # Right arrow
        moved = slide_right()
      elif buf[2] == cast[uint8](68):    # Left arrow
        moved = slide_left()
  elif c == 119 or c == 87:  # w/W
    moved = slide_up()
  elif c == 115 or c == 83:  # s/S
    moved = slide_down()
  elif c == 100 or c == 68:  # d/D - but 68 is also 'D' which conflicts with arrow
    if n == 1:
      moved = slide_right()
  elif c == 97 or c == 65:   # a/A
    if n == 1:
      moved = slide_left()
  elif c == 113 or c == 81:  # q/Q
    g_running = 0
  elif c == 114 or c == 82:  # r/R - restart
    init_game()
    add_random_tile()
    add_random_tile()

  if moved != 0 and g_game_over == 0:
    add_random_tile()
    if can_move() == 0:
      g_game_over = 1

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)

  var path: ptr uint8 = cast[ptr uint8]("/dev/fb0")
  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  var fb_size: int32 = g_xres * g_yres * 4
  var fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
  if fb_addr < 0:
    return 1

  g_fb = cast[ptr uint32](fb_addr)
  return 0

# ============ Main ============

proc main(): int32 =
  if init_framebuffer() != 0:
    return 1

  init_colors()

  # Set stdin to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

  # Calculate board position (centered)
  var board_size: int32 = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_GAP
  g_board_x = (g_xres - board_size) / 2
  g_board_y = (g_yres - board_size) / 2 + 30

  # Initialize game
  init_game()
  add_random_tile()
  add_random_tile()

  # Main loop
  while g_running != 0:
    draw_screen()
    handle_input()
    sleep_ms(50)

  # Restore stdin
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0)

  return 0
