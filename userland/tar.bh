# tar - Tape Archive utility (simplified)
# Usage:
#   tar -c file1 file2 ... > archive.tar  (create archive)
#   tar -t < archive.tar                  (list contents)
#   tar -x < archive.tar                  (extract files)

from lib.syscalls import *

# File mode bits
# TAR constants
const TAR_BLOCK_SIZE: int32 = 512
const TAR_NAME_SIZE: int32 = 100

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Convert number to octal string (right-aligned, null-terminated)
def write_octal(buf: *uint8, value: int32, size: int32):
  memset(buf, cast[uint8](48), size)
  buf[size - 1] = cast[uint8](0)

  v: int32 = value
  pos: int32 = size - 2

  while v > 0 and pos >= 0:
    buf[pos] = cast[uint8](48 + (v & 7))
    v = v >> 3
    pos = pos - 1

# Parse octal string to number
def parse_octal(buf: *uint8, size: int32) -> int32:
  result: int32 = 0
  i: int32 = 0

  while i < size and buf[i] != cast[uint8](0):
    if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](55):
      result = (result << 3) | (cast[int32](buf[i]) - 48)
    i = i + 1

  return result

# Calculate checksum for TAR header
def calc_checksum(header: *uint8) -> int32:
  sum: int32 = 0
  i: int32 = 0

  # Treat checksum field as spaces for calculation
  while i < TAR_BLOCK_SIZE:
    if i >= 148 and i < 156:
      sum = sum + 32
    else:
      sum = sum + cast[int32](header[i])
    i = i + 1

  return sum

# Create TAR header for a file
def create_header(header: *uint8, filename: *uint8, size: int32, mode: int32, typeflag: uint8):
  memset(header, cast[uint8](0), TAR_BLOCK_SIZE)

  # Copy filename (max 100 bytes)
  namelen: int32 = strlen(filename)
  if namelen > TAR_NAME_SIZE - 1:
    namelen = TAR_NAME_SIZE - 1
  memcpy(header, filename, namelen)

  # mode: offset 100, 8 bytes
  write_octal(cast[*uint8](cast[int32](header) + 100), mode, 8)

  # uid: offset 108, 8 bytes
  write_octal(cast[*uint8](cast[int32](header) + 108), 0, 8)

  # gid: offset 116, 8 bytes
  write_octal(cast[*uint8](cast[int32](header) + 116), 0, 8)

  # size: offset 124, 12 bytes
  write_octal(cast[*uint8](cast[int32](header) + 124), size, 12)

  # mtime: offset 136, 12 bytes (use 0 for simplicity)
  write_octal(cast[*uint8](cast[int32](header) + 136), 0, 12)

  # checksum: offset 148, 8 bytes (fill with spaces first)
  memset(cast[*uint8](cast[int32](header) + 148), cast[uint8](32), 8)

  # typeflag: offset 156, 1 byte
  header[156] = typeflag

  # Calculate and write checksum
  chksum: int32 = calc_checksum(header)
  write_octal(cast[*uint8](cast[int32](header) + 148), chksum, 7)
  header[155] = cast[uint8](0)

# Create archive mode
def tar_create(start_arg: int32):
  argc: int32 = get_argc()

  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 65536
  syscall1(SYS_brk, new_brk)

  header: *uint8 = cast[*uint8](old_brk)
  buffer: *uint8 = cast[*uint8](old_brk + TAR_BLOCK_SIZE)
  stat_buf: *uint8 = cast[*uint8](old_brk + 8192)

  # Process each file
  arg_idx: int32 = start_arg
  while arg_idx < argc:
    filename: *uint8 = get_argv(arg_idx)

    # Get file stats
    ret: int32 = syscall2(SYS_lstat64, cast[int32](filename), cast[int32](stat_buf))
    if ret >= 0:
      # Parse stat64 structure (32-bit x86)
      # st_mode at offset 16, st_size at offset 44
      mode_ptr: *uint32 = cast[*uint32](cast[int32](stat_buf) + 16)
      size_ptr: *int32 = cast[*int32](cast[int32](stat_buf) + 44)
      mode: int32 = cast[int32](mode_ptr[0])
      size: int32 = size_ptr[0]
      file_type: int32 = mode & S_IFMT

      # Determine typeflag
      typeflag: uint8 = cast[uint8](48)  # '0' = regular file
      if file_type == S_IFDIR:
        typeflag = cast[uint8](53)  # '5' = directory
        size = 0

      # Only process regular files and directories
      if file_type == S_IFREG or file_type == S_IFDIR:
        # Create header
        create_header(header, filename, size, mode & 4095, typeflag)

        # Write header to stdout
        syscall3(SYS_write, STDOUT, cast[int32](header), TAR_BLOCK_SIZE)

        # Write file data if regular file
        if file_type == S_IFREG and size > 0:
          fd: int32 = syscall3(SYS_open, cast[int32](filename), O_RDONLY, 0)
          if fd >= 0:
            remaining: int32 = size
            while remaining > 0:
              to_read: int32 = 4096
              if to_read > remaining:
                to_read = remaining

              n: int32 = syscall3(SYS_read, fd, cast[int32](buffer), to_read)
              if n <= 0:
                remaining = 0
              else:
                syscall3(SYS_write, STDOUT, cast[int32](buffer), n)
                remaining = remaining - n

            # Pad to 512-byte boundary
            padding: int32 = TAR_BLOCK_SIZE - (size % TAR_BLOCK_SIZE)
            if padding != TAR_BLOCK_SIZE:
              memset(buffer, cast[uint8](0), padding)
              syscall3(SYS_write, STDOUT, cast[int32](buffer), padding)

            syscall1(SYS_close, fd)

    arg_idx = arg_idx + 1

  # Write two zero blocks to mark end of archive
  memset(header, cast[uint8](0), TAR_BLOCK_SIZE)
  syscall3(SYS_write, STDOUT, cast[int32](header), TAR_BLOCK_SIZE)
  syscall3(SYS_write, STDOUT, cast[int32](header), TAR_BLOCK_SIZE)

# List archive contents
def tar_list():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  syscall1(SYS_brk, new_brk)

  header: *uint8 = cast[*uint8](old_brk)
  buffer: *uint8 = cast[*uint8](old_brk + TAR_BLOCK_SIZE)

  running: int32 = 1
  while running != 0:
    # Read header
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](header), TAR_BLOCK_SIZE)
    if n != TAR_BLOCK_SIZE:
      running = 0
    else:
      # Check if empty block (end of archive)
      is_zero: int32 = 1
      i: int32 = 0
      while i < TAR_BLOCK_SIZE:
        if header[i] != cast[uint8](0):
          is_zero = 0
        i = i + 1

      if is_zero != 0:
        running = 0
      else:
        # Print filename
        name: *uint8 = header
        print(name)
        syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

        # Get file size
        size_field: *uint8 = cast[*uint8](cast[int32](header) + 124)
        size: int32 = parse_octal(size_field, 12)

        # Skip file data
        remaining: int32 = size
        while remaining > 0:
          to_read: int32 = 4096
          if to_read > remaining:
            to_read = remaining

          n = syscall3(SYS_read, STDIN, cast[int32](buffer), to_read)
          if n <= 0:
            remaining = 0
          else:
            remaining = remaining - n

        # Skip padding
        padding: int32 = TAR_BLOCK_SIZE - (size % TAR_BLOCK_SIZE)
        if padding != TAR_BLOCK_SIZE:
          syscall3(SYS_read, STDIN, cast[int32](buffer), padding)

# Extract archive
def tar_extract():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  syscall1(SYS_brk, new_brk)

  header: *uint8 = cast[*uint8](old_brk)
  buffer: *uint8 = cast[*uint8](old_brk + TAR_BLOCK_SIZE)

  running: int32 = 1
  while running != 0:
    # Read header
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](header), TAR_BLOCK_SIZE)
    if n != TAR_BLOCK_SIZE:
      running = 0
    else:
      # Check if empty block (end of archive)
      is_zero: int32 = 1
      i: int32 = 0
      while i < TAR_BLOCK_SIZE:
        if header[i] != cast[uint8](0):
          is_zero = 0
        i = i + 1

      if is_zero != 0:
        running = 0
      else:
        # Get filename
        filename: *uint8 = header

        # Get file size
        size_field: *uint8 = cast[*uint8](cast[int32](header) + 124)
        size: int32 = parse_octal(size_field, 12)

        # Get mode
        mode_field: *uint8 = cast[*uint8](cast[int32](header) + 100)
        mode: int32 = parse_octal(mode_field, 8)

        # Get typeflag
        typeflag: uint8 = header[156]

        # Create file
        if typeflag == cast[uint8](48):  # Regular file
          fd: int32 = syscall3(SYS_creat, cast[int32](filename), mode)
          if fd < 0:
            print_err(cast[*uint8]("tar: cannot create "))
            print_err(filename)
            syscall3(SYS_write, STDERR, cast[int32]("\n"), 1)
          else:
            # Write file data
            remaining: int32 = size
            while remaining > 0:
              to_read: int32 = 4096
              if to_read > remaining:
                to_read = remaining

              n = syscall3(SYS_read, STDIN, cast[int32](buffer), to_read)
              if n <= 0:
                remaining = 0
              else:
                syscall3(SYS_write, fd, cast[int32](buffer), n)
                remaining = remaining - n

            syscall1(SYS_close, fd)

          # Skip padding
          padding: int32 = TAR_BLOCK_SIZE - (size % TAR_BLOCK_SIZE)
          if padding != TAR_BLOCK_SIZE:
            syscall3(SYS_read, STDIN, cast[int32](buffer), padding)
        else:
          # Skip file data for non-regular files
          remaining: int32 = size
          while remaining > 0:
            to_read: int32 = 4096
            if to_read > remaining:
              to_read = remaining

            n = syscall3(SYS_read, STDIN, cast[int32](buffer), to_read)
            if n <= 0:
              remaining = 0
            else:
              remaining = remaining - n

          # Skip padding
          padding: int32 = TAR_BLOCK_SIZE - (size % TAR_BLOCK_SIZE)
          if padding != TAR_BLOCK_SIZE:
            syscall3(SYS_read, STDIN, cast[int32](buffer), padding)

def main():
  argc: int32 = get_argc()

  if argc < 2:
    print_err(cast[*uint8]("Usage: tar -c file1 file2 ... > archive.tar\n"))
    print_err(cast[*uint8]("       tar -t < archive.tar\n"))
    print_err(cast[*uint8]("       tar -x < archive.tar\n"))
    syscall1(SYS_exit, 1)

  mode: *uint8 = get_argv(1)

  # Check mode
  if strcmp(mode, cast[*uint8]("-c")) == 0:
    tar_create(2)
  else:
    if strcmp(mode, cast[*uint8]("-t")) == 0:
      tar_list()
    else:
      if strcmp(mode, cast[*uint8]("-x")) == 0:
        tar_extract()
      else:
        print_err(cast[*uint8]("tar: invalid option\n"))
        syscall1(SYS_exit, 1)

  syscall1(SYS_exit, 0)
