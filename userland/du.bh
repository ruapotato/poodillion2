# du - Estimate file space usage
# Usage: du [-s] [path]
# -s: Display only total for directory

from lib.syscalls import *


# File mode bits

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

# String utilities
def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Print a number
def print_num(n: int32):
    if n == 0:
        syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
        return

    buf: *uint8 = cast[*uint8](0)
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 32
    syscall1(SYS_brk, new_brk)
    buf = cast[*uint8](old_brk)

    num: int32 = n
    i: int32 = 0
    while num > 0:
        digit: int32 = num % 10
        buf[i] = cast[uint8](48 + digit)
        num = num / 10
        i = i + 1

    # Reverse
    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        temp: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = temp
        j = j + 1
        k = k - 1

    syscall3(SYS_write, STDOUT, cast[int32](buf), i)

# String copy
# Append path component
def path_append(path: *uint8, name: *uint8):
    path_len: int32 = strlen(path)
    # Add slash if needed
    if path_len > 0 and path[path_len - 1] != cast[uint8](47):
        path[path_len] = cast[uint8](47)  # '/'
        path_len = path_len + 1
    # Copy name
    i: int32 = 0
    while name[i] != cast[uint8](0):
        path[path_len + i] = name[i]
        i = i + 1
    path[path_len + i] = cast[uint8](0)

# Global variables for recursion
global_stat_buf: *uint8 = cast[*uint8](0)
global_dent_buf: *uint8 = cast[*uint8](0)
global_path_buf: *uint8 = cast[*uint8](0)
global_summary_only: int32 = 0

# Calculate size of a file or directory
def calculate_size(path: *uint8) -> int32:
    # Get file stats
    ret: int32 = syscall2(SYS_lstat, cast[int32](path), cast[int32](global_stat_buf))
    if ret < 0:
        return 0

    # stat structure:
    # st_dev: uint64 (8 bytes) at offset 0
    # st_ino: uint64 (8 bytes) at offset 8
    # st_mode: uint32 (4 bytes) at offset 16
    # st_nlink: uint32 (4 bytes) at offset 20
    # ...
    # st_size: int64 (8 bytes) at offset 48
    # st_blksize: int32 (4 bytes) at offset 56
    # st_blocks: int64 (8 bytes) at offset 60

    mode_ptr: *uint32 = cast[*uint32](cast[int32](global_stat_buf) + 16)
    blocks_ptr: *int32 = cast[*int32](cast[int32](global_stat_buf) + 60)

    mode: int32 = cast[int32](mode_ptr[0])
    blocks: int32 = blocks_ptr[0]

    # Use block count * 512 for actual disk usage
    file_size: int32 = blocks * 512

    # Check if directory
    if (mode & S_IFMT) == S_IFDIR:
        # Open directory
        fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY | O_DIRECTORY, 0)
        if fd < 0:
            return file_size

        # Read directory entries and recurse
        nread: int32 = syscall3(SYS_getdents64, fd, cast[int32](global_dent_buf), 8192)

        while nread > 0:
            pos: int32 = 0
            while pos < nread:
                reclen_ptr: *uint16 = cast[*uint16](cast[int32](global_dent_buf) + pos + 16)
                reclen: int32 = cast[int32](reclen_ptr[0])
                d_name: *uint8 = cast[*uint8](cast[int32](global_dent_buf) + pos + 19)

                # Skip . and ..
                skip: int32 = 0
                if d_name[0] == cast[uint8](46):  # '.'
                    if d_name[1] == cast[uint8](0):
                        skip = 1
                    if d_name[1] == cast[uint8](46) and d_name[2] == cast[uint8](0):
                        skip = 1

                if skip == 0:
                    # Build full path
                    old_len: int32 = strcpy(global_path_buf, path)
                    path_append(global_path_buf, d_name)

                    # Recurse
                    child_size: int32 = calculate_size(global_path_buf)
                    file_size = file_size + child_size

                    # Restore path
                    global_path_buf[old_len] = cast[uint8](0)

                pos = pos + reclen

            nread = syscall3(SYS_getdents64, fd, cast[int32](global_dent_buf), 8192)

        syscall1(SYS_close, fd)

        # Print directory size if not summary only
        if global_summary_only == 0:
            print_num(file_size / 1024)
            syscall3(SYS_write, STDOUT, cast[int32]("\t"), 1)
            print(path)
            syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

    return file_size

def main():
    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 20480
    syscall1(SYS_brk, new_brk)

    # Memory layout:
    # old_brk + 0: stat buffer (256 bytes)
    # old_brk + 256: getdents buffer (8KB)
    # old_brk + 8448: path buffer (4KB)
    global_stat_buf = cast[*uint8](old_brk)
    global_dent_buf = cast[*uint8](old_brk + 256)
    global_path_buf = cast[*uint8](old_brk + 8448)

    # Parse arguments
    argc: int32 = get_argc()
    target_path: *uint8 = cast[*uint8](".")
    global_summary_only = 0

    i: int32 = 1
    while i < argc:
        arg: *uint8 = get_argv(i)
        if arg[0] == cast[uint8](45):  # '-'
            if arg[1] == cast[uint8](115):  # 's'
                global_summary_only = 1
        else:
            target_path = arg
        i = i + 1

    # Calculate total size
    total_size: int32 = calculate_size(target_path)

    # Print total
    print_num(total_size / 1024)
    syscall3(SYS_write, STDOUT, cast[int32]("\t"), 1)
    print(target_path)
    syscall3(SYS_write, STDOUT, cast[int32]("\n"), 1)

    syscall1(SYS_exit, 0)
