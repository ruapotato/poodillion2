# killall - Kill all processes by name
# Usage: killall [-SIGNAL] processname
# Combines pidof + kill functionality

from lib.syscalls import *

const SIGTERM: int32 = 15
const SIGKILL: int32 = 9

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Check if string is all digits
def is_numeric(s: *uint8) -> int32:
    i: int32 = 0
    if s[0] == cast[uint8](0):
        return 0
    while s[i] != cast[uint8](0):
        if s[i] < cast[uint8](48):  # '0'
            return 0
        if s[i] > cast[uint8](57):  # '9'
            return 0
        i = i + 1
    return 1

# Compare two strings
# Build path: /proc/PID/comm
def build_comm_path(path: *uint8, pid_str: *uint8):
    path[0] = cast[uint8](47)   # /
    path[1] = cast[uint8](112)  # p
    path[2] = cast[uint8](114)  # r
    path[3] = cast[uint8](111)  # o
    path[4] = cast[uint8](99)   # c
    path[5] = cast[uint8](47)   # /
    pos: int32 = 6
    # Copy PID
    i: int32 = 0
    while pid_str[i] != cast[uint8](0):
        path[pos] = pid_str[i]
        pos = pos + 1
        i = i + 1
    # /comm
    path[pos] = cast[uint8](47)      # /
    path[pos + 1] = cast[uint8](99)  # c
    path[pos + 2] = cast[uint8](111) # o
    path[pos + 3] = cast[uint8](109) # m
    path[pos + 4] = cast[uint8](109) # m
    path[pos + 5] = cast[uint8](0)

# Parse integer from string
def parse_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    while s[i] >= cast[uint8](48):
        if s[i] > cast[uint8](57):
            break
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
    return result

# Print integer
def main():
    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 32768
    _ = syscall1(SYS_brk, new_brk)

    # Memory layout:
    # +0: dent buffer (8KB)
    # +8192: comm buffer (256 bytes)
    # +8448: path buffer (256 bytes)
    # +8704: search name buffer (256 bytes)
    # +8960: PID list (1024 PIDs * 4 bytes = 4KB)
    dent_buf: *uint8 = cast[*uint8](old_brk)
    comm_buf: *uint8 = cast[*uint8](old_brk + 8192)
    path_buf: *uint8 = cast[*uint8](old_brk + 8448)
    search_name: *uint8 = cast[*uint8](old_brk + 8704)
    pid_list: *int32 = cast[*int32](old_brk + 8960)

    # Default: SIGTERM
    signal: int32 = SIGTERM

    # For demonstration, kill all "sleep" processes
    # In a real implementation, this would come from argv
    search_name[0] = cast[uint8](115)  # s
    search_name[1] = cast[uint8](108)  # l
    search_name[2] = cast[uint8](101)  # e
    search_name[3] = cast[uint8](101)  # e
    search_name[4] = cast[uint8](112)  # p
    search_name[5] = cast[uint8](0)

    print_err(cast[*uint8]("killall: Searching for process: sleep\n"))

    # Open /proc
    path_buf[0] = cast[uint8](47)   # /
    path_buf[1] = cast[uint8](112)  # p
    path_buf[2] = cast[uint8](114)  # r
    path_buf[3] = cast[uint8](111)  # o
    path_buf[4] = cast[uint8](99)   # c
    path_buf[5] = cast[uint8](0)

    proc_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY | O_DIRECTORY, 0)
    if proc_fd < 0:
        print_err(cast[*uint8]("Error: cannot open /proc\n"))
        _ = syscall1(SYS_exit, 1)

    found_count: int32 = 0

    # Read /proc directory and collect matching PIDs
    nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

    while nread > 0:
        pos: int32 = 0
        while pos < nread:
            # Parse dirent64
            reclen_ptr: *uint16 = cast[*uint16](cast[int32](dent_buf) + pos + 16)
            reclen: int32 = cast[int32](reclen_ptr[0])
            d_name: *uint8 = cast[*uint8](cast[int32](dent_buf) + pos + 19)

            # Check if this is a PID directory (all numeric)
            if is_numeric(d_name) == 1:
                # Build path to /proc/PID/comm
                build_comm_path(path_buf, d_name)

                # Open and read comm file
                comm_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
                if comm_fd >= 0:
                    comm_len: int32 = syscall3(SYS_read, comm_fd, cast[int32](comm_buf), 255)
                    _ = syscall1(SYS_close, comm_fd)

                    if comm_len > 0:
                        # Remove trailing newline
                        if comm_buf[comm_len - 1] == cast[uint8](10):
                            comm_len = comm_len - 1
                        comm_buf[comm_len] = cast[uint8](0)

                        # Compare with search name
                        if strcmp(comm_buf, search_name) == 0:
                            # Found a match - store PID
                            pid: int32 = parse_int(d_name)
                            if found_count < 1024:
                                pid_list[found_count] = pid
                                found_count = found_count + 1

            pos = pos + reclen

        nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

    _ = syscall1(SYS_close, proc_fd)

    # Now kill all found processes
    if found_count == 0:
        print_err(cast[*uint8]("killall: no process found\n"))
        _ = syscall1(SYS_exit, 1)

    print_err(cast[*uint8]("killall: Killing "))
    print_int(found_count)
    print_err(cast[*uint8](" process(es)...\n"))

    killed: int32 = 0
    i: int32 = 0
    while i < found_count:
        pid: int32 = pid_list[i]
        result: int32 = syscall2(SYS_kill, pid, signal)

        if result == 0:
            print_err(cast[*uint8]("Killed PID "))
            print_int(pid)
            _ = syscall3(SYS_write, STDERR, cast[int32]("\n"), 1)
            killed = killed + 1
        else:
            print_err(cast[*uint8]("Failed to kill PID "))
            print_int(pid)
            _ = syscall3(SYS_write, STDERR, cast[int32]("\n"), 1)

        i = i + 1

    if killed > 0:
        print_err(cast[*uint8]("killall: Successfully killed "))
        print_int(killed)
        print_err(cast[*uint8](" process(es)\n"))
        _ = syscall1(SYS_exit, 0)

    print_err(cast[*uint8]("killall: No processes were killed\n"))
    _ = syscall1(SYS_exit, 1)
