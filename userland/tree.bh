# tree.bh - Display directory tree
# Usage: tree [directory]
#
# List contents of directories in a tree-like format.
#
# Options:
#   -d         List directories only
#   -L LEVEL   Max display depth
#   -a         Show hidden files
#
# Examples:
#   tree           Show current directory tree
#   tree /bin      Show /bin directory tree
#   tree -L 2      Show tree with max depth 2

from lib.syscalls import *

opt_dirs_only: int32 = 0
opt_max_depth: int32 = 100
opt_show_hidden: int32 = 0
dir_count: int32 = 0
file_count: int32 = 0

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] >= 48 and s[i] <= 57:
    result = result * 10 + (cast[int32](s[i]) - 48)
    i = i + 1
  return result

def is_hidden(name: *uint8) -> int32:
  if name[0] == 46:  # starts with '.'
    return 1
  return 0

def is_directory(path: *uint8) -> int32:
  # Try to open as directory
  fd: int32 = open(path, O_RDONLY)
  if fd < 0:
    return 0

  # Try reading directory entries
  buf: array[256, uint8]
  result: int32 = syscall3(SYS_getdents64, fd, cast[int32](addr(buf[0])), 256)
  close(fd)

  if result > 0:
    return 1
  return 0

def print_indent(depth: int32, is_last: int32):
  i: int32 = 0
  while i < depth - 1:
    print(cast[*uint8]("│   "))
    i = i + 1

  if depth > 0:
    if is_last != 0:
      print(cast[*uint8]("└── "))
    else:
      print(cast[*uint8]("├── "))

def list_tree(path: *uint8, depth: int32):
  if depth >= opt_max_depth:
    return

  fd: int32 = open(path, O_RDONLY)
  if fd < 0:
    return

  # Buffer for directory entries
  buf: array[4096, uint8]
  entries: array[128, *uint8]
  entry_types: array[128, int32]
  entry_count: int32 = 0

  # Read all entries first
  while 1:
    n: int32 = syscall3(SYS_getdents64, fd, cast[int32](addr(buf[0])), 4096)
    if n <= 0:
      break

    pos: int32 = 0
    while pos < n:
      d_ino: int32 = cast[*int32](addr(buf[pos]))[0]
      d_reclen: int32 = cast[int32](buf[pos + 8]) or (cast[int32](buf[pos + 9]) * 256)
      d_type: int32 = cast[int32](buf[pos + 10])
      d_name: *uint8 = addr(buf[pos + 11])

      # Skip . and ..
      if d_name[0] == 46:  # '.'
        if d_name[1] == 0:
          pos = pos + d_reclen
          continue
        if d_name[1] == 46 and d_name[2] == 0:
          pos = pos + d_reclen
          continue

      # Skip hidden files unless -a
      if opt_show_hidden == 0 and is_hidden(d_name) != 0:
        pos = pos + d_reclen
        continue

      # Skip non-directories if -d
      if opt_dirs_only != 0 and d_type != 4:
        pos = pos + d_reclen
        continue

      if entry_count < 128:
        # Allocate and copy name
        name_len: int32 = strlen(d_name)
        old_brk: int32 = syscall1(SYS_brk, 0)
        new_brk: int32 = old_brk + name_len + 1
        syscall1(SYS_brk, new_brk)
        name_copy: *uint8 = cast[*uint8](old_brk)
        j: int32 = 0
        while j <= name_len:
          name_copy[j] = d_name[j]
          j = j + 1

        entries[entry_count] = name_copy
        entry_types[entry_count] = d_type
        entry_count = entry_count + 1

      pos = pos + d_reclen

  close(fd)

  # Print entries
  i: int32 = 0
  while i < entry_count:
    is_last: int32 = 0
    if i + 1 == entry_count:
      is_last = 1

    print_indent(depth + 1, is_last)
    println(entries[i])

    # Track counts
    if entry_types[i] == 4:
      dir_count = dir_count + 1

      # Build full path for recursion
      full_path: array[512, uint8]
      pi: int32 = 0

      # Copy path
      while path[pi] != 0 and pi < 500:
        full_path[pi] = path[pi]
        pi = pi + 1

      # Add / if needed
      if pi > 0 and full_path[pi - 1] != 47:
        full_path[pi] = 47
        pi = pi + 1

      # Add entry name
      ni: int32 = 0
      while entries[i][ni] != 0 and pi < 510:
        full_path[pi] = entries[i][ni]
        pi = pi + 1
        ni = ni + 1
      full_path[pi] = 0

      # Recurse
      list_tree(addr(full_path[0]), depth + 1)
    else:
      file_count = file_count + 1

    i = i + 1

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
  path: *uint8 = cast[*uint8](".")
  i: int32 = 1

  # Parse options
  while i < argc:
    arg: *uint8 = argv[i]

    if arg[0] == 45:  # '-'
      if arg[1] == 100 and arg[2] == 0:  # -d
        opt_dirs_only = 1
      elif arg[1] == 97 and arg[2] == 0:  # -a
        opt_show_hidden = 1
      elif arg[1] == 76 and arg[2] == 0:  # -L
        i = i + 1
        if i < argc:
          opt_max_depth = parse_int(argv[i])
      elif arg[1] == 104 and arg[2] == 0:  # -h
        println(cast[*uint8]("Usage: tree [-d] [-a] [-L level] [directory]"))
        println(cast[*uint8](""))
        println(cast[*uint8]("Options:"))
        println(cast[*uint8]("  -d         Directories only"))
        println(cast[*uint8]("  -a         Show hidden files"))
        println(cast[*uint8]("  -L LEVEL   Max display depth"))
        return 0
    else:
      path = arg

    i = i + 1

  # Print root
  println(path)

  # List tree
  list_tree(path, 0)

  # Print summary
  println(cast[*uint8](""))
  print_int(dir_count)
  print(cast[*uint8](" directories, "))
  print_int(file_count)
  println(cast[*uint8](" files"))

  return 0
