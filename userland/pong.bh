# pong - Classic 2-player pong game
# Player 1: W/S keys, Player 2: Up/Down arrows, Q to quit

import "lib/syscalls"

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const PADDLE_WIDTH: int32 = 15
const PADDLE_HEIGHT: int32 = 80
const PADDLE_SPEED: int32 = 10
const BALL_SIZE: int32 = 15
const BALL_SPEED: int32 = 6
const WIN_SCORE: int32 = 10

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Game area
var g_area_x: int32 = 0
var g_area_y: int32 = 0
var g_area_w: int32 = 0
var g_area_h: int32 = 0

# Paddle state
var g_paddle1_y: int32 = 0  # Left paddle
var g_paddle2_y: int32 = 0  # Right paddle

# Ball state
var g_ball_x: int32 = 0
var g_ball_y: int32 = 0
var g_ball_dx: int32 = 5
var g_ball_dy: int32 = 3

# Scores
var g_score1: int32 = 0
var g_score2: int32 = 0

# Game state
var g_running: int32 = 1
var g_paused: int32 = 1  # Start paused
var g_game_over: int32 = 0
var g_winner: int32 = 0  # 1 or 2

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

proc random_seed(seed: int32): int32 =
  return seed * 1103515245 + 12345

# ============ Graphics ============

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var py: int32 = y
  while py < y + h:
    if py >= 0 and py < g_yres:
      var px: int32 = x
      while px < x + w:
        if px >= 0 and px < g_xres:
          g_fb[py * g_xres + px] = cast[uint32](color)
        px = px + 1
    py = py + 1

proc draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32) =
  if d == 0:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 1:
    fill_rect(x + scale * 2, y, scale, scale * 7, color)
  elif d == 2:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 3:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 4:
    fill_rect(x, y, scale, scale * 4, color)
    fill_rect(x + scale * 4, y, scale, scale * 7, color)
    fill_rect(x, y + scale * 3, scale * 5, scale, color)
  elif d == 5:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 6:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 7:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 6, color)
  elif d == 8:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 9:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)

proc draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32) =
  if num < 0:
    return
  if num < 10:
    draw_digit(num, x, y, color, scale)
    return

  var tens: int32 = num / 10
  var ones: int32 = num - tens * 10
  draw_digit(tens, x, y, color, scale)
  draw_digit(ones, x + scale * 6, y, color, scale)

# ============ Game Logic ============

proc init_game() =
  g_score1 = 0
  g_score2 = 0
  g_game_over = 0
  g_winner = 0
  g_paused = 1

  # Center paddles
  g_paddle1_y = g_area_y + (g_area_h - PADDLE_HEIGHT) / 2
  g_paddle2_y = g_area_y + (g_area_h - PADDLE_HEIGHT) / 2

  # Center ball
  g_ball_x = g_area_x + g_area_w / 2 - BALL_SIZE / 2
  g_ball_y = g_area_y + g_area_h / 2 - BALL_SIZE / 2
  g_ball_dx = 5
  g_ball_dy = 3

proc reset_ball(direction: int32) =
  g_ball_x = g_area_x + g_area_w / 2 - BALL_SIZE / 2
  g_ball_y = g_area_y + g_area_h / 2 - BALL_SIZE / 2

  if direction > 0:
    g_ball_dx = BALL_SPEED
  else:
    g_ball_dx = 0 - BALL_SPEED

  # Random vertical direction based on time
  var t: int32 = syscall1(SYS_time, 0)
  if (t - (t / 2) * 2) != 0:
    g_ball_dy = 3
  else:
    g_ball_dy = 0 - 3

  g_paused = 1

proc update_ball() =
  if g_paused != 0:
    return

  # Move ball
  g_ball_x = g_ball_x + g_ball_dx
  g_ball_y = g_ball_y + g_ball_dy

  # Top/bottom wall collisions
  if g_ball_y <= g_area_y:
    g_ball_y = g_area_y
    g_ball_dy = 0 - g_ball_dy
  if g_ball_y + BALL_SIZE >= g_area_y + g_area_h:
    g_ball_y = g_area_y + g_area_h - BALL_SIZE
    g_ball_dy = 0 - g_ball_dy

  # Left paddle collision (paddle 1)
  var paddle1_x: int32 = g_area_x + 20
  if g_ball_dx < 0:
    if g_ball_x <= paddle1_x + PADDLE_WIDTH:
      if g_ball_y + BALL_SIZE >= g_paddle1_y and g_ball_y <= g_paddle1_y + PADDLE_HEIGHT:
        g_ball_x = paddle1_x + PADDLE_WIDTH
        g_ball_dx = 0 - g_ball_dx

        # Adjust angle based on hit position
        var hit_offset: int32 = (g_ball_y + BALL_SIZE / 2) - (g_paddle1_y + PADDLE_HEIGHT / 2)
        g_ball_dy = hit_offset / 8
        if g_ball_dy > 7: g_ball_dy = 7
        if g_ball_dy < 0 - 7: g_ball_dy = 0 - 7

  # Right paddle collision (paddle 2)
  var paddle2_x: int32 = g_area_x + g_area_w - 20 - PADDLE_WIDTH
  if g_ball_dx > 0:
    if g_ball_x + BALL_SIZE >= paddle2_x:
      if g_ball_y + BALL_SIZE >= g_paddle2_y and g_ball_y <= g_paddle2_y + PADDLE_HEIGHT:
        g_ball_x = paddle2_x - BALL_SIZE
        g_ball_dx = 0 - g_ball_dx

        var hit_offset: int32 = (g_ball_y + BALL_SIZE / 2) - (g_paddle2_y + PADDLE_HEIGHT / 2)
        g_ball_dy = hit_offset / 8
        if g_ball_dy > 7: g_ball_dy = 7
        if g_ball_dy < 0 - 7: g_ball_dy = 0 - 7

  # Scoring
  if g_ball_x <= g_area_x:
    # Player 2 scores
    g_score2 = g_score2 + 1
    if g_score2 >= WIN_SCORE:
      g_game_over = 1
      g_winner = 2
    else:
      reset_ball(0 - 1)  # Ball goes toward player 1

  if g_ball_x + BALL_SIZE >= g_area_x + g_area_w:
    # Player 1 scores
    g_score1 = g_score1 + 1
    if g_score1 >= WIN_SCORE:
      g_game_over = 1
      g_winner = 1
    else:
      reset_ball(1)  # Ball goes toward player 2

# ============ Drawing ============

proc draw_center_line() =
  var y: int32 = g_area_y + 10
  var center_x: int32 = g_area_x + g_area_w / 2 - 2
  while y < g_area_y + g_area_h - 10:
    fill_rect(center_x, y, 4, 15, 0x444444)
    y = y + 30

proc draw_scores() =
  # Player 1 score (left side)
  var score1_x: int32 = g_area_x + g_area_w / 4 - 20
  draw_number(g_score1, score1_x, g_area_y + 20, 0x666666, 8)

  # Player 2 score (right side)
  var score2_x: int32 = g_area_x + g_area_w * 3 / 4 - 20
  draw_number(g_score2, score2_x, g_area_y + 20, 0x666666, 8)

proc draw_paddles() =
  var paddle1_x: int32 = g_area_x + 20
  var paddle2_x: int32 = g_area_x + g_area_w - 20 - PADDLE_WIDTH

  fill_rect(paddle1_x, g_paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, 0xFFFFFF)
  fill_rect(paddle2_x, g_paddle2_y, PADDLE_WIDTH, PADDLE_HEIGHT, 0xFFFFFF)

proc draw_ball() =
  fill_rect(g_ball_x, g_ball_y, BALL_SIZE, BALL_SIZE, 0xFFFFFF)

proc draw_game_over_screen() =
  # Winner display
  var msg_y: int32 = g_area_y + g_area_h / 2 - 30
  var msg_x: int32 = g_area_x + g_area_w / 2 - 50

  fill_rect(msg_x - 20, msg_y - 20, 140, 80, 0x004400)

  # Show winner number
  draw_number(g_winner, msg_x + 30, msg_y, 0x00FF00, 10)

proc draw_paused_indicator() =
  if g_paused != 0 and g_game_over == 0:
    # Simple "SPACE" prompt - draw as a small indicator
    var cx: int32 = g_area_x + g_area_w / 2
    var cy: int32 = g_area_y + g_area_h - 40
    fill_rect(cx - 30, cy, 60, 20, 0x333333)

proc draw_screen() =
  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0x000000)

  # Game area border
  fill_rect(g_area_x - 2, g_area_y - 2, g_area_w + 4, 2, 0x444444)
  fill_rect(g_area_x - 2, g_area_y + g_area_h, g_area_w + 4, 2, 0x444444)

  draw_center_line()
  draw_scores()
  draw_paddles()
  draw_ball()
  draw_paused_indicator()

  if g_game_over != 0:
    draw_game_over_screen()

# ============ Input ============

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  var c: int32 = cast[int32](buf[0])

  # Arrow keys for player 2
  if c == 27 and n >= 3:
    if buf[1] == cast[uint8](91):
      if buf[2] == cast[uint8](65):  # Up
        g_paddle2_y = g_paddle2_y - PADDLE_SPEED
        if g_paddle2_y < g_area_y:
          g_paddle2_y = g_area_y
      elif buf[2] == cast[uint8](66):  # Down
        g_paddle2_y = g_paddle2_y + PADDLE_SPEED
        if g_paddle2_y + PADDLE_HEIGHT > g_area_y + g_area_h:
          g_paddle2_y = g_area_y + g_area_h - PADDLE_HEIGHT
  elif c == 119 or c == 87:  # W - player 1 up
    g_paddle1_y = g_paddle1_y - PADDLE_SPEED
    if g_paddle1_y < g_area_y:
      g_paddle1_y = g_area_y
  elif c == 115 or c == 83:  # S - player 1 down
    g_paddle1_y = g_paddle1_y + PADDLE_SPEED
    if g_paddle1_y + PADDLE_HEIGHT > g_area_y + g_area_h:
      g_paddle1_y = g_area_y + g_area_h - PADDLE_HEIGHT
  elif c == 32:  # Space - start/unpause
    if g_game_over == 0:
      g_paused = 0
  elif c == 113 or c == 81:  # q/Q - quit
    g_running = 0
  elif c == 114 or c == 82:  # r/R - restart
    init_game()

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)

  var path: ptr uint8 = cast[ptr uint8]("/dev/fb0")
  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  var fb_size: int32 = g_xres * g_yres * 4
  var fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
  if fb_addr < 0:
    return 1

  g_fb = cast[ptr uint32](fb_addr)
  return 0

# ============ Main ============

proc main(): int32 =
  if init_framebuffer() != 0:
    return 1

  # Set stdin to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

  # Calculate game area (centered, 4:3 aspect)
  g_area_w = 800
  g_area_h = 500
  g_area_x = (g_xres - g_area_w) / 2
  g_area_y = (g_yres - g_area_h) / 2

  # Initialize game
  init_game()

  # Main loop
  while g_running != 0:
    if g_game_over == 0:
      update_ball()

    draw_screen()
    handle_input()
    sleep_ms(16)  # ~60 FPS

  # Restore stdin
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0)

  return 0
