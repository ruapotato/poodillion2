# minesweeper - Classic Minesweeper Game
# Arrow keys to move, Space to reveal, F to flag

from lib.syscalls import *

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const GRID_WIDTH: int32 = 16
const GRID_HEIGHT: int32 = 16
const CELL_SIZE: int32 = 28
const MINE_COUNT: int32 = 40

# Cell states
const HIDDEN: int32 = 0
const REVEALED: int32 = 1
const FLAGGED: int32 = 2

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Game state
g_mines: array[256, int32]       # 1 = mine, 0 = no mine
g_state: array[256, int32]       # HIDDEN, REVEALED, FLAGGED
g_numbers: array[256, int32]     # Adjacent mine count
g_cursor_x: int32 = 8
g_cursor_y: int32 = 8
g_game_over: int32 = 0
g_won: int32 = 0
g_running: int32 = 1
g_flags_placed: int32 = 0
g_cells_revealed: int32 = 0

# Board position
g_board_x: int32 = 0
g_board_y: int32 = 0

# Random state
g_rand_state: int32 = 12345

# Colors
g_num_colors: array[9, int32]

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    ts: *int32 = cast[*int32](old_brk)
    ts[0] = 0
    ts[1] = ms * 1000000
    _ = syscall2(SYS_nanosleep, cast[int32](ts), 0)

def random() -> int32:
    global g_rand_state
    g_rand_state = g_rand_state * 1103515245 + 12345
    r: int32 = g_rand_state / 65536
    if r < 0:
        r = 0 - r
    return r

def init_colors():
    g_num_colors[0] = 0x808080  # 0 - not shown
    g_num_colors[1] = 0x0000FF  # 1 - blue
    g_num_colors[2] = 0x008000  # 2 - green
    g_num_colors[3] = 0xFF0000  # 3 - red
    g_num_colors[4] = 0x000080  # 4 - dark blue
    g_num_colors[5] = 0x800000  # 5 - maroon
    g_num_colors[6] = 0x008080  # 6 - teal
    g_num_colors[7] = 0x000000  # 7 - black
    g_num_colors[8] = 0x808080  # 8 - gray

# ============ Drawing ============

def fb_pixel(x: int32, y: int32, color: int32):
    if x >= 0 and x < g_xres and y >= 0 and y < g_yres:
        g_fb[y * g_xres + x] = cast[uint32](color)

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
    cy: int32 = y
    while cy < y + h:
        if cy >= 0 and cy < g_yres:
            cx: int32 = x
            while cx < x + w:
                if cx >= 0 and cx < g_xres:
                    g_fb[cy * g_xres + cx] = cast[uint32](color)
                cx = cx + 1
        cy = cy + 1

# Simple font for numbers
font: array[768, uint8]

def init_font():
    i: int32 = 0
    while i < 768:
        font[i] = cast[uint8](0)
        i = i + 1

    # Digits 1-8
    font[392] = cast[uint8](0x18)
    font[393] = cast[uint8](0x38)
    font[394] = cast[uint8](0x18)
    font[395] = cast[uint8](0x18)
    font[396] = cast[uint8](0x18)
    font[397] = cast[uint8](0x18)
    font[398] = cast[uint8](0x7E)
    font[399] = cast[uint8](0x00)

    font[400] = cast[uint8](0x3C)
    font[401] = cast[uint8](0x66)
    font[402] = cast[uint8](0x06)
    font[403] = cast[uint8](0x0C)
    font[404] = cast[uint8](0x18)
    font[405] = cast[uint8](0x30)
    font[406] = cast[uint8](0x7E)
    font[407] = cast[uint8](0x00)

    font[408] = cast[uint8](0x3C)
    font[409] = cast[uint8](0x66)
    font[410] = cast[uint8](0x06)
    font[411] = cast[uint8](0x1C)
    font[412] = cast[uint8](0x06)
    font[413] = cast[uint8](0x66)
    font[414] = cast[uint8](0x3C)
    font[415] = cast[uint8](0x00)

    font[416] = cast[uint8](0x0C)
    font[417] = cast[uint8](0x1C)
    font[418] = cast[uint8](0x3C)
    font[419] = cast[uint8](0x6C)
    font[420] = cast[uint8](0x7E)
    font[421] = cast[uint8](0x0C)
    font[422] = cast[uint8](0x0C)
    font[423] = cast[uint8](0x00)

    font[424] = cast[uint8](0x7E)
    font[425] = cast[uint8](0x60)
    font[426] = cast[uint8](0x7C)
    font[427] = cast[uint8](0x06)
    font[428] = cast[uint8](0x06)
    font[429] = cast[uint8](0x66)
    font[430] = cast[uint8](0x3C)
    font[431] = cast[uint8](0x00)

    font[432] = cast[uint8](0x1C)
    font[433] = cast[uint8](0x30)
    font[434] = cast[uint8](0x60)
    font[435] = cast[uint8](0x7C)
    font[436] = cast[uint8](0x66)
    font[437] = cast[uint8](0x66)
    font[438] = cast[uint8](0x3C)
    font[439] = cast[uint8](0x00)

    font[440] = cast[uint8](0x7E)
    font[441] = cast[uint8](0x06)
    font[442] = cast[uint8](0x0C)
    font[443] = cast[uint8](0x18)
    font[444] = cast[uint8](0x30)
    font[445] = cast[uint8](0x30)
    font[446] = cast[uint8](0x30)
    font[447] = cast[uint8](0x00)

    font[448] = cast[uint8](0x3C)
    font[449] = cast[uint8](0x66)
    font[450] = cast[uint8](0x66)
    font[451] = cast[uint8](0x3C)
    font[452] = cast[uint8](0x66)
    font[453] = cast[uint8](0x66)
    font[454] = cast[uint8](0x3C)
    font[455] = cast[uint8](0x00)

def draw_char_scaled(x: int32, y: int32, c: uint8, color: int32, scale: int32):
    idx: int32 = cast[int32](c) * 8
    if idx < 0 or idx >= 760:
        return
    row: int32 = 0
    while row < 8:
        bits: uint8 = font[idx + row]
        col: int32 = 0
        while col < 8:
            mask: int32 = 128
            shift: int32 = col
            while shift > 0:
                mask = mask / 2
                shift = shift - 1
            if (cast[int32](bits) & mask) != 0:
                fill_rect(x + col * scale, y + row * scale, scale, scale, color)
            col = col + 1
        row = row + 1

def draw_cell(gx: int32, gy: int32):
    px: int32 = g_board_x + gx * CELL_SIZE
    py: int32 = g_board_y + gy * CELL_SIZE
    idx: int32 = gy * GRID_WIDTH + gx
    state: int32 = g_state[idx]

    if state == HIDDEN:
        # Draw raised button look
        fill_rect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2, 0xC0C0C0)
        # Highlight
        fill_rect(px + 1, py + 1, CELL_SIZE - 2, 2, 0xFFFFFF)
        fill_rect(px + 1, py + 1, 2, CELL_SIZE - 2, 0xFFFFFF)
        # Shadow
        fill_rect(px + 1, py + CELL_SIZE - 3, CELL_SIZE - 2, 2, 0x808080)
        fill_rect(px + CELL_SIZE - 3, py + 1, 2, CELL_SIZE - 2, 0x808080)

    else:
        if state == FLAGGED:
            # Draw flagged cell
            fill_rect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2, 0xC0C0C0)
            # Draw flag
            fill_rect(px + 10, py + 6, 8, 10, 0xFF0000)
            fill_rect(px + 18, py + 6, 2, 16, 0x000000)

        else:  # REVEALED
            fill_rect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2, 0xD0D0D0)

            if g_mines[idx] != 0:
                # Draw mine
                fill_rect(px + 8, py + 8, 12, 12, 0x000000)
                fill_rect(px + 10, py + 6, 8, 2, 0x000000)
                fill_rect(px + 10, py + 20, 8, 2, 0x000000)
                fill_rect(px + 6, py + 10, 2, 8, 0x000000)
                fill_rect(px + 20, py + 10, 2, 8, 0x000000)
            else:
                num: int32 = g_numbers[idx]
                if num > 0:
                    draw_char_scaled(px + 8, py + 6, cast[uint8](48 + num), g_num_colors[num], 2)

def draw_cursor():
    px: int32 = g_board_x + g_cursor_x * CELL_SIZE
    py: int32 = g_board_y + g_cursor_y * CELL_SIZE

    # Draw cursor outline
    i: int32 = 0
    while i < CELL_SIZE:
        fb_pixel(px + i, py, 0xFF0000)
        fb_pixel(px + i, py + CELL_SIZE - 1, 0xFF0000)
        fb_pixel(px, py + i, 0xFF0000)
        fb_pixel(px + CELL_SIZE - 1, py + i, 0xFF0000)
        i = i + 1

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 512)
    path: *uint8 = cast[*uint8](old_brk)
    path[0] = cast[uint8](47)
    path[1] = cast[uint8](100)
    path[2] = cast[uint8](101)
    path[3] = cast[uint8](118)
    path[4] = cast[uint8](47)
    path[5] = cast[uint8](102)
    path[6] = cast[uint8](98)
    path[7] = cast[uint8](48)
    path[8] = cast[uint8](0)

    g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
    if g_fb_fd < 0:
        print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
        return 1

    vinfo: *int32 = cast[*int32](old_brk + 32)
    i: int32 = 0
    while i < 40:
        vinfo[i] = 0
        i = i + 1

    FBIOGET_VSCREENINFO: int32 = 0x4600
    _ = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

    g_xres = vinfo[0]
    g_yres = vinfo[1]

    fb_size: int32 = g_xres * g_yres * 4
    g_fb = cast[*uint32](syscall6(SYS_mmap2, 0, fb_size, PROT_READ + PROT_WRITE, MAP_SHARED, g_fb_fd, 0))

    if cast[int32](g_fb) < 0:
        return 1

    # Center board
    g_board_x = (g_xres - GRID_WIDTH * CELL_SIZE) / 2
    g_board_y = (g_yres - GRID_HEIGHT * CELL_SIZE) / 2

    # Set stdin non-blocking
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags + O_NONBLOCK)

    return 0

# ============ Game Logic ============

def count_adjacent(x: int32, y: int32) -> int32:
    count: int32 = 0
    dy: int32 = -1
    while dy <= 1:
        dx: int32 = -1
        while dx <= 1:
            if dx != 0 or dy != 0:
                nx: int32 = x + dx
                ny: int32 = y + dy
                if nx >= 0 and nx < GRID_WIDTH and ny >= 0 and ny < GRID_HEIGHT:
                    if g_mines[ny * GRID_WIDTH + nx] != 0:
                        count = count + 1
            dx = dx + 1
        dy = dy + 1
    return count

def init_game():
    global g_game_over, g_won, g_flags_placed, g_cells_revealed, g_cursor_x, g_cursor_y

    i: int32 = 0
    while i < 256:
        g_mines[i] = 0
        g_state[i] = HIDDEN
        g_numbers[i] = 0
        i = i + 1

    g_game_over = 0
    g_won = 0
    g_flags_placed = 0
    g_cells_revealed = 0
    g_cursor_x = GRID_WIDTH / 2
    g_cursor_y = GRID_HEIGHT / 2

    # Initialize random seed
    g_rand_state = syscall1(SYS_time, 0)
    if g_rand_state == 0:
        g_rand_state = 12345

    # Place mines
    mines_placed: int32 = 0
    while mines_placed < MINE_COUNT:
        x: int32 = random() % GRID_WIDTH
        y: int32 = random() % GRID_HEIGHT
        idx: int32 = y * GRID_WIDTH + x
        if g_mines[idx] == 0:
            g_mines[idx] = 1
            mines_placed = mines_placed + 1

    # Calculate numbers
    y: int32 = 0
    while y < GRID_HEIGHT:
        x: int32 = 0
        while x < GRID_WIDTH:
            g_numbers[y * GRID_WIDTH + x] = count_adjacent(x, y)
            x = x + 1
        y = y + 1

def reveal_cell(x: int32, y: int32):
    global g_game_over, g_cells_revealed

    if x < 0 or x >= GRID_WIDTH or y < 0 or y >= GRID_HEIGHT:
        return

    idx: int32 = y * GRID_WIDTH + x
    if g_state[idx] != HIDDEN:
        return

    g_state[idx] = REVEALED
    g_cells_revealed = g_cells_revealed + 1

    # Check for mine
    if g_mines[idx] != 0:
        g_game_over = 1
        return

    # Auto-reveal adjacent empty cells
    if g_numbers[idx] == 0:
        reveal_cell(x - 1, y - 1)
        reveal_cell(x, y - 1)
        reveal_cell(x + 1, y - 1)
        reveal_cell(x - 1, y)
        reveal_cell(x + 1, y)
        reveal_cell(x - 1, y + 1)
        reveal_cell(x, y + 1)
        reveal_cell(x + 1, y + 1)

def toggle_flag():
    global g_flags_placed

    idx: int32 = g_cursor_y * GRID_WIDTH + g_cursor_x
    if g_state[idx] == HIDDEN:
        g_state[idx] = FLAGGED
        g_flags_placed = g_flags_placed + 1
    else:
        if g_state[idx] == FLAGGED:
            g_state[idx] = HIDDEN
            g_flags_placed = g_flags_placed - 1

def check_win():
    global g_won, g_game_over

    # Win if all non-mine cells are revealed
    total_safe: int32 = GRID_WIDTH * GRID_HEIGHT - MINE_COUNT
    if g_cells_revealed == total_safe:
        g_won = 1
        g_game_over = 1

# ============ Input ============

def handle_input():
    global g_running, g_cursor_x, g_cursor_y

    buf: array[8, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

    if n <= 0:
        return

    c: uint8 = buf[0]

    if g_game_over != 0:
        if c == cast[uint8](114) or c == cast[uint8](82):  # r/R - restart
            init_game()
        if c == cast[uint8](113) or c == cast[uint8](81):  # q/Q - quit
            g_running = 0
        return

    # Movement
    if c == cast[uint8](119) or c == cast[uint8](87):  # w/W - up
        if g_cursor_y > 0:
            g_cursor_y = g_cursor_y - 1
    else:
        if c == cast[uint8](115) or c == cast[uint8](83):  # s/S - down
            if g_cursor_y < GRID_HEIGHT - 1:
                g_cursor_y = g_cursor_y + 1
        else:
            if c == cast[uint8](97) or c == cast[uint8](65):  # a/A - left
                if g_cursor_x > 0:
                    g_cursor_x = g_cursor_x - 1
            else:
                if c == cast[uint8](100) or c == cast[uint8](68):  # d/D - right
                    if g_cursor_x < GRID_WIDTH - 1:
                        g_cursor_x = g_cursor_x + 1

    # Reveal
    if c == cast[uint8](32):  # Space
        reveal_cell(g_cursor_x, g_cursor_y)
        check_win()

    # Flag
    if c == cast[uint8](102) or c == cast[uint8](70):  # f/F
        toggle_flag()

    # Quit
    if c == cast[uint8](113) or c == cast[uint8](81):
        g_running = 0

    # Arrow keys
    if n >= 3 and buf[0] == cast[uint8](27) and buf[1] == cast[uint8](91):
        if buf[2] == cast[uint8](65):       # Up
            if g_cursor_y > 0:
                g_cursor_y = g_cursor_y - 1
        else:
            if buf[2] == cast[uint8](66):     # Down
                if g_cursor_y < GRID_HEIGHT - 1:
                    g_cursor_y = g_cursor_y + 1
            else:
                if buf[2] == cast[uint8](68):   # Left
                    if g_cursor_x > 0:
                        g_cursor_x = g_cursor_x - 1
                else:
                    if buf[2] == cast[uint8](67): # Right
                        if g_cursor_x < GRID_WIDTH - 1:
                            g_cursor_x = g_cursor_x + 1

# ============ Rendering ============

def render():
    # Clear background
    i: int32 = 0
    total: int32 = g_xres * g_yres
    while i < total:
        g_fb[i] = cast[uint32](0x404040)
        i = i + 1

    # Draw border
    fill_rect(g_board_x - 4, g_board_y - 4, GRID_WIDTH * CELL_SIZE + 8, GRID_HEIGHT * CELL_SIZE + 8, 0x808080)

    # Draw all cells
    y: int32 = 0
    while y < GRID_HEIGHT:
        x: int32 = 0
        while x < GRID_WIDTH:
            draw_cell(x, y)
            x = x + 1
        y = y + 1

    # Draw cursor
    if g_game_over == 0:
        draw_cursor()

    # If game over, reveal all mines
    if g_game_over != 0:
        y = 0
        while y < GRID_HEIGHT:
            x: int32 = 0
            while x < GRID_WIDTH:
                idx: int32 = y * GRID_WIDTH + x
                if g_mines[idx] != 0:
                    g_state[idx] = REVEALED
                    draw_cell(x, y)
                x = x + 1
            y = y + 1

# ============ Main ============

def main() -> int32:
    global g_running

    print_str(cast[*uint8]("Minesweeper - Arrows/WASD to move, Space to reveal, F to flag, Q to quit, R to restart\n"))

    if init_framebuffer() != 0:
        return 1

    init_font()
    init_colors()
    init_game()

    while g_running != 0:
        handle_input()
        render()
        sleep_ms(16)

    # Clear screen
    i: int32 = 0
    total: int32 = g_xres * g_yres
    while i < total:
        g_fb[i] = cast[uint32](0)
        i = i + 1

    _ = syscall1(SYS_close, g_fb_fd)

    if g_won != 0:
        print_str(cast[*uint8]("You won!\n"))
    else:
        print_str(cast[*uint8]("Game over!\n"))

    return 0

main()
