# nl - number lines
# Usage: nl [FILE]
#        nl -b a [FILE]     (number all lines)
#        nl -n ln [FILE]    (left justified)
#        nl -n rn [FILE]    (right justified)
#        nl -n rz [FILE]    (right justified, zero padded)

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Format styles: 0 = left, 1 = right, 2 = right-zero
def print_line_number(n: int32, style: int32):
  if n == 0:
    if style == 0:
      print(cast[*uint8]("0\t"))
    if style == 1:
      print(cast[*uint8]("     0\t"))
    if style == 2:
      print(cast[*uint8]("000000\t"))
    return

  # Convert number to string
  temp: *uint8 = cast[*uint8](0)
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 32
  _ = syscall1(SYS_brk, new_brk)
  temp = cast[*uint8](old_brk)

  num: int32 = n
  i: int32 = 0

  # Build string in reverse
  while num > 0:
    digit: int32 = num % 10
    temp[i] = cast[uint8](48 + digit)
    num = num / 10
    i = i + 1

  len: int32 = i

  # Print based on style
  if style == 0:
    # Left justified
    j: int32 = len - 1
    while j >= 0:
      _ = syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[*uint8]("\t"))

  if style == 1:
    # Right justified (6 chars)
    padding: int32 = 6 - len
    p: int32 = 0
    while p < padding:
      _ = syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
      p = p + 1
    j: int32 = len - 1
    while j >= 0:
      _ = syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[*uint8]("\t"))

  if style == 2:
    # Right justified, zero padded (6 chars)
    padding: int32 = 6 - len
    p: int32 = 0
    while p < padding:
      _ = syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
      p = p + 1
    j: int32 = len - 1
    while j >= 0:
      _ = syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[*uint8]("\t"))

def main():
  argc: int32 = get_argc()
  fd: int32 = STDIN
  number_all: int32 = 1  # Default: number all lines
  format_style: int32 = 1  # Default: right justified
  arg_idx: int32 = 1

  # Parse options
  while arg_idx < argc:
    arg: *uint8 = get_argv(arg_idx)
    if arg[0] == cast[uint8](45):  # '-'
      if arg[1] == cast[uint8](98):  # 'b'
        arg_idx = arg_idx + 1
        if arg_idx < argc:
          opt: *uint8 = get_argv(arg_idx)
          if opt[0] == cast[uint8](97):  # 'a'
            number_all = 1
        arg_idx = arg_idx + 1
      if arg[1] == cast[uint8](110):  # 'n'
        arg_idx = arg_idx + 1
        if arg_idx < argc:
          opt: *uint8 = get_argv(arg_idx)
          # Check format
          if opt[0] == cast[uint8](108):  # 'l'
            format_style = 0  # left
          if opt[0] == cast[uint8](114):  # 'r'
            if opt[1] == cast[uint8](110):  # 'n'
              format_style = 1  # right
            if opt[1] == cast[uint8](122):  # 'z'
              format_style = 2  # right-zero
        arg_idx = arg_idx + 1
    if arg[0] != cast[uint8](45):
      # This is the filename
      fd = syscall3(SYS_open, cast[int32](arg), O_RDONLY, 0)
      if fd < 0:
        print_err(cast[*uint8]("nl: cannot open file\n"))
        _ = syscall1(SYS_exit, 1)
      arg_idx = arg_idx + 1
      break

  # Allocate buffers
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  _ = syscall1(SYS_brk, new_brk)
  buffer: *uint8 = cast[*uint8](old_brk)
  line_buf: *uint8 = cast[*uint8](old_brk + 4096)

  line_num: int32 = 0
  buf_pos: int32 = 0
  buf_size: int32 = 0
  running: int32 = 1

  while running != 0:
    # Read a line
    line_start: int32 = 0
    line_done: int32 = 0

    while line_done == 0:
      if buf_pos >= buf_size:
        buf_size = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
        buf_pos = 0
        if buf_size <= 0:
          running = 0
          line_done = 1
          break

      if buf_pos < buf_size:
        c: uint8 = buffer[buf_pos]
        buf_pos = buf_pos + 1

        line_buf[line_start] = c
        line_start = line_start + 1

        if c == cast[uint8](10):  # newline
          line_done = 1

    # Output line with number
    if line_start > 0:
      line_num = line_num + 1
      print_line_number(line_num, format_style)
      _ = syscall3(SYS_write, STDOUT, cast[int32](line_buf), line_start)

  if fd != STDIN:
    _ = syscall1(SYS_close, fd)

  _ = syscall1(SYS_exit, 0)
