# nl - number lines
# Usage: nl [FILE]
#        nl -b a [FILE]     (number all lines)
#        nl -n ln [FILE]    (left justified)
#        nl -n rn [FILE]    (right justified)
#        nl -n rz [FILE]    (right justified, zero padded)

import "lib/syscalls"

extern get_argc(): int32
extern get_argv(index: int32): ptr uint8

proc print_err(msg: ptr uint8) =
  var len: int32 = strlen(msg)
  discard syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Format styles: 0 = left, 1 = right, 2 = right-zero
proc print_line_number(n: int32, style: int32) =
  if n == 0:
    if style == 0:
      print(cast[ptr uint8]("0\t"))
    if style == 1:
      print(cast[ptr uint8]("     0\t"))
    if style == 2:
      print(cast[ptr uint8]("000000\t"))
    return

  # Convert number to string
  var temp: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 32
  discard syscall1(SYS_brk, new_brk)
  temp = cast[ptr uint8](old_brk)

  var num: int32 = n
  var i: int32 = 0

  # Build string in reverse
  while num > 0:
    var digit: int32 = num % 10
    temp[i] = cast[uint8](48 + digit)
    num = num / 10
    i = i + 1

  var len: int32 = i

  # Print based on style
  if style == 0:
    # Left justified
    var j: int32 = len - 1
    while j >= 0:
      discard syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[ptr uint8]("\t"))

  if style == 1:
    # Right justified (6 chars)
    var padding: int32 = 6 - len
    var p: int32 = 0
    while p < padding:
      discard syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
      p = p + 1
    var j: int32 = len - 1
    while j >= 0:
      discard syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[ptr uint8]("\t"))

  if style == 2:
    # Right justified, zero padded (6 chars)
    var padding: int32 = 6 - len
    var p: int32 = 0
    while p < padding:
      discard syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
      p = p + 1
    var j: int32 = len - 1
    while j >= 0:
      discard syscall3(SYS_write, STDOUT, cast[int32](temp + j), 1)
      j = j - 1
    print(cast[ptr uint8]("\t"))

proc main() =
  var argc: int32 = get_argc()
  var fd: int32 = STDIN
  var number_all: int32 = 1  # Default: number all lines
  var format_style: int32 = 1  # Default: right justified
  var arg_idx: int32 = 1

  # Parse options
  while arg_idx < argc:
    var arg: ptr uint8 = get_argv(arg_idx)
    if arg[0] == cast[uint8](45):  # '-'
      if arg[1] == cast[uint8](98):  # 'b'
        arg_idx = arg_idx + 1
        if arg_idx < argc:
          var opt: ptr uint8 = get_argv(arg_idx)
          if opt[0] == cast[uint8](97):  # 'a'
            number_all = 1
        arg_idx = arg_idx + 1
      if arg[1] == cast[uint8](110):  # 'n'
        arg_idx = arg_idx + 1
        if arg_idx < argc:
          var opt: ptr uint8 = get_argv(arg_idx)
          # Check format
          if opt[0] == cast[uint8](108):  # 'l'
            format_style = 0  # left
          if opt[0] == cast[uint8](114):  # 'r'
            if opt[1] == cast[uint8](110):  # 'n'
              format_style = 1  # right
            if opt[1] == cast[uint8](122):  # 'z'
              format_style = 2  # right-zero
        arg_idx = arg_idx + 1
    if arg[0] != cast[uint8](45):
      # This is the filename
      fd = syscall3(SYS_open, cast[int32](arg), O_RDONLY, 0)
      if fd < 0:
        print_err(cast[ptr uint8]("nl: cannot open file\n"))
        discard syscall1(SYS_exit, 1)
      arg_idx = arg_idx + 1
      break

  # Allocate buffers
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 8192
  discard syscall1(SYS_brk, new_brk)
  var buffer: ptr uint8 = cast[ptr uint8](old_brk)
  var line_buf: ptr uint8 = cast[ptr uint8](old_brk + 4096)

  var line_num: int32 = 0
  var buf_pos: int32 = 0
  var buf_size: int32 = 0
  var running: int32 = 1

  while running != 0:
    # Read a line
    var line_start: int32 = 0
    var line_done: int32 = 0

    while line_done == 0:
      if buf_pos >= buf_size:
        buf_size = syscall3(SYS_read, fd, cast[int32](buffer), 4096)
        buf_pos = 0
        if buf_size <= 0:
          running = 0
          line_done = 1
          break

      if buf_pos < buf_size:
        var c: uint8 = buffer[buf_pos]
        buf_pos = buf_pos + 1

        line_buf[line_start] = c
        line_start = line_start + 1

        if c == cast[uint8](10):  # newline
          line_done = 1

    # Output line with number
    if line_start > 0:
      line_num = line_num + 1
      print_line_number(line_num, format_style)
      discard syscall3(SYS_write, STDOUT, cast[int32](line_buf), line_start)

  if fd != STDIN:
    discard syscall1(SYS_close, fd)

  discard syscall1(SYS_exit, 0)
