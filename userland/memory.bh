# memory - Classic card matching memory game
# Click or use arrows+space to flip cards, match pairs to win
# Q to quit, R to restart

from lib.syscalls import *

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const GRID_COLS: int32 = 4
const GRID_ROWS: int32 = 4
const TOTAL_CARDS: int32 = 16
const CARD_WIDTH: int32 = 80
const CARD_HEIGHT: int32 = 100
const CARD_GAP: int32 = 10

# Card states
const CARD_HIDDEN: int32 = 0
const CARD_SHOWN: int32 = 1
const CARD_MATCHED: int32 = 2

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Game area
g_board_x: int32 = 0
g_board_y: int32 = 0

# Game state
g_cards: array[16, int32]       # Card values (0-7, each appears twice)
g_card_state: array[16, int32]  # HIDDEN, SHOWN, or MATCHED
g_cursor: int32 = 0             # Current cursor position
g_first_card: int32 = 0 - 1     # First flipped card index (-1 if none)
g_second_card: int32 = 0 - 1    # Second flipped card index (-1 if none)
g_matches: int32 = 0            # Number of matches found
g_moves: int32 = 0              # Number of moves made
g_running: int32 = 1
g_won: int32 = 0
g_show_delay: int32 = 0         # Delay counter for showing mismatched cards

# Random state
g_rand_state: int32 = 12345

# Card colors (for the symbols)
g_card_colors: array[8, int32]

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    ts: *int32 = cast[*int32](old_brk)
    ts[0] = 0
    ts[1] = ms * 1000000
    _ = syscall2(SYS_nanosleep, cast[int32](ts), 0)

def random() -> int32:
    global g_rand_state
    g_rand_state = g_rand_state * 1103515245 + 12345
    r: int32 = g_rand_state / 65536
    if r < 0:
        r = 0 - r
    return r

def init_colors():
    global g_card_colors
    g_card_colors[0] = 0xFF0000  # Red
    g_card_colors[1] = 0x00FF00  # Green
    g_card_colors[2] = 0x0000FF  # Blue
    g_card_colors[3] = 0xFFFF00  # Yellow
    g_card_colors[4] = 0xFF00FF  # Magenta
    g_card_colors[5] = 0x00FFFF  # Cyan
    g_card_colors[6] = 0xFF8800  # Orange
    g_card_colors[7] = 0x8800FF  # Purple

# ============ Graphics ============

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
    global g_fb, g_xres, g_yres
    py: int32 = y
    while py < y + h:
        if py >= 0 and py < g_yres:
            px: int32 = x
            while px < x + w:
                if px >= 0 and px < g_xres:
                    g_fb[py * g_xres + px] = cast[uint32](color)
                px = px + 1
        py = py + 1

def draw_border(x: int32, y: int32, w: int32, h: int32, color: int32, thickness: int32):
    fill_rect(x, y, w, thickness, color)
    fill_rect(x, y + h - thickness, w, thickness, color)
    fill_rect(x, y, thickness, h, color)
    fill_rect(x + w - thickness, y, thickness, h, color)

# Draw simple symbols on cards
def draw_symbol(card_val: int32, x: int32, y: int32, size: int32, color: int32):
    cx: int32 = x + size / 2
    cy: int32 = y + size / 2

    if card_val == 0:  # Circle
        r: int32 = size / 3
        py: int32 = cy - r
        while py <= cy + r:
            px: int32 = cx - r
            while px <= cx + r:
                dx: int32 = px - cx
                dy: int32 = py - cy
                dist: int32 = dx * dx + dy * dy
                if dist >= (r - 3) * (r - 3) and dist <= r * r:
                    fill_rect(px, py, 1, 1, color)
                px = px + 1
            py = py + 1
    elif card_val == 1:  # Square
        fill_rect(cx - 15, cy - 15, 30, 30, color)
    elif card_val == 2:  # Triangle (simplified)
        row: int32 = 0
        while row < 30:
            width: int32 = row + 1
            fill_rect(cx - width / 2, cy - 15 + row, width, 1, color)
            row = row + 1
    elif card_val == 3:  # Diamond
        row: int32 = 0
        while row < 15:
            fill_rect(cx - row, cy - 15 + row, row * 2 + 1, 1, color)
            row = row + 1
        row = 0
        while row < 15:
            fill_rect(cx - 14 + row, cy + row, (14 - row) * 2 + 1, 1, color)
            row = row + 1
    elif card_val == 4:  # Star (simplified - plus sign)
        fill_rect(cx - 3, cy - 18, 6, 36, color)
        fill_rect(cx - 18, cy - 3, 36, 6, color)
    elif card_val == 5:  # Heart (simplified)
        fill_rect(cx - 12, cy - 10, 10, 10, color)
        fill_rect(cx + 2, cy - 10, 10, 10, color)
        row: int32 = 0
        while row < 15:
            width: int32 = 24 - row * 2
            if width > 0:
                fill_rect(cx - width / 2, cy + row, width, 1, color)
            row = row + 1
    elif card_val == 6:  # Cross
        fill_rect(cx - 15, cy - 3, 30, 6, color)
        fill_rect(cx - 3, cy - 15, 6, 30, color)
    elif card_val == 7:  # X
        i: int32 = 0
        while i < 30:
            fill_rect(cx - 15 + i, cy - 15 + i - 2, 4, 4, color)
            fill_rect(cx - 15 + i, cy + 15 - i - 2, 4, 4, color)
            i = i + 1

def draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32):
    if d == 0:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 5, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 1:
        fill_rect(x + scale * 2, y, scale, scale * 7, color)
    elif d == 2:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 3:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 4:
        fill_rect(x, y, scale, scale * 4, color)
        fill_rect(x + scale * 4, y, scale, scale * 7, color)
        fill_rect(x, y + scale * 3, scale * 5, scale, color)
    elif d == 5:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x, y + scale * 3, scale * 4, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 6:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 5, color)
        fill_rect(x, y + scale * 3, scale * 4, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 7:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 6, color)
    elif d == 8:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 9:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)

def draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32):
    if num < 0:
        return
    if num == 0:
        draw_digit(0, x, y, color, scale)
        return

    n: int32 = num
    digits: int32 = 0
    while n > 0:
        digits = digits + 1
        n = n / 10

    digit_arr: array[6, int32]
    n = num
    i: int32 = digits - 1
    while i >= 0:
        digit_arr[i] = n - (n / 10) * 10
        n = n / 10
        i = i - 1

    dx: int32 = x
    i = 0
    while i < digits:
        draw_digit(digit_arr[i], dx, y, color, scale)
        dx = dx + scale * 6
        i = i + 1

# ============ Game Logic ============

def shuffle_cards():
    global g_cards, g_rand_state
    # Initialize cards with pairs (0-7 appears twice each)
    i: int32 = 0
    while i < 8:
        g_cards[i * 2] = i
        g_cards[i * 2 + 1] = i
        i = i + 1

    # Seed random
    t: int32 = syscall1(SYS_time, 0)
    g_rand_state = t

    # Fisher-Yates shuffle
    i = TOTAL_CARDS - 1
    while i > 0:
        j: int32 = random() - (random() / (i + 1)) * (i + 1)
        if j < 0:
            j = 0 - j
        if j > i:
            j = i

        # Swap
        temp: int32 = g_cards[i]
        g_cards[i] = g_cards[j]
        g_cards[j] = temp
        i = i - 1

def init_game():
    global g_cursor, g_first_card, g_second_card, g_matches, g_moves, g_won, g_show_delay, g_card_state
    g_cursor = 0
    g_first_card = 0 - 1
    g_second_card = 0 - 1
    g_matches = 0
    g_moves = 0
    g_won = 0
    g_show_delay = 0

    i: int32 = 0
    while i < TOTAL_CARDS:
        g_card_state[i] = CARD_HIDDEN
        i = i + 1

    shuffle_cards()

def flip_card(idx: int32):
    global g_card_state, g_first_card, g_second_card, g_moves, g_matches, g_show_delay, g_won, g_cards
    if g_card_state[idx] != CARD_HIDDEN:
        return  # Already shown or matched

    if g_show_delay > 0:
        return  # Waiting to hide previous mismatch

    if g_first_card < 0:
        # First card
        g_first_card = idx
        g_card_state[idx] = CARD_SHOWN
    elif g_second_card < 0 and idx != g_first_card:
        # Second card
        g_second_card = idx
        g_card_state[idx] = CARD_SHOWN
        g_moves = g_moves + 1

        # Check for match
        if g_cards[g_first_card] == g_cards[g_second_card]:
            g_card_state[g_first_card] = CARD_MATCHED
            g_card_state[g_second_card] = CARD_MATCHED
            g_matches = g_matches + 1
            g_first_card = 0 - 1
            g_second_card = 0 - 1

            if g_matches == 8:
                g_won = 1
        else:
            # Mismatch - set delay
            g_show_delay = 30  # ~0.5 seconds

def update_game():
    global g_show_delay, g_card_state, g_first_card, g_second_card
    if g_show_delay > 0:
        g_show_delay = g_show_delay - 1
        if g_show_delay == 0:
            # Hide mismatched cards
            g_card_state[g_first_card] = CARD_HIDDEN
            g_card_state[g_second_card] = CARD_HIDDEN
            g_first_card = 0 - 1
            g_second_card = 0 - 1

# ============ Drawing ============

def draw_card(idx: int32):
    global g_board_x, g_board_y, g_cursor, g_card_state, g_cards, g_card_colors
    col: int32 = idx - (idx / GRID_COLS) * GRID_COLS
    row: int32 = idx / GRID_COLS

    x: int32 = g_board_x + col * (CARD_WIDTH + CARD_GAP)
    y: int32 = g_board_y + row * (CARD_HEIGHT + CARD_GAP)

    is_selected: int32 = 0
    if idx == g_cursor:
        is_selected = 1

    state: int32 = g_card_state[idx]

    if state == CARD_HIDDEN:
        # Card back
        fill_rect(x, y, CARD_WIDTH, CARD_HEIGHT, 0x2244AA)
        fill_rect(x + 4, y + 4, CARD_WIDTH - 8, CARD_HEIGHT - 8, 0x3355BB)
        # Pattern on back
        fill_rect(x + 15, y + 20, CARD_WIDTH - 30, 4, 0x4466CC)
        fill_rect(x + 15, y + 40, CARD_WIDTH - 30, 4, 0x4466CC)
        fill_rect(x + 15, y + 60, CARD_WIDTH - 30, 4, 0x4466CC)
        fill_rect(x + 15, y + 80, CARD_WIDTH - 30, 4, 0x4466CC)
    elif state == CARD_SHOWN or state == CARD_MATCHED:
        # Card face
        bg: int32 = 0xFFFFFF
        if state == CARD_MATCHED:
            bg = 0xCCFFCC

        fill_rect(x, y, CARD_WIDTH, CARD_HEIGHT, bg)
        fill_rect(x + 2, y + 2, CARD_WIDTH - 4, CARD_HEIGHT - 4, bg)

        # Draw symbol
        card_val: int32 = g_cards[idx]
        symbol_color: int32 = g_card_colors[card_val]
        draw_symbol(card_val, x + 10, y + 10, CARD_WIDTH - 20, symbol_color)

    # Cursor highlight
    if is_selected != 0:
        draw_border(x - 2, y - 2, CARD_WIDTH + 4, CARD_HEIGHT + 4, 0xFFFF00, 3)

def draw_header():
    global g_board_x, g_moves, g_matches
    # Title
    title_x: int32 = g_board_x
    fill_rect(title_x, 20, 200, 40, 0x333333)

    # Moves
    moves_x: int32 = g_board_x + 250
    fill_rect(moves_x, 30, 80, 30, 0x444444)
    draw_number(g_moves, moves_x + 10, 35, 0xFFFFFF, 3)

    # Matches
    matches_x: int32 = g_board_x + 350
    fill_rect(matches_x, 30, 80, 30, 0x444444)
    draw_number(g_matches, matches_x + 10, 35, 0x00FF00, 3)

def draw_won_screen():
    global g_board_x, g_board_y, g_moves
    msg_x: int32 = g_board_x + 80
    msg_y: int32 = g_board_y + 150
    fill_rect(msg_x, msg_y, 200, 80, 0x004400)
    draw_number(g_moves, msg_x + 70, msg_y + 30, 0x00FF00, 6)

def draw_screen():
    global g_xres, g_yres, g_won
    # Clear screen
    fill_rect(0, 0, g_xres, g_yres, 0x1a1a2e)

    draw_header()

    # Draw all cards
    i: int32 = 0
    while i < TOTAL_CARDS:
        draw_card(i)
        i = i + 1

    if g_won != 0:
        draw_won_screen()

# ============ Input ============

def handle_input():
    global g_cursor, g_won, g_running
    buf: array[8, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

    if n <= 0:
        return

    c: int32 = cast[int32](buf[0])

    # Arrow keys
    if c == 27 and n >= 3:
        if buf[1] == cast[uint8](91):
            if buf[2] == cast[uint8](65):  # Up
                if g_cursor >= GRID_COLS:
                    g_cursor = g_cursor - GRID_COLS
            elif buf[2] == cast[uint8](66):  # Down
                if g_cursor < TOTAL_CARDS - GRID_COLS:
                    g_cursor = g_cursor + GRID_COLS
            elif buf[2] == cast[uint8](67):  # Right
                if g_cursor < TOTAL_CARDS - 1:
                    g_cursor = g_cursor + 1
            elif buf[2] == cast[uint8](68):  # Left
                if g_cursor > 0:
                    g_cursor = g_cursor - 1
    elif c == 32 or c == 10:  # Space or Enter - flip card
        if g_won == 0:
            flip_card(g_cursor)
    elif c == 119 or c == 87:  # w/W - up
        if g_cursor >= GRID_COLS:
            g_cursor = g_cursor - GRID_COLS
    elif c == 115 or c == 83:  # s/S - down
        if g_cursor < TOTAL_CARDS - GRID_COLS:
            g_cursor = g_cursor + GRID_COLS
    elif c == 97 or c == 65:  # a/A - left
        if g_cursor > 0:
            g_cursor = g_cursor - 1
    elif c == 100:  # d - right
        if g_cursor < TOTAL_CARDS - 1:
            g_cursor = g_cursor + 1
    elif c == 113 or c == 81:  # q/Q - quit
        g_running = 0
    elif c == 114 or c == 82:  # r/R - restart
        init_game()

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
    global g_fb_fd, g_xres, g_yres, g_fb
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 256)

    path: *uint8 = cast[*uint8]("/dev/fb0")
    g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
    if g_fb_fd < 0:
        print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
        return 1

    vinfo: *int32 = cast[*int32](old_brk + 32)
    i: int32 = 0
    while i < 40:
        vinfo[i] = 0
        i = i + 1

    const FBIOGET_VSCREENINFO: int32 = 0x4600
    _ = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

    g_xres = vinfo[0]
    g_yres = vinfo[1]

    fb_size: int32 = g_xres * g_yres * 4
    fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
    if fb_addr < 0:
        return 1

    g_fb = cast[*uint32](fb_addr)
    return 0

# ============ Main ============

def main() -> int32:
    global g_xres, g_yres, g_board_x, g_board_y, g_running
    if init_framebuffer() != 0:
        return 1

    init_colors()

    # Set stdin to non-blocking
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

    # Calculate board position (centered)
    board_w: int32 = GRID_COLS * CARD_WIDTH + (GRID_COLS - 1) * CARD_GAP
    board_h: int32 = GRID_ROWS * CARD_HEIGHT + (GRID_ROWS - 1) * CARD_GAP
    g_board_x = (g_xres - board_w) / 2
    g_board_y = (g_yres - board_h) / 2 + 20

    # Initialize game
    init_game()

    # Main loop
    while g_running != 0:
        update_game()
        draw_screen()
        handle_input()
        sleep_ms(16)

    # Restore stdin
    _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

    # Clear screen
    fill_rect(0, 0, g_xres, g_yres, 0)

    return 0
