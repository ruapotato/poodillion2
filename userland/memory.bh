# memory - Classic card matching memory game
# Click or use arrows+space to flip cards, match pairs to win
# Q to quit, R to restart

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192
const SYS_nanosleep: int32 = 162
const SYS_time: int32 = 13

const STDIN: int32 = 0
const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const GRID_COLS: int32 = 4
const GRID_ROWS: int32 = 4
const TOTAL_CARDS: int32 = 16
const CARD_WIDTH: int32 = 80
const CARD_HEIGHT: int32 = 100
const CARD_GAP: int32 = 10

# Card states
const CARD_HIDDEN: int32 = 0
const CARD_SHOWN: int32 = 1
const CARD_MATCHED: int32 = 2

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Game area
var g_board_x: int32 = 0
var g_board_y: int32 = 0

# Game state
var g_cards: array[16, int32]       # Card values (0-7, each appears twice)
var g_card_state: array[16, int32]  # HIDDEN, SHOWN, or MATCHED
var g_cursor: int32 = 0             # Current cursor position
var g_first_card: int32 = 0 - 1     # First flipped card index (-1 if none)
var g_second_card: int32 = 0 - 1    # Second flipped card index (-1 if none)
var g_matches: int32 = 0            # Number of matches found
var g_moves: int32 = 0              # Number of moves made
var g_running: int32 = 1
var g_won: int32 = 0
var g_show_delay: int32 = 0         # Delay counter for showing mismatched cards

# Random state
var g_rand_state: int32 = 12345

# Card colors (for the symbols)
var g_card_colors: array[8, int32]

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

proc random(): int32 =
  g_rand_state = g_rand_state * 1103515245 + 12345
  var r: int32 = g_rand_state / 65536
  if r < 0:
    r = 0 - r
  return r

proc init_colors() =
  g_card_colors[0] = 0xFF0000  # Red
  g_card_colors[1] = 0x00FF00  # Green
  g_card_colors[2] = 0x0000FF  # Blue
  g_card_colors[3] = 0xFFFF00  # Yellow
  g_card_colors[4] = 0xFF00FF  # Magenta
  g_card_colors[5] = 0x00FFFF  # Cyan
  g_card_colors[6] = 0xFF8800  # Orange
  g_card_colors[7] = 0x8800FF  # Purple

# ============ Graphics ============

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var py: int32 = y
  while py < y + h:
    if py >= 0 and py < g_yres:
      var px: int32 = x
      while px < x + w:
        if px >= 0 and px < g_xres:
          g_fb[py * g_xres + px] = cast[uint32](color)
        px = px + 1
    py = py + 1

proc draw_border(x: int32, y: int32, w: int32, h: int32, color: int32, thickness: int32) =
  fill_rect(x, y, w, thickness, color)
  fill_rect(x, y + h - thickness, w, thickness, color)
  fill_rect(x, y, thickness, h, color)
  fill_rect(x + w - thickness, y, thickness, h, color)

# Draw simple symbols on cards
proc draw_symbol(card_val: int32, x: int32, y: int32, size: int32, color: int32) =
  var cx: int32 = x + size / 2
  var cy: int32 = y + size / 2

  if card_val == 0:  # Circle
    var r: int32 = size / 3
    var py: int32 = cy - r
    while py <= cy + r:
      var px: int32 = cx - r
      while px <= cx + r:
        var dx: int32 = px - cx
        var dy: int32 = py - cy
        var dist: int32 = dx * dx + dy * dy
        if dist >= (r - 3) * (r - 3) and dist <= r * r:
          fill_rect(px, py, 1, 1, color)
        px = px + 1
      py = py + 1
  elif card_val == 1:  # Square
    fill_rect(cx - 15, cy - 15, 30, 30, color)
  elif card_val == 2:  # Triangle (simplified)
    var row: int32 = 0
    while row < 30:
      var width: int32 = row + 1
      fill_rect(cx - width / 2, cy - 15 + row, width, 1, color)
      row = row + 1
  elif card_val == 3:  # Diamond
    var row: int32 = 0
    while row < 15:
      fill_rect(cx - row, cy - 15 + row, row * 2 + 1, 1, color)
      row = row + 1
    row = 0
    while row < 15:
      fill_rect(cx - 14 + row, cy + row, (14 - row) * 2 + 1, 1, color)
      row = row + 1
  elif card_val == 4:  # Star (simplified - plus sign)
    fill_rect(cx - 3, cy - 18, 6, 36, color)
    fill_rect(cx - 18, cy - 3, 36, 6, color)
  elif card_val == 5:  # Heart (simplified)
    fill_rect(cx - 12, cy - 10, 10, 10, color)
    fill_rect(cx + 2, cy - 10, 10, 10, color)
    var row: int32 = 0
    while row < 15:
      var width: int32 = 24 - row * 2
      if width > 0:
        fill_rect(cx - width / 2, cy + row, width, 1, color)
      row = row + 1
  elif card_val == 6:  # Cross
    fill_rect(cx - 15, cy - 3, 30, 6, color)
    fill_rect(cx - 3, cy - 15, 6, 30, color)
  elif card_val == 7:  # X
    var i: int32 = 0
    while i < 30:
      fill_rect(cx - 15 + i, cy - 15 + i - 2, 4, 4, color)
      fill_rect(cx - 15 + i, cy + 15 - i - 2, 4, 4, color)
      i = i + 1

proc draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32) =
  if d == 0:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 1:
    fill_rect(x + scale * 2, y, scale, scale * 7, color)
  elif d == 2:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 3:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 4:
    fill_rect(x, y, scale, scale * 4, color)
    fill_rect(x + scale * 4, y, scale, scale * 7, color)
    fill_rect(x, y + scale * 3, scale * 5, scale, color)
  elif d == 5:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 6:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 7:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 6, color)
  elif d == 8:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 9:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)

proc draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32) =
  if num < 0:
    return
  if num == 0:
    draw_digit(0, x, y, color, scale)
    return

  var n: int32 = num
  var digits: int32 = 0
  while n > 0:
    digits = digits + 1
    n = n / 10

  var digit_arr: array[6, int32]
  n = num
  var i: int32 = digits - 1
  while i >= 0:
    digit_arr[i] = n - (n / 10) * 10
    n = n / 10
    i = i - 1

  var dx: int32 = x
  i = 0
  while i < digits:
    draw_digit(digit_arr[i], dx, y, color, scale)
    dx = dx + scale * 6
    i = i + 1

# ============ Game Logic ============

proc shuffle_cards() =
  # Initialize cards with pairs (0-7 appears twice each)
  var i: int32 = 0
  while i < 8:
    g_cards[i * 2] = i
    g_cards[i * 2 + 1] = i
    i = i + 1

  # Seed random
  var t: int32 = syscall1(SYS_time, 0)
  g_rand_state = t

  # Fisher-Yates shuffle
  i = TOTAL_CARDS - 1
  while i > 0:
    var j: int32 = random() - (random() / (i + 1)) * (i + 1)
    if j < 0: j = 0 - j
    if j > i: j = i

    # Swap
    var temp: int32 = g_cards[i]
    g_cards[i] = g_cards[j]
    g_cards[j] = temp
    i = i - 1

proc init_game() =
  g_cursor = 0
  g_first_card = 0 - 1
  g_second_card = 0 - 1
  g_matches = 0
  g_moves = 0
  g_won = 0
  g_show_delay = 0

  var i: int32 = 0
  while i < TOTAL_CARDS:
    g_card_state[i] = CARD_HIDDEN
    i = i + 1

  shuffle_cards()

proc flip_card(idx: int32) =
  if g_card_state[idx] != CARD_HIDDEN:
    return  # Already shown or matched

  if g_show_delay > 0:
    return  # Waiting to hide previous mismatch

  if g_first_card < 0:
    # First card
    g_first_card = idx
    g_card_state[idx] = CARD_SHOWN
  elif g_second_card < 0 and idx != g_first_card:
    # Second card
    g_second_card = idx
    g_card_state[idx] = CARD_SHOWN
    g_moves = g_moves + 1

    # Check for match
    if g_cards[g_first_card] == g_cards[g_second_card]:
      g_card_state[g_first_card] = CARD_MATCHED
      g_card_state[g_second_card] = CARD_MATCHED
      g_matches = g_matches + 1
      g_first_card = 0 - 1
      g_second_card = 0 - 1

      if g_matches == 8:
        g_won = 1
    else:
      # Mismatch - set delay
      g_show_delay = 30  # ~0.5 seconds

proc update_game() =
  if g_show_delay > 0:
    g_show_delay = g_show_delay - 1
    if g_show_delay == 0:
      # Hide mismatched cards
      g_card_state[g_first_card] = CARD_HIDDEN
      g_card_state[g_second_card] = CARD_HIDDEN
      g_first_card = 0 - 1
      g_second_card = 0 - 1

# ============ Drawing ============

proc draw_card(idx: int32) =
  var col: int32 = idx - (idx / GRID_COLS) * GRID_COLS
  var row: int32 = idx / GRID_COLS

  var x: int32 = g_board_x + col * (CARD_WIDTH + CARD_GAP)
  var y: int32 = g_board_y + row * (CARD_HEIGHT + CARD_GAP)

  var is_selected: int32 = 0
  if idx == g_cursor:
    is_selected = 1

  var state: int32 = g_card_state[idx]

  if state == CARD_HIDDEN:
    # Card back
    fill_rect(x, y, CARD_WIDTH, CARD_HEIGHT, 0x2244AA)
    fill_rect(x + 4, y + 4, CARD_WIDTH - 8, CARD_HEIGHT - 8, 0x3355BB)
    # Pattern on back
    fill_rect(x + 15, y + 20, CARD_WIDTH - 30, 4, 0x4466CC)
    fill_rect(x + 15, y + 40, CARD_WIDTH - 30, 4, 0x4466CC)
    fill_rect(x + 15, y + 60, CARD_WIDTH - 30, 4, 0x4466CC)
    fill_rect(x + 15, y + 80, CARD_WIDTH - 30, 4, 0x4466CC)
  elif state == CARD_SHOWN or state == CARD_MATCHED:
    # Card face
    var bg: int32 = 0xFFFFFF
    if state == CARD_MATCHED:
      bg = 0xCCFFCC

    fill_rect(x, y, CARD_WIDTH, CARD_HEIGHT, bg)
    fill_rect(x + 2, y + 2, CARD_WIDTH - 4, CARD_HEIGHT - 4, bg)

    # Draw symbol
    var card_val: int32 = g_cards[idx]
    var symbol_color: int32 = g_card_colors[card_val]
    draw_symbol(card_val, x + 10, y + 10, CARD_WIDTH - 20, symbol_color)

  # Cursor highlight
  if is_selected != 0:
    draw_border(x - 2, y - 2, CARD_WIDTH + 4, CARD_HEIGHT + 4, 0xFFFF00, 3)

proc draw_header() =
  # Title
  var title_x: int32 = g_board_x
  fill_rect(title_x, 20, 200, 40, 0x333333)

  # Moves
  var moves_x: int32 = g_board_x + 250
  fill_rect(moves_x, 30, 80, 30, 0x444444)
  draw_number(g_moves, moves_x + 10, 35, 0xFFFFFF, 3)

  # Matches
  var matches_x: int32 = g_board_x + 350
  fill_rect(matches_x, 30, 80, 30, 0x444444)
  draw_number(g_matches, matches_x + 10, 35, 0x00FF00, 3)

proc draw_won_screen() =
  var msg_x: int32 = g_board_x + 80
  var msg_y: int32 = g_board_y + 150
  fill_rect(msg_x, msg_y, 200, 80, 0x004400)
  draw_number(g_moves, msg_x + 70, msg_y + 30, 0x00FF00, 6)

proc draw_screen() =
  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0x1a1a2e)

  draw_header()

  # Draw all cards
  var i: int32 = 0
  while i < TOTAL_CARDS:
    draw_card(i)
    i = i + 1

  if g_won != 0:
    draw_won_screen()

# ============ Input ============

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  var c: int32 = cast[int32](buf[0])

  # Arrow keys
  if c == 27 and n >= 3:
    if buf[1] == cast[uint8](91):
      if buf[2] == cast[uint8](65):  # Up
        if g_cursor >= GRID_COLS:
          g_cursor = g_cursor - GRID_COLS
      elif buf[2] == cast[uint8](66):  # Down
        if g_cursor < TOTAL_CARDS - GRID_COLS:
          g_cursor = g_cursor + GRID_COLS
      elif buf[2] == cast[uint8](67):  # Right
        if g_cursor < TOTAL_CARDS - 1:
          g_cursor = g_cursor + 1
      elif buf[2] == cast[uint8](68):  # Left
        if g_cursor > 0:
          g_cursor = g_cursor - 1
  elif c == 32 or c == 10:  # Space or Enter - flip card
    if g_won == 0:
      flip_card(g_cursor)
  elif c == 119 or c == 87:  # w/W - up
    if g_cursor >= GRID_COLS:
      g_cursor = g_cursor - GRID_COLS
  elif c == 115 or c == 83:  # s/S - down
    if g_cursor < TOTAL_CARDS - GRID_COLS:
      g_cursor = g_cursor + GRID_COLS
  elif c == 97 or c == 65:  # a/A - left
    if g_cursor > 0:
      g_cursor = g_cursor - 1
  elif c == 100:  # d - right
    if g_cursor < TOTAL_CARDS - 1:
      g_cursor = g_cursor + 1
  elif c == 113 or c == 81:  # q/Q - quit
    g_running = 0
  elif c == 114 or c == 82:  # r/R - restart
    init_game()

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)

  var path: ptr uint8 = cast[ptr uint8]("/dev/fb0")
  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  var fb_size: int32 = g_xres * g_yres * 4
  var fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
  if fb_addr < 0:
    return 1

  g_fb = cast[ptr uint32](fb_addr)
  return 0

# ============ Main ============

proc main(): int32 =
  if init_framebuffer() != 0:
    return 1

  init_colors()

  # Set stdin to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

  # Calculate board position (centered)
  var board_w: int32 = GRID_COLS * CARD_WIDTH + (GRID_COLS - 1) * CARD_GAP
  var board_h: int32 = GRID_ROWS * CARD_HEIGHT + (GRID_ROWS - 1) * CARD_GAP
  g_board_x = (g_xres - board_w) / 2
  g_board_y = (g_yres - board_h) / 2 + 20

  # Initialize game
  init_game()

  # Main loop
  while g_running != 0:
    update_game()
    draw_screen()
    handle_input()
    sleep_ms(16)

  # Restore stdin
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0)

  return 0
