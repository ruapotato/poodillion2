# curl.bh - HTTP client for BrainhairOS
# Usage: curl [options] <url>
#
# Options:
#   -o <file>    Write output to file instead of stdout
#   -i           Include response headers in output
#   -L           Follow redirects (up to 5)
#   -X <method>  Request method (GET, POST, HEAD)
#   -d <data>    POST data
#   -H <header>  Add custom header (can be used multiple times)
#   -v           Verbose mode
#   -s           Silent mode (no progress)
#
# Examples:
#   curl http://example.com/
#   curl -o page.html http://example.com/
#   curl -i http://example.com/api
#   curl -X POST -d "data" http://example.com/api
#   curl -L http://example.com/redirect

from lib.syscalls import *
from lib.net import *
from lib.dns import *

# Buffer sizes
MAX_URL_LEN: int32 = 1024
MAX_HOST_LEN: int32 = 256
MAX_PATH_LEN: int32 = 512
MAX_HEADERS: int32 = 16
MAX_HEADER_LEN: int32 = 256
RECV_BUF_SIZE: int32 = 8192
MAX_REDIRECTS: int32 = 5

# Options structure
opt_output_file: array[256, uint8]
opt_show_headers: int32 = 0
opt_follow_redirects: int32 = 0
opt_method: array[16, uint8]
opt_post_data: array[4096, uint8]
opt_post_data_len: int32 = 0
opt_verbose: int32 = 0
opt_silent: int32 = 0
opt_custom_headers: array[4096, uint8]
opt_custom_headers_len: int32 = 0

# ===========================================================================
# HTTP Functions
# ===========================================================================

def http_parse_status(response: *uint8) -> int32:
    i: int32 = 0
    while response[i] != 0 and response[i] != 32:
        i = i + 1
    if response[i] == 0:
        return -1
    i = i + 1
    status: int32 = 0
    digits: int32 = 0
    while digits < 3 and response[i] >= 48 and response[i] <= 57:
        status = status * 10 + (cast[int32](response[i]) - 48)
        i = i + 1
        digits = digits + 1
    if digits != 3:
        return -1
    return status

def http_get_header(response: *uint8, header_name: *uint8, value_buf: *uint8, max_len: int32) -> int32:
    i: int32 = 0
    name_len: int32 = strlen(header_name)
    while response[i] != 0 and response[i] != 10:
        i = i + 1
    if response[i] == 10:
        i = i + 1
    while response[i] != 0:
        if response[i] == 13 and response[i + 1] == 10:
            break
        if response[i] == 10:
            break
        matched: int32 = 1
        j: int32 = 0
        while j < name_len:
            c1: int32 = cast[int32](response[i + j])
            c2: int32 = cast[int32](header_name[j])
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1
        if matched == 1 and response[i + name_len] == 58:
            i = i + name_len + 1
            while response[i] == 32 or response[i] == 9:
                i = i + 1
            val_len: int32 = 0
            while response[i] != 0 and response[i] != 13 and response[i] != 10 and val_len < max_len - 1:
                value_buf[val_len] = response[i]
                val_len = val_len + 1
                i = i + 1
            value_buf[val_len] = 0
            return val_len
        while response[i] != 0 and response[i] != 10:
            i = i + 1
        if response[i] == 10:
            i = i + 1
    return -1

def http_get_content_length(response: *uint8) -> int32:
    value: array[32, uint8]
    len: int32 = http_get_header(response, cast[*uint8]("Content-Length"), addr(value[0]), 32)
    if len < 0:
        return -1
    result: int32 = 0
    i: int32 = 0
    while value[i] >= 48 and value[i] <= 57:
        result = result * 10 + (cast[int32](value[i]) - 48)
        i = i + 1
    return result

def http_get_location(response: *uint8, location_buf: *uint8, max_len: int32) -> int32:
    return http_get_header(response, cast[*uint8]("Location"), location_buf, max_len)

def http_parse_url(url: *uint8, host_buf: *uint8, host_max: int32, path_buf: *uint8, path_max: int32, port: *int32) -> int32:
    i: int32 = 0
    if url[0] == 104 and url[1] == 116 and url[2] == 116 and url[3] == 112:
        i = 4
        if url[4] == 115:
            i = 5
            if port != cast[*int32](0):
                port[0] = 443
        else:
            if port != cast[*int32](0):
                port[0] = 80
        if url[i] == 58 and url[i + 1] == 47 and url[i + 2] == 47:
            i = i + 3
    host_len: int32 = 0
    while url[i] != 0 and url[i] != 47 and url[i] != 58 and host_len < host_max - 1:
        host_buf[host_len] = url[i]
        host_len = host_len + 1
        i = i + 1
    host_buf[host_len] = 0
    if host_len == 0:
        return -1
    if url[i] == 58:
        i = i + 1
        parsed_port: int32 = 0
        while url[i] >= 48 and url[i] <= 57:
            parsed_port = parsed_port * 10 + (cast[int32](url[i]) - 48)
            i = i + 1
        if parsed_port > 0 and port != cast[*int32](0):
            port[0] = parsed_port
    path_len: int32 = 0
    if url[i] == 47:
        while url[i] != 0 and path_len < path_max - 1:
            path_buf[path_len] = url[i]
            path_len = path_len + 1
            i = i + 1
    else:
        path_buf[0] = 47
        path_len = 1
    path_buf[path_len] = 0
    return 0

# ===========================================================================
# Helper Functions
# ===========================================================================

def is_ip_address(host: *uint8) -> int32:
    i: int32 = 0
    dots: int32 = 0
    has_alpha: int32 = 0
    while host[i] != 0:
        if host[i] == 46:
            dots = dots + 1
        elif host[i] >= 97 and host[i] <= 122:
            has_alpha = 1
        elif host[i] >= 65 and host[i] <= 90:
            has_alpha = 1
        i = i + 1
    if dots == 3 and has_alpha == 0:
        return 1
    return 0

def verbose_print(msg: *uint8):
    if opt_verbose != 0:
        print(cast[*uint8]("* "))
        println(msg)

def verbose_print2(msg1: *uint8, msg2: *uint8):
    if opt_verbose != 0:
        print(cast[*uint8]("* "))
        print(msg1)
        println(msg2)

def show_usage():
    println(cast[*uint8]("curl - HTTP client for BrainhairOS"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Usage: curl [options] <url>"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Options:"))
    println(cast[*uint8]("  -o <file>    Write output to file"))
    println(cast[*uint8]("  -i           Include response headers"))
    println(cast[*uint8]("  -L           Follow redirects (max 5)"))
    println(cast[*uint8]("  -X <method>  Request method (GET/POST/HEAD)"))
    println(cast[*uint8]("  -d <data>    POST data"))
    println(cast[*uint8]("  -H <header>  Add custom header"))
    println(cast[*uint8]("  -v           Verbose mode"))
    println(cast[*uint8]("  -s           Silent mode"))
    println(cast[*uint8](""))
    println(cast[*uint8]("Examples:"))
    println(cast[*uint8]("  curl http://example.com/"))
    println(cast[*uint8]("  curl -i http://api.example.com/data"))
    println(cast[*uint8]("  curl -o file.html http://example.com/"))
    println(cast[*uint8]("  curl -X POST -d 'data' http://api.example.com/"))
    println(cast[*uint8]("  curl -L http://short.url/abc"))

# Parse command line arguments
def parse_args(argc: int32, argv: Ptr[Ptr[uint8]], url_out: *uint8) -> int32:
    i: int32 = 1
    url_found: int32 = 0

    # Default method
    opt_method[0] = 71  # G
    opt_method[1] = 69  # E
    opt_method[2] = 84  # T
    opt_method[3] = 0

    while i < argc:
        arg: *uint8 = argv[i]

        if arg[0] == 45:  # '-'
            if arg[1] == 111 and arg[2] == 0:  # -o
                i = i + 1
                if i >= argc:
                    println(cast[*uint8]("Error: -o requires argument"))
                    return -1
                fn: *uint8 = argv[i]
                j: int32 = 0
                while fn[j] != 0 and j < 255:
                    opt_output_file[j] = fn[j]
                    j = j + 1
                opt_output_file[j] = 0

            elif arg[1] == 105 and arg[2] == 0:  # -i
                opt_show_headers = 1

            elif arg[1] == 76 and arg[2] == 0:  # -L
                opt_follow_redirects = 1

            elif arg[1] == 88 and arg[2] == 0:  # -X
                i = i + 1
                if i >= argc:
                    println(cast[*uint8]("Error: -X requires argument"))
                    return -1
                method: *uint8 = argv[i]
                j: int32 = 0
                while method[j] != 0 and j < 15:
                    opt_method[j] = method[j]
                    j = j + 1
                opt_method[j] = 0

            elif arg[1] == 100 and arg[2] == 0:  # -d
                i = i + 1
                if i >= argc:
                    println(cast[*uint8]("Error: -d requires argument"))
                    return -1
                data: *uint8 = argv[i]
                j: int32 = 0
                while data[j] != 0 and j < 4095:
                    opt_post_data[j] = data[j]
                    j = j + 1
                opt_post_data[j] = 0
                opt_post_data_len = j
                # Auto-set method to POST
                opt_method[0] = 80  # P
                opt_method[1] = 79  # O
                opt_method[2] = 83  # S
                opt_method[3] = 84  # T
                opt_method[4] = 0

            elif arg[1] == 72 and arg[2] == 0:  # -H
                i = i + 1
                if i >= argc:
                    println(cast[*uint8]("Error: -H requires argument"))
                    return -1
                hdr: *uint8 = argv[i]
                j: int32 = 0
                while hdr[j] != 0 and opt_custom_headers_len < 4090:
                    opt_custom_headers[opt_custom_headers_len] = hdr[j]
                    opt_custom_headers_len = opt_custom_headers_len + 1
                    j = j + 1
                opt_custom_headers[opt_custom_headers_len] = 13
                opt_custom_headers_len = opt_custom_headers_len + 1
                opt_custom_headers[opt_custom_headers_len] = 10
                opt_custom_headers_len = opt_custom_headers_len + 1

            elif arg[1] == 118 and arg[2] == 0:  # -v
                opt_verbose = 1

            elif arg[1] == 115 and arg[2] == 0:  # -s
                opt_silent = 1

            elif arg[1] == 104 and arg[2] == 0:  # -h
                show_usage()
                return -2

            else:
                print(cast[*uint8]("Unknown option: "))
                println(arg)
                return -1

        else:
            # URL argument
            j: int32 = 0
            while arg[j] != 0 and j < MAX_URL_LEN - 1:
                url_out[j] = arg[j]
                j = j + 1
            url_out[j] = 0
            url_found = 1

        i = i + 1

    if url_found == 0:
        return -1

    return 0

# Perform HTTP request to a URL
def do_request(url: *uint8, output_fd: int32, redirect_count: int32) -> int32:
    host: array[256, uint8]
    path: array[512, uint8]
    port: int32 = 80

    if http_parse_url(url, addr(host[0]), 256, addr(path[0]), 512, addr(port)) < 0:
        println(cast[*uint8]("curl: (3) URL malformed"))
        return 3

    verbose_print2(cast[*uint8]("Host: "), addr(host[0]))
    verbose_print2(cast[*uint8]("Path: "), addr(path[0]))

    # Resolve hostname
    ip: array[4, uint8]

    if is_ip_address(addr(host[0])) == 1:
        if parse_ipv4(addr(host[0]), addr(ip[0])) == 0:
            println(cast[*uint8]("curl: (6) Could not parse IP address"))
            return 6
        verbose_print(cast[*uint8]("Using direct IP address"))
    else:
        verbose_print2(cast[*uint8]("Resolving hostname: "), addr(host[0]))
        if dns_resolve(addr(host[0]), addr(ip[0])) == 0:
            print(cast[*uint8]("curl: (6) Could not resolve host: "))
            println(addr(host[0]))
            return 6

        if opt_verbose != 0:
            ip_str: array[16, uint8]
            format_ipv4(addr(ip[0]), addr(ip_str[0]))
            verbose_print2(cast[*uint8]("Resolved to: "), addr(ip_str[0]))

    # Connect
    if opt_verbose != 0:
        print(cast[*uint8]("* Connecting to "))
        ip_str: array[16, uint8]
        format_ipv4(addr(ip[0]), addr(ip_str[0]))
        print(addr(ip_str[0]))
        print(cast[*uint8](" port "))
        print_int(port)
        println(cast[*uint8]("..."))

    sock: int32 = net_connect(addr(ip[0]), port)
    if sock < 0:
        println(cast[*uint8]("curl: (7) Failed to connect"))
        return 7

    if net_wait_connected(sock, 10000) == 0:
        println(cast[*uint8]("curl: (28) Connection timeout"))
        net_close(sock)
        return 28

    verbose_print(cast[*uint8]("Connected"))

    # Send request
    verbose_print2(cast[*uint8]("> "), addr(opt_method[0]))

    net_send_str(sock, addr(opt_method[0]))
    net_send_str(sock, cast[*uint8](" "))
    net_send_str(sock, addr(path[0]))
    net_send_str(sock, cast[*uint8](" HTTP/1.1\r\n"))

    net_send_str(sock, cast[*uint8]("Host: "))
    net_send_str(sock, addr(host[0]))
    net_send_str(sock, cast[*uint8]("\r\n"))

    net_send_str(sock, cast[*uint8]("User-Agent: curl/BrainhairOS\r\n"))
    net_send_str(sock, cast[*uint8]("Accept: */*\r\n"))

    # Custom headers
    if opt_custom_headers_len > 0:
        net_send(sock, addr(opt_custom_headers[0]), opt_custom_headers_len)

    # POST data
    if opt_post_data_len > 0:
        net_send_str(sock, cast[*uint8]("Content-Type: application/x-www-form-urlencoded\r\n"))
        net_send_str(sock, cast[*uint8]("Content-Length: "))
        len_str: array[16, uint8]
        val: int32 = opt_post_data_len
        idx: int32 = 0
        if val == 0:
            len_str[0] = 48
            idx = 1
        else:
            temp: array[16, uint8]
            ti: int32 = 0
            while val > 0:
                temp[ti] = cast[uint8](48 + (val % 10))
                val = val / 10
                ti = ti + 1
            while ti > 0:
                ti = ti - 1
                len_str[idx] = temp[ti]
                idx = idx + 1
        len_str[idx] = 0
        net_send_str(sock, addr(len_str[0]))
        net_send_str(sock, cast[*uint8]("\r\n"))

    net_send_str(sock, cast[*uint8]("Connection: close\r\n"))
    net_send_str(sock, cast[*uint8]("\r\n"))

    # Send POST body
    if opt_post_data_len > 0:
        net_send(sock, addr(opt_post_data[0]), opt_post_data_len)

    # Receive response
    buf: array[8192, uint8]
    total_read: int32 = 0
    headers_end: int32 = -1

    while headers_end < 0 and total_read < 8000:
        n: int32 = net_recv_blocking(sock, addr(buf[total_read]), 8000 - total_read, 10000)
        if n <= 0:
            break
        total_read = total_read + n

        i: int32 = 0
        while i < total_read - 3:
            if buf[i] == 13 and buf[i + 1] == 10 and buf[i + 2] == 13 and buf[i + 3] == 10:
                headers_end = i + 4
                break
            i = i + 1

    if headers_end < 0:
        println(cast[*uint8]("curl: (52) Empty reply from server"))
        net_close(sock)
        return 52

    buf[headers_end] = 0

    # Parse status
    status: int32 = http_parse_status(addr(buf[0]))

    if opt_verbose != 0:
        print(cast[*uint8]("< HTTP/1.1 "))
        print_int(status)
        println(cast[*uint8](""))

    # Handle redirects
    if (status == 301 or status == 302 or status == 303 or status == 307 or status == 308) and opt_follow_redirects != 0:
        if redirect_count >= MAX_REDIRECTS:
            println(cast[*uint8]("curl: (47) Maximum redirects reached"))
            net_close(sock)
            return 47

        location: array[1024, uint8]
        if http_get_location(addr(buf[0]), addr(location[0]), 1024) > 0:
            verbose_print2(cast[*uint8]("Following redirect to: "), addr(location[0]))
            net_close(sock)
            return do_request(addr(location[0]), output_fd, redirect_count + 1)
        else:
            println(cast[*uint8]("curl: (47) Redirect with no Location header"))
            net_close(sock)
            return 47

    # Output headers if requested
    if opt_show_headers != 0:
        i: int32 = 0
        while i < headers_end - 1:
            buf[i] = buf[i]  # Keep as-is
            i = i + 1
        write(output_fd, addr(buf[0]), headers_end)

    # Output body
    body_start: int32 = headers_end
    initial_body: int32 = total_read - body_start

    if initial_body > 0:
        write(output_fd, addr(buf[body_start]), initial_body)

    bytes_written: int32 = initial_body

    while 1:
        n: int32 = net_recv_blocking(sock, addr(buf[0]), 8192, 5000)
        if n <= 0:
            break
        write(output_fd, addr(buf[0]), n)
        bytes_written = bytes_written + n

        if opt_silent == 0 and opt_verbose != 0:
            print(cast[*uint8]("\r* Received: "))
            print_int(bytes_written)
            print(cast[*uint8](" bytes"))

    if opt_verbose != 0:
        println(cast[*uint8](""))
        print(cast[*uint8]("* Total: "))
        print_int(bytes_written)
        println(cast[*uint8](" bytes"))

    net_close(sock)

    # Return error code based on status
    if status >= 400:
        return 22  # HTTP error

    return 0

def main(argc: int32, argv: Ptr[Ptr[uint8]]) -> int32:
    url: array[1024, uint8]

    if argc < 2:
        show_usage()
        return 1

    result: int32 = parse_args(argc, argv, addr(url[0]))
    if result == -2:
        return 0  # Help shown
    if result < 0:
        show_usage()
        return 1

    # Initialize DNS
    dns_init()

    # Determine output
    output_fd: int32 = STDOUT

    if opt_output_file[0] != 0:
        output_fd = open(addr(opt_output_file[0]), O_WRONLY or O_CREAT or O_TRUNC)
        if output_fd < 0:
            print(cast[*uint8]("curl: (23) Failed to create file: "))
            println(addr(opt_output_file[0]))
            return 23

    # Make the request
    result = do_request(addr(url[0]), output_fd, 0)

    # Clean up
    if output_fd != STDOUT:
        close(output_fd)
        if result == 0 and opt_silent == 0:
            print(cast[*uint8]("Saved to: "))
            println(addr(opt_output_file[0]))

    return result
