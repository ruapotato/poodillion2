# curl.bh - HTTP client for BrainhairOS
# Usage: curl [options] <url>
#
# Options:
#   -o <file>    Write output to file instead of stdout
#   -i           Include response headers in output
#   -L           Follow redirects (up to 5)
#   -X <method>  Request method (GET, POST, HEAD)
#   -d <data>    POST data
#   -H <header>  Add custom header (can be used multiple times)
#   -v           Verbose mode
#   -s           Silent mode (no progress)
#
# Examples:
#   curl http://example.com/
#   curl -o page.html http://example.com/
#   curl -i http://example.com/api
#   curl -X POST -d "data" http://example.com/api
#   curl -L http://example.com/redirect

import "lib/syscalls"
import "lib/net"
import "lib/dns"

# Buffer sizes
const MAX_URL_LEN: int32 = 1024
const MAX_HOST_LEN: int32 = 256
const MAX_PATH_LEN: int32 = 512
const MAX_HEADERS: int32 = 16
const MAX_HEADER_LEN: int32 = 256
const RECV_BUF_SIZE: int32 = 8192
const MAX_REDIRECTS: int32 = 5

# Options structure
var opt_output_file: array[256, uint8]
var opt_show_headers: int32 = 0
var opt_follow_redirects: int32 = 0
var opt_method: array[16, uint8]
var opt_post_data: array[4096, uint8]
var opt_post_data_len: int32 = 0
var opt_verbose: int32 = 0
var opt_silent: int32 = 0
var opt_custom_headers: array[4096, uint8]
var opt_custom_headers_len: int32 = 0

# ===========================================================================
# HTTP Functions
# ===========================================================================

proc http_parse_status(response: ptr uint8): int32 =
  var i: int32 = 0
  while response[i] != 0 and response[i] != 32:
    i = i + 1
  if response[i] == 0:
    return -1
  i = i + 1
  var status: int32 = 0
  var digits: int32 = 0
  while digits < 3 and response[i] >= 48 and response[i] <= 57:
    status = status * 10 + (cast[int32](response[i]) - 48)
    i = i + 1
    digits = digits + 1
  if digits != 3:
    return -1
  return status

proc http_get_header(response: ptr uint8, header_name: ptr uint8, value_buf: ptr uint8, max_len: int32): int32 =
  var i: int32 = 0
  var name_len: int32 = strlen(header_name)
  while response[i] != 0 and response[i] != 10:
    i = i + 1
  if response[i] == 10:
    i = i + 1
  while response[i] != 0:
    if response[i] == 13 and response[i + 1] == 10:
      break
    if response[i] == 10:
      break
    var matched: int32 = 1
    var j: int32 = 0
    while j < name_len:
      var c1: int32 = cast[int32](response[i + j])
      var c2: int32 = cast[int32](header_name[j])
      if c1 >= 65 and c1 <= 90:
        c1 = c1 + 32
      if c2 >= 65 and c2 <= 90:
        c2 = c2 + 32
      if c1 != c2:
        matched = 0
        break
      j = j + 1
    if matched == 1 and response[i + name_len] == 58:
      i = i + name_len + 1
      while response[i] == 32 or response[i] == 9:
        i = i + 1
      var val_len: int32 = 0
      while response[i] != 0 and response[i] != 13 and response[i] != 10 and val_len < max_len - 1:
        value_buf[val_len] = response[i]
        val_len = val_len + 1
        i = i + 1
      value_buf[val_len] = 0
      return val_len
    while response[i] != 0 and response[i] != 10:
      i = i + 1
    if response[i] == 10:
      i = i + 1
  return -1

proc http_get_content_length(response: ptr uint8): int32 =
  var value: array[32, uint8]
  var len: int32 = http_get_header(response, cast[ptr uint8]("Content-Length"), addr(value[0]), 32)
  if len < 0:
    return -1
  var result: int32 = 0
  var i: int32 = 0
  while value[i] >= 48 and value[i] <= 57:
    result = result * 10 + (cast[int32](value[i]) - 48)
    i = i + 1
  return result

proc http_get_location(response: ptr uint8, location_buf: ptr uint8, max_len: int32): int32 =
  return http_get_header(response, cast[ptr uint8]("Location"), location_buf, max_len)

proc http_parse_url(url: ptr uint8, host_buf: ptr uint8, host_max: int32, path_buf: ptr uint8, path_max: int32, port: ptr int32): int32 =
  var i: int32 = 0
  if url[0] == 104 and url[1] == 116 and url[2] == 116 and url[3] == 112:
    i = 4
    if url[4] == 115:
      i = 5
      if port != cast[ptr int32](0):
        port[0] = 443
    else:
      if port != cast[ptr int32](0):
        port[0] = 80
    if url[i] == 58 and url[i + 1] == 47 and url[i + 2] == 47:
      i = i + 3
  var host_len: int32 = 0
  while url[i] != 0 and url[i] != 47 and url[i] != 58 and host_len < host_max - 1:
    host_buf[host_len] = url[i]
    host_len = host_len + 1
    i = i + 1
  host_buf[host_len] = 0
  if host_len == 0:
    return -1
  if url[i] == 58:
    i = i + 1
    var parsed_port: int32 = 0
    while url[i] >= 48 and url[i] <= 57:
      parsed_port = parsed_port * 10 + (cast[int32](url[i]) - 48)
      i = i + 1
    if parsed_port > 0 and port != cast[ptr int32](0):
      port[0] = parsed_port
  var path_len: int32 = 0
  if url[i] == 47:
    while url[i] != 0 and path_len < path_max - 1:
      path_buf[path_len] = url[i]
      path_len = path_len + 1
      i = i + 1
  else:
    path_buf[0] = 47
    path_len = 1
  path_buf[path_len] = 0
  return 0

# ===========================================================================
# Helper Functions
# ===========================================================================

proc is_ip_address(host: ptr uint8): int32 =
  var i: int32 = 0
  var dots: int32 = 0
  var has_alpha: int32 = 0
  while host[i] != 0:
    if host[i] == 46:
      dots = dots + 1
    elif host[i] >= 97 and host[i] <= 122:
      has_alpha = 1
    elif host[i] >= 65 and host[i] <= 90:
      has_alpha = 1
    i = i + 1
  if dots == 3 and has_alpha == 0:
    return 1
  return 0

proc verbose_print(msg: ptr uint8) =
  if opt_verbose != 0:
    print(cast[ptr uint8]("* "))
    println(msg)

proc verbose_print2(msg1: ptr uint8, msg2: ptr uint8) =
  if opt_verbose != 0:
    print(cast[ptr uint8]("* "))
    print(msg1)
    println(msg2)

proc show_usage() =
  println(cast[ptr uint8]("curl - HTTP client for BrainhairOS"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Usage: curl [options] <url>"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Options:"))
  println(cast[ptr uint8]("  -o <file>    Write output to file"))
  println(cast[ptr uint8]("  -i           Include response headers"))
  println(cast[ptr uint8]("  -L           Follow redirects (max 5)"))
  println(cast[ptr uint8]("  -X <method>  Request method (GET/POST/HEAD)"))
  println(cast[ptr uint8]("  -d <data>    POST data"))
  println(cast[ptr uint8]("  -H <header>  Add custom header"))
  println(cast[ptr uint8]("  -v           Verbose mode"))
  println(cast[ptr uint8]("  -s           Silent mode"))
  println(cast[ptr uint8](""))
  println(cast[ptr uint8]("Examples:"))
  println(cast[ptr uint8]("  curl http://example.com/"))
  println(cast[ptr uint8]("  curl -i http://api.example.com/data"))
  println(cast[ptr uint8]("  curl -o file.html http://example.com/"))
  println(cast[ptr uint8]("  curl -X POST -d 'data' http://api.example.com/"))
  println(cast[ptr uint8]("  curl -L http://short.url/abc"))

# Parse command line arguments
proc parse_args(argc: int32, argv: ptr ptr uint8, url_out: ptr uint8): int32 =
  var i: int32 = 1
  var url_found: int32 = 0

  # Default method
  opt_method[0] = 71  # G
  opt_method[1] = 69  # E
  opt_method[2] = 84  # T
  opt_method[3] = 0

  while i < argc:
    var arg: ptr uint8 = argv[i]

    if arg[0] == 45:  # '-'
      if arg[1] == 111 and arg[2] == 0:  # -o
        i = i + 1
        if i >= argc:
          println(cast[ptr uint8]("Error: -o requires argument"))
          return -1
        var fn: ptr uint8 = argv[i]
        var j: int32 = 0
        while fn[j] != 0 and j < 255:
          opt_output_file[j] = fn[j]
          j = j + 1
        opt_output_file[j] = 0

      elif arg[1] == 105 and arg[2] == 0:  # -i
        opt_show_headers = 1

      elif arg[1] == 76 and arg[2] == 0:  # -L
        opt_follow_redirects = 1

      elif arg[1] == 88 and arg[2] == 0:  # -X
        i = i + 1
        if i >= argc:
          println(cast[ptr uint8]("Error: -X requires argument"))
          return -1
        var method: ptr uint8 = argv[i]
        var j: int32 = 0
        while method[j] != 0 and j < 15:
          opt_method[j] = method[j]
          j = j + 1
        opt_method[j] = 0

      elif arg[1] == 100 and arg[2] == 0:  # -d
        i = i + 1
        if i >= argc:
          println(cast[ptr uint8]("Error: -d requires argument"))
          return -1
        var data: ptr uint8 = argv[i]
        var j: int32 = 0
        while data[j] != 0 and j < 4095:
          opt_post_data[j] = data[j]
          j = j + 1
        opt_post_data[j] = 0
        opt_post_data_len = j
        # Auto-set method to POST
        opt_method[0] = 80  # P
        opt_method[1] = 79  # O
        opt_method[2] = 83  # S
        opt_method[3] = 84  # T
        opt_method[4] = 0

      elif arg[1] == 72 and arg[2] == 0:  # -H
        i = i + 1
        if i >= argc:
          println(cast[ptr uint8]("Error: -H requires argument"))
          return -1
        var hdr: ptr uint8 = argv[i]
        var j: int32 = 0
        while hdr[j] != 0 and opt_custom_headers_len < 4090:
          opt_custom_headers[opt_custom_headers_len] = hdr[j]
          opt_custom_headers_len = opt_custom_headers_len + 1
          j = j + 1
        opt_custom_headers[opt_custom_headers_len] = 13
        opt_custom_headers_len = opt_custom_headers_len + 1
        opt_custom_headers[opt_custom_headers_len] = 10
        opt_custom_headers_len = opt_custom_headers_len + 1

      elif arg[1] == 118 and arg[2] == 0:  # -v
        opt_verbose = 1

      elif arg[1] == 115 and arg[2] == 0:  # -s
        opt_silent = 1

      elif arg[1] == 104 and arg[2] == 0:  # -h
        show_usage()
        return -2

      else:
        print(cast[ptr uint8]("Unknown option: "))
        println(arg)
        return -1

    else:
      # URL argument
      var j: int32 = 0
      while arg[j] != 0 and j < MAX_URL_LEN - 1:
        url_out[j] = arg[j]
        j = j + 1
      url_out[j] = 0
      url_found = 1

    i = i + 1

  if url_found == 0:
    return -1

  return 0

# Perform HTTP request to a URL
proc do_request(url: ptr uint8, output_fd: int32, redirect_count: int32): int32 =
  var host: array[256, uint8]
  var path: array[512, uint8]
  var port: int32 = 80

  if http_parse_url(url, addr(host[0]), 256, addr(path[0]), 512, addr(port)) < 0:
    println(cast[ptr uint8]("curl: (3) URL malformed"))
    return 3

  verbose_print2(cast[ptr uint8]("Host: "), addr(host[0]))
  verbose_print2(cast[ptr uint8]("Path: "), addr(path[0]))

  # Resolve hostname
  var ip: array[4, uint8]

  if is_ip_address(addr(host[0])) == 1:
    if parse_ipv4(addr(host[0]), addr(ip[0])) == 0:
      println(cast[ptr uint8]("curl: (6) Could not parse IP address"))
      return 6
    verbose_print(cast[ptr uint8]("Using direct IP address"))
  else:
    verbose_print2(cast[ptr uint8]("Resolving hostname: "), addr(host[0]))
    if dns_resolve(addr(host[0]), addr(ip[0])) == 0:
      print(cast[ptr uint8]("curl: (6) Could not resolve host: "))
      println(addr(host[0]))
      return 6

    if opt_verbose != 0:
      var ip_str: array[16, uint8]
      discard format_ipv4(addr(ip[0]), addr(ip_str[0]))
      verbose_print2(cast[ptr uint8]("Resolved to: "), addr(ip_str[0]))

  # Connect
  if opt_verbose != 0:
    print(cast[ptr uint8]("* Connecting to "))
    var ip_str: array[16, uint8]
    discard format_ipv4(addr(ip[0]), addr(ip_str[0]))
    print(addr(ip_str[0]))
    print(cast[ptr uint8](" port "))
    print_int(port)
    println(cast[ptr uint8]("..."))

  var sock: int32 = net_connect(addr(ip[0]), port)
  if sock < 0:
    println(cast[ptr uint8]("curl: (7) Failed to connect"))
    return 7

  if net_wait_connected(sock, 10000) == 0:
    println(cast[ptr uint8]("curl: (28) Connection timeout"))
    net_close(sock)
    return 28

  verbose_print(cast[ptr uint8]("Connected"))

  # Send request
  verbose_print2(cast[ptr uint8]("> "), addr(opt_method[0]))

  discard net_send_str(sock, addr(opt_method[0]))
  discard net_send_str(sock, cast[ptr uint8](" "))
  discard net_send_str(sock, addr(path[0]))
  discard net_send_str(sock, cast[ptr uint8](" HTTP/1.1\r\n"))

  discard net_send_str(sock, cast[ptr uint8]("Host: "))
  discard net_send_str(sock, addr(host[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  discard net_send_str(sock, cast[ptr uint8]("User-Agent: curl/BrainhairOS\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("Accept: */*\r\n"))

  # Custom headers
  if opt_custom_headers_len > 0:
    discard net_send(sock, addr(opt_custom_headers[0]), opt_custom_headers_len)

  # POST data
  if opt_post_data_len > 0:
    discard net_send_str(sock, cast[ptr uint8]("Content-Type: application/x-www-form-urlencoded\r\n"))
    discard net_send_str(sock, cast[ptr uint8]("Content-Length: "))
    var len_str: array[16, uint8]
    var val: int32 = opt_post_data_len
    var idx: int32 = 0
    if val == 0:
      len_str[0] = 48
      idx = 1
    else:
      var temp: array[16, uint8]
      var ti: int32 = 0
      while val > 0:
        temp[ti] = cast[uint8](48 + (val % 10))
        val = val / 10
        ti = ti + 1
      while ti > 0:
        ti = ti - 1
        len_str[idx] = temp[ti]
        idx = idx + 1
    len_str[idx] = 0
    discard net_send_str(sock, addr(len_str[0]))
    discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  discard net_send_str(sock, cast[ptr uint8]("Connection: close\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Send POST body
  if opt_post_data_len > 0:
    discard net_send(sock, addr(opt_post_data[0]), opt_post_data_len)

  # Receive response
  var buf: array[8192, uint8]
  var total_read: int32 = 0
  var headers_end: int32 = -1

  while headers_end < 0 and total_read < 8000:
    var n: int32 = net_recv_blocking(sock, addr(buf[total_read]), 8000 - total_read, 10000)
    if n <= 0:
      break
    total_read = total_read + n

    var i: int32 = 0
    while i < total_read - 3:
      if buf[i] == 13 and buf[i + 1] == 10 and buf[i + 2] == 13 and buf[i + 3] == 10:
        headers_end = i + 4
        break
      i = i + 1

  if headers_end < 0:
    println(cast[ptr uint8]("curl: (52) Empty reply from server"))
    net_close(sock)
    return 52

  buf[headers_end] = 0

  # Parse status
  var status: int32 = http_parse_status(addr(buf[0]))

  if opt_verbose != 0:
    print(cast[ptr uint8]("< HTTP/1.1 "))
    print_int(status)
    println(cast[ptr uint8](""))

  # Handle redirects
  if (status == 301 or status == 302 or status == 303 or status == 307 or status == 308) and opt_follow_redirects != 0:
    if redirect_count >= MAX_REDIRECTS:
      println(cast[ptr uint8]("curl: (47) Maximum redirects reached"))
      net_close(sock)
      return 47

    var location: array[1024, uint8]
    if http_get_location(addr(buf[0]), addr(location[0]), 1024) > 0:
      verbose_print2(cast[ptr uint8]("Following redirect to: "), addr(location[0]))
      net_close(sock)
      return do_request(addr(location[0]), output_fd, redirect_count + 1)
    else:
      println(cast[ptr uint8]("curl: (47) Redirect with no Location header"))
      net_close(sock)
      return 47

  # Output headers if requested
  if opt_show_headers != 0:
    var i: int32 = 0
    while i < headers_end - 1:
      buf[i] = buf[i]  # Keep as-is
      i = i + 1
    discard write(output_fd, addr(buf[0]), headers_end)

  # Output body
  var body_start: int32 = headers_end
  var initial_body: int32 = total_read - body_start

  if initial_body > 0:
    discard write(output_fd, addr(buf[body_start]), initial_body)

  var bytes_written: int32 = initial_body

  while 1:
    var n: int32 = net_recv_blocking(sock, addr(buf[0]), 8192, 5000)
    if n <= 0:
      break
    discard write(output_fd, addr(buf[0]), n)
    bytes_written = bytes_written + n

    if opt_silent == 0 and opt_verbose != 0:
      print(cast[ptr uint8]("\r* Received: "))
      print_int(bytes_written)
      print(cast[ptr uint8](" bytes"))

  if opt_verbose != 0:
    println(cast[ptr uint8](""))
    print(cast[ptr uint8]("* Total: "))
    print_int(bytes_written)
    println(cast[ptr uint8](" bytes"))

  net_close(sock)

  # Return error code based on status
  if status >= 400:
    return 22  # HTTP error

  return 0

proc main(argc: int32, argv: ptr ptr uint8): int32 =
  var url: array[1024, uint8]

  if argc < 2:
    show_usage()
    return 1

  var result: int32 = parse_args(argc, argv, addr(url[0]))
  if result == -2:
    return 0  # Help shown
  if result < 0:
    show_usage()
    return 1

  # Initialize DNS
  dns_init()

  # Determine output
  var output_fd: int32 = STDOUT

  if opt_output_file[0] != 0:
    output_fd = open(addr(opt_output_file[0]), O_WRONLY or O_CREAT or O_TRUNC)
    if output_fd < 0:
      print(cast[ptr uint8]("curl: (23) Failed to create file: "))
      println(addr(opt_output_file[0]))
      return 23

  # Make the request
  result = do_request(addr(url[0]), output_fd, 0)

  # Clean up
  if output_fd != STDOUT:
    close(output_fd)
    if result == 0 and opt_silent == 0:
      print(cast[ptr uint8]("Saved to: "))
      println(addr(opt_output_file[0]))

  return result
