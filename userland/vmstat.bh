# vmstat - Virtual memory statistics
# Displays system statistics including processes, memory, swap, io, system, cpu
# Output: r b swpd free buff cache si so bi bo in cs us sy id wa

from lib.syscalls import *

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Compare strings up to n characters
def strncmp(s1: *uint8, s2: *uint8, n: int32) -> int32:
  i: int32 = 0
  while i < n:
    if s1[i] != s2[i]:
      if s1[i] < s2[i]:
        return -1
      return 1
    if s1[i] == cast[uint8](0):
      return 0
    i = i + 1
  return 0

# Parse integer from string (skip non-digits)
def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  # Skip non-digits
  while s[i] != cast[uint8](0):
    if s[i] >= cast[uint8](48):
      if s[i] <= cast[uint8](57):
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
        # Continue parsing
        while s[i] >= cast[uint8](48):
          if s[i] <= cast[uint8](57):
            result = result * 10 + cast[int32](s[i]) - 48
          i = i + 1
        return result
    i = i + 1
  return result

# Print integer with padding
def print_int_padded(n: int32, width: int32):
  if n == 0:
    spaces: int32 = width - 1
    while spaces > 0:
      syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
      spaces = spaces - 1
    syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
    return

  neg: int32 = 0
  num: int32 = n
  if num < 0:
    neg = 1
    num = 0 - num

  # Count digits
  temp: int32 = num
  digits: int32 = 0
  while temp > 0:
    digits = digits + 1
    temp = temp / 10

  if neg == 1:
    digits = digits + 1

  # Print padding spaces
  spaces: int32 = width - digits
  while spaces > 0:
    syscall3(SYS_write, STDOUT, cast[int32](" "), 1)
    spaces = spaces - 1

  # Allocate buffer for number
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 32
  syscall1(SYS_brk, new_brk)
  buf: *uint8 = cast[*uint8](old_brk)

  pos: int32 = 0
  if neg == 1:
    buf[0] = cast[uint8](45)
    pos = 1

  # Convert to string in reverse
  temp = num
  end_pos: int32 = pos + (digits - pos) - 1
  while temp > 0:
    digit: int32 = temp % 10
    buf[end_pos] = cast[uint8](48 + digit)
    end_pos = end_pos - 1
    temp = temp / 10

  # Print the number
  i: int32 = 0
  while i < digits:
    syscall3(SYS_write, STDOUT, cast[int32](cast[int32](buf) + i), 1)
    i = i + 1

# Build string path
def build_path(buf: *uint8, s: *uint8):
  i: int32 = 0
  while s[i] != cast[uint8](0):
    buf[i] = s[i]
    i = i + 1
  buf[i] = cast[uint8](0)

def main():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 16384
  syscall1(SYS_brk, new_brk)

  # Memory layout:
  # +0: meminfo buffer (4KB)
  # +4096: stat buffer (4KB)
  # +8192: path buffer (256 bytes)
  meminfo_buf: *uint8 = cast[*uint8](old_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk + 4096)
  path_buf: *uint8 = cast[*uint8](old_brk + 8192)

  # Read /proc/meminfo
  build_path(path_buf, cast[*uint8]("/proc/meminfo"))
  meminfo_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
  if meminfo_fd < 0:
    print_err(cast[*uint8]("vmstat: cannot open /proc/meminfo\n"))
    syscall1(SYS_exit, 1)

  meminfo_len: int32 = syscall3(SYS_read, meminfo_fd, cast[int32](meminfo_buf), 4095)
  syscall1(SYS_close, meminfo_fd)

  if meminfo_len <= 0:
    print_err(cast[*uint8]("vmstat: cannot read /proc/meminfo\n"))
    syscall1(SYS_exit, 1)

  meminfo_buf[meminfo_len] = cast[uint8](0)

  # Parse memory statistics from /proc/meminfo
  mem_total: int32 = 0
  mem_free: int32 = 0
  mem_available: int32 = 0
  buffers: int32 = 0
  cached: int32 = 0
  swap_total: int32 = 0
  swap_free: int32 = 0
  swap_cached: int32 = 0

  i: int32 = 0
  while i < meminfo_len:
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("MemTotal:"), 9) == 0:
      mem_total = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 9))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("MemFree:"), 8) == 0:
      mem_free = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 8))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("MemAvailable:"), 13) == 0:
      mem_available = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 13))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("Buffers:"), 8) == 0:
      buffers = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 8))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("Cached:"), 7) == 0:
      cached = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 7))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("SwapTotal:"), 10) == 0:
      swap_total = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 10))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("SwapFree:"), 9) == 0:
      swap_free = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 9))
    if strncmp(cast[*uint8](cast[int32](meminfo_buf) + i), cast[*uint8]("SwapCached:"), 11) == 0:
      swap_cached = parse_int(cast[*uint8](cast[int32](meminfo_buf) + i + 11))

    # Skip to next line
    while i < meminfo_len:
      if meminfo_buf[i] == cast[uint8](10):
        i = i + 1
        break
      i = i + 1

  # Read /proc/stat for CPU and system stats
  build_path(path_buf, cast[*uint8]("/proc/stat"))
  stat_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
  if stat_fd < 0:
    print_err(cast[*uint8]("vmstat: cannot open /proc/stat\n"))
    syscall1(SYS_exit, 1)

  stat_len: int32 = syscall3(SYS_read, stat_fd, cast[int32](stat_buf), 4095)
  syscall1(SYS_close, stat_fd)

  if stat_len <= 0:
    print_err(cast[*uint8]("vmstat: cannot read /proc/stat\n"))
    syscall1(SYS_exit, 1)

  stat_buf[stat_len] = cast[uint8](0)

  # Parse /proc/stat for CPU times and process counts
  # Format: cpu user nice system idle iowait irq softirq ...
  cpu_user: int32 = 0
  cpu_system: int32 = 0
  cpu_idle: int32 = 0
  cpu_iowait: int32 = 0
  procs_running: int32 = 0
  procs_blocked: int32 = 0
  ctxt: int32 = 0
  intr: int32 = 0

  i = 0
  while i < stat_len:
    # Parse "cpu" line (aggregate)
    if strncmp(cast[*uint8](cast[int32](stat_buf) + i), cast[*uint8]("cpu "), 4) == 0:
      # Skip "cpu "
      j: int32 = i + 4
      # Parse fields: user nice system idle iowait irq softirq
      # user
      cpu_user = parse_int(cast[*uint8](cast[int32](stat_buf) + j))
      while stat_buf[j] != cast[uint8](32):
        j = j + 1
      j = j + 1  # skip space
      # skip nice
      while stat_buf[j] != cast[uint8](32):
        j = j + 1
      j = j + 1
      # system
      cpu_system = parse_int(cast[*uint8](cast[int32](stat_buf) + j))
      while stat_buf[j] != cast[uint8](32):
        j = j + 1
      j = j + 1
      # idle
      cpu_idle = parse_int(cast[*uint8](cast[int32](stat_buf) + j))
      while stat_buf[j] != cast[uint8](32):
        j = j + 1
      j = j + 1
      # iowait
      cpu_iowait = parse_int(cast[*uint8](cast[int32](stat_buf) + j))

    # Parse "procs_running"
    if strncmp(cast[*uint8](cast[int32](stat_buf) + i), cast[*uint8]("procs_running "), 14) == 0:
      procs_running = parse_int(cast[*uint8](cast[int32](stat_buf) + i + 14))

    # Parse "procs_blocked"
    if strncmp(cast[*uint8](cast[int32](stat_buf) + i), cast[*uint8]("procs_blocked "), 14) == 0:
      procs_blocked = parse_int(cast[*uint8](cast[int32](stat_buf) + i + 14))

    # Parse "ctxt" (context switches)
    if strncmp(cast[*uint8](cast[int32](stat_buf) + i), cast[*uint8]("ctxt "), 5) == 0:
      ctxt = parse_int(cast[*uint8](cast[int32](stat_buf) + i + 5))

    # Parse "intr" (interrupts)
    if strncmp(cast[*uint8](cast[int32](stat_buf) + i), cast[*uint8]("intr "), 5) == 0:
      intr = parse_int(cast[*uint8](cast[int32](stat_buf) + i + 5))

    # Skip to next line
    while i < stat_len:
      if stat_buf[i] == cast[uint8](10):
        i = i + 1
        break
      i = i + 1

  # Calculate derived values
  swap_used: int32 = swap_total - swap_free
  cpu_total: int32 = cpu_user + cpu_system + cpu_idle + cpu_iowait
  cpu_us_pct: int32 = 0
  cpu_sy_pct: int32 = 0
  cpu_id_pct: int32 = 0
  cpu_wa_pct: int32 = 0

  if cpu_total > 0:
    cpu_us_pct = (cpu_user * 100) / cpu_total
    cpu_sy_pct = (cpu_system * 100) / cpu_total
    cpu_id_pct = (cpu_idle * 100) / cpu_total
    cpu_wa_pct = (cpu_iowait * 100) / cpu_total

  # Simplified I/O stats (would need /proc/diskstats for real values)
  si: int32 = 0  # swap in
  so: int32 = 0  # swap out
  bi: int32 = 0  # blocks in
  bo: int32 = 0  # blocks out

  # Print header
  print(cast[*uint8]("procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n"))
  print(cast[*uint8](" r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n"))

  # Print values
  print_int_padded(procs_running, 2)
  print(cast[*uint8](" "))
  print_int_padded(procs_blocked, 2)
  print(cast[*uint8](" "))
  print_int_padded(swap_used, 6)
  print(cast[*uint8](" "))
  print_int_padded(mem_free, 6)
  print(cast[*uint8](" "))
  print_int_padded(buffers, 6)
  print(cast[*uint8](" "))
  print_int_padded(cached, 6)
  print(cast[*uint8](" "))
  print_int_padded(si, 4)
  print(cast[*uint8](" "))
  print_int_padded(so, 4)
  print(cast[*uint8](" "))
  print_int_padded(bi, 5)
  print(cast[*uint8](" "))
  print_int_padded(bo, 5)
  print(cast[*uint8](" "))
  print_int_padded(intr % 10000, 4)  # Simplified interrupt count
  print(cast[*uint8](" "))
  print_int_padded(ctxt % 10000, 4)  # Simplified context switch count
  print(cast[*uint8](" "))
  print_int_padded(cpu_us_pct, 2)
  print(cast[*uint8](" "))
  print_int_padded(cpu_sy_pct, 2)
  print(cast[*uint8](" "))
  print_int_padded(cpu_id_pct, 2)
  print(cast[*uint8](" "))
  print_int_padded(cpu_wa_pct, 2)
  print(cast[*uint8]("  0\n"))

  syscall1(SYS_exit, 0)
