# mouse - Read mouse input and display cursor
# Reads from /dev/input/mice (PS/2 mouse protocol)
# Click to exit

from lib.syscalls import *

const FBIOGET_VSCREENINFO: int32 = 0x4600
const CURSOR_SIZE: int32 = 12

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

# Draw a pixel
def draw_pixel(fd: int32, x: int32, y: int32, color: int32, xres: int32, yres: int32, pixel_buf: *uint32):
    if x >= 0 and x < xres and y >= 0 and y < yres:
        pixel_buf[0] = cast[uint32](color)
        offset: int32 = (y * xres + x) * 4
        _ = syscall3(SYS_lseek, fd, offset, SEEK_SET)
        _ = syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

# Draw cursor (arrow shape)
def draw_cursor(fd: int32, x: int32, y: int32, xres: int32, yres: int32, pixel_buf: *uint32):
    # Simple arrow cursor
    i: int32 = 0
    while i < CURSOR_SIZE:
        # Left edge of arrow
        draw_pixel(fd, x, y + i, 0xFFFFFF, xres, yres, pixel_buf)
        # Diagonal
        if i < 8:
            draw_pixel(fd, x + i, y + i, 0xFFFFFF, xres, yres, pixel_buf)
        # Fill (black interior)
        j: int32 = 1
        while j < i and j < 7:
            draw_pixel(fd, x + j, y + i, 0x000000, xres, yres, pixel_buf)
            j = j + 1
        i = i + 1
    # Bottom of arrow head
    draw_pixel(fd, x + 1, y + 8, 0xFFFFFF, xres, yres, pixel_buf)
    draw_pixel(fd, x + 2, y + 9, 0xFFFFFF, xres, yres, pixel_buf)
    draw_pixel(fd, x + 3, y + 10, 0xFFFFFF, xres, yres, pixel_buf)
    draw_pixel(fd, x + 4, y + 11, 0xFFFFFF, xres, yres, pixel_buf)

# Erase cursor by drawing background color
def erase_cursor(fd: int32, x: int32, y: int32, bg: int32, xres: int32, yres: int32, pixel_buf: *uint32):
    i: int32 = 0
    while i < CURSOR_SIZE + 2:
        j: int32 = 0
        while j < CURSOR_SIZE:
            draw_pixel(fd, x + j, y + i, bg, xres, yres, pixel_buf)
            j = j + 1
        i = i + 1

def main():
    print_str(cast[*uint8]("Mouse demo - move mouse, click to exit\n"))

    # Open mouse device
    mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDONLY)
    if mouse_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open /dev/input/mice\n"))
        print_str(cast[*uint8]("Try: sudo chmod 644 /dev/input/mice\n"))
        _ = syscall1(SYS_exit, 1)

    # Open framebuffer
    fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fb_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open /dev/fb0\n"))
        _ = syscall1(SYS_close, mouse_fd)
        _ = syscall1(SYS_exit, 1)

    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    _ = syscall1(SYS_brk, new_brk)
    vinfo: *uint32 = cast[*uint32](old_brk)
    pixel_buf: *uint32 = cast[*uint32](old_brk + 256)
    mouse_buf: *uint8 = cast[*uint8](old_brk + 512)

    # Get screen info
    result: int32 = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    if result < 0:
        print_str(cast[*uint8]("Error: Cannot get screen info\n"))
        _ = syscall1(SYS_close, fb_fd)
        _ = syscall1(SYS_close, mouse_fd)
        _ = syscall1(SYS_exit, 1)

    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    # Background color (dark blue)
    bg_color: int32 = 0x002040

    # Initial cursor position (center of screen)
    cursor_x: int32 = xres / 2
    cursor_y: int32 = yres / 2

    # Clear screen
    cy: int32 = 0
    while cy < yres:
        cx: int32 = 0
        while cx < xres:
            draw_pixel(fb_fd, cx, cy, bg_color, xres, yres, pixel_buf)
            cx = cx + 4  # Skip pixels for speed
        cy = cy + 1

    # Draw initial cursor
    draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

    # Main loop - read mouse events
    running: int32 = 1
    while running != 0:
        bytes_read: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 3)

        if bytes_read == 3:
            # PS/2 mouse packet:
            # Byte 0: Y overflow | X overflow | Y sign | X sign | Always 1 | Middle | Right | Left
            # Byte 1: X movement
            # Byte 2: Y movement

            buttons: int32 = cast[int32](mouse_buf[0])
            dx: int32 = cast[int32](mouse_buf[1])
            dy: int32 = cast[int32](mouse_buf[2])

            # Handle sign extension for negative movement
            if (buttons & 0x10) != 0:  # X sign bit
                dx = dx - 256
            if (buttons & 0x20) != 0:  # Y sign bit
                dy = dy - 256

            # Check for left click to exit
            if (buttons & 0x01) != 0:
                running = 0

            # Erase old cursor
            erase_cursor(fb_fd, cursor_x, cursor_y, bg_color, xres, yres, pixel_buf)

            # Update cursor position
            cursor_x = cursor_x + dx
            cursor_y = cursor_y - dy  # Y is inverted in framebuffer

            # Clamp to screen bounds
            if cursor_x < 0:
                cursor_x = 0
            if cursor_x >= xres - CURSOR_SIZE:
                cursor_x = xres - CURSOR_SIZE - 1
            if cursor_y < 0:
                cursor_y = 0
            if cursor_y >= yres - CURSOR_SIZE:
                cursor_y = yres - CURSOR_SIZE - 1

            # Draw new cursor
            draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

    # Cleanup
    _ = syscall1(SYS_close, fb_fd)
    _ = syscall1(SYS_close, mouse_fd)

    print_str(cast[*uint8]("Mouse demo exited\n"))
    _ = syscall1(SYS_exit, 0)

main()
