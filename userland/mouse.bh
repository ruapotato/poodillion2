# mouse - Read mouse input and display cursor
# Reads from /dev/input/mice (PS/2 mouse protocol)
# Click to exit

import "lib/syscalls"

const FBIOGET_VSCREENINFO: int32 = 0x4600
const CURSOR_SIZE: int32 = 12

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

# Draw a pixel
proc draw_pixel(fd: int32, x: int32, y: int32, color: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    pixel_buf[0] = cast[uint32](color)
    var offset: int32 = (y * xres + x) * 4
    discard syscall3(SYS_lseek, fd, offset, SEEK_SET)
    discard syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

# Draw cursor (arrow shape)
proc draw_cursor(fd: int32, x: int32, y: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  # Simple arrow cursor
  var i: int32 = 0
  while i < CURSOR_SIZE:
    # Left edge of arrow
    draw_pixel(fd, x, y + i, 0xFFFFFF, xres, yres, pixel_buf)
    # Diagonal
    if i < 8:
      draw_pixel(fd, x + i, y + i, 0xFFFFFF, xres, yres, pixel_buf)
    # Fill (black interior)
    var j: int32 = 1
    while j < i and j < 7:
      draw_pixel(fd, x + j, y + i, 0x000000, xres, yres, pixel_buf)
      j = j + 1
    i = i + 1
  # Bottom of arrow head
  draw_pixel(fd, x + 1, y + 8, 0xFFFFFF, xres, yres, pixel_buf)
  draw_pixel(fd, x + 2, y + 9, 0xFFFFFF, xres, yres, pixel_buf)
  draw_pixel(fd, x + 3, y + 10, 0xFFFFFF, xres, yres, pixel_buf)
  draw_pixel(fd, x + 4, y + 11, 0xFFFFFF, xres, yres, pixel_buf)

# Erase cursor by drawing background color
proc erase_cursor(fd: int32, x: int32, y: int32, bg: int32, xres: int32, yres: int32, pixel_buf: ptr uint32) =
  var i: int32 = 0
  while i < CURSOR_SIZE + 2:
    var j: int32 = 0
    while j < CURSOR_SIZE:
      draw_pixel(fd, x + j, y + i, bg, xres, yres, pixel_buf)
      j = j + 1
    i = i + 1

proc main() =
  print_str(cast[ptr uint8]("Mouse demo - move mouse, click to exit\n"))

  # Open mouse device
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDONLY)
  if mouse_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/input/mice\n"))
    print_str(cast[ptr uint8]("Try: sudo chmod 644 /dev/input/mice\n"))
    discard syscall1(SYS_exit, 1)

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_close, mouse_fd)
    discard syscall1(SYS_exit, 1)

  # Allocate memory
  var old_brk: int32 = syscall1(SYS_brk, 0)
  var new_brk: int32 = old_brk + 4096
  discard syscall1(SYS_brk, new_brk)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var pixel_buf: ptr uint32 = cast[ptr uint32](old_brk + 256)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 512)

  # Get screen info
  var result: int32 = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  if result < 0:
    print_str(cast[ptr uint8]("Error: Cannot get screen info\n"))
    discard syscall1(SYS_close, fb_fd)
    discard syscall1(SYS_close, mouse_fd)
    discard syscall1(SYS_exit, 1)

  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  # Background color (dark blue)
  var bg_color: int32 = 0x002040

  # Initial cursor position (center of screen)
  var cursor_x: int32 = xres / 2
  var cursor_y: int32 = yres / 2

  # Clear screen
  var cy: int32 = 0
  while cy < yres:
    var cx: int32 = 0
    while cx < xres:
      draw_pixel(fb_fd, cx, cy, bg_color, xres, yres, pixel_buf)
      cx = cx + 4  # Skip pixels for speed
    cy = cy + 1

  # Draw initial cursor
  draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

  # Main loop - read mouse events
  var running: int32 = 1
  while running != 0:
    var bytes_read: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 3)

    if bytes_read == 3:
      # PS/2 mouse packet:
      # Byte 0: Y overflow | X overflow | Y sign | X sign | Always 1 | Middle | Right | Left
      # Byte 1: X movement
      # Byte 2: Y movement

      var buttons: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      # Handle sign extension for negative movement
      if (buttons & 0x10) != 0:  # X sign bit
        dx = dx - 256
      if (buttons & 0x20) != 0:  # Y sign bit
        dy = dy - 256

      # Check for left click to exit
      if (buttons & 0x01) != 0:
        running = 0

      # Erase old cursor
      erase_cursor(fb_fd, cursor_x, cursor_y, bg_color, xres, yres, pixel_buf)

      # Update cursor position
      cursor_x = cursor_x + dx
      cursor_y = cursor_y - dy  # Y is inverted in framebuffer

      # Clamp to screen bounds
      if cursor_x < 0:
        cursor_x = 0
      if cursor_x >= xres - CURSOR_SIZE:
        cursor_x = xres - CURSOR_SIZE - 1
      if cursor_y < 0:
        cursor_y = 0
      if cursor_y >= yres - CURSOR_SIZE:
        cursor_y = yres - CURSOR_SIZE - 1

      # Draw new cursor
      draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

  # Cleanup
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_close, mouse_fd)

  print_str(cast[ptr uint8]("Mouse demo exited\n"))
  discard syscall1(SYS_exit, 0)

main()
