# getty - Get TTY and spawn login
# Getty opens a tty, sets it up, displays a login prompt, and execs login
#
# Usage: getty /dev/tty1
#
# Simple implementation:
# - Opens the specified tty device
# - Redirects stdin/stdout/stderr to the tty
# - Displays a banner
# - Execs login (or shell directly if login not available)

from lib.syscalls import *

# Open flags
O_NOCTTY: Final[int32] = 256

# ioctl commands for terminal control
TIOCSCTTY: Final[uint32] = 0x540E  # Make this tty the controlling terminal

extern def get_argc() -> int32
extern def get_argv(index: int32) -> *uint8

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

def main():
    argc: int32 = get_argc()

    if argc < 2:
        print_err(cast[*uint8]("getty: usage: getty /dev/ttyN\n"))
        _ = syscall1(SYS_exit, 1)

    tty_path: *uint8 = get_argv(1)

    # Create a new session
    # This makes the process a session leader
    sid: int32 = syscall1(SYS_setsid, 0)
    if sid < 0:
        print_err(cast[*uint8]("getty: warning: setsid failed\n"))

    # Open the tty device
    fd: int32 = syscall2(SYS_open, cast[int32](tty_path), O_RDWR)

    if fd < 0:
        print_err(cast[*uint8]("getty: failed to open "))
        print_err(tty_path)
        print_err(cast[*uint8]("\n"))
        _ = syscall1(SYS_exit, 1)

    # Make this tty our controlling terminal
    # TIOCSCTTY = 0x540E (make terminal our controlling tty)
    ioctl_result: int32 = syscall3(SYS_ioctl, fd, cast[int32](TIOCSCTTY), 0)
    if ioctl_result < 0:
        print_err(cast[*uint8]("getty: warning: ioctl TIOCSCTTY failed\n"))

    # Redirect stdin, stdout, stderr to the tty
    if fd != STDIN:
        _ = syscall2(SYS_dup2, fd, STDIN)
    if fd != STDOUT:
        _ = syscall2(SYS_dup2, fd, STDOUT)
    if fd != STDERR:
        _ = syscall2(SYS_dup2, fd, STDERR)

    # Close the original fd if it's not 0, 1, or 2
    if fd > 2:
        _ = syscall1(SYS_close, fd)

    # Display banner
    print(cast[*uint8]("BrainhairOS v0.1 Alpha\n"))
    print(cast[*uint8]("The Future of Computing\n"))

    # Allocate memory for argv
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 512
    _ = syscall1(SYS_brk, new_brk)
    argv: *int32 = cast[*int32](old_brk)
    login_path: *uint8 = cast[*uint8](old_brk + 64)

    # Try to exec login
    # argv[0] = "/bin/login"
    # argv[1] = NULL
    strcpy(login_path, cast[*uint8]("/bin/login"))
    argv[0] = cast[int32](login_path)
    argv[1] = 0

    _ = syscall3(SYS_execve, cast[int32](login_path), cast[int32](argv), 0)

    # If that fails, try ./bin/login
    strcpy(login_path, cast[*uint8]("./bin/login"))
    argv[0] = cast[int32](login_path)
    _ = syscall3(SYS_execve, cast[int32](login_path), cast[int32](argv), 0)

    # If login doesn't exist, exec shell directly
    strcpy(login_path, cast[*uint8]("/bin/psh"))
    argv[0] = cast[int32](login_path)
    _ = syscall3(SYS_execve, cast[int32](login_path), cast[int32](argv), 0)

    # Try ./bin/psh
    strcpy(login_path, cast[*uint8]("./bin/psh"))
    argv[0] = cast[int32](login_path)
    _ = syscall3(SYS_execve, cast[int32](login_path), cast[int32](argv), 0)

    # If everything fails, show error and exit
    print_err(cast[*uint8]("getty: failed to exec login or shell\n"))
    _ = syscall1(SYS_exit, 1)
