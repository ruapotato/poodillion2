# script - Record terminal session
# Usage: script [FILE]
# Records all terminal input/output to a file (default: typescript)
# Uses fork, dup2, and exec to capture shell session

from lib.syscalls import *

extern def get_argc() -> int32
extern def get_argv(i: int32) -> *uint8

def print_err(msg: *uint8):
  len: int32 = strlen(msg)
  syscall3(SYS_write, STDERR, cast[int32](msg), len)

def main():
  # Allocate memory
  old_brk: int32 = syscall1(SYS_brk, 0)
  new_brk: int32 = old_brk + 8192
  syscall1(SYS_brk, new_brk)

  filename: *uint8 = cast[*uint8](old_brk)
  buffer: *uint8 = cast[*uint8](old_brk + 256)
  shell_path: *uint8 = cast[*uint8](old_brk + 4096)
  argv: *int32 = cast[*int32](old_brk + 4200)
  envp: *int32 = cast[*int32](old_brk + 4300)

  # Default filename: typescript
  argc: int32 = get_argc()
  if argc < 2:
    filename[0] = cast[uint8](116)  # t
    filename[1] = cast[uint8](121)  # y
    filename[2] = cast[uint8](112)  # p
    filename[3] = cast[uint8](101)  # e
    filename[4] = cast[uint8](115)  # s
    filename[5] = cast[uint8](99)   # c
    filename[6] = cast[uint8](114)  # r
    filename[7] = cast[uint8](105)  # i
    filename[8] = cast[uint8](112)  # p
    filename[9] = cast[uint8](116)  # t
    filename[10] = cast[uint8](0)
  if argc >= 2:
    arg_file: *uint8 = get_argv(1)
    strcpy(filename, arg_file)

  # Open output file
  flags: int32 = O_WRONLY | O_CREAT | O_TRUNC
  mode: int32 = 420  # 0644 in octal = 420 in decimal
  fd: int32 = syscall3(SYS_open, cast[int32](filename), flags, mode)

  if fd < 0:
    print_err(cast[*uint8]("script: cannot open "))
    print_err(filename)
    print_err(cast[*uint8]("\n"))
    syscall1(SYS_exit, 1)

  # Print start message
  print(cast[*uint8]("Script started, file is "))
  print(filename)
  print(cast[*uint8]("\n"))

  # Write header to file
  header: *uint8 = cast[*uint8]("Script started\n")
  header_len: int32 = strlen(header)
  syscall3(SYS_write, fd, cast[int32](header), header_len)

  # Simple implementation: just copy stdin to both stdout and file
  # A full implementation would use pseudo-terminals (pty)

  # Fork to run shell
  pid: int32 = syscall1(SYS_fork, 0)

  if pid < 0:
    print_err(cast[*uint8]("script: fork failed\n"))
    syscall1(SYS_close, fd)
    syscall1(SYS_exit, 1)

  if pid == 0:
    # Child: exec shell
    # Build shell path: /bin/sh
    shell_path[0] = cast[uint8](47)   # /
    shell_path[1] = cast[uint8](98)   # b
    shell_path[2] = cast[uint8](105)  # i
    shell_path[3] = cast[uint8](110)  # n
    shell_path[4] = cast[uint8](47)   # /
    shell_path[5] = cast[uint8](115)  # s
    shell_path[6] = cast[uint8](104)  # h
    shell_path[7] = cast[uint8](0)

    # Setup argv
    argv[0] = cast[int32](shell_path)
    argv[1] = 0

    # Setup envp (empty)
    envp[0] = 0

    # Exec shell
    syscall3(SYS_execve, cast[int32](shell_path), cast[int32](argv), cast[int32](envp))

    # If exec fails
    print_err(cast[*uint8]("script: cannot exec shell\n"))
    syscall1(SYS_exit, 1)

  # Parent: wait for child and copy output
  # For simplicity, we just wait for the child to finish
  # A real script would use pty to capture all I/O

  status_buf: *int32 = cast[*int32](old_brk + 5000)
  status_buf[0] = 0
  wait_ret: int32 = syscall4(SYS_wait4, pid, cast[int32](status_buf), 0, 0)

  # Write footer to file
  footer: *uint8 = cast[*uint8]("Script done\n")
  footer_len: int32 = strlen(footer)
  syscall3(SYS_write, fd, cast[int32](footer), footer_len)

  syscall1(SYS_close, fd)

  print(cast[*uint8]("Script done, file is "))
  print(filename)
  print(cast[*uint8]("\n"))

  syscall1(SYS_exit, 0)
