# login - User login program
# Displays login prompt, reads username, and spawns a shell
#
# Usage: login
#
# Simple implementation (no password checking):
# - Print "login: " prompt
# - Read username
# - Set environment (future: setuid/setgid)
# - Exec shell
#
# For a bootable system, this is simplified - no actual authentication

from lib.syscalls import *

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Read a line from stdin into buffer
# Returns length read (without newline)
def readline(buf: *uint8, max_len: int32) -> int32:
    i: int32 = 0
    while i < max_len - 1:
        ch: uint8 = 0
        n: int32 = syscall3(SYS_read, STDIN, cast[int32](addr(ch)), 1)

        if n <= 0:
            # EOF or error
            break

        # Echo the character
        _ = syscall3(SYS_write, STDOUT, cast[int32](addr(ch)), 1)

        if ch == cast[uint8](10):  # newline
            break

        if ch == cast[uint8](13):  # carriage return
            break

        buf[i] = ch
        i = i + 1

    buf[i] = cast[uint8](0)
    return i

def main():
    # Allocate working memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 4096
    _ = syscall1(SYS_brk, new_brk)

    username: *uint8 = cast[*uint8](old_brk)
    argv: *int32 = cast[*int32](old_brk + 256)
    shell_path: *uint8 = cast[*uint8](old_brk + 512)
    home_dir: *uint8 = cast[*uint8](old_brk + 768)

    # Display login prompt
    print(cast[*uint8]("login: "))

    # Read username
    name_len: int32 = readline(username, 128)

    if name_len <= 0:
        print_err(cast[*uint8]("\nlogin: no username entered\n"))
        _ = syscall1(SYS_exit, 1)

    print(cast[*uint8]("\n"))

    # In a real system, we'd check /etc/passwd here
    # For now, just accept any username and proceed

    # Welcome message
    print(cast[*uint8]("Welcome to BrainhairOS, "))
    print(username)
    print(cast[*uint8]("!\n"))

    # Set home directory
    # For simplicity, use /home/username or just /
    strcpy(home_dir, cast[*uint8]("/"))

    # Try to change to home directory
    chdir_result: int32 = syscall2(SYS_chdir, cast[int32](home_dir), 0)
    if chdir_result < 0:
        print_err(cast[*uint8]("login: warning: could not chdir to home\n"))

    # For a minimal system, we skip setuid/setgid
    # In production, you'd parse /etc/passwd and:
    # - syscall1(SYS_setgid, gid)
    # - syscall1(SYS_setuid, uid)

    # Check if root login
    is_root: int32 = 0
    if strcmp(username, cast[*uint8]("root")) == 0:
        is_root = 1
        print(cast[*uint8]("# Root access granted #\n"))

    # Prepare to exec shell
    # Try /bin/psh first, then ./bin/psh
    strcpy(shell_path, cast[*uint8]("/bin/psh"))
    argv[0] = cast[int32](shell_path)
    argv[1] = 0

    # Try to exec the shell
    _ = syscall3(SYS_execve, cast[int32](shell_path), cast[int32](argv), 0)

    # If that fails, try ./bin/psh
    strcpy(shell_path, cast[*uint8]("./bin/psh"))
    argv[0] = cast[int32](shell_path)
    _ = syscall3(SYS_execve, cast[int32](shell_path), cast[int32](argv), 0)

    # Try /bin/sh
    strcpy(shell_path, cast[*uint8]("/bin/sh"))
    argv[0] = cast[int32](shell_path)
    _ = syscall3(SYS_execve, cast[int32](shell_path), cast[int32](argv), 0)

    # Try /bin/bash
    strcpy(shell_path, cast[*uint8]("/bin/bash"))
    argv[0] = cast[int32](shell_path)
    _ = syscall3(SYS_execve, cast[int32](shell_path), cast[int32](argv), 0)

    # If all shells fail
    print_err(cast[*uint8]("login: failed to exec shell\n"))
    _ = syscall1(SYS_exit, 1)
