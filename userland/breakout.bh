# breakout - Classic brick-breaking arcade game
# Arrow keys or A/D to move paddle, Space to launch, Q to quit, R to restart

import "lib/syscalls"

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Game constants
const BRICK_ROWS: int32 = 6
const BRICK_COLS: int32 = 10
const BRICK_WIDTH: int32 = 60
const BRICK_HEIGHT: int32 = 20
const BRICK_GAP: int32 = 4
const PADDLE_WIDTH: int32 = 80
const PADDLE_HEIGHT: int32 = 12
const BALL_SIZE: int32 = 10
const PADDLE_SPEED: int32 = 12
const BALL_SPEED: int32 = 6

# Global framebuffer state
var g_fb: ptr uint32 = cast[ptr uint32](0)
var g_xres: int32 = 0
var g_yres: int32 = 0
var g_fb_fd: int32 = 0

# Game area
var g_area_x: int32 = 0
var g_area_y: int32 = 0
var g_area_w: int32 = 0
var g_area_h: int32 = 0

# Paddle state
var g_paddle_x: int32 = 0
var g_paddle_y: int32 = 0

# Ball state
var g_ball_x: int32 = 0
var g_ball_y: int32 = 0
var g_ball_dx: int32 = 4
var g_ball_dy: int32 = 0 - 4
var g_ball_launched: int32 = 0

# Brick state (60 bricks max)
var g_bricks: array[60, int32]  # 1 = alive, 0 = destroyed
var g_brick_colors: array[6, int32]

# Game state
var g_score: int32 = 0
var g_lives: int32 = 3
var g_game_over: int32 = 0
var g_won: int32 = 0
var g_running: int32 = 1
var g_bricks_left: int32 = 0

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc sleep_ms(ms: int32) =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  var ts: ptr int32 = cast[ptr int32](old_brk)
  ts[0] = 0
  ts[1] = ms * 1000000
  discard syscall2(SYS_nanosleep, cast[int32](ts), 0)

proc init_colors() =
  # Brick colors - rainbow from top to bottom
  g_brick_colors[0] = 0xFF0000  # red
  g_brick_colors[1] = 0xFF8800  # orange
  g_brick_colors[2] = 0xFFFF00  # yellow
  g_brick_colors[3] = 0x00FF00  # green
  g_brick_colors[4] = 0x0088FF  # blue
  g_brick_colors[5] = 0x8800FF  # purple

# ============ Graphics ============

proc set_pixel(x: int32, y: int32, color: int32) =
  if x < 0 or x >= g_xres or y < 0 or y >= g_yres:
    return
  g_fb[y * g_xres + x] = cast[uint32](color)

proc fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var py: int32 = y
  while py < y + h:
    if py >= 0 and py < g_yres:
      var px: int32 = x
      while px < x + w:
        if px >= 0 and px < g_xres:
          g_fb[py * g_xres + px] = cast[uint32](color)
        px = px + 1
    py = py + 1

proc draw_ball(x: int32, y: int32, color: int32) =
  # Draw a simple circle approximation
  fill_rect(x + 2, y, BALL_SIZE - 4, BALL_SIZE, color)
  fill_rect(x, y + 2, BALL_SIZE, BALL_SIZE - 4, color)
  fill_rect(x + 1, y + 1, BALL_SIZE - 2, BALL_SIZE - 2, color)

# Simple number drawing
proc draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32) =
  if d == 0:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 1:
    fill_rect(x + scale * 2, y, scale, scale * 7, color)
    fill_rect(x + scale, y + scale, scale, scale, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 2:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 3:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 4:
    fill_rect(x, y, scale, scale * 4, color)
    fill_rect(x + scale * 4, y, scale, scale * 7, color)
    fill_rect(x, y + scale * 3, scale * 5, scale, color)
  elif d == 5:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x, y + scale * 6, scale * 5, scale, color)
  elif d == 6:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 5, color)
    fill_rect(x, y + scale * 3, scale * 4, scale, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 7:
    fill_rect(x, y, scale * 5, scale, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 3, y + scale * 3, scale, scale * 2, color)
    fill_rect(x + scale * 2, y + scale * 5, scale, scale * 2, color)
  elif d == 8:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
  elif d == 9:
    fill_rect(x + scale, y, scale * 3, scale, color)
    fill_rect(x, y + scale, scale, scale * 2, color)
    fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
    fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
    fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)

proc draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32) =
  if num < 0:
    return
  if num == 0:
    draw_digit(0, x, y, color, scale)
    return

  var n: int32 = num
  var digits: int32 = 0
  while n > 0:
    digits = digits + 1
    n = n / 10

  var digit_arr: array[6, int32]
  n = num
  var i: int32 = digits - 1
  while i >= 0:
    digit_arr[i] = n - (n / 10) * 10
    n = n / 10
    i = i - 1

  var dx: int32 = x
  i = 0
  while i < digits:
    draw_digit(digit_arr[i], dx, y, color, scale)
    dx = dx + scale * 6
    i = i + 1

# ============ Game Logic ============

proc init_game() =
  g_score = 0
  g_lives = 3
  g_game_over = 0
  g_won = 0
  g_bricks_left = BRICK_ROWS * BRICK_COLS

  # Initialize all bricks as alive
  var i: int32 = 0
  while i < BRICK_ROWS * BRICK_COLS:
    g_bricks[i] = 1
    i = i + 1

  # Reset paddle position
  g_paddle_x = g_area_x + (g_area_w - PADDLE_WIDTH) / 2
  g_paddle_y = g_area_y + g_area_h - PADDLE_HEIGHT - 20

  # Reset ball
  g_ball_launched = 0
  g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
  g_ball_y = g_paddle_y - BALL_SIZE - 2
  g_ball_dx = 4
  g_ball_dy = 0 - 4

proc reset_ball() =
  g_ball_launched = 0
  g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
  g_ball_y = g_paddle_y - BALL_SIZE - 2
  g_ball_dx = 4
  g_ball_dy = 0 - 4

proc check_brick_collision(): int32 =
  var brick_y: int32 = 0
  while brick_y < BRICK_ROWS:
    var brick_x: int32 = 0
    while brick_x < BRICK_COLS:
      var idx: int32 = brick_y * BRICK_COLS + brick_x
      if g_bricks[idx] != 0:
        # Calculate brick position
        var bx: int32 = g_area_x + 10 + brick_x * (BRICK_WIDTH + BRICK_GAP)
        var by: int32 = g_area_y + 60 + brick_y * (BRICK_HEIGHT + BRICK_GAP)

        # Check collision with ball
        if g_ball_x + BALL_SIZE > bx and g_ball_x < bx + BRICK_WIDTH:
          if g_ball_y + BALL_SIZE > by and g_ball_y < by + BRICK_HEIGHT:
            # Destroy brick
            g_bricks[idx] = 0
            g_bricks_left = g_bricks_left - 1
            g_score = g_score + (BRICK_ROWS - brick_y) * 10

            # Determine bounce direction
            var ball_cx: int32 = g_ball_x + BALL_SIZE / 2
            var ball_cy: int32 = g_ball_y + BALL_SIZE / 2
            var brick_cx: int32 = bx + BRICK_WIDTH / 2
            var brick_cy: int32 = by + BRICK_HEIGHT / 2

            var dx: int32 = ball_cx - brick_cx
            var dy: int32 = ball_cy - brick_cy
            if dx < 0: dx = 0 - dx
            if dy < 0: dy = 0 - dy

            # Determine if hit was more horizontal or vertical
            if dx * BRICK_HEIGHT > dy * BRICK_WIDTH:
              g_ball_dx = 0 - g_ball_dx
            else:
              g_ball_dy = 0 - g_ball_dy

            return 1
      brick_x = brick_x + 1
    brick_y = brick_y + 1
  return 0

proc update_ball() =
  if g_ball_launched == 0:
    # Ball follows paddle
    g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
    return

  # Move ball
  g_ball_x = g_ball_x + g_ball_dx
  g_ball_y = g_ball_y + g_ball_dy

  # Wall collisions
  if g_ball_x <= g_area_x:
    g_ball_x = g_area_x
    g_ball_dx = 0 - g_ball_dx
  if g_ball_x + BALL_SIZE >= g_area_x + g_area_w:
    g_ball_x = g_area_x + g_area_w - BALL_SIZE
    g_ball_dx = 0 - g_ball_dx
  if g_ball_y <= g_area_y:
    g_ball_y = g_area_y
    g_ball_dy = 0 - g_ball_dy

  # Bottom - lose life
  if g_ball_y + BALL_SIZE >= g_area_y + g_area_h:
    g_lives = g_lives - 1
    if g_lives <= 0:
      g_game_over = 1
    else:
      reset_ball()

  # Paddle collision
  if g_ball_dy > 0:  # Only check when moving down
    if g_ball_y + BALL_SIZE >= g_paddle_y and g_ball_y + BALL_SIZE <= g_paddle_y + PADDLE_HEIGHT:
      if g_ball_x + BALL_SIZE >= g_paddle_x and g_ball_x <= g_paddle_x + PADDLE_WIDTH:
        g_ball_y = g_paddle_y - BALL_SIZE
        g_ball_dy = 0 - g_ball_dy

        # Adjust angle based on where ball hit paddle
        var hit_pos: int32 = (g_ball_x + BALL_SIZE / 2) - g_paddle_x
        var paddle_center: int32 = PADDLE_WIDTH / 2
        var offset: int32 = hit_pos - paddle_center

        # Adjust dx based on offset from center (-40 to +40)
        g_ball_dx = offset / 8
        if g_ball_dx > 6: g_ball_dx = 6
        if g_ball_dx < 0 - 6: g_ball_dx = 0 - 6
        if g_ball_dx == 0: g_ball_dx = 2

  # Brick collision
  discard check_brick_collision()

  # Check win condition
  if g_bricks_left == 0:
    g_won = 1

# ============ Drawing ============

proc draw_bricks() =
  var brick_y: int32 = 0
  while brick_y < BRICK_ROWS:
    var brick_x: int32 = 0
    while brick_x < BRICK_COLS:
      var idx: int32 = brick_y * BRICK_COLS + brick_x
      if g_bricks[idx] != 0:
        var bx: int32 = g_area_x + 10 + brick_x * (BRICK_WIDTH + BRICK_GAP)
        var by: int32 = g_area_y + 60 + brick_y * (BRICK_HEIGHT + BRICK_GAP)
        var color: int32 = g_brick_colors[brick_y]
        fill_rect(bx, by, BRICK_WIDTH, BRICK_HEIGHT, color)
        # Highlight
        fill_rect(bx, by, BRICK_WIDTH - 2, 2, 0xFFFFFF)
        fill_rect(bx, by, 2, BRICK_HEIGHT - 2, 0xFFFFFF)
      brick_x = brick_x + 1
    brick_y = brick_y + 1

proc draw_paddle() =
  # Main paddle body
  fill_rect(g_paddle_x, g_paddle_y, PADDLE_WIDTH, PADDLE_HEIGHT, 0xCCCCCC)
  # Highlight
  fill_rect(g_paddle_x, g_paddle_y, PADDLE_WIDTH - 2, 2, 0xFFFFFF)
  fill_rect(g_paddle_x, g_paddle_y, 2, PADDLE_HEIGHT - 2, 0xFFFFFF)
  # Shadow
  fill_rect(g_paddle_x + 2, g_paddle_y + PADDLE_HEIGHT - 2, PADDLE_WIDTH - 2, 2, 0x888888)
  fill_rect(g_paddle_x + PADDLE_WIDTH - 2, g_paddle_y + 2, 2, PADDLE_HEIGHT - 2, 0x888888)

proc draw_header() =
  # Score
  fill_rect(g_area_x + 10, g_area_y + 10, 100, 30, 0x333333)
  draw_number(g_score, g_area_x + 20, g_area_y + 16, 0xFFFFFF, 3)

  # Lives
  var lx: int32 = g_area_x + g_area_w - 80
  var i: int32 = 0
  while i < g_lives:
    draw_ball(lx + i * 15, g_area_y + 15, 0xFF0000)
    i = i + 1

proc draw_game_area() =
  # Background
  fill_rect(g_area_x, g_area_y, g_area_w, g_area_h, 0x1a1a2e)

  # Border
  fill_rect(g_area_x, g_area_y, g_area_w, 4, 0x444444)
  fill_rect(g_area_x, g_area_y, 4, g_area_h, 0x444444)
  fill_rect(g_area_x + g_area_w - 4, g_area_y, 4, g_area_h, 0x444444)

proc draw_game_over_screen() =
  fill_rect(g_area_x + 100, g_area_y + 200, 400, 80, 0x000000)
  # "GAME OVER" - show score
  draw_number(g_score, g_area_x + 200, g_area_y + 230, 0xFF0000, 6)

proc draw_won_screen() =
  fill_rect(g_area_x + 100, g_area_y + 200, 400, 80, 0x004400)
  draw_number(g_score, g_area_x + 200, g_area_y + 230, 0x00FF00, 6)

proc draw_screen() =
  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0x0a0a1e)

  draw_game_area()
  draw_header()
  draw_bricks()
  draw_paddle()
  draw_ball(g_ball_x, g_ball_y, 0xFFFFFF)

  if g_game_over != 0:
    draw_game_over_screen()
  elif g_won != 0:
    draw_won_screen()

# ============ Input ============

proc handle_input() =
  var buf: array[8, uint8]
  var n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 8)

  if n <= 0:
    return

  var c: int32 = cast[int32](buf[0])

  # Arrow keys
  if c == 27 and n >= 3:
    if buf[1] == cast[uint8](91):
      if buf[2] == cast[uint8](67):  # Right
        g_paddle_x = g_paddle_x + PADDLE_SPEED
        if g_paddle_x + PADDLE_WIDTH > g_area_x + g_area_w - 4:
          g_paddle_x = g_area_x + g_area_w - PADDLE_WIDTH - 4
      elif buf[2] == cast[uint8](68):  # Left
        g_paddle_x = g_paddle_x - PADDLE_SPEED
        if g_paddle_x < g_area_x + 4:
          g_paddle_x = g_area_x + 4
  elif c == 97 or c == 65:  # a/A - left
    g_paddle_x = g_paddle_x - PADDLE_SPEED
    if g_paddle_x < g_area_x + 4:
      g_paddle_x = g_area_x + 4
  elif c == 100:  # d - right (68 is 'D' which conflicts)
    g_paddle_x = g_paddle_x + PADDLE_SPEED
    if g_paddle_x + PADDLE_WIDTH > g_area_x + g_area_w - 4:
      g_paddle_x = g_area_x + g_area_w - PADDLE_WIDTH - 4
  elif c == 32:  # Space - launch ball
    if g_ball_launched == 0 and g_game_over == 0 and g_won == 0:
      g_ball_launched = 1
  elif c == 113 or c == 81:  # q/Q - quit
    g_running = 0
  elif c == 114 or c == 82:  # r/R - restart
    init_game()

# ============ Framebuffer Setup ============

proc init_framebuffer(): int32 =
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 256)

  var path: ptr uint8 = cast[ptr uint8]("/dev/fb0")
  g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
  if g_fb_fd < 0:
    print_str(cast[ptr uint8]("Error: cannot open /dev/fb0\n"))
    return 1

  var vinfo: ptr int32 = cast[ptr int32](old_brk + 32)
  var i: int32 = 0
  while i < 40:
    vinfo[i] = 0
    i = i + 1

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

  g_xres = vinfo[0]
  g_yres = vinfo[1]

  var fb_size: int32 = g_xres * g_yres * 4
  var fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
  if fb_addr < 0:
    return 1

  g_fb = cast[ptr uint32](fb_addr)
  return 0

# ============ Main ============

proc main(): int32 =
  if init_framebuffer() != 0:
    return 1

  init_colors()

  # Set stdin to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

  # Calculate game area (centered)
  g_area_w = BRICK_COLS * (BRICK_WIDTH + BRICK_GAP) + 20
  g_area_h = 500
  g_area_x = (g_xres - g_area_w) / 2
  g_area_y = (g_yres - g_area_h) / 2

  # Initialize game
  init_game()

  # Main loop
  while g_running != 0:
    if g_game_over == 0 and g_won == 0:
      update_ball()

    draw_screen()
    handle_input()
    sleep_ms(16)  # ~60 FPS

  # Restore stdin
  discard syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

  # Clear screen
  fill_rect(0, 0, g_xres, g_yres, 0)

  return 0
