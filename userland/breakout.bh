# breakout - Classic brick-breaking arcade game
# Arrow keys or A/D to move paddle, Space to launch, Q to quit, R to restart

from lib.syscalls import *

O_NONBLOCK: int32 = 2048
F_SETFL: int32 = 4
F_GETFL: int32 = 3

PROT_READ: int32 = 1
PROT_WRITE: int32 = 2
MAP_SHARED: int32 = 1

# Game constants
BRICK_ROWS: int32 = 6
BRICK_COLS: int32 = 10
BRICK_WIDTH: int32 = 60
BRICK_HEIGHT: int32 = 20
BRICK_GAP: int32 = 4
PADDLE_WIDTH: int32 = 80
PADDLE_HEIGHT: int32 = 12
BALL_SIZE: int32 = 10
PADDLE_SPEED: int32 = 12
BALL_SPEED: int32 = 6

# Global framebuffer state
g_fb: *uint32 = cast[*uint32](0)
g_xres: int32 = 0
g_yres: int32 = 0
g_fb_fd: int32 = 0

# Game area
g_area_x: int32 = 0
g_area_y: int32 = 0
g_area_w: int32 = 0
g_area_h: int32 = 0

# Paddle state
g_paddle_x: int32 = 0
g_paddle_y: int32 = 0

# Ball state
g_ball_x: int32 = 0
g_ball_y: int32 = 0
g_ball_dx: int32 = 4
g_ball_dy: int32 = 0 - 4
g_ball_launched: int32 = 0

# Brick state (60 bricks max)
g_bricks: Array[60, int32]  # 1 = alive, 0 = destroyed
g_brick_colors: Array[6, int32]

# Game state
g_score: int32 = 0
g_lives: int32 = 3
g_game_over: int32 = 0
g_won: int32 = 0
g_running: int32 = 1
g_bricks_left: int32 = 0

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    ts: *int32 = cast[*int32](old_brk)
    ts[0] = 0
    ts[1] = ms * 1000000
    _ = syscall2(SYS_nanosleep, cast[int32](ts), 0)

def init_colors():
    # Brick colors - rainbow from top to bottom
    g_brick_colors[0] = 0xFF0000  # red
    g_brick_colors[1] = 0xFF8800  # orange
    g_brick_colors[2] = 0xFFFF00  # yellow
    g_brick_colors[3] = 0x00FF00  # green
    g_brick_colors[4] = 0x0088FF  # blue
    g_brick_colors[5] = 0x8800FF  # purple

# ============ Graphics ============

def set_pixel(x: int32, y: int32, color: int32):
    if x < 0 or x >= g_xres or y < 0 or y >= g_yres:
        return
    g_fb[y * g_xres + x] = cast[uint32](color)

def fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32):
    py: int32 = y
    while py < y + h:
        if py >= 0 and py < g_yres:
            px: int32 = x
            while px < x + w:
                if px >= 0 and px < g_xres:
                    g_fb[py * g_xres + px] = cast[uint32](color)
                px = px + 1
        py = py + 1

def draw_ball(x: int32, y: int32, color: int32):
    # Draw a simple circle approximation
    fill_rect(x + 2, y, BALL_SIZE - 4, BALL_SIZE, color)
    fill_rect(x, y + 2, BALL_SIZE, BALL_SIZE - 4, color)
    fill_rect(x + 1, y + 1, BALL_SIZE - 2, BALL_SIZE - 2, color)

# Simple number drawing
def draw_digit(d: int32, x: int32, y: int32, color: int32, scale: int32):
    if d == 0:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 5, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 1:
        fill_rect(x + scale * 2, y, scale, scale * 7, color)
        fill_rect(x + scale, y + scale, scale, scale, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 2:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 3:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 4:
        fill_rect(x, y, scale, scale * 4, color)
        fill_rect(x + scale * 4, y, scale, scale * 7, color)
        fill_rect(x, y + scale * 3, scale * 5, scale, color)
    elif d == 5:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x, y + scale * 3, scale * 4, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x, y + scale * 6, scale * 5, scale, color)
    elif d == 6:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 5, color)
        fill_rect(x, y + scale * 3, scale * 4, scale, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 7:
        fill_rect(x, y, scale * 5, scale, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale * 3, y + scale * 3, scale, scale * 2, color)
        fill_rect(x + scale * 2, y + scale * 5, scale, scale * 2, color)
    elif d == 8:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale * 4, scale, scale * 2, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)
    elif d == 9:
        fill_rect(x + scale, y, scale * 3, scale, color)
        fill_rect(x, y + scale, scale, scale * 2, color)
        fill_rect(x + scale * 4, y + scale, scale, scale * 5, color)
        fill_rect(x + scale, y + scale * 3, scale * 3, scale, color)
        fill_rect(x + scale, y + scale * 6, scale * 3, scale, color)

def draw_number(num: int32, x: int32, y: int32, color: int32, scale: int32):
    if num < 0:
        return
    if num == 0:
        draw_digit(0, x, y, color, scale)
        return

    n: int32 = num
    digits: int32 = 0
    while n > 0:
        digits = digits + 1
        n = n / 10

    digit_arr: Array[6, int32]
    n = num
    i: int32 = digits - 1
    while i >= 0:
        digit_arr[i] = n - (n / 10) * 10
        n = n / 10
        i = i - 1

    dx: int32 = x
    i = 0
    while i < digits:
        draw_digit(digit_arr[i], dx, y, color, scale)
        dx = dx + scale * 6
        i = i + 1

# ============ Game Logic ============

def init_game():
    g_score = 0
    g_lives = 3
    g_game_over = 0
    g_won = 0
    g_bricks_left = BRICK_ROWS * BRICK_COLS

    # Initialize all bricks as alive
    i: int32 = 0
    while i < BRICK_ROWS * BRICK_COLS:
        g_bricks[i] = 1
        i = i + 1

    # Reset paddle position
    g_paddle_x = g_area_x + (g_area_w - PADDLE_WIDTH) / 2
    g_paddle_y = g_area_y + g_area_h - PADDLE_HEIGHT - 20

    # Reset ball
    g_ball_launched = 0
    g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
    g_ball_y = g_paddle_y - BALL_SIZE - 2
    g_ball_dx = 4
    g_ball_dy = 0 - 4

def reset_ball():
    g_ball_launched = 0
    g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
    g_ball_y = g_paddle_y - BALL_SIZE - 2
    g_ball_dx = 4
    g_ball_dy = 0 - 4

def check_brick_collision() -> int32:
    brick_y: int32 = 0
    while brick_y < BRICK_ROWS:
        brick_x: int32 = 0
        while brick_x < BRICK_COLS:
            idx: int32 = brick_y * BRICK_COLS + brick_x
            if g_bricks[idx] != 0:
                # Calculate brick position
                bx: int32 = g_area_x + 10 + brick_x * (BRICK_WIDTH + BRICK_GAP)
                by: int32 = g_area_y + 60 + brick_y * (BRICK_HEIGHT + BRICK_GAP)

                # Check collision with ball
                if g_ball_x + BALL_SIZE > bx and g_ball_x < bx + BRICK_WIDTH:
                    if g_ball_y + BALL_SIZE > by and g_ball_y < by + BRICK_HEIGHT:
                        # Destroy brick
                        g_bricks[idx] = 0
                        g_bricks_left = g_bricks_left - 1
                        g_score = g_score + (BRICK_ROWS - brick_y) * 10

                        # Determine bounce direction
                        ball_cx: int32 = g_ball_x + BALL_SIZE / 2
                        ball_cy: int32 = g_ball_y + BALL_SIZE / 2
                        brick_cx: int32 = bx + BRICK_WIDTH / 2
                        brick_cy: int32 = by + BRICK_HEIGHT / 2

                        dx: int32 = ball_cx - brick_cx
                        dy: int32 = ball_cy - brick_cy
                        if dx < 0: dx = 0 - dx
                        if dy < 0: dy = 0 - dy

                        # Determine if hit was more horizontal or vertical
                        if dx * BRICK_HEIGHT > dy * BRICK_WIDTH:
                            g_ball_dx = 0 - g_ball_dx
                        else:
                            g_ball_dy = 0 - g_ball_dy

                        return 1
            brick_x = brick_x + 1
        brick_y = brick_y + 1
    return 0

def update_ball():
    if g_ball_launched == 0:
        # Ball follows paddle
        g_ball_x = g_paddle_x + PADDLE_WIDTH / 2 - BALL_SIZE / 2
        return

    # Move ball
    g_ball_x = g_ball_x + g_ball_dx
    g_ball_y = g_ball_y + g_ball_dy

    # Wall collisions
    if g_ball_x <= g_area_x:
        g_ball_x = g_area_x
        g_ball_dx = 0 - g_ball_dx
    if g_ball_x + BALL_SIZE >= g_area_x + g_area_w:
        g_ball_x = g_area_x + g_area_w - BALL_SIZE
        g_ball_dx = 0 - g_ball_dx
    if g_ball_y <= g_area_y:
        g_ball_y = g_area_y
        g_ball_dy = 0 - g_ball_dy

    # Bottom - lose life
    if g_ball_y + BALL_SIZE >= g_area_y + g_area_h:
        g_lives = g_lives - 1
        if g_lives <= 0:
            g_game_over = 1
        else:
            reset_ball()

    # Paddle collision
    if g_ball_dy > 0:  # Only check when moving down
        if g_ball_y + BALL_SIZE >= g_paddle_y and g_ball_y + BALL_SIZE <= g_paddle_y + PADDLE_HEIGHT:
            if g_ball_x + BALL_SIZE >= g_paddle_x and g_ball_x <= g_paddle_x + PADDLE_WIDTH:
                g_ball_y = g_paddle_y - BALL_SIZE
                g_ball_dy = 0 - g_ball_dy

                # Adjust angle based on where ball hit paddle
                hit_pos: int32 = (g_ball_x + BALL_SIZE / 2) - g_paddle_x
                paddle_center: int32 = PADDLE_WIDTH / 2
                offset: int32 = hit_pos - paddle_center

                # Adjust dx based on offset from center (-40 to +40)
                g_ball_dx = offset / 8
                if g_ball_dx > 6: g_ball_dx = 6
                if g_ball_dx < 0 - 6: g_ball_dx = 0 - 6
                if g_ball_dx == 0: g_ball_dx = 2

    # Brick collision
    _ = check_brick_collision()

    # Check win condition
    if g_bricks_left == 0:
        g_won = 1

# ============ Drawing ============

def draw_bricks():
    brick_y: int32 = 0
    while brick_y < BRICK_ROWS:
        brick_x: int32 = 0
        while brick_x < BRICK_COLS:
            idx: int32 = brick_y * BRICK_COLS + brick_x
            if g_bricks[idx] != 0:
                bx: int32 = g_area_x + 10 + brick_x * (BRICK_WIDTH + BRICK_GAP)
                by: int32 = g_area_y + 60 + brick_y * (BRICK_HEIGHT + BRICK_GAP)
                color: int32 = g_brick_colors[brick_y]
                fill_rect(bx, by, BRICK_WIDTH, BRICK_HEIGHT, color)
                # Highlight
                fill_rect(bx, by, BRICK_WIDTH - 2, 2, 0xFFFFFF)
                fill_rect(bx, by, 2, BRICK_HEIGHT - 2, 0xFFFFFF)
            brick_x = brick_x + 1
        brick_y = brick_y + 1

def draw_paddle():
    # Main paddle body
    fill_rect(g_paddle_x, g_paddle_y, PADDLE_WIDTH, PADDLE_HEIGHT, 0xCCCCCC)
    # Highlight
    fill_rect(g_paddle_x, g_paddle_y, PADDLE_WIDTH - 2, 2, 0xFFFFFF)
    fill_rect(g_paddle_x, g_paddle_y, 2, PADDLE_HEIGHT - 2, 0xFFFFFF)
    # Shadow
    fill_rect(g_paddle_x + 2, g_paddle_y + PADDLE_HEIGHT - 2, PADDLE_WIDTH - 2, 2, 0x888888)
    fill_rect(g_paddle_x + PADDLE_WIDTH - 2, g_paddle_y + 2, 2, PADDLE_HEIGHT - 2, 0x888888)

def draw_header():
    # Score
    fill_rect(g_area_x + 10, g_area_y + 10, 100, 30, 0x333333)
    draw_number(g_score, g_area_x + 20, g_area_y + 16, 0xFFFFFF, 3)

    # Lives
    lx: int32 = g_area_x + g_area_w - 80
    i: int32 = 0
    while i < g_lives:
        draw_ball(lx + i * 15, g_area_y + 15, 0xFF0000)
        i = i + 1

def draw_game_area():
    # Background
    fill_rect(g_area_x, g_area_y, g_area_w, g_area_h, 0x1a1a2e)

    # Border
    fill_rect(g_area_x, g_area_y, g_area_w, 4, 0x444444)
    fill_rect(g_area_x, g_area_y, 4, g_area_h, 0x444444)
    fill_rect(g_area_x + g_area_w - 4, g_area_y, 4, g_area_h, 0x444444)

def draw_game_over_screen():
    fill_rect(g_area_x + 100, g_area_y + 200, 400, 80, 0x000000)
    # "GAME OVER" - show score
    draw_number(g_score, g_area_x + 200, g_area_y + 230, 0xFF0000, 6)

def draw_won_screen():
    fill_rect(g_area_x + 100, g_area_y + 200, 400, 80, 0x004400)
    draw_number(g_score, g_area_x + 200, g_area_y + 230, 0x00FF00, 6)

def draw_screen():
    # Clear screen
    fill_rect(0, 0, g_xres, g_yres, 0x0a0a1e)

    draw_game_area()
    draw_header()
    draw_bricks()
    draw_paddle()
    draw_ball(g_ball_x, g_ball_y, 0xFFFFFF)

    if g_game_over != 0:
        draw_game_over_screen()
    elif g_won != 0:
        draw_won_screen()

# ============ Input ============

def handle_input():
    buf: Array[8, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](addr(buf[0])), 8)

    if n <= 0:
        return

    c: int32 = cast[int32](buf[0])

    # Arrow keys
    if c == 27 and n >= 3:
        if buf[1] == cast[uint8](91):
            if buf[2] == cast[uint8](67):  # Right
                g_paddle_x = g_paddle_x + PADDLE_SPEED
                if g_paddle_x + PADDLE_WIDTH > g_area_x + g_area_w - 4:
                    g_paddle_x = g_area_x + g_area_w - PADDLE_WIDTH - 4
            elif buf[2] == cast[uint8](68):  # Left
                g_paddle_x = g_paddle_x - PADDLE_SPEED
                if g_paddle_x < g_area_x + 4:
                    g_paddle_x = g_area_x + 4
    elif c == 97 or c == 65:  # a/A - left
        g_paddle_x = g_paddle_x - PADDLE_SPEED
        if g_paddle_x < g_area_x + 4:
            g_paddle_x = g_area_x + 4
    elif c == 100:  # d - right (68 is 'D' which conflicts)
        g_paddle_x = g_paddle_x + PADDLE_SPEED
        if g_paddle_x + PADDLE_WIDTH > g_area_x + g_area_w - 4:
            g_paddle_x = g_area_x + g_area_w - PADDLE_WIDTH - 4
    elif c == 32:  # Space - launch ball
        if g_ball_launched == 0 and g_game_over == 0 and g_won == 0:
            g_ball_launched = 1
    elif c == 113 or c == 81:  # q/Q - quit
        g_running = 0
    elif c == 114 or c == 82:  # r/R - restart
        init_game()

# ============ Framebuffer Setup ============

def init_framebuffer() -> int32:
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 256)

    path: *uint8 = cast[*uint8]("/dev/fb0")
    g_fb_fd = syscall3(SYS_open, cast[int32](path), O_RDWR, 0)
    if g_fb_fd < 0:
        print_str(cast[*uint8]("Error: cannot open /dev/fb0\n"))
        return 1

    vinfo: *int32 = cast[*int32](old_brk + 32)
    i: int32 = 0
    while i < 40:
        vinfo[i] = 0
        i = i + 1

    FBIOGET_VSCREENINFO: int32 = 0x4600
    _ = syscall3(SYS_ioctl, g_fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))

    g_xres = vinfo[0]
    g_yres = vinfo[1]

    fb_size: int32 = g_xres * g_yres * 4
    fb_addr: int32 = syscall6(SYS_mmap2, 0, fb_size, PROT_READ | PROT_WRITE, MAP_SHARED, g_fb_fd, 0)
    if fb_addr < 0:
        return 1

    g_fb = cast[*uint32](fb_addr)
    return 0

# ============ Main ============

def main() -> int32:
    if init_framebuffer() != 0:
        return 1

    init_colors()

    # Set stdin to non-blocking
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags | O_NONBLOCK)

    # Calculate game area (centered)
    g_area_w = BRICK_COLS * (BRICK_WIDTH + BRICK_GAP) + 20
    g_area_h = 500
    g_area_x = (g_xres - g_area_w) / 2
    g_area_y = (g_yres - g_area_h) / 2

    # Initialize game
    init_game()

    # Main loop
    while g_running != 0:
        if g_game_over == 0 and g_won == 0:
            update_ball()

        draw_screen()
        handle_input()
        sleep_ms(16)  # ~60 FPS

    # Restore stdin
    _ = syscall3(SYS_fcntl, STDIN, F_SETFL, flags)

    # Clear screen
    fill_rect(0, 0, g_xres, g_yres, 0)

    return 0
