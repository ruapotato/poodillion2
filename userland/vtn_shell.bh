from lib.syscalls import *
from lib.vtnext import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
SCREEN_WIDTH: Final[int32] = 1024
SCREEN_HEIGHT: Final[int32] = 768
CHAR_WIDTH: Final[int32] = 9
CHAR_HEIGHT: Final[int32] = 16
HEADER_HEIGHT: Final[int32] = 30
PROMPT_HEIGHT: Final[int32] = 40
CONTENT_TOP: Final[int32] = 35
CONTENT_LEFT: Final[int32] = 10
CONTENT_WIDTH: Final[int32] = 1004
MAX_COLS: Final[int32] = 110
MAX_VISIBLE_LINES: Final[int32] = 42
BG_R: Final[int32] = 25
BG_G: Final[int32] = 28
BG_B: Final[int32] = 35
HEADER_R: Final[int32] = 40
HEADER_G: Final[int32] = 45
HEADER_B: Final[int32] = 55
PROMPT_BG_R: Final[int32] = 35
PROMPT_BG_G: Final[int32] = 40
PROMPT_BG_B: Final[int32] = 50
TEXT_R: Final[int32] = 220
TEXT_G: Final[int32] = 225
TEXT_B: Final[int32] = 230
PROMPT_R: Final[int32] = 100
PROMPT_G: Final[int32] = 220
PROMPT_B: Final[int32] = 140
CMD_R: Final[int32] = 255
CMD_G: Final[int32] = 255
CMD_B: Final[int32] = 255
ERROR_R: Final[int32] = 255
ERROR_G: Final[int32] = 100
ERROR_B: Final[int32] = 100
DIR_R: Final[int32] = 100
DIR_G: Final[int32] = 180
DIR_B: Final[int32] = 255
EXEC_R: Final[int32] = 100
EXEC_G: Final[int32] = 255
EXEC_B: Final[int32] = 100
CURSOR_R: Final[int32] = 255
CURSOR_G: Final[int32] = 200
CURSOR_B: Final[int32] = 100
MAX_OUTPUT_LINES: Final[int32] = 500
MAX_LINE_LEN: Final[int32] = 120

output_buffer: Array[60000, uint8]

output_colors_r: Array[500, uint8]

output_colors_g: Array[500, uint8]

output_colors_b: Array[500, uint8]

output_lens: Array[500, int32]

output_head: int32 = 0

output_tail: int32 = 0

output_count: int32 = 0

scroll_offset: int32 = 0
MAX_CMD_LEN: Final[int32] = 256

cmd_buffer: Array[256, uint8]

cmd_len: int32 = 0

cursor_pos: int32 = 0
MAX_HISTORY: Final[int32] = 50

history: Array[12800, uint8]

history_count: int32 = 0

history_pos: int32 = 0

running: int32 = 1

current_dir: Array[256, uint8]

current_dir_len: int32 = 0

last_exit_code: int32 = 0

cursor_visible: int32 = 1

blink_counter: int32 = 0

def sleep_ms(ms: int32):
    old_brk: int32 = syscall1(SYS_brk, 0)
    syscall1(SYS_brk, (old_brk + 16))
    ts: Ptr[int32] = Ptr[int32](old_brk)
    ts[0] = 0
    ts[1] = (ms * 1000000)
    syscall2(SYS_nanosleep, cast[int32](ts), 0)

def str_len(s: Ptr[uint8]) -> int32:
    i: int32 = 0
    while (s[i] != cast[uint8](0)):
        i = (i + 1)
    return i

def str_copy(dst: Ptr[uint8], src: Ptr[uint8]) -> int32:
    i: int32 = 0
    while (src[i] != cast[uint8](0)):
        dst[i] = src[i]
        i = (i + 1)
    dst[i] = cast[uint8](0)
    return i

def str_eq(a: Ptr[uint8], b: Ptr[uint8]) -> int32:
    i: int32 = 0
    while ((a[i] != cast[uint8](0)) and (b[i] != cast[uint8](0))):
        if (a[i] != b[i]):
            return 0
        i = (i + 1)
    if (a[i] == b[i]):
        return 1
    return 0

def str_starts_with(s: Ptr[uint8], prefix: Ptr[uint8]) -> int32:
    i: int32 = 0
    while (prefix[i] != cast[uint8](0)):
        if (s[i] != prefix[i]):
            return 0
        i = (i + 1)
    return 1

def get_output_line(idx: int32) -> Ptr[uint8]:
    real_idx: int32 = (output_head + idx)
    if (real_idx >= MAX_OUTPUT_LINES):
        real_idx = (real_idx - MAX_OUTPUT_LINES)
    return Ptr[uint8]((addr(output_buffer) + (real_idx * MAX_LINE_LEN)))

def add_output_line(text: Ptr[uint8], r: int32, g: int32, b: int32):
    line: Ptr[uint8] = Ptr[uint8]((addr(output_buffer) + (output_tail * MAX_LINE_LEN)))
    len: int32 = str_copy(line, text)
    if (len > (MAX_LINE_LEN - 1)):
        len = (MAX_LINE_LEN - 1)
    line[len] = cast[uint8](0)
    output_lens[output_tail] = len
    output_colors_r[output_tail] = cast[uint8](r)
    output_colors_g[output_tail] = cast[uint8](g)
    output_colors_b[output_tail] = cast[uint8](b)
    output_tail = (output_tail + 1)
    if (output_tail >= MAX_OUTPUT_LINES):
        output_tail = 0
    if (output_count < MAX_OUTPUT_LINES):
        output_count = (output_count + 1)
    else:
        output_head = (output_head + 1)
        if (output_head >= MAX_OUTPUT_LINES):
            output_head = 0
    if (output_count > MAX_VISIBLE_LINES):
        scroll_offset = (output_count - MAX_VISIBLE_LINES)

def history_add(cmd: Ptr[uint8]):
    if (str_len(cmd) == 0):
        return
    if (history_count > 0):
        last: Ptr[uint8] = Ptr[uint8]((addr(history) + ((history_count - 1) * 256)))
        if (str_eq(last, cmd) != 0):
            history_pos = history_count
            return
    if (history_count < MAX_HISTORY):
        dest: Ptr[uint8] = Ptr[uint8]((addr(history) + (history_count * 256)))

        str_copy(dest, cmd)
        history_count = (history_count + 1)
    history_pos = history_count

def history_get(idx: int32) -> Ptr[uint8]:
    return Ptr[uint8]((addr(history) + (idx * 256)))

def print_line(text: Ptr[uint8], r: int32, g: int32, b: int32):
    add_output_line(text, r, g, b)

def print_error(text: Ptr[uint8]):
    print_line(text, ERROR_R, ERROR_G, ERROR_B)

def print_success(text: Ptr[uint8]):
    print_line(text, EXEC_G, EXEC_G, EXEC_G)

def print_info(text: Ptr[uint8]):
    print_line(text, TEXT_R, TEXT_G, TEXT_B)

def print_dir(text: Ptr[uint8]):
    print_line(text, DIR_R, DIR_G, DIR_B)

def cmd_help():
    print_line(Ptr[uint8]("Available commands:"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  help      - Show this help message"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  clear     - Clear the screen"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  echo      - Print text"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  ls        - List files"), DIR_R, DIR_G, DIR_B)
    print_line(Ptr[uint8]("  pwd       - Print working directory"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  cd        - Change directory"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  cat       - Display file contents"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  uname     - System information"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  date      - Show current date"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  uptime    - Show system uptime"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  ps        - List processes"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  free      - Show memory usage"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  history   - Show command history"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("  exit/quit - Exit the shell"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8](""), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("Apps: pong, 2048, edit, term, demo"), EXEC_R, EXEC_G, EXEC_B)

def cmd_clear():
    output_head = 0
    output_tail = 0
    output_count = 0
    scroll_offset = 0

def cmd_echo(args: Ptr[uint8]):
    print_line(args, TEXT_R, TEXT_G, TEXT_B)

def cmd_ls():
    print_line(Ptr[uint8]("bin/    dev/    home/   tmp/    usr/"), DIR_R, DIR_G, DIR_B)
    print_line(Ptr[uint8]("boot/   etc/    proc/   var/    lib/"), DIR_R, DIR_G, DIR_B)

def cmd_pwd():
    if (current_dir_len == 0):
        print_line(Ptr[uint8]("/"), TEXT_R, TEXT_G, TEXT_B)
    else:
        print_line(Ptr[uint8](addr(current_dir)), TEXT_R, TEXT_G, TEXT_B)

def cmd_cd(path: Ptr[uint8]):
    if (str_len(path) == 0):
        current_dir_len = 0
        current_dir[0] = cast[uint8](47)
        current_dir[1] = cast[uint8](0)
        current_dir_len = 1
        return
    if (path[0] == cast[uint8](47)):
        current_dir_len = str_copy(Ptr[uint8](addr(current_dir)), path)
    elif (str_eq(path, Ptr[uint8]("..")) != 0):
        if (current_dir_len > 1):
            current_dir_len = (current_dir_len - 1)
            while ((current_dir_len > 0) and (current_dir[(current_dir_len - 1)] != cast[uint8](47))):
                current_dir_len = (current_dir_len - 1)
            if (current_dir_len == 0):
                current_dir[0] = cast[uint8](47)
                current_dir_len = 1
            current_dir[current_dir_len] = cast[uint8](0)
    else:
        if ((current_dir_len > 0) and (current_dir[(current_dir_len - 1)] != cast[uint8](47))):
            current_dir[current_dir_len] = cast[uint8](47)
            current_dir_len = (current_dir_len + 1)
        i: int32 = 0
        while (path[i] != cast[uint8](0)):
            current_dir[current_dir_len] = path[i]
            current_dir_len = (current_dir_len + 1)
            i = (i + 1)
        current_dir[current_dir_len] = cast[uint8](0)

def cmd_cat(file: Ptr[uint8]):
    if (str_len(file) == 0):
        print_error(Ptr[uint8]("Usage: cat <file>"))
        return
    if (str_eq(file, Ptr[uint8]("/etc/passwd")) != 0):
        print_line(Ptr[uint8]("root:x:0:0:root:/root:/bin/sh"), TEXT_R, TEXT_G, TEXT_B)
        print_line(Ptr[uint8]("nobody:x:65534:65534:Nobody:/:/sbin/nologin"), TEXT_R, TEXT_G, TEXT_B)
    elif (str_eq(file, Ptr[uint8]("/etc/hostname")) != 0):
        print_line(Ptr[uint8]("poodillion"), TEXT_R, TEXT_G, TEXT_B)
    elif (str_eq(file, Ptr[uint8]("/proc/version")) != 0):
        print_line(Ptr[uint8]("PoodillionOS version 0.1 (brainhair@poodillion)"), TEXT_R, TEXT_G, TEXT_B)
        print_line(Ptr[uint8]("Brainhair Compiler v0.1"), TEXT_R, TEXT_G, TEXT_B)
    else:
        print_error(Ptr[uint8]("cat: No such file or directory"))

def cmd_uname():
    print_line(Ptr[uint8]("PoodillionOS 0.1 i386"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("Kernel: Brainhair 0.1"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("VTNext Graphics Subsystem"), EXEC_R, EXEC_G, EXEC_B)

def cmd_date():
    print_line(Ptr[uint8]("Thu Dec 26 2024 00:00:00 UTC"), TEXT_R, TEXT_G, TEXT_B)

def cmd_uptime():
    print_line(Ptr[uint8]("up 0 days, 0:00:00"), TEXT_R, TEXT_G, TEXT_B)

def cmd_ps():
    print_line(Ptr[uint8]("  PID  TTY      TIME CMD"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("    1  tty1     0:00 init"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("    2  tty1     0:00 vtn_shell"), EXEC_R, EXEC_G, EXEC_B)

def cmd_free():
    print_line(Ptr[uint8]("              total        used        free"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("Mem:          128M         32M         96M"), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("Swap:           0B          0B          0B"), TEXT_R, TEXT_G, TEXT_B)

def cmd_history_show():
    i: int32 = 0
    line: Array[280, uint8]
    while (i < history_count):
        pos: int32 = 0
        line[pos] = cast[uint8](32)
        pos = (pos + 1)
        line[pos] = cast[uint8](32)
        pos = (pos + 1)
        num: int32 = (i + 1)
        digits: Array[10, uint8]
        dcount: int32 = 0
        if (num == 0):
            digits[0] = cast[uint8](48)
            dcount = 1
        else:
            while (num > 0):
                digits[dcount] = cast[uint8]((48 + (num - ((num / 10) * 10))))
                num = (num / 10)
                dcount = (dcount + 1)
        j: int32 = (dcount - 1)
        while (j >= 0):
            line[pos] = digits[j]
            pos = (pos + 1)
            j = (j - 1)
        line[pos] = cast[uint8](32)
        pos = (pos + 1)
        line[pos] = cast[uint8](32)
        pos = (pos + 1)
        hist: Ptr[uint8] = history_get(i)
        j = 0
        while (hist[j] != cast[uint8](0)):
            line[pos] = hist[j]
            pos = (pos + 1)
            j = (j + 1)
        line[pos] = cast[uint8](0)
        print_line(Ptr[uint8](addr(line)), TEXT_R, TEXT_G, TEXT_B)
        i = (i + 1)

def execute_command():
    if (cmd_len == 0):
        return
    cmd_buffer[cmd_len] = cast[uint8](0)
    history_add(Ptr[uint8](addr(cmd_buffer)))
    echo_line: Array[280, uint8]
    pos: int32 = 0
    echo_line[pos] = cast[uint8](36)
    pos = (pos + 1)
    echo_line[pos] = cast[uint8](32)
    pos = (pos + 1)
    i: int32 = 0
    while (i < cmd_len):
        echo_line[pos] = cmd_buffer[i]
        pos = (pos + 1)
        i = (i + 1)
    echo_line[pos] = cast[uint8](0)
    print_line(Ptr[uint8](addr(echo_line)), PROMPT_R, PROMPT_G, PROMPT_B)
    cmd_end: int32 = 0
    while ((cmd_end < cmd_len) and (cmd_buffer[cmd_end] != cast[uint8](32))):
        cmd_end = (cmd_end + 1)
    args_start: int32 = cmd_end
    while ((args_start < cmd_len) and (cmd_buffer[args_start] == cast[uint8](32))):
        args_start = (args_start + 1)
    saved: uint8 = cmd_buffer[cmd_end]
    cmd_buffer[cmd_end] = cast[uint8](0)
    cmd: Ptr[uint8] = Ptr[uint8](addr(cmd_buffer))
    args: Ptr[uint8] = Ptr[uint8](addr(cmd_buffer[args_start]))
    if (str_eq(cmd, Ptr[uint8]("help")) != 0):
        cmd_help()
    elif (str_eq(cmd, Ptr[uint8]("clear")) != 0):
        cmd_clear()
    elif (str_eq(cmd, Ptr[uint8]("echo")) != 0):
        cmd_echo(args)
    elif (str_eq(cmd, Ptr[uint8]("ls")) != 0):
        cmd_ls()
    elif (str_eq(cmd, Ptr[uint8]("pwd")) != 0):
        cmd_pwd()
    elif (str_eq(cmd, Ptr[uint8]("cd")) != 0):
        cmd_cd(args)
    elif (str_eq(cmd, Ptr[uint8]("cat")) != 0):
        cmd_cat(args)
    elif (str_eq(cmd, Ptr[uint8]("uname")) != 0):
        cmd_uname()
    elif (str_eq(cmd, Ptr[uint8]("date")) != 0):
        cmd_date()
    elif (str_eq(cmd, Ptr[uint8]("uptime")) != 0):
        cmd_uptime()
    elif (str_eq(cmd, Ptr[uint8]("ps")) != 0):
        cmd_ps()
    elif (str_eq(cmd, Ptr[uint8]("free")) != 0):
        cmd_free()
    elif (str_eq(cmd, Ptr[uint8]("history")) != 0):
        cmd_history_show()
    elif (str_eq(cmd, Ptr[uint8]("exit")) != 0):
        running = 0
    elif (str_eq(cmd, Ptr[uint8]("quit")) != 0):
        running = 0
    else:
        if (str_eq(cmd, Ptr[uint8]("pong")) != 0):
            print_info(Ptr[uint8]("Launching pong..."))
            print_info(Ptr[uint8]("(In real system: exec /bin/vtn_pong)"))
        elif (str_eq(cmd, Ptr[uint8]("2048")) != 0):
            print_info(Ptr[uint8]("Launching 2048..."))
            print_info(Ptr[uint8]("(In real system: exec /bin/2048)"))
        elif (str_eq(cmd, Ptr[uint8]("edit")) != 0):
            print_info(Ptr[uint8]("Launching editor..."))
            print_info(Ptr[uint8]("(In real system: exec /bin/vtn_edit)"))
        elif (str_eq(cmd, Ptr[uint8]("term")) != 0):
            print_info(Ptr[uint8]("Launching terminal..."))
            print_info(Ptr[uint8]("(In real system: exec /bin/vtn_term)"))
        elif (str_eq(cmd, Ptr[uint8]("demo")) != 0):
            print_info(Ptr[uint8]("Launching VTNext demo..."))
            print_info(Ptr[uint8]("(In real system: exec /bin/vtn_demo)"))
        else:
            cmd_buffer[cmd_end] = saved
            err: Array[300, uint8]
            pos = 0
            err[pos] = cast[uint8](45)
            pos = (pos + 1)
            err[pos] = cast[uint8](98)
            pos = (pos + 1)
            err[pos] = cast[uint8](115)
            pos = (pos + 1)
            err[pos] = cast[uint8](104)
            pos = (pos + 1)
            err[pos] = cast[uint8](58)
            pos = (pos + 1)
            err[pos] = cast[uint8](32)
            pos = (pos + 1)
            i = 0
            while (i < cmd_end):
                err[pos] = cmd_buffer[i]
                pos = (pos + 1)
                i = (i + 1)
            err[pos] = cast[uint8](58)
            pos = (pos + 1)
            err[pos] = cast[uint8](32)
            pos = (pos + 1)
            msg: Ptr[uint8] = Ptr[uint8]("command not found")
            i = 0
            while (msg[i] != cast[uint8](0)):
                err[pos] = msg[i]
                pos = (pos + 1)
                i = (i + 1)
            err[pos] = cast[uint8](0)
            print_error(Ptr[uint8](addr(err)))
    cmd_buffer[cmd_end] = saved
    cmd_len = 0
    cursor_pos = 0

def render():
    vtn_clear_color(BG_R, BG_G, BG_B, 255)
    vtn_fill_rect(0, 0, SCREEN_WIDTH, HEADER_HEIGHT, HEADER_R, HEADER_G, HEADER_B, 255)
    vtn_text_simple(Ptr[uint8]("PoodillionOS VTNext Shell"), 10, 7, 200, 210, 220)
    vtn_text_simple(Ptr[uint8]("v0.1"), 280, 7, 150, 160, 170)
    if (current_dir_len > 0):
        vtn_text_simple(Ptr[uint8](addr(current_dir)), (SCREEN_WIDTH - 300), 7, 100, 180, 255)
    else:
        vtn_text_simple(Ptr[uint8]("/"), (SCREEN_WIDTH - 300), 7, 100, 180, 255)
    y: int32 = CONTENT_TOP
    i: int32 = 0
    while ((i < MAX_VISIBLE_LINES) and ((scroll_offset + i) < output_count)):
        line_idx: int32 = (scroll_offset + i)
        line: Ptr[uint8] = get_output_line(line_idx)
        real_idx: int32 = (output_head + line_idx)
        if (real_idx >= MAX_OUTPUT_LINES):
            real_idx = (real_idx - MAX_OUTPUT_LINES)
        r: int32 = cast[int32](output_colors_r[real_idx])
        g: int32 = cast[int32](output_colors_g[real_idx])
        b: int32 = cast[int32](output_colors_b[real_idx])
        vtn_text_simple(line, CONTENT_LEFT, y, r, g, b)
        y = (y + CHAR_HEIGHT)
        i = (i + 1)
    prompt_y: int32 = (SCREEN_HEIGHT - PROMPT_HEIGHT)
    vtn_fill_rect(0, prompt_y, SCREEN_WIDTH, PROMPT_HEIGHT, PROMPT_BG_R, PROMPT_BG_G, PROMPT_BG_B, 255)
    prompt_text: Array[32, uint8]
    pos: int32 = 0
    prompt_text[pos] = cast[uint8](36)
    pos = (pos + 1)
    prompt_text[pos] = cast[uint8](32)
    pos = (pos + 1)
    prompt_text[pos] = cast[uint8](0)
    vtn_text_simple(Ptr[uint8](addr(prompt_text)), CONTENT_LEFT, (prompt_y + 12), PROMPT_R, PROMPT_G, PROMPT_B)
    if (cmd_len > 0):
        cmd_buffer[cmd_len] = cast[uint8](0)
        vtn_text_simple(Ptr[uint8](addr(cmd_buffer)), (CONTENT_LEFT + 20), (prompt_y + 12), CMD_R, CMD_G, CMD_B)
    if (cursor_visible != 0):
        cursor_x: int32 = ((CONTENT_LEFT + 20) + (cursor_pos * CHAR_WIDTH))
        cursor_y: int32 = (prompt_y + 10)
        vtn_fill_rect(cursor_x, cursor_y, 2, CHAR_HEIGHT, CURSOR_R, CURSOR_G, CURSOR_B, 255)
    if (output_count > MAX_VISIBLE_LINES):
        scroll_total: int32 = (output_count - MAX_VISIBLE_LINES)
        scroll_pct: int32 = 0
        if (scroll_total > 0):
            scroll_pct = ((scroll_offset * 100) / scroll_total)
        indicator_h: int32 = 50
        indicator_y: int32 = (CONTENT_TOP + (((((SCREEN_HEIGHT - HEADER_HEIGHT) - PROMPT_HEIGHT) - indicator_h) * scroll_pct) / 100))
        vtn_fill_rect((SCREEN_WIDTH - 8), indicator_y, 4, indicator_h, 80, 90, 110, 200)
    vtn_flush()

def handle_input():
    buf: Array[16, uint8]
    n: int32 = syscall3(SYS_read, STDIN, cast[int32](buf), 16)
    if (n <= 0):
        return
    i: int32 = 0
    while (i < n):
        c: int32 = cast[int32](buf[i])
        if ((c == 27) and ((i + 2) < n)):
            if (buf[(i + 1)] == cast[uint8](91)):
                code: int32 = cast[int32](buf[(i + 2)])
                if (code == 65):
                    if (history_pos > 0):
                        history_pos = (history_pos - 1)
                        hist: Ptr[uint8] = history_get(history_pos)
                        cmd_len = str_copy(Ptr[uint8](addr(cmd_buffer)), hist)
                        cursor_pos = cmd_len
                elif (code == 66):
                    if (history_pos < (history_count - 1)):
                        history_pos = (history_pos + 1)
                        hist: Ptr[uint8] = history_get(history_pos)
                        cmd_len = str_copy(Ptr[uint8](addr(cmd_buffer)), hist)
                        cursor_pos = cmd_len
                    elif (history_pos == (history_count - 1)):
                        history_pos = history_count
                        cmd_len = 0
                        cursor_pos = 0
                elif (code == 67):
                    if (cursor_pos < cmd_len):
                        cursor_pos = (cursor_pos + 1)
                elif (code == 68):
                    if (cursor_pos > 0):
                        cursor_pos = (cursor_pos - 1)
                elif (code == 53):
                    if (((i + 3) < n) and (buf[(i + 3)] == cast[uint8](126))):
                        scroll_offset = (scroll_offset - 10)
                        if (scroll_offset < 0):
                            scroll_offset = 0
                        i = (i + 1)
                elif (code == 54):
                    if (((i + 3) < n) and (buf[(i + 3)] == cast[uint8](126))):
                        scroll_offset = (scroll_offset + 10)
                        max_scroll: int32 = (output_count - MAX_VISIBLE_LINES)
                        if (max_scroll < 0):
                            max_scroll = 0
                        if (scroll_offset > max_scroll):
                            scroll_offset = max_scroll
                        i = (i + 1)
                i = (i + 3)
                continue
        if (c == 3):
            cmd_len = 0
            cursor_pos = 0
            print_line(Ptr[uint8]("^C"), ERROR_R, ERROR_G, ERROR_B)
        elif (c == 12):
            cmd_clear()
        elif (c == 17):
            running = 0
        elif ((c == 10) or (c == 13)):
            execute_command()
        elif ((c == 8) or (c == 127)):
            if (cursor_pos > 0):
                j: int32 = (cursor_pos - 1)
                while (j < (cmd_len - 1)):
                    cmd_buffer[j] = cmd_buffer[(j + 1)]
                    j = (j + 1)
                cmd_len = (cmd_len - 1)
                cursor_pos = (cursor_pos - 1)
        elif (c == 9):

        elif ((c >= 32) and (c < 127)):
            if (cmd_len < (MAX_CMD_LEN - 1)):
                j: int32 = cmd_len
                while (j > cursor_pos):
                    cmd_buffer[j] = cmd_buffer[(j - 1)]
                    j = (j - 1)
                cmd_buffer[cursor_pos] = cast[uint8](c)
                cmd_len = (cmd_len + 1)
                cursor_pos = (cursor_pos + 1)
        i = (i + 1)

def main() -> int32:
    vtn_init_raw()
    vtn_cursor_hide()
    vtn_flush()
    flags: int32 = syscall2(SYS_fcntl, STDIN, F_GETFL)
    syscall3(SYS_fcntl, STDIN, F_SETFL, (flags | O_NONBLOCK))
    current_dir[0] = cast[uint8](47)
    current_dir[1] = cast[uint8](0)
    current_dir_len = 1
    print_line(Ptr[uint8](""), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8]("Welcome to PoodillionOS VTNext Shell!"), EXEC_R, EXEC_G, EXEC_B)
    print_line(Ptr[uint8]("Type 'help' for available commands."), TEXT_R, TEXT_G, TEXT_B)
    print_line(Ptr[uint8](""), TEXT_R, TEXT_G, TEXT_B)
    while (running != 0):
        handle_input()
        blink_counter = (blink_counter + 1)
        if (blink_counter >= 20):
            blink_counter = 0
            cursor_visible = (1 - cursor_visible)
        render()
        sleep_ms(16)
    syscall3(SYS_fcntl, STDIN, F_SETFL, flags)
    vtn_cursor_show()
    vtn_clear_color(0, 0, 0, 255)
    vtn_flush()
    return 0