# calc - Brainhair Calculator
# A simple graphical calculator with clickable buttons

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_ioctl: int32 = 54
const SYS_mmap2: int32 = 192

const STDOUT: int32 = 1
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8

# Calculator layout constants
const CALC_WIDTH: int32 = 240
const CALC_HEIGHT: int32 = 320
const DISPLAY_HEIGHT: int32 = 40
const BUTTON_SIZE: int32 = 50
const BUTTON_SPACING: int32 = 10
const CALC_MARGIN: int32 = 10

# Colors
const BG_COLOR: int32 = 0x2C2C2C
const DISPLAY_BG: int32 = 0x1A1A1A
const DISPLAY_FG: int32 = 0x00FF00
const BUTTON_BG: int32 = 0x404040
const BUTTON_NUM_BG: int32 = 0x505050
const BUTTON_OP_BG: int32 = 0x3060A0
const BUTTON_FG: int32 = 0xFFFFFF

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32
extern proc fast_memcpy(dst: int32, src: int32, count_bytes: int32)

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

# ============ Drawing Primitives ============

proc buf_pixel(buf: ptr uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

proc fill_rect(buf: ptr uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      var cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc get_font_row(c: int32, row: int32): int32 =
  # 8x8 bitmap font - returns 8 bits for each row
  if c == 32: return 0  # space

  # Numbers 0-9 (48-57)
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0
  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0
  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  # Plus sign (43)
  if c == 43:
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x18
    if row == 3: return 0x7E
    if row == 4: return 0x18
    if row == 5: return 0x00
    if row == 6: return 0x00
    return 0

  # Minus/hyphen (45)
  if c == 45:
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x00
    if row == 3: return 0x7E
    if row == 4: return 0x00
    if row == 5: return 0x00
    if row == 6: return 0x00
    return 0

  # Asterisk (42)
  if c == 42:
    if row == 0: return 0x00
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0xFF
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x00
    return 0

  # Slash (47)
  if c == 47:
    if row == 0: return 0x06
    if row == 1: return 0x0C
    if row == 2: return 0x18
    if row == 3: return 0x30
    if row == 4: return 0x60
    if row == 5: return 0x40
    if row == 6: return 0x00
    return 0

  # Equals (61)
  if c == 61:
    if row == 0: return 0x00
    if row == 1: return 0x00
    if row == 2: return 0x7E
    if row == 3: return 0x00
    if row == 4: return 0x7E
    if row == 5: return 0x00
    if row == 6: return 0x00
    return 0

  # C
  if c == 67:
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0

  return 0

proc draw_char(buf: ptr uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

proc draw_text(buf: ptr uint32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, yres: int32, max_chars: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0) and i < max_chars:
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

# ============ Calculator Logic ============

proc int_to_str(n: int32, buf: ptr uint8): int32 =
  # Convert integer to string, return length
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    return 1
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  # Reverse the string
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  return i

proc str_len(s: ptr uint8): int32 =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  return len

proc str_copy(dst: ptr uint8, src: ptr uint8) =
  var i: int32 = 0
  while src[i] != cast[uint8](0):
    dst[i] = src[i]
    i = i + 1
  dst[i] = cast[uint8](0)

proc str_append_char(s: ptr uint8, c: uint8) =
  var len: int32 = str_len(s)
  s[len] = c
  s[len + 1] = cast[uint8](0)

proc str_to_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  var neg: int32 = 0
  if s[0] == cast[uint8](45):  # minus sign
    neg = 1
    i = 1
  while s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  if neg != 0:
    result = 0 - result
  return result

# ============ Calculator UI ============

proc draw_button(buf: ptr uint32, x: int32, y: int32, label: ptr uint8, bg: int32, xres: int32, yres: int32) =
  # Draw button background
  fill_rect(buf, x, y, BUTTON_SIZE, BUTTON_SIZE, bg, xres, yres)
  # Draw border (lighter on top/left, darker on bottom/right for 3D effect)
  fill_rect(buf, x, y, BUTTON_SIZE, 2, bg + 0x202020, xres, yres)
  fill_rect(buf, x, y, 2, BUTTON_SIZE, bg + 0x202020, xres, yres)
  fill_rect(buf, x, y + BUTTON_SIZE - 2, BUTTON_SIZE, 2, bg - 0x202020, xres, yres)
  fill_rect(buf, x + BUTTON_SIZE - 2, y, 2, BUTTON_SIZE, bg - 0x202020, xres, yres)
  # Draw centered label
  var len: int32 = str_len(label)
  var text_x: int32 = x + (BUTTON_SIZE - len * FONT_WIDTH) / 2
  var text_y: int32 = y + (BUTTON_SIZE - FONT_HEIGHT) / 2
  draw_text(buf, text_x, text_y, label, BUTTON_FG, bg, xres, yres, 3)

proc get_button_at(px: int32, py: int32, calc_x: int32, calc_y: int32): int32 =
  # Returns button id: 0-9 for digits, 10=+, 11=-, 12=*, 13=/, 14==, 15=C, -1=none
  var by: int32 = calc_y + DISPLAY_HEIGHT + CALC_MARGIN
  var bx: int32 = calc_x + CALC_MARGIN

  # Check if in button area
  if py < by or py >= calc_y + CALC_HEIGHT - CALC_MARGIN:
    return -1
  if px < bx or px >= calc_x + CALC_WIDTH - CALC_MARGIN:
    return -1

  # Calculate row and column (4 rows of 4 buttons)
  var rel_y: int32 = py - by
  var rel_x: int32 = px - bx
  var row: int32 = rel_y / (BUTTON_SIZE + BUTTON_SPACING)
  var col: int32 = rel_x / (BUTTON_SIZE + BUTTON_SPACING)

  if row < 0 or row >= 5 or col < 0 or col >= 4:
    return -1

  # Check if within button (not in spacing)
  var in_button_y: int32 = rel_y - row * (BUTTON_SIZE + BUTTON_SPACING)
  var in_button_x: int32 = rel_x - col * (BUTTON_SIZE + BUTTON_SPACING)
  if in_button_y >= BUTTON_SIZE or in_button_x >= BUTTON_SIZE:
    return -1

  # Layout: Row 0: 7 8 9 /
  #         Row 1: 4 5 6 *
  #         Row 2: 1 2 3 -
  #         Row 3: C 0 = +
  if row == 0:
    if col == 0: return 7
    if col == 1: return 8
    if col == 2: return 9
    if col == 3: return 13  # /
  if row == 1:
    if col == 0: return 4
    if col == 1: return 5
    if col == 2: return 6
    if col == 3: return 12  # *
  if row == 2:
    if col == 0: return 1
    if col == 1: return 2
    if col == 2: return 3
    if col == 3: return 11  # -
  if row == 3:
    if col == 0: return 15  # C
    if col == 1: return 0
    if col == 2: return 14  # =
    if col == 3: return 10  # +
  return -1

proc draw_calculator(buf: ptr uint32, calc_x: int32, calc_y: int32, display: ptr uint8, xres: int32, yres: int32) =
  # Draw calculator background
  fill_rect(buf, calc_x, calc_y, CALC_WIDTH, CALC_HEIGHT, BG_COLOR, xres, yres)

  # Draw display
  fill_rect(buf, calc_x + CALC_MARGIN, calc_y + CALC_MARGIN,
            CALC_WIDTH - CALC_MARGIN * 2, DISPLAY_HEIGHT, DISPLAY_BG, xres, yres)

  # Draw display text (right-aligned)
  var len: int32 = str_len(display)
  var text_x: int32 = calc_x + CALC_WIDTH - CALC_MARGIN - 8 - len * FONT_WIDTH
  if text_x < calc_x + CALC_MARGIN + 4:
    text_x = calc_x + CALC_MARGIN + 4
  var text_y: int32 = calc_y + CALC_MARGIN + (DISPLAY_HEIGHT - FONT_HEIGHT) / 2
  draw_text(buf, text_x, text_y, display, DISPLAY_FG, DISPLAY_BG, xres, yres, 20)

  # Draw buttons (4x4 grid)
  var by: int32 = calc_y + DISPLAY_HEIGHT + CALC_MARGIN * 2
  var bx: int32 = calc_x + CALC_MARGIN

  # Row 0: 7 8 9 /
  draw_button(buf, bx, by, cast[ptr uint8]("7"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[ptr uint8]("8"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[ptr uint8]("9"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[ptr uint8]("/"), BUTTON_OP_BG, xres, yres)

  # Row 1: 4 5 6 *
  by = by + BUTTON_SIZE + BUTTON_SPACING
  draw_button(buf, bx, by, cast[ptr uint8]("4"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[ptr uint8]("5"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[ptr uint8]("6"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[ptr uint8]("*"), BUTTON_OP_BG, xres, yres)

  # Row 2: 1 2 3 -
  by = by + BUTTON_SIZE + BUTTON_SPACING
  draw_button(buf, bx, by, cast[ptr uint8]("1"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[ptr uint8]("2"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[ptr uint8]("3"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[ptr uint8]("-"), BUTTON_OP_BG, xres, yres)

  # Row 3: C 0 = +
  by = by + BUTTON_SIZE + BUTTON_SPACING
  draw_button(buf, bx, by, cast[ptr uint8]("C"), BUTTON_BG, xres, yres)
  draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[ptr uint8]("0"), BUTTON_NUM_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[ptr uint8]("="), BUTTON_OP_BG, xres, yres)
  draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[ptr uint8]("+"), BUTTON_OP_BG, xres, yres)

proc perform_operation(a: int32, b: int32, op: int32): int32 =
  if op == 10: return a + b  # +
  if op == 11: return a - b  # -
  if op == 12: return a * b  # *
  if op == 13:  # /
    if b == 0: return 0  # Avoid division by zero
    return a / b
  return 0

# ============ Main ============

proc main() =
  print_str(cast[ptr uint8]("Calculator starting...\n"))

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 8192)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 256)
  var display_buf: ptr uint8 = cast[ptr uint8](old_brk + 512)
  var temp_buf: ptr uint8 = cast[ptr uint8](old_brk + 768)

  const FBIOGET_VSCREENINFO: int32 = 0x4600
  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # mmap framebuffer
  var buf_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    print_str(cast[ptr uint8]("Error: mmap failed\n"))
    discard syscall1(SYS_exit, 1)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open mouse\n"))
    discard syscall1(SYS_exit, 1)
  var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
  discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Calculator state
  display_buf[0] = cast[uint8](48)  # "0"
  display_buf[1] = cast[uint8](0)
  var current_value: int32 = 0
  var stored_value: int32 = 0
  var operation: int32 = -1  # -1=none, 10=+, 11=-, 12=*, 13=/
  var new_number: int32 = 1  # Flag: 1=next digit starts new number

  # Mouse state
  var mouse_x: int32 = xres / 2
  var mouse_y: int32 = yres / 2
  var mouse_btn: int32 = 0
  var prev_btn: int32 = 0

  # Calculator position (centered)
  var calc_x: int32 = (xres - CALC_WIDTH) / 2
  var calc_y: int32 = (yres - CALC_HEIGHT) / 2

  # Initial draw
  fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
  draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)

  var running: int32 = 1
  while running != 0:
    # Read mouse
    prev_btn = mouse_btn
    var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
    var got_mouse: int32 = 0

    while bytes >= 3:
      got_mouse = 1
      var btns: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      if (btns & 0x10) != 0: dx = dx - 256
      if (btns & 0x20) != 0: dy = dy - 256

      mouse_x = mouse_x + dx
      mouse_y = mouse_y - dy
      if mouse_x < 0: mouse_x = 0
      if mouse_x >= xres: mouse_x = xres - 1
      if mouse_y < 0: mouse_y = 0
      if mouse_y >= yres: mouse_y = yres - 1

      mouse_btn = btns & 0x07
      bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

    # Handle button clicks
    var left_pressed: int32 = (mouse_btn & 1) != 0 and (prev_btn & 1) == 0

    if left_pressed != 0:
      var button: int32 = get_button_at(mouse_x, mouse_y, calc_x, calc_y)

      if button >= 0 and button <= 9:
        # Digit button
        if new_number != 0:
          display_buf[0] = cast[uint8](48 + button)
          display_buf[1] = cast[uint8](0)
          new_number = 0
        else:
          var len: int32 = str_len(display_buf)
          if len < 15:  # Limit display length
            str_append_char(display_buf, cast[uint8](48 + button))
        current_value = str_to_int(display_buf)

      if button == 15:  # C (clear)
        display_buf[0] = cast[uint8](48)
        display_buf[1] = cast[uint8](0)
        current_value = 0
        stored_value = 0
        operation = -1
        new_number = 1

      if button == 10 or button == 11 or button == 12 or button == 13:
        # Operation buttons
        if operation != -1 and new_number == 0:
          # Perform pending operation first
          var result: int32 = perform_operation(stored_value, current_value, operation)
          discard int_to_str(result, display_buf)
          current_value = result
        stored_value = current_value
        operation = button
        new_number = 1

      if button == 14:  # = (equals)
        if operation != -1:
          var result: int32 = perform_operation(stored_value, current_value, operation)
          discard int_to_str(result, display_buf)
          current_value = result
          operation = -1
        new_number = 1

      # Redraw calculator
      fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
      draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)

    if got_mouse != 0:
      # Redraw cursor on screen
      fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
      draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)
      # Draw simple cursor
      fill_rect(framebuffer, mouse_x, mouse_y, 2, 10, 0xFFFFFF, xres, yres)
      fill_rect(framebuffer, mouse_x, mouse_y, 10, 2, 0xFFFFFF, xres, yres)

  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_exit, 0)

main()
