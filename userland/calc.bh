# calc - Brainhair Calculator
# A simple graphical calculator with clickable buttons

from lib.syscalls import *

O_NONBLOCK: int32 = 2048
F_SETFL: int32 = 4
F_GETFL: int32 = 3

PROT_READ: int32 = 1
PROT_WRITE: int32 = 2
MAP_SHARED: int32 = 1

FONT_WIDTH: int32 = 8
FONT_HEIGHT: int32 = 8

# Calculator layout constants
CALC_WIDTH: int32 = 240
CALC_HEIGHT: int32 = 320
DISPLAY_HEIGHT: int32 = 40
BUTTON_SIZE: int32 = 50
BUTTON_SPACING: int32 = 10
CALC_MARGIN: int32 = 10

# Colors
BG_COLOR: int32 = 0x2C2C2C
DISPLAY_BG: int32 = 0x1A1A1A
DISPLAY_FG: int32 = 0x00FF00
BUTTON_BG: int32 = 0x404040
BUTTON_NUM_BG: int32 = 0x505050
BUTTON_OP_BG: int32 = 0x3060A0
BUTTON_FG: int32 = 0xFFFFFF

extern def fast_memcpy(dst: int32, src: int32, count_bytes: int32)

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def print_num(n: int32):
    buf: *uint8 = cast[*uint8](0)
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 16)
    buf = cast[*uint8](old_brk)
    if n == 0:
        buf[0] = cast[uint8](48)
        buf[1] = cast[uint8](0)
        print_str(buf)
        return
    neg: int32 = 0
    tmp: int32 = n
    if n < 0:
        neg = 1
        tmp = 0 - n
    i: int32 = 0
    while tmp > 0:
        buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
        tmp = tmp / 10
        i = i + 1
    if neg != 0:
        buf[i] = cast[uint8](45)
        i = i + 1
    buf[i] = cast[uint8](0)
    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        t: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = t
        j = j + 1
        k = k - 1
    print_str(buf)

# ============ Drawing Primitives ============

def buf_pixel(buf: *uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32):
    if x >= 0 and x < xres and y >= 0 and y < yres:
        buf[y * xres + x] = cast[uint32](color)

def fill_rect(buf: *uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32):
    cy: int32 = y
    while cy < y + h:
        if cy >= 0 and cy < yres:
            sx: int32 = x
            ex: int32 = x + w
            if sx < 0: sx = 0
            if ex > xres: ex = xres
            cx: int32 = sx
            while cx < ex:
                buf[cy * xres + cx] = cast[uint32](color)
                cx = cx + 1
        cy = cy + 1

def get_font_row(c: int32, row: int32) -> int32:
    # 8x8 bitmap font - returns 8 bits for each row
    if c == 32: return 0  # space

    # Numbers 0-9 (48-57)
    if c == 48:  # 0
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x6E
        if row == 3: return 0x76
        if row == 4: return 0x66
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0
    if c == 49:  # 1
        if row == 0: return 0x18
        if row == 1: return 0x38
        if row == 2: return 0x18
        if row == 3: return 0x18
        if row == 4: return 0x18
        if row == 5: return 0x18
        if row == 6: return 0x7E
        return 0
    if c == 50:  # 2
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x06
        if row == 3: return 0x0C
        if row == 4: return 0x18
        if row == 5: return 0x30
        if row == 6: return 0x7E
        return 0
    if c == 51:  # 3
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x06
        if row == 3: return 0x1C
        if row == 4: return 0x06
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0
    if c == 52:  # 4
        if row == 0: return 0x0C
        if row == 1: return 0x1C
        if row == 2: return 0x3C
        if row == 3: return 0x6C
        if row == 4: return 0x7E
        if row == 5: return 0x0C
        if row == 6: return 0x0C
        return 0
    if c == 53:  # 5
        if row == 0: return 0x7E
        if row == 1: return 0x60
        if row == 2: return 0x7C
        if row == 3: return 0x06
        if row == 4: return 0x06
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0
    if c == 54:  # 6
        if row == 0: return 0x1C
        if row == 1: return 0x30
        if row == 2: return 0x60
        if row == 3: return 0x7C
        if row == 4: return 0x66
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0
    if c == 55:  # 7
        if row == 0: return 0x7E
        if row == 1: return 0x06
        if row == 2: return 0x0C
        if row == 3: return 0x18
        if row == 4: return 0x18
        if row == 5: return 0x18
        if row == 6: return 0x18
        return 0
    if c == 56:  # 8
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x66
        if row == 3: return 0x3C
        if row == 4: return 0x66
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0
    if c == 57:  # 9
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x66
        if row == 3: return 0x3E
        if row == 4: return 0x06
        if row == 5: return 0x0C
        if row == 6: return 0x38
        return 0

    # Plus sign (43)
    if c == 43:
        if row == 0: return 0x00
        if row == 1: return 0x00
        if row == 2: return 0x18
        if row == 3: return 0x7E
        if row == 4: return 0x18
        if row == 5: return 0x00
        if row == 6: return 0x00
        return 0

    # Minus/hyphen (45)
    if c == 45:
        if row == 0: return 0x00
        if row == 1: return 0x00
        if row == 2: return 0x00
        if row == 3: return 0x7E
        if row == 4: return 0x00
        if row == 5: return 0x00
        if row == 6: return 0x00
        return 0

    # Asterisk (42)
    if c == 42:
        if row == 0: return 0x00
        if row == 1: return 0x66
        if row == 2: return 0x3C
        if row == 3: return 0xFF
        if row == 4: return 0x3C
        if row == 5: return 0x66
        if row == 6: return 0x00
        return 0

    # Slash (47)
    if c == 47:
        if row == 0: return 0x06
        if row == 1: return 0x0C
        if row == 2: return 0x18
        if row == 3: return 0x30
        if row == 4: return 0x60
        if row == 5: return 0x40
        if row == 6: return 0x00
        return 0

    # Equals (61)
    if c == 61:
        if row == 0: return 0x00
        if row == 1: return 0x00
        if row == 2: return 0x7E
        if row == 3: return 0x00
        if row == 4: return 0x7E
        if row == 5: return 0x00
        if row == 6: return 0x00
        return 0

    # C
    if c == 67:
        if row == 0: return 0x3C
        if row == 1: return 0x66
        if row == 2: return 0x60
        if row == 3: return 0x60
        if row == 4: return 0x60
        if row == 5: return 0x66
        if row == 6: return 0x3C
        return 0

    return 0

def draw_char(buf: *uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32):
    row: int32 = 0
    while row < 8:
        bitmap: int32 = get_font_row(c, row)
        col: int32 = 0
        while col < 8:
            bit: int32 = (bitmap >> (7 - col)) & 1
            color: int32 = bg
            if bit != 0: color = fg
            buf_pixel(buf, x + col, y + row, color, xres, yres)
            col = col + 1
        row = row + 1

def draw_text(buf: *uint32, x: int32, y: int32, s: *uint8, fg: int32, bg: int32, xres: int32, yres: int32, max_chars: int32):
    i: int32 = 0
    while s[i] != cast[uint8](0) and i < max_chars:
        draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
        i = i + 1

# ============ Calculator Logic ============

def int_to_str(n: int32, buf: *uint8) -> int32:
    # Convert integer to string, return length
    if n == 0:
        buf[0] = cast[uint8](48)
        buf[1] = cast[uint8](0)
        return 1
    neg: int32 = 0
    tmp: int32 = n
    if n < 0:
        neg = 1
        tmp = 0 - n
    i: int32 = 0
    while tmp > 0:
        buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
        tmp = tmp / 10
        i = i + 1
    if neg != 0:
        buf[i] = cast[uint8](45)
        i = i + 1
    buf[i] = cast[uint8](0)
    # Reverse the string
    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        t: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = t
        j = j + 1
        k = k - 1
    return i

def str_len(s: *uint8) -> int32:
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    return len

def str_copy(dst: *uint8, src: *uint8):
    i: int32 = 0
    while src[i] != cast[uint8](0):
        dst[i] = src[i]
        i = i + 1
    dst[i] = cast[uint8](0)

def str_append_char(s: *uint8, c: uint8):
    len: int32 = str_len(s)
    s[len] = c
    s[len + 1] = cast[uint8](0)

def str_to_int(s: *uint8) -> int32:
    result: int32 = 0
    i: int32 = 0
    neg: int32 = 0
    if s[0] == cast[uint8](45):  # minus sign
        neg = 1
        i = 1
    while s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
        result = result * 10 + cast[int32](s[i]) - 48
        i = i + 1
    if neg != 0:
        result = 0 - result
    return result

# ============ Calculator UI ============

def draw_button(buf: *uint32, x: int32, y: int32, label: *uint8, bg: int32, xres: int32, yres: int32):
    # Draw button background
    fill_rect(buf, x, y, BUTTON_SIZE, BUTTON_SIZE, bg, xres, yres)
    # Draw border (lighter on top/left, darker on bottom/right for 3D effect)
    fill_rect(buf, x, y, BUTTON_SIZE, 2, bg + 0x202020, xres, yres)
    fill_rect(buf, x, y, 2, BUTTON_SIZE, bg + 0x202020, xres, yres)
    fill_rect(buf, x, y + BUTTON_SIZE - 2, BUTTON_SIZE, 2, bg - 0x202020, xres, yres)
    fill_rect(buf, x + BUTTON_SIZE - 2, y, 2, BUTTON_SIZE, bg - 0x202020, xres, yres)
    # Draw centered label
    len: int32 = str_len(label)
    text_x: int32 = x + (BUTTON_SIZE - len * FONT_WIDTH) / 2
    text_y: int32 = y + (BUTTON_SIZE - FONT_HEIGHT) / 2
    draw_text(buf, text_x, text_y, label, BUTTON_FG, bg, xres, yres, 3)

def get_button_at(px: int32, py: int32, calc_x: int32, calc_y: int32) -> int32:
    # Returns button id: 0-9 for digits, 10=+, 11=-, 12=*, 13=/, 14==, 15=C, -1=none
    by: int32 = calc_y + DISPLAY_HEIGHT + CALC_MARGIN
    bx: int32 = calc_x + CALC_MARGIN

    # Check if in button area
    if py < by or py >= calc_y + CALC_HEIGHT - CALC_MARGIN:
        return -1
    if px < bx or px >= calc_x + CALC_WIDTH - CALC_MARGIN:
        return -1

    # Calculate row and column (4 rows of 4 buttons)
    rel_y: int32 = py - by
    rel_x: int32 = px - bx
    row: int32 = rel_y / (BUTTON_SIZE + BUTTON_SPACING)
    col: int32 = rel_x / (BUTTON_SIZE + BUTTON_SPACING)

    if row < 0 or row >= 5 or col < 0 or col >= 4:
        return -1

    # Check if within button (not in spacing)
    in_button_y: int32 = rel_y - row * (BUTTON_SIZE + BUTTON_SPACING)
    in_button_x: int32 = rel_x - col * (BUTTON_SIZE + BUTTON_SPACING)
    if in_button_y >= BUTTON_SIZE or in_button_x >= BUTTON_SIZE:
        return -1

    # Layout: Row 0: 7 8 9 /
    #         Row 1: 4 5 6 *
    #         Row 2: 1 2 3 -
    #         Row 3: C 0 = +
    if row == 0:
        if col == 0: return 7
        if col == 1: return 8
        if col == 2: return 9
        if col == 3: return 13  # /
    if row == 1:
        if col == 0: return 4
        if col == 1: return 5
        if col == 2: return 6
        if col == 3: return 12  # *
    if row == 2:
        if col == 0: return 1
        if col == 1: return 2
        if col == 2: return 3
        if col == 3: return 11  # -
    if row == 3:
        if col == 0: return 15  # C
        if col == 1: return 0
        if col == 2: return 14  # =
        if col == 3: return 10  # +
    return -1

def draw_calculator(buf: *uint32, calc_x: int32, calc_y: int32, display: *uint8, xres: int32, yres: int32):
    # Draw calculator background
    fill_rect(buf, calc_x, calc_y, CALC_WIDTH, CALC_HEIGHT, BG_COLOR, xres, yres)

    # Draw display
    fill_rect(buf, calc_x + CALC_MARGIN, calc_y + CALC_MARGIN,
              CALC_WIDTH - CALC_MARGIN * 2, DISPLAY_HEIGHT, DISPLAY_BG, xres, yres)

    # Draw display text (right-aligned)
    len: int32 = str_len(display)
    text_x: int32 = calc_x + CALC_WIDTH - CALC_MARGIN - 8 - len * FONT_WIDTH
    if text_x < calc_x + CALC_MARGIN + 4:
        text_x = calc_x + CALC_MARGIN + 4
    text_y: int32 = calc_y + CALC_MARGIN + (DISPLAY_HEIGHT - FONT_HEIGHT) / 2
    draw_text(buf, text_x, text_y, display, DISPLAY_FG, DISPLAY_BG, xres, yres, 20)

    # Draw buttons (4x4 grid)
    by: int32 = calc_y + DISPLAY_HEIGHT + CALC_MARGIN * 2
    bx: int32 = calc_x + CALC_MARGIN

    # Row 0: 7 8 9 /
    draw_button(buf, bx, by, cast[*uint8]("7"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[*uint8]("8"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[*uint8]("9"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[*uint8]("/"), BUTTON_OP_BG, xres, yres)

    # Row 1: 4 5 6 *
    by = by + BUTTON_SIZE + BUTTON_SPACING
    draw_button(buf, bx, by, cast[*uint8]("4"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[*uint8]("5"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[*uint8]("6"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[*uint8]("*"), BUTTON_OP_BG, xres, yres)

    # Row 2: 1 2 3 -
    by = by + BUTTON_SIZE + BUTTON_SPACING
    draw_button(buf, bx, by, cast[*uint8]("1"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[*uint8]("2"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[*uint8]("3"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[*uint8]("-"), BUTTON_OP_BG, xres, yres)

    # Row 3: C 0 = +
    by = by + BUTTON_SIZE + BUTTON_SPACING
    draw_button(buf, bx, by, cast[*uint8]("C"), BUTTON_BG, xres, yres)
    draw_button(buf, bx + BUTTON_SIZE + BUTTON_SPACING, by, cast[*uint8]("0"), BUTTON_NUM_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 2, by, cast[*uint8]("="), BUTTON_OP_BG, xres, yres)
    draw_button(buf, bx + (BUTTON_SIZE + BUTTON_SPACING) * 3, by, cast[*uint8]("+"), BUTTON_OP_BG, xres, yres)

def perform_operation(a: int32, b: int32, op: int32) -> int32:
    if op == 10: return a + b  # +
    if op == 11: return a - b  # -
    if op == 12: return a * b  # *
    if op == 13:  # /
        if b == 0: return 0  # Avoid division by zero
        return a / b
    return 0

# ============ Main ============

def main():
    print_str(cast[*uint8]("Calculator starting...\n"))

    # Open framebuffer
    fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fb_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open /dev/fb0\n"))
        _ = syscall1(SYS_exit, 1)

    # Get screen info
    old_brk: int32 = syscall1(SYS_brk, 0)
    _ = syscall1(SYS_brk, old_brk + 8192)
    vinfo: *uint32 = cast[*uint32](old_brk)
    mouse_buf: *uint8 = cast[*uint8](old_brk + 256)
    display_buf: *uint8 = cast[*uint8](old_brk + 512)
    temp_buf: *uint8 = cast[*uint8](old_brk + 768)

    FBIOGET_VSCREENINFO: int32 = 0x4600
    _ = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    print_str(cast[*uint8]("Screen: "))
    print_num(xres)
    print_str(cast[*uint8]("x"))
    print_num(yres)
    print_str(cast[*uint8]("\n"))

    # mmap framebuffer
    buf_size: int32 = xres * yres * 4
    mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
    framebuffer: *uint32 = cast[*uint32](0)

    mmap_unsigned: uint32 = cast[uint32](mmap_result)
    if mmap_unsigned < cast[uint32](0xFFFFF000):
        framebuffer = cast[*uint32](mmap_result)
    else:
        print_str(cast[*uint8]("Error: mmap failed\n"))
        _ = syscall1(SYS_exit, 1)

    # Open mouse
    mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
    if mouse_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open mouse\n"))
        _ = syscall1(SYS_exit, 1)
    flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
    _ = syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

    # Calculator state
    display_buf[0] = cast[uint8](48)  # "0"
    display_buf[1] = cast[uint8](0)
    current_value: int32 = 0
    stored_value: int32 = 0
    operation: int32 = -1  # -1=none, 10=+, 11=-, 12=*, 13=/
    new_number: int32 = 1  # Flag: 1=next digit starts new number

    # Mouse state
    mouse_x: int32 = xres / 2
    mouse_y: int32 = yres / 2
    mouse_btn: int32 = 0
    prev_btn: int32 = 0

    # Calculator position (centered)
    calc_x: int32 = (xres - CALC_WIDTH) / 2
    calc_y: int32 = (yres - CALC_HEIGHT) / 2

    # Initial draw
    fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
    draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)

    running: int32 = 1
    while running != 0:
        # Read mouse
        prev_btn = mouse_btn
        bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
        got_mouse: int32 = 0

        while bytes >= 3:
            got_mouse = 1
            btns: int32 = cast[int32](mouse_buf[0])
            dx: int32 = cast[int32](mouse_buf[1])
            dy: int32 = cast[int32](mouse_buf[2])

            if (btns & 0x10) != 0: dx = dx - 256
            if (btns & 0x20) != 0: dy = dy - 256

            mouse_x = mouse_x + dx
            mouse_y = mouse_y - dy
            if mouse_x < 0: mouse_x = 0
            if mouse_x >= xres: mouse_x = xres - 1
            if mouse_y < 0: mouse_y = 0
            if mouse_y >= yres: mouse_y = yres - 1

            mouse_btn = btns & 0x07
            bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

        # Handle button clicks
        left_pressed: int32 = (mouse_btn & 1) != 0 and (prev_btn & 1) == 0

        if left_pressed != 0:
            button: int32 = get_button_at(mouse_x, mouse_y, calc_x, calc_y)

            if button >= 0 and button <= 9:
                # Digit button
                if new_number != 0:
                    display_buf[0] = cast[uint8](48 + button)
                    display_buf[1] = cast[uint8](0)
                    new_number = 0
                else:
                    len: int32 = str_len(display_buf)
                    if len < 15:  # Limit display length
                        str_append_char(display_buf, cast[uint8](48 + button))
                current_value = str_to_int(display_buf)

            if button == 15:  # C (clear)
                display_buf[0] = cast[uint8](48)
                display_buf[1] = cast[uint8](0)
                current_value = 0
                stored_value = 0
                operation = -1
                new_number = 1

            if button == 10 or button == 11 or button == 12 or button == 13:
                # Operation buttons
                if operation != -1 and new_number == 0:
                    # Perform pending operation first
                    result: int32 = perform_operation(stored_value, current_value, operation)
                    _ = int_to_str(result, display_buf)
                    current_value = result
                stored_value = current_value
                operation = button
                new_number = 1

            if button == 14:  # = (equals)
                if operation != -1:
                    result: int32 = perform_operation(stored_value, current_value, operation)
                    _ = int_to_str(result, display_buf)
                    current_value = result
                    operation = -1
                new_number = 1

            # Redraw calculator
            fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
            draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)

        if got_mouse != 0:
            # Redraw cursor on screen
            fill_rect(framebuffer, 0, 0, xres, yres, 0x000000, xres, yres)
            draw_calculator(framebuffer, calc_x, calc_y, display_buf, xres, yres)
            # Draw simple cursor
            fill_rect(framebuffer, mouse_x, mouse_y, 2, 10, 0xFFFFFF, xres, yres)
            fill_rect(framebuffer, mouse_x, mouse_y, 10, 2, 0xFFFFFF, xres, yres)

    _ = syscall1(SYS_close, fb_fd)
    _ = syscall1(SYS_close, mouse_fd)
    _ = syscall1(SYS_exit, 0)

main()
