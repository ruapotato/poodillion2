# settings.bh - BrainhairOS Settings/Preferences Application
# A simple graphical system information viewer using framebuffer

const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_ioctl: int32 = 54
const SYS_exit: int32 = 1
const SYS_brk: int32 = 45
const SYS_fcntl: int32 = 55
const SYS_mmap2: int32 = 192

const STDOUT: int32 = 1
const O_RDONLY: int32 = 0
const O_RDWR: int32 = 2
const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

# Framebuffer ioctls
const FBIOGET_VSCREENINFO: int32 = 0x4600

# UI constants
const SIDEBAR_WIDTH: int32 = 180
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8
const BUTTON_HEIGHT: int32 = 32
const MARGIN: int32 = 12
const TAB_HEIGHT: int32 = 40

# Color scheme
const COLOR_BG: int32 = 0xF0F0F0
const COLOR_SIDEBAR: int32 = 0x2D2D2D
const COLOR_TAB_ACTIVE: int32 = 0x0088FF
const COLOR_TAB_INACTIVE: int32 = 0x404040
const COLOR_TEXT_LIGHT: int32 = 0xFFFFFF
const COLOR_TEXT_DARK: int32 = 0x000000
const COLOR_BUTTON: int32 = 0x0066AA
const COLOR_BUTTON_HOVER: int32 = 0x0088DD

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32
extern proc fast_memcpy(dst: int32, src: int32, count_bytes: int32)

proc print_str(s: ptr uint8) =
  var len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_num(n: int32) =
  var buf: ptr uint8 = cast[ptr uint8](0)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 16)
  buf = cast[ptr uint8](old_brk)
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    print_str(buf)
    return
  var neg: int32 = 0
  var tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  print_str(buf)

# ============ Drawing Primitives ============

proc fill_rect(buf: ptr uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32) =
  var cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      var sx: int32 = x
      var ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      var cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

proc get_font_row(c: int32, row: int32): int32 =
  # 8x8 bitmap font - returns 8 bits for each row
  if c == 32: return 0  # space

  # Uppercase letters A-Z (65-90)
  if c == 65:  # A
    if row == 0: return 0x18
    if row == 1: return 0x3C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0
  if c == 67:  # C
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0
  if c == 69:  # E
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 70:  # F
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 71:  # G
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x6E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 72:  # H
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 73:  # I
    if row == 0: return 0x3C
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0
  if c == 74:  # J
    if row == 0: return 0x1E
    if row == 1: return 0x0C
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x6C
    if row == 6: return 0x38
    return 0
  if c == 75:  # K
    if row == 0: return 0x66
    if row == 1: return 0x6C
    if row == 2: return 0x78
    if row == 3: return 0x70
    if row == 4: return 0x78
    if row == 5: return 0x6C
    if row == 6: return 0x66
    return 0
  if c == 76:  # L
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 77:  # M
    if row == 0: return 0x63
    if row == 1: return 0x77
    if row == 2: return 0x7F
    if row == 3: return 0x6B
    if row == 4: return 0x63
    if row == 5: return 0x63
    if row == 6: return 0x63
    return 0
  if c == 78:  # N
    if row == 0: return 0x66
    if row == 1: return 0x76
    if row == 2: return 0x7E
    if row == 3: return 0x7E
    if row == 4: return 0x6E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 80:  # P
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 81:  # Q
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x6A
    if row == 5: return 0x6C
    if row == 6: return 0x36
    return 0
  if c == 82:  # R
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x6C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 83:  # S
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x3C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 84:  # T
    if row == 0: return 0x7E
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 85:  # U
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 86:  # V
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0
  if c == 87:  # W
    if row == 0: return 0x63
    if row == 1: return 0x63
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x7F
    if row == 5: return 0x77
    if row == 6: return 0x63
    return 0
  if c == 88:  # X
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 89:  # Y
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 90:  # Z
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  # Lowercase letters - use same as uppercase for simplicity
  if c >= 97 and c <= 122:
    return get_font_row(c - 32, row)

  # Numbers 0-9 (48-57)
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0
  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0
  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  # Special characters
  if c == 58:  # :
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 46:  # .
    if row == 6: return 0x18
    return 0
  if c == 47:  # /
    if row == 0: return 0x06
    if row == 1: return 0x0C
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x30
    if row == 5: return 0x60
    return 0
  if c == 45:  # -
    if row == 3: return 0x7E
    return 0
  if c == 120:  # x
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0

  return 0

proc buf_pixel(buf: ptr uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32) =
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

proc draw_char(buf: ptr uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32) =
  var row: int32 = 0
  while row < 8:
    var bitmap: int32 = get_font_row(c, row)
    var col: int32 = 0
    while col < 8:
      var bit: int32 = (bitmap >> (7 - col)) & 1
      var color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

proc draw_text(buf: ptr uint32, x: int32, y: int32, s: ptr uint8, fg: int32, bg: int32, xres: int32, yres: int32, max_chars: int32) =
  var i: int32 = 0
  while s[i] != cast[uint8](0) and i < max_chars:
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

proc draw_cursor(buf: ptr uint32, x: int32, y: int32, xres: int32, yres: int32) =
  # Draw arrow cursor
  buf_pixel(buf, x, y, 0x000000, xres, yres)
  buf_pixel(buf, x, y+1, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+1, 0x000000, xres, yres)
  buf_pixel(buf, x, y+2, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+2, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+2, 0x000000, xres, yres)
  buf_pixel(buf, x, y+3, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+3, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+3, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+3, 0x000000, xres, yres)
  buf_pixel(buf, x, y+4, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+4, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+4, 0x000000, xres, yres)
  buf_pixel(buf, x, y+5, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+5, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+5, 0x000000, xres, yres)
  buf_pixel(buf, x, y+6, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+6, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+6, 0x000000, xres, yres)
  buf_pixel(buf, x, y+7, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+7, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+7, 0x000000, xres, yres)
  buf_pixel(buf, x, y+8, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+6, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+8, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+8, 0x000000, xres, yres)
  buf_pixel(buf, x, y+9, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+4, y+9, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+5, y+9, 0x000000, xres, yres)
  buf_pixel(buf, x, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+3, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+5, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+10, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+7, y+10, 0x000000, xres, yres)
  buf_pixel(buf, x, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+11, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+2, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x+7, y+11, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+11, 0x000000, xres, yres)
  buf_pixel(buf, x, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+1, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+6, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+7, y+12, 0xFFFFFF, xres, yres)
  buf_pixel(buf, x+8, y+12, 0x000000, xres, yres)
  buf_pixel(buf, x+7, y+13, 0x000000, xres, yres)
  buf_pixel(buf, x+8, y+13, 0x000000, xres, yres)

# ============ File Reading ============

proc read_file_to_buffer(path: ptr uint8, buffer: ptr uint8, max_len: int32): int32 =
  var fd: int32 = syscall2(SYS_open, cast[int32](path), O_RDONLY)
  if fd < 0:
    return -1
  var bytes_read: int32 = syscall3(SYS_read, fd, cast[int32](buffer), max_len - 1)
  discard syscall1(SYS_close, fd)
  if bytes_read > 0:
    # Remove trailing newline if present
    if buffer[bytes_read - 1] == cast[uint8](10):
      bytes_read = bytes_read - 1
    buffer[bytes_read] = cast[uint8](0)
    return bytes_read
  return -1

# ============ UI Drawing ============

proc draw_sidebar(buf: ptr uint32, xres: int32, yres: int32, selected_tab: int32) =
  # Draw sidebar background
  fill_rect(buf, 0, 0, SIDEBAR_WIDTH, yres, COLOR_SIDEBAR, xres, yres)

  # Draw tabs
  var tab_y: int32 = MARGIN

  # Display tab
  var color1: int32 = COLOR_TAB_INACTIVE
  if selected_tab == 0: color1 = COLOR_TAB_ACTIVE
  fill_rect(buf, MARGIN, tab_y, SIDEBAR_WIDTH - MARGIN * 2, TAB_HEIGHT, color1, xres, yres)
  draw_text(buf, MARGIN + 8, tab_y + 16, cast[ptr uint8]("Display"), COLOR_TEXT_LIGHT, color1, xres, yres, 20)

  # System tab
  tab_y = tab_y + TAB_HEIGHT + MARGIN
  var color2: int32 = COLOR_TAB_INACTIVE
  if selected_tab == 1: color2 = COLOR_TAB_ACTIVE
  fill_rect(buf, MARGIN, tab_y, SIDEBAR_WIDTH - MARGIN * 2, TAB_HEIGHT, color2, xres, yres)
  draw_text(buf, MARGIN + 8, tab_y + 16, cast[ptr uint8]("System"), COLOR_TEXT_LIGHT, color2, xres, yres, 20)

  # About tab
  tab_y = tab_y + TAB_HEIGHT + MARGIN
  var color3: int32 = COLOR_TAB_INACTIVE
  if selected_tab == 2: color3 = COLOR_TAB_ACTIVE
  fill_rect(buf, MARGIN, tab_y, SIDEBAR_WIDTH - MARGIN * 2, TAB_HEIGHT, color3, xres, yres)
  draw_text(buf, MARGIN + 8, tab_y + 16, cast[ptr uint8]("About"), COLOR_TEXT_LIGHT, color3, xres, yres, 20)

proc int_to_str(n: int32, buf: ptr uint8) =
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    return
  var tmp: int32 = n
  var i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp - (tmp / 10) * 10)
    tmp = tmp / 10
    i = i + 1
  buf[i] = cast[uint8](0)
  # Reverse the string
  var j: int32 = 0
  var k: int32 = i - 1
  while j < k:
    var t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1

proc draw_display_tab(buf: ptr uint32, xres: int32, yres: int32) =
  var content_x: int32 = SIDEBAR_WIDTH + MARGIN
  var content_y: int32 = MARGIN

  # Title
  draw_text(buf, content_x, content_y, cast[ptr uint8]("Display Settings"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 32

  # Resolution info
  content_y = content_y + MARGIN
  draw_text(buf, content_x, content_y, cast[ptr uint8]("Current Resolution:"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 16

  # Build resolution string "WxH"
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 64)
  var res_str: ptr uint8 = cast[ptr uint8](old_brk)
  var num_buf: ptr uint8 = cast[ptr uint8](old_brk + 32)

  # Convert width to string
  int_to_str(xres, num_buf)
  var i: int32 = 0
  while num_buf[i] != cast[uint8](0):
    res_str[i] = num_buf[i]
    i = i + 1
  res_str[i] = cast[uint8](120)  # 'x'
  i = i + 1

  # Convert height to string
  int_to_str(yres, num_buf)
  var j: int32 = 0
  while num_buf[j] != cast[uint8](0):
    res_str[i] = num_buf[j]
    i = i + 1
    j = j + 1
  res_str[i] = cast[uint8](0)

  draw_text(buf, content_x + 16, content_y, res_str, 0x0066AA, COLOR_BG, xres, yres, 30)

proc draw_system_tab(buf: ptr uint32, xres: int32, yres: int32) =
  var content_x: int32 = SIDEBAR_WIDTH + MARGIN
  var content_y: int32 = MARGIN

  # Title
  draw_text(buf, content_x, content_y, cast[ptr uint8]("System Information"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 32

  # Hostname
  content_y = content_y + MARGIN
  draw_text(buf, content_x, content_y, cast[ptr uint8]("Hostname:"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 16

  # Read hostname from /etc/hostname (try both paths)
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 128)
  var hostname: ptr uint8 = cast[ptr uint8](old_brk)

  var result: int32 = read_file_to_buffer(cast[ptr uint8]("/etc/hostname"), hostname, 64)
  if result < 0:
    result = read_file_to_buffer(cast[ptr uint8]("/proc/sys/kernel/hostname"), hostname, 64)

  if result >= 0:
    draw_text(buf, content_x + 16, content_y, hostname, 0x0066AA, COLOR_BG, xres, yres, 30)
  else:
    draw_text(buf, content_x + 16, content_y, cast[ptr uint8]("unknown"), 0x888888, COLOR_BG, xres, yres, 30)

proc draw_about_tab(buf: ptr uint32, xres: int32, yres: int32) =
  var content_x: int32 = SIDEBAR_WIDTH + MARGIN
  var content_y: int32 = MARGIN

  # Title
  draw_text(buf, content_x, content_y, cast[ptr uint8]("About"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 32

  # OS Name
  content_y = content_y + MARGIN
  draw_text(buf, content_x, content_y, cast[ptr uint8]("BrainhairOS"), 0x0066AA, COLOR_BG, xres, yres, 30)
  content_y = content_y + 16

  # Version
  content_y = content_y + 8
  draw_text(buf, content_x, content_y, cast[ptr uint8]("Version 0.1"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 16

  # Description
  content_y = content_y + 16
  draw_text(buf, content_x, content_y, cast[ptr uint8]("A minimal OS written in"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)
  content_y = content_y + 16
  draw_text(buf, content_x, content_y, cast[ptr uint8]("Brainhair language"), COLOR_TEXT_DARK, COLOR_BG, xres, yres, 30)

proc draw_close_button(buf: ptr uint32, xres: int32, yres: int32, hover: int32) =
  var button_x: int32 = xres / 2 - 50
  var button_y: int32 = yres - BUTTON_HEIGHT - MARGIN * 2
  var button_w: int32 = 100

  var btn_color: int32 = COLOR_BUTTON
  if hover != 0: btn_color = COLOR_BUTTON_HOVER

  fill_rect(buf, button_x, button_y, button_w, BUTTON_HEIGHT, btn_color, xres, yres)
  draw_text(buf, button_x + 32, button_y + 12, cast[ptr uint8]("Close"), COLOR_TEXT_LIGHT, btn_color, xres, yres, 10)

proc point_in_close_button(px: int32, py: int32, xres: int32, yres: int32): int32 =
  var button_x: int32 = xres / 2 - 50
  var button_y: int32 = yres - BUTTON_HEIGHT - MARGIN * 2
  var button_w: int32 = 100

  if px >= button_x and px < button_x + button_w:
    if py >= button_y and py < button_y + BUTTON_HEIGHT:
      return 1
  return 0

proc point_in_tab(px: int32, py: int32, tab_num: int32): int32 =
  if px < MARGIN or px >= SIDEBAR_WIDTH - MARGIN:
    return 0
  var tab_y: int32 = MARGIN + tab_num * (TAB_HEIGHT + MARGIN)
  if py >= tab_y and py < tab_y + TAB_HEIGHT:
    return 1
  return 0

# ============ Main ============

proc main() =
  print_str(cast[ptr uint8]("BrainhairOS Settings v0.1\n"))

  # Open framebuffer
  var fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open /dev/fb0\n"))
    discard syscall1(SYS_exit, 1)

  # Get screen info
  var old_brk: int32 = syscall1(SYS_brk, 0)
  discard syscall1(SYS_brk, old_brk + 4096)
  var vinfo: ptr uint32 = cast[ptr uint32](old_brk)
  var mouse_buf: ptr uint8 = cast[ptr uint8](old_brk + 256)

  discard syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  var xres: int32 = cast[int32](vinfo[0])
  var yres: int32 = cast[int32](vinfo[1])

  print_str(cast[ptr uint8]("Screen: "))
  print_num(xres)
  print_str(cast[ptr uint8]("x"))
  print_num(yres)
  print_str(cast[ptr uint8]("\n"))

  # mmap framebuffer
  var buf_size: int32 = xres * yres * 4
  var mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  var framebuffer: ptr uint32 = cast[ptr uint32](0)

  var mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned < cast[uint32](0xFFFFF000):
    framebuffer = cast[ptr uint32](mmap_result)
  else:
    print_str(cast[ptr uint8]("Error: mmap failed\n"))
    discard syscall1(SYS_exit, 1)

  # Open mouse
  var mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd < 0:
    print_str(cast[ptr uint8]("Error: Cannot open mouse\n"))
    discard syscall1(SYS_exit, 1)

  # Set mouse to non-blocking
  var flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
  discard syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Initialize cursor position
  var cursor_x: int32 = xres / 2
  var cursor_y: int32 = yres / 2
  var selected_tab: int32 = 0
  var mouse_btn: int32 = 0
  var prev_btn: int32 = 0
  var button_hover: int32 = 0

  var running: int32 = 1
  while running != 0:
    # Draw UI
    fill_rect(framebuffer, 0, 0, xres, yres, COLOR_BG, xres, yres)
    draw_sidebar(framebuffer, xres, yres, selected_tab)

    # Draw selected tab content
    if selected_tab == 0:
      draw_display_tab(framebuffer, xres, yres)
    if selected_tab == 1:
      draw_system_tab(framebuffer, xres, yres)
    if selected_tab == 2:
      draw_about_tab(framebuffer, xres, yres)

    # Check if mouse is over close button
    button_hover = point_in_close_button(cursor_x, cursor_y, xres, yres)
    draw_close_button(framebuffer, xres, yres, button_hover)

    # Draw cursor
    draw_cursor(framebuffer, cursor_x, cursor_y, xres, yres)

    # Handle mouse input
    prev_btn = mouse_btn
    var bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
    while bytes >= 3:
      var btns: int32 = cast[int32](mouse_buf[0])
      var dx: int32 = cast[int32](mouse_buf[1])
      var dy: int32 = cast[int32](mouse_buf[2])

      if (btns & 0x10) != 0: dx = dx - 256
      if (btns & 0x20) != 0: dy = dy - 256

      cursor_x = cursor_x + dx
      cursor_y = cursor_y - dy
      if cursor_x < 0: cursor_x = 0
      if cursor_x >= xres: cursor_x = xres - 1
      if cursor_y < 0: cursor_y = 0
      if cursor_y >= yres: cursor_y = yres - 1

      mouse_btn = btns & 0x07

      bytes = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)

    # Handle clicks
    var left_pressed: int32 = (mouse_btn & 1) != 0 and (prev_btn & 1) == 0

    if left_pressed != 0:
      # Check if clicking close button
      if point_in_close_button(cursor_x, cursor_y, xres, yres) != 0:
        running = 0

      # Check if clicking on tabs
      if point_in_tab(cursor_x, cursor_y, 0) != 0:
        selected_tab = 0
      if point_in_tab(cursor_x, cursor_y, 1) != 0:
        selected_tab = 1
      if point_in_tab(cursor_x, cursor_y, 2) != 0:
        selected_tab = 2

  # Cleanup
  discard syscall1(SYS_close, mouse_fd)
  discard syscall1(SYS_close, fb_fd)
  discard syscall1(SYS_exit, 0)

main()
