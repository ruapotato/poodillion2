# chpasswd - Batch password update
# Reads username:password pairs from stdin and updates passwords
# Usage: chpasswd < user_password_file
# Note: Simplified version that just displays what would be updated

from lib.syscalls import *

def print_err(msg: *uint8):
    len: int32 = strlen(msg)
    _ = syscall3(SYS_write, STDERR, cast[int32](msg), len)

# Write a single character
def print_char(c: uint8):
    _ = syscall3(SYS_write, STDOUT, cast[int32](cast[*uint8](cast[int32](cast[*uint8](c)))), 1)

def main():
    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 16384
    _ = syscall1(SYS_brk, new_brk)

    input_buf: *uint8 = cast[*uint8](old_brk)
    username: *uint8 = cast[*uint8](old_brk + 8192)
    password: *uint8 = cast[*uint8](old_brk + 8704)

    print(cast[*uint8]("chpasswd: reading username:password pairs from stdin\n"))
    print(cast[*uint8]("chpasswd: simplified version - passwords will not be updated\n"))
    print(cast[*uint8]("chpasswd: full implementation requires crypt() support\n"))
    print(cast[*uint8]("\n"))

    # Read from stdin
    total_read: int32 = 0
    running: int32 = 1

    while running != 0:
        n: int32 = syscall3(SYS_read, STDIN, cast[int32](cast[*uint8](cast[int32](input_buf) + total_read)), 8000 - total_read)
        if n <= 0:
            running = 0
            break
        total_read = total_read + n

    if total_read == 0:
        print_err(cast[*uint8]("chpasswd: no input received\n"))
        print_err(cast[*uint8]("          usage: chpasswd < user_password_file\n"))
        print_err(cast[*uint8]("          format: username:password (one per line)\n"))
        _ = syscall1(SYS_exit, 1)

    input_buf[total_read] = cast[uint8](0)

    # Parse input line by line
    i: int32 = 0
    count: int32 = 0

    while i < total_read:
        # Skip empty lines (restructured without continue)
        if input_buf[i] != cast[uint8](10):
            # Parse username (before colon)
            username_idx: int32 = 0
            while i < total_read:
                if input_buf[i] == cast[uint8](58):  # colon
                    break
                if input_buf[i] == cast[uint8](10):  # newline
                    break
                username[username_idx] = input_buf[i]
                username_idx = username_idx + 1
                i = i + 1
            username[username_idx] = cast[uint8](0)

            # Check if we found a colon
            if i < total_read:
                if input_buf[i] == cast[uint8](58):  # colon found
                    i = i + 1  # Skip the colon

                    # Parse password (until newline)
                    password_idx: int32 = 0
                    while i < total_read:
                        if input_buf[i] == cast[uint8](10):  # newline
                            break
                        password[password_idx] = input_buf[i]
                        password_idx = password_idx + 1
                        i = i + 1
                    password[password_idx] = cast[uint8](0)

                    # Skip newline
                    if i < total_read:
                        if input_buf[i] == cast[uint8](10):
                            i = i + 1

                    # Process this username:password pair
                    if username_idx > 0:
                        if password_idx > 0:
                            count = count + 1
                            print(cast[*uint8]("  Would update password for user: "))
                            print(username)
                            print(cast[*uint8](" (password length: "))

                            # Print password length
                            temp: int32 = password_idx
                            if temp == 0:
                                _ = syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
                            else:
                                # Count digits
                                digits: int32 = 0
                                t2: int32 = temp
                                while t2 > 0:
                                    digits = digits + 1
                                    t2 = t2 / 10

                                # Convert to string
                                digit_buf: *uint8 = cast[*uint8](old_brk + 9216)
                                pos: int32 = digits - 1
                                while temp > 0:
                                    digit: int32 = temp % 10
                                    digit_buf[pos] = cast[uint8](48 + digit)
                                    pos = pos - 1
                                    temp = temp / 10
                                digit_buf[digits] = cast[uint8](0)
                                print(digit_buf)

                            print(cast[*uint8](" characters)\n"))
                else:
                    # Skip to next line (no colon found)
                    while i < total_read:
                        if input_buf[i] == cast[uint8](10):  # newline
                            i = i + 1
                            break
                        i = i + 1
        else:
            # Empty line, just skip
            i = i + 1

    print(cast[*uint8]("\n"))
    print(cast[*uint8]("chpasswd: processed "))

    # Print count
    temp: int32 = count
    if temp == 0:
        _ = syscall3(SYS_write, STDOUT, cast[int32]("0"), 1)
    else:
        # Count digits
        digits: int32 = 0
        t2: int32 = temp
        while t2 > 0:
            digits = digits + 1
            t2 = t2 / 10

        # Convert to string
        digit_buf: *uint8 = cast[*uint8](old_brk + 9216)
        pos: int32 = digits - 1
        while temp > 0:
            digit: int32 = temp % 10
            digit_buf[pos] = cast[uint8](48 + digit)
            pos = pos - 1
            temp = temp / 10
        digit_buf[digits] = cast[uint8](0)
        print(digit_buf)

    print(cast[*uint8](" user(s)\n"))
    print(cast[*uint8]("chpasswd: note - passwords were NOT actually updated\n"))

    _ = syscall1(SYS_exit, 0)
