# wm - Simple Window Manager
# A basic tiling/floating window manager for BrainhairOS
# Supports multiple windows, mouse interaction, and keyboard control

from lib.syscalls import *

O_NONBLOCK: Final[int32] = 2048
F_SETFL: Final[int32] = 4
F_GETFL: Final[int32] = 3
FBIOGET_VSCREENINFO: Final[int32] = 0x4600
MAX_WINDOWS: Final[int32] = 8
TITLE_HEIGHT: Final[int32] = 20
BORDER_WIDTH: Final[int32] = 2

def print_str(s: *uint8):
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    syscall3(SYS_write, STDOUT, cast[int32](s), len)

# Window structure stored in memory:
# offset 0: active (1 = active, 0 = inactive)
# offset 4: x position
# offset 8: y position
# offset 12: width
# offset 16: height
# offset 20: title color
# offset 24: body color

def get_window_ptr(windows: *int32, idx: int32) -> *int32:
    return cast[*int32](cast[int32](windows) + idx * 28)

def window_get(win: *int32, field: int32) -> int32:
    return win[field]

def window_set(win: *int32, field: int32, value: int32):
    win[field] = value

# Fill a rectangle efficiently using line buffer
def fill_rect(fd: int32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32, line_buf: *uint32):
    cy: int32 = y
    while cy < y + h:
        if cy >= 0 and cy < yres:
            start_x: int32 = x
            end_x: int32 = x + w
            if start_x < 0:
                start_x = 0
            if end_x > xres:
                end_x = xres
            if start_x < end_x:
                width: int32 = end_x - start_x
                i: int32 = 0
                while i < width:
                    line_buf[i] = cast[uint32](color)
                    i = i + 1
                offset: int32 = (cy * xres + start_x) * 4
                syscall3(SYS_lseek, fd, offset, SEEK_SET)
                syscall3(SYS_write, fd, cast[int32](line_buf), width * 4)
        cy = cy + 1

# Draw a single pixel
def draw_pixel(fd: int32, x: int32, y: int32, color: int32, xres: int32, yres: int32, pixel_buf: *uint32):
    if x >= 0 and x < xres and y >= 0 and y < yres:
        pixel_buf[0] = cast[uint32](color)
        offset: int32 = (y * xres + x) * 4
        syscall3(SYS_lseek, fd, offset, SEEK_SET)
        syscall3(SYS_write, fd, cast[int32](pixel_buf), 4)

# Draw window
def draw_window(fd: int32, win: *int32, focused: int32, xres: int32, yres: int32, line_buf: *uint32):
    if window_get(win, 0) == 0:
        return

    x: int32 = window_get(win, 1)
    y: int32 = window_get(win, 2)
    w: int32 = window_get(win, 3)
    h: int32 = window_get(win, 4)
    title_color: int32 = window_get(win, 5)
    body_color: int32 = window_get(win, 6)

    # Border color based on focus
    border_color: int32 = 0x404040
    if focused != 0:
        border_color = 0x0080FF

    # Draw border
    fill_rect(fd, x, y, w, BORDER_WIDTH, border_color, xres, yres, line_buf)
    fill_rect(fd, x, y + h - BORDER_WIDTH, w, BORDER_WIDTH, border_color, xres, yres, line_buf)
    fill_rect(fd, x, y, BORDER_WIDTH, h, border_color, xres, yres, line_buf)
    fill_rect(fd, x + w - BORDER_WIDTH, y, BORDER_WIDTH, h, border_color, xres, yres, line_buf)

    # Draw title bar
    fill_rect(fd, x + BORDER_WIDTH, y + BORDER_WIDTH, w - BORDER_WIDTH * 2, TITLE_HEIGHT, title_color, xres, yres, line_buf)

    # Draw close button (red square in top right)
    fill_rect(fd, x + w - BORDER_WIDTH - 16, y + BORDER_WIDTH + 2, 14, 16, 0xFF0000, xres, yres, line_buf)

    # Draw body
    fill_rect(fd, x + BORDER_WIDTH, y + BORDER_WIDTH + TITLE_HEIGHT, w - BORDER_WIDTH * 2, h - BORDER_WIDTH * 2 - TITLE_HEIGHT, body_color, xres, yres, line_buf)

# Draw cursor
def draw_cursor(fd: int32, x: int32, y: int32, xres: int32, yres: int32, pixel_buf: *uint32):
    i: int32 = 0
    while i < 12:
        draw_pixel(fd, x, y + i, 0xFFFFFF, xres, yres, pixel_buf)
        if i < 8:
            draw_pixel(fd, x + i, y + i, 0xFFFFFF, xres, yres, pixel_buf)
        j: int32 = 1
        while j < i and j < 7:
            draw_pixel(fd, x + j, y + i, 0x000000, xres, yres, pixel_buf)
            j = j + 1
        i = i + 1

# Check if point is in window title bar
def point_in_titlebar(win: *int32, px: int32, py: int32) -> int32:
    if window_get(win, 0) == 0:
        return 0
    x: int32 = window_get(win, 1)
    y: int32 = window_get(win, 2)
    w: int32 = window_get(win, 3)
    if px >= x + BORDER_WIDTH and px < x + w - BORDER_WIDTH - 16:
        if py >= y + BORDER_WIDTH and py < y + BORDER_WIDTH + TITLE_HEIGHT:
            return 1
    return 0

# Check if point is on close button
def point_on_close(win: *int32, px: int32, py: int32) -> int32:
    if window_get(win, 0) == 0:
        return 0
    x: int32 = window_get(win, 1)
    y: int32 = window_get(win, 2)
    w: int32 = window_get(win, 3)
    if px >= x + w - BORDER_WIDTH - 16 and px < x + w - BORDER_WIDTH:
        if py >= y + BORDER_WIDTH and py < y + BORDER_WIDTH + 18:
            return 1
    return 0

# Check if point is in window
def point_in_window(win: *int32, px: int32, py: int32) -> int32:
    if window_get(win, 0) == 0:
        return 0
    x: int32 = window_get(win, 1)
    y: int32 = window_get(win, 2)
    w: int32 = window_get(win, 3)
    h: int32 = window_get(win, 4)
    if px >= x and px < x + w and py >= y and py < y + h:
        return 1
    return 0

def main():
    print_str(cast[*uint8]("BrainhairOS Window Manager\n"))
    print_str(cast[*uint8]("Left-click title bar to drag, click X to close\n"))
    print_str(cast[*uint8]("Right-click to create window, middle-click to quit\n"))

    # Open devices
    mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDONLY)
    if mouse_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open /dev/input/mice\n"))
        syscall1(SYS_exit, 1)

    # Set mouse to non-blocking
    flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
    syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

    fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
    if fb_fd < 0:
        print_str(cast[*uint8]("Error: Cannot open /dev/fb0\n"))
        syscall1(SYS_close, mouse_fd)
        syscall1(SYS_exit, 1)

    # Allocate memory
    old_brk: int32 = syscall1(SYS_brk, 0)
    new_brk: int32 = old_brk + 32768
    syscall1(SYS_brk, new_brk)

    vinfo: *uint32 = cast[*uint32](old_brk)
    line_buf: *uint32 = cast[*uint32](old_brk + 256)
    pixel_buf: *uint32 = cast[*uint32](old_brk + 8192)
    mouse_buf: *uint8 = cast[*uint8](old_brk + 8200)
    windows: *int32 = cast[*int32](old_brk + 8256)  # 8 windows * 28 bytes

    # Get screen info
    result: int32 = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
    if result < 0:
        print_str(cast[*uint8]("Error: Cannot get screen info\n"))
        syscall1(SYS_exit, 1)

    xres: int32 = cast[int32](vinfo[0])
    yres: int32 = cast[int32](vinfo[1])

    # Initialize windows (all inactive)
    i: int32 = 0
    while i < MAX_WINDOWS:
        win: *int32 = get_window_ptr(windows, i)
        window_set(win, 0, 0)  # inactive
        i = i + 1

    # Create initial window
    win0: *int32 = get_window_ptr(windows, 0)
    window_set(win0, 0, 1)  # active
    window_set(win0, 1, 100)  # x
    window_set(win0, 2, 100)  # y
    window_set(win0, 3, 300)  # width
    window_set(win0, 4, 200)  # height
    window_set(win0, 5, 0x004080)  # title color
    window_set(win0, 6, 0xC0C0C0)  # body color

    # Create second window
    win1: *int32 = get_window_ptr(windows, 1)
    window_set(win1, 0, 1)
    window_set(win1, 1, 250)
    window_set(win1, 2, 150)
    window_set(win1, 3, 350)
    window_set(win1, 4, 250)
    window_set(win1, 5, 0x408000)  # green title
    window_set(win1, 6, 0xE0E0E0)  # light gray body

    # State
    cursor_x: int32 = xres / 2
    cursor_y: int32 = yres / 2
    focused_window: int32 = 1
    dragging: int32 = 0
    drag_offset_x: int32 = 0
    drag_offset_y: int32 = 0
    needs_redraw: int32 = 1
    next_window_x: int32 = 200
    next_window_y: int32 = 200

    # Desktop background color
    bg_color: int32 = 0x008080

    # Main loop
    running: int32 = 1
    while running != 0:
        # Redraw if needed
        if needs_redraw != 0:
            # Clear background
            fill_rect(fb_fd, 0, 0, xres, yres, bg_color, xres, yres, line_buf)

            # Draw all windows (back to front based on focus)
            i = 0
            while i < MAX_WINDOWS:
                if i != focused_window:
                    win: *int32 = get_window_ptr(windows, i)
                    draw_window(fb_fd, win, 0, xres, yres, line_buf)
                i = i + 1

            # Draw focused window last (on top)
            if focused_window >= 0 and focused_window < MAX_WINDOWS:
                fwin: *int32 = get_window_ptr(windows, focused_window)
                draw_window(fb_fd, fwin, 1, xres, yres, line_buf)

            needs_redraw = 0

        # Draw cursor
        draw_cursor(fb_fd, cursor_x, cursor_y, xres, yres, pixel_buf)

        # Read mouse (non-blocking)
        bytes_read: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 3)

        if bytes_read == 3:
            buttons: int32 = cast[int32](mouse_buf[0])
            dx: int32 = cast[int32](mouse_buf[1])
            dy: int32 = cast[int32](mouse_buf[2])

            # Sign extend
            if (buttons & 0x10) != 0:
                dx = dx - 256
            if (buttons & 0x20) != 0:
                dy = dy - 256

            # Middle click to quit
            if (buttons & 0x04) != 0:
                running = 0

            # Erase cursor at old position
            fill_rect(fb_fd, cursor_x, cursor_y, 12, 14, bg_color, xres, yres, line_buf)

            # Update cursor position
            cursor_x = cursor_x + dx
            cursor_y = cursor_y - dy

            # Clamp
            if cursor_x < 0:
                cursor_x = 0
            if cursor_x >= xres - 12:
                cursor_x = xres - 13
            if cursor_y < 0:
                cursor_y = 0
            if cursor_y >= yres - 14:
                cursor_y = yres - 15

            # Handle dragging
            if dragging != 0:
                if (buttons & 0x01) != 0:
                    # Still dragging - move window
                    fwin: *int32 = get_window_ptr(windows, focused_window)
                    window_set(fwin, 1, cursor_x - drag_offset_x)
                    window_set(fwin, 2, cursor_y - drag_offset_y)
                    needs_redraw = 1
                else:
                    # Released
                    dragging = 0
            else:
                # Left click
                if (buttons & 0x01) != 0:
                    # Check windows from front to back
                    i = focused_window
                    found: int32 = 0

                    # First check focused window
                    if found == 0:
                        win: *int32 = get_window_ptr(windows, focused_window)
                        if point_on_close(win, cursor_x, cursor_y) != 0:
                            # Close window
                            window_set(win, 0, 0)
                            needs_redraw = 1
                            found = 1
                        if found == 0 and point_in_titlebar(win, cursor_x, cursor_y) != 0:
                            # Start drag
                            dragging = 1
                            drag_offset_x = cursor_x - window_get(win, 1)
                            drag_offset_y = cursor_y - window_get(win, 2)
                            found = 1

                    # Check other windows
                    if found == 0:
                        i = MAX_WINDOWS - 1
                        while i >= 0 and found == 0:
                            if i != focused_window:
                                win: *int32 = get_window_ptr(windows, i)
                                if point_in_window(win, cursor_x, cursor_y) != 0:
                                    focused_window = i
                                    needs_redraw = 1
                                    found = 1
                            i = i - 1

                # Right click - create new window
                if (buttons & 0x02) != 0:
                    # Find an inactive window slot
                    i = 0
                    while i < MAX_WINDOWS:
                        win: *int32 = get_window_ptr(windows, i)
                        if window_get(win, 0) == 0:
                            # Create window at cursor
                            window_set(win, 0, 1)
                            window_set(win, 1, cursor_x)
                            window_set(win, 2, cursor_y)
                            window_set(win, 3, 250)
                            window_set(win, 4, 180)
                            window_set(win, 5, 0x800040)  # purple title
                            window_set(win, 6, 0xD0D0D0)
                            focused_window = i
                            needs_redraw = 1
                            i = MAX_WINDOWS  # break
                        i = i + 1

    # Cleanup
    syscall1(SYS_close, fb_fd)
    syscall1(SYS_close, mouse_fd)

    print_str(cast[*uint8]("Window Manager exited\n"))
    syscall1(SYS_exit, 0)

main()
