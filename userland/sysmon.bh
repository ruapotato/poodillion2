# sysmon - Graphical System Monitor
# Displays real-time CPU, memory, load average, and top processes
# Uses framebuffer directly for rendering

from lib.syscalls import *

const O_NONBLOCK: int32 = 2048
const F_SETFL: int32 = 4
const F_GETFL: int32 = 3

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_SHARED: int32 = 1

const FBIOGET_VSCREENINFO: int32 = 0x4600

# Colors
const COLOR_BG: int32 = 0x1A1A1A
const COLOR_PANEL: int32 = 0x2D2D2D
const COLOR_TEXT: int32 = 0xE0E0E0
const COLOR_LABEL: int32 = 0x808080
const COLOR_CPU_BAR: int32 = 0x4A90E2
const COLOR_MEM_BAR: int32 = 0xE24A4A
const COLOR_BORDER: int32 = 0x404040

# Layout
const FONT_WIDTH: int32 = 8
const FONT_HEIGHT: int32 = 8
const PANEL_MARGIN: int32 = 10
const PANEL_PADDING: int32 = 8
const BAR_HEIGHT: int32 = 20
const MAX_PROCESSES: int32 = 10

extern def fast_memcpy(dst: int32, src: int32, count_bytes: int32)

# Global variables for CPU calculation
g_prev_total: int32 = 0
g_prev_idle: int32 = 0

def print_str(s: *uint8):
  len: int32 = 0
  while s[len] != cast[uint8](0):
    len = len + 1
  _ = syscall3(SYS_write, STDOUT, cast[int32](s), len)

def sleep_ms(ms: int32):
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 16)
  timespec: *int32 = cast[*int32](old_brk)
  timespec[0] = ms / 1000
  timespec[1] = (ms % 1000) * 1000000
  _ = syscall2(SYS_nanosleep, cast[int32](timespec), 0)

# ============ Drawing Primitives ============

def buf_pixel(buf: *uint32, x: int32, y: int32, color: int32, xres: int32, yres: int32):
  if x >= 0 and x < xres and y >= 0 and y < yres:
    buf[y * xres + x] = cast[uint32](color)

def fill_rect(buf: *uint32, x: int32, y: int32, w: int32, h: int32, color: int32, xres: int32, yres: int32):
  cy: int32 = y
  while cy < y + h:
    if cy >= 0 and cy < yres:
      sx: int32 = x
      ex: int32 = x + w
      if sx < 0: sx = 0
      if ex > xres: ex = xres
      cx: int32 = sx
      while cx < ex:
        buf[cy * xres + cx] = cast[uint32](color)
        cx = cx + 1
    cy = cy + 1

def get_font_row(c: int32, row: int32) -> int32:
  # 8x8 bitmap font - returns 8 bits for each row
  if c == 32: return 0  # space

  # Uppercase letters A-Z (65-90)
  if c == 65:  # A
    if row == 0: return 0x18
    if row == 1: return 0x3C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x7E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 66:  # B
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x7C
    return 0
  if c == 67:  # C
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 68:  # D
    if row == 0: return 0x78
    if row == 1: return 0x6C
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x6C
    if row == 6: return 0x78
    return 0
  if c == 69:  # E
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 70:  # F
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 71:  # G
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x6E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 72:  # H
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7E
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 73:  # I
    if row == 0: return 0x3C
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x3C
    return 0
  if c == 74:  # J
    if row == 0: return 0x1E
    if row == 1: return 0x0C
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x6C
    if row == 6: return 0x38
    return 0
  if c == 75:  # K
    if row == 0: return 0x66
    if row == 1: return 0x6C
    if row == 2: return 0x78
    if row == 3: return 0x70
    if row == 4: return 0x78
    if row == 5: return 0x6C
    if row == 6: return 0x66
    return 0
  if c == 76:  # L
    if row == 0: return 0x60
    if row == 1: return 0x60
    if row == 2: return 0x60
    if row == 3: return 0x60
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0
  if c == 77:  # M
    if row == 0: return 0x63
    if row == 1: return 0x77
    if row == 2: return 0x7F
    if row == 3: return 0x6B
    if row == 4: return 0x63
    if row == 5: return 0x63
    if row == 6: return 0x63
    return 0
  if c == 78:  # N
    if row == 0: return 0x66
    if row == 1: return 0x76
    if row == 2: return 0x7E
    if row == 3: return 0x7E
    if row == 4: return 0x6E
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 79:  # O
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 80:  # P
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x60
    if row == 5: return 0x60
    if row == 6: return 0x60
    return 0
  if c == 81:  # Q
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x6A
    if row == 5: return 0x6C
    if row == 6: return 0x36
    return 0
  if c == 82:  # R
    if row == 0: return 0x7C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x7C
    if row == 4: return 0x6C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 83:  # S
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x60
    if row == 3: return 0x3C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 84:  # T
    if row == 0: return 0x7E
    if row == 1: return 0x18
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 85:  # U
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 86:  # V
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x66
    if row == 4: return 0x66
    if row == 5: return 0x3C
    if row == 6: return 0x18
    return 0
  if c == 87:  # W
    if row == 0: return 0x63
    if row == 1: return 0x63
    if row == 2: return 0x63
    if row == 3: return 0x6B
    if row == 4: return 0x7F
    if row == 5: return 0x77
    if row == 6: return 0x63
    return 0
  if c == 88:  # X
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x3C
    if row == 3: return 0x18
    if row == 4: return 0x3C
    if row == 5: return 0x66
    if row == 6: return 0x66
    return 0
  if c == 89:  # Y
    if row == 0: return 0x66
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 90:  # Z
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x30
    if row == 5: return 0x60
    if row == 6: return 0x7E
    return 0

  # Lowercase letters - use same as uppercase for simplicity
  if c >= 97 and c <= 122:
    return get_font_row(c - 32, row)

  # Numbers 0-9 (48-57)
  if c == 48:  # 0
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x6E
    if row == 3: return 0x76
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 49:  # 1
    if row == 0: return 0x18
    if row == 1: return 0x38
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x7E
    return 0
  if c == 50:  # 2
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x0C
    if row == 4: return 0x18
    if row == 5: return 0x30
    if row == 6: return 0x7E
    return 0
  if c == 51:  # 3
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x06
    if row == 3: return 0x1C
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 52:  # 4
    if row == 0: return 0x0C
    if row == 1: return 0x1C
    if row == 2: return 0x3C
    if row == 3: return 0x6C
    if row == 4: return 0x7E
    if row == 5: return 0x0C
    if row == 6: return 0x0C
    return 0
  if c == 53:  # 5
    if row == 0: return 0x7E
    if row == 1: return 0x60
    if row == 2: return 0x7C
    if row == 3: return 0x06
    if row == 4: return 0x06
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 54:  # 6
    if row == 0: return 0x1C
    if row == 1: return 0x30
    if row == 2: return 0x60
    if row == 3: return 0x7C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 55:  # 7
    if row == 0: return 0x7E
    if row == 1: return 0x06
    if row == 2: return 0x0C
    if row == 3: return 0x18
    if row == 4: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 56:  # 8
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3C
    if row == 4: return 0x66
    if row == 5: return 0x66
    if row == 6: return 0x3C
    return 0
  if c == 57:  # 9
    if row == 0: return 0x3C
    if row == 1: return 0x66
    if row == 2: return 0x66
    if row == 3: return 0x3E
    if row == 4: return 0x06
    if row == 5: return 0x0C
    if row == 6: return 0x38
    return 0

  # Special characters
  if c == 37:  # %
    if row == 0: return 0x62
    if row == 1: return 0x64
    if row == 2: return 0x08
    if row == 3: return 0x10
    if row == 4: return 0x20
    if row == 5: return 0x4C
    if row == 6: return 0x8C
    return 0
  if c == 46:  # .
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 58:  # :
    if row == 2: return 0x18
    if row == 3: return 0x18
    if row == 5: return 0x18
    if row == 6: return 0x18
    return 0
  if c == 47:  # /
    if row == 0: return 0x02
    if row == 1: return 0x04
    if row == 2: return 0x08
    if row == 3: return 0x10
    if row == 4: return 0x20
    if row == 5: return 0x40
    if row == 6: return 0x80
    return 0
  if c == 40:  # (
    if row == 0: return 0x0C
    if row == 1: return 0x18
    if row == 2: return 0x30
    if row == 3: return 0x30
    if row == 4: return 0x30
    if row == 5: return 0x18
    if row == 6: return 0x0C
    return 0
  if c == 41:  # )
    if row == 0: return 0x30
    if row == 1: return 0x18
    if row == 2: return 0x0C
    if row == 3: return 0x0C
    if row == 4: return 0x0C
    if row == 5: return 0x18
    if row == 6: return 0x30
    return 0

  return 0

def draw_char(buf: *uint32, x: int32, y: int32, c: int32, fg: int32, bg: int32, xres: int32, yres: int32):
  row: int32 = 0
  while row < 8:
    bitmap: int32 = get_font_row(c, row)
    col: int32 = 0
    while col < 8:
      bit: int32 = (bitmap >> (7 - col)) & 1
      color: int32 = bg
      if bit != 0: color = fg
      buf_pixel(buf, x + col, y + row, color, xres, yres)
      col = col + 1
    row = row + 1

def draw_text(buf: *uint32, x: int32, y: int32, s: *uint8, fg: int32, bg: int32, xres: int32, yres: int32):
  i: int32 = 0
  while s[i] != cast[uint8](0):
    draw_char(buf, x + i * FONT_WIDTH, y, cast[int32](s[i]), fg, bg, xres, yres)
    i = i + 1

# ============ String/Number Utilities ============

def int_to_str(n: int32, buf: *uint8) -> int32:
  if n == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    return 1
  neg: int32 = 0
  tmp: int32 = n
  if n < 0:
    neg = 1
    tmp = 0 - n
  i: int32 = 0
  while tmp > 0:
    buf[i] = cast[uint8](48 + tmp % 10)
    tmp = tmp / 10
    i = i + 1
  if neg != 0:
    buf[i] = cast[uint8](45)
    i = i + 1
  buf[i] = cast[uint8](0)
  # Reverse string
  j: int32 = 0
  k: int32 = i - 1
  while j < k:
    t: uint8 = buf[j]
    buf[j] = buf[k]
    buf[k] = t
    j = j + 1
    k = k - 1
  return i

def parse_int(s: *uint8) -> int32:
  result: int32 = 0
  i: int32 = 0
  while s[i] == cast[uint8](32):
    i = i + 1
  while s[i] >= cast[uint8](48) and s[i] <= cast[uint8](57):
    result = result * 10 + cast[int32](s[i]) - 48
    i = i + 1
  return result

def strncmp(s1: *uint8, s2: *uint8, n: int32) -> int32:
  i: int32 = 0
  while i < n:
    if s1[i] != s2[i]:
      return 1
    if s1[i] == cast[uint8](0):
      return 0
    i = i + 1
  return 0

def is_numeric(s: *uint8) -> int32:
  if s[0] == cast[uint8](0):
    return 0
  i: int32 = 0
  while s[i] != cast[uint8](0):
    if s[i] < cast[uint8](48) or s[i] > cast[uint8](57):
      return 0
    i = i + 1
  return 1

# ============ /proc Parsers ============

def read_cpu_stats(user: *int32, nice: *int32, system: *int32, idle: *int32) -> int32:
  path: *uint8 = cast[*uint8]("/proc/stat")
  fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return -1

  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 2048)
  buf: *uint8 = cast[*uint8](old_brk)

  nread: int32 = syscall3(SYS_read, fd, cast[int32](buf), 2000)
  _ = syscall1(SYS_close, fd)

  if nread <= 0:
    return -1

  buf[nread] = cast[uint8](0)

  # Parse first line "cpu user nice system idle..."
  i: int32 = 0
  # Skip "cpu "
  while buf[i] != cast[uint8](32):
    i = i + 1
  i = i + 1

  # Parse user
  user[0] = parse_int(cast[*uint8](cast[int32](buf) + i))
  while buf[i] != cast[uint8](32):
    i = i + 1
  i = i + 1

  # Parse nice
  nice[0] = parse_int(cast[*uint8](cast[int32](buf) + i))
  while buf[i] != cast[uint8](32):
    i = i + 1
  i = i + 1

  # Parse system
  system[0] = parse_int(cast[*uint8](cast[int32](buf) + i))
  while buf[i] != cast[uint8](32):
    i = i + 1
  i = i + 1

  # Parse idle
  idle[0] = parse_int(cast[*uint8](cast[int32](buf) + i))

  return 0

def read_mem_info(total: *int32, free: *int32, available: *int32, buffers: *int32, cached: *int32) -> int32:
  path: *uint8 = cast[*uint8]("/proc/meminfo")
  fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return -1

  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 4096)
  buf: *uint8 = cast[*uint8](old_brk)

  nread: int32 = syscall3(SYS_read, fd, cast[int32](buf), 4000)
  _ = syscall1(SYS_close, fd)

  if nread <= 0:
    return -1

  buf[nread] = cast[uint8](0)

  total[0] = 0
  free[0] = 0
  available[0] = 0
  buffers[0] = 0
  cached[0] = 0

  i: int32 = 0
  while i < nread:
    if strncmp(cast[*uint8](cast[int32](buf) + i), cast[*uint8]("MemTotal:"), 9) == 0:
      total[0] = parse_int(cast[*uint8](cast[int32](buf) + i + 9))
    if strncmp(cast[*uint8](cast[int32](buf) + i), cast[*uint8]("MemFree:"), 8) == 0:
      free[0] = parse_int(cast[*uint8](cast[int32](buf) + i + 8))
    if strncmp(cast[*uint8](cast[int32](buf) + i), cast[*uint8]("MemAvailable:"), 13) == 0:
      available[0] = parse_int(cast[*uint8](cast[int32](buf) + i + 13))
    if strncmp(cast[*uint8](cast[int32](buf) + i), cast[*uint8]("Buffers:"), 8) == 0:
      buffers[0] = parse_int(cast[*uint8](cast[int32](buf) + i + 8))
    if strncmp(cast[*uint8](cast[int32](buf) + i), cast[*uint8]("Cached:"), 7) == 0:
      cached[0] = parse_int(cast[*uint8](cast[int32](buf) + i + 7))

    # Skip to next line
    while i < nread and buf[i] != cast[uint8](10):
      i = i + 1
    i = i + 1

  return 0

def read_load_avg(load1: *int32, load5: *int32, load15: *int32) -> int32:
  path: *uint8 = cast[*uint8]("/proc/loadavg")
  fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
  if fd < 0:
    return -1

  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 256)
  buf: *uint8 = cast[*uint8](old_brk)

  nread: int32 = syscall3(SYS_read, fd, cast[int32](buf), 200)
  _ = syscall1(SYS_close, fd)

  if nread <= 0:
    return -1

  buf[nread] = cast[uint8](0)

  # Parse format: "0.05 0.10 0.15 ..."
  # We'll multiply by 100 to get integer representation
  i: int32 = 0
  val: int32 = 0
  decimal: int32 = 0

  # Parse first number
  while buf[i] != cast[uint8](46):  # .
    if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
      val = val * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  i = i + 1
  # Parse decimal part (2 digits)
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = cast[int32](buf[i]) - 48
    i = i + 1
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = decimal * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  load1[0] = val * 100 + decimal

  # Skip to next space
  while buf[i] == cast[uint8](32):
    i = i + 1

  # Parse second number
  val = 0
  decimal = 0
  while buf[i] != cast[uint8](46):
    if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
      val = val * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  i = i + 1
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = cast[int32](buf[i]) - 48
    i = i + 1
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = decimal * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  load5[0] = val * 100 + decimal

  # Skip to next space
  while buf[i] == cast[uint8](32):
    i = i + 1

  # Parse third number
  val = 0
  decimal = 0
  while buf[i] != cast[uint8](46):
    if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
      val = val * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  i = i + 1
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = cast[int32](buf[i]) - 48
    i = i + 1
  if buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    decimal = decimal * 10 + cast[int32](buf[i]) - 48
    i = i + 1
  load15[0] = val * 100 + decimal

  return 0

def read_top_processes(pids: *int32, names: *uint8, cpus: *int32, count: *int32) -> int32:
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 16384)
  dent_buf: *uint8 = cast[*uint8](old_brk)
  stat_buf: *uint8 = cast[*uint8](old_brk + 8192)
  path_buf: *uint8 = cast[*uint8](old_brk + 12288)

  proc_fd: int32 = syscall3(SYS_open, cast[int32]("/proc"), O_RDONLY | O_DIRECTORY, 0)
  if proc_fd < 0:
    return -1

  count[0] = 0
  nread: int32 = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  while nread > 0 and count[0] < MAX_PROCESSES:
    pos: int32 = 0
    while pos < nread and count[0] < MAX_PROCESSES:
      reclen_ptr: *uint16 = cast[*uint16](cast[int32](dent_buf) + pos + 16)
      reclen: int32 = cast[int32](reclen_ptr[0])
      d_name: *uint8 = cast[*uint8](cast[int32](dent_buf) + pos + 19)

      if is_numeric(d_name) != 0:
        # Build path /proc/[pid]/stat
        path_buf[0] = cast[uint8](47)
        path_buf[1] = cast[uint8](112)
        path_buf[2] = cast[uint8](114)
        path_buf[3] = cast[uint8](111)
        path_buf[4] = cast[uint8](99)
        path_buf[5] = cast[uint8](47)
        i: int32 = 0
        while d_name[i] != cast[uint8](0):
          path_buf[6 + i] = d_name[i]
          i = i + 1
        path_buf[6 + i] = cast[uint8](47)
        path_buf[7 + i] = cast[uint8](115)
        path_buf[8 + i] = cast[uint8](116)
        path_buf[9 + i] = cast[uint8](97)
        path_buf[10 + i] = cast[uint8](116)
        path_buf[11 + i] = cast[uint8](0)

        stat_fd: int32 = syscall3(SYS_open, cast[int32](path_buf), O_RDONLY, 0)
        if stat_fd >= 0:
          stat_len: int32 = syscall3(SYS_read, stat_fd, cast[int32](stat_buf), 4095)
          _ = syscall1(SYS_close, stat_fd)

          if stat_len > 0:
            stat_buf[stat_len] = cast[uint8](0)

            # Parse PID
            pid: int32 = parse_int(stat_buf)

            # Find command name in parentheses
            comm_start: int32 = 0
            i = 0
            while stat_buf[i] != cast[uint8](0):
              if stat_buf[i] == cast[uint8](40):
                comm_start = i + 1
                break
              i = i + 1

            comm_end: int32 = comm_start
            last_paren: int32 = comm_start
            while stat_buf[comm_end] != cast[uint8](0):
              if stat_buf[comm_end] == cast[uint8](41):
                last_paren = comm_end
              comm_end = comm_end + 1
            comm_end = last_paren

            # Get utime + stime (fields 14 and 15)
            field_pos: int32 = comm_end + 2
            field_num: int32 = 3
            i = field_pos
            # Skip to field 14 (utime)
            while field_num < 14 and stat_buf[i] != cast[uint8](0):
              if stat_buf[i] == cast[uint8](32):
                field_num = field_num + 1
              i = i + 1

            utime: int32 = parse_int(cast[*uint8](cast[int32](stat_buf) + i))

            # Skip to field 15 (stime)
            while stat_buf[i] != cast[uint8](32) and stat_buf[i] != cast[uint8](0):
              i = i + 1
            i = i + 1
            stime: int32 = parse_int(cast[*uint8](cast[int32](stat_buf) + i))

            # Store process info
            idx: int32 = count[0]
            pids[idx] = pid
            cpus[idx] = utime + stime

            # Copy name (max 16 chars)
            name_len: int32 = comm_end - comm_start
            if name_len > 15:
              name_len = 15
            i = 0
            while i < name_len:
              names[idx * 16 + i] = stat_buf[comm_start + i]
              i = i + 1
            names[idx * 16 + name_len] = cast[uint8](0)

            count[0] = count[0] + 1

      pos = pos + reclen

    nread = syscall3(SYS_getdents64, proc_fd, cast[int32](dent_buf), 8192)

  _ = syscall1(SYS_close, proc_fd)
  return 0

# ============ Drawing UI Elements ============

def draw_panel(buf: *uint32, x: int32, y: int32, w: int32, h: int32, xres: int32, yres: int32):
  fill_rect(buf, x, y, w, h, COLOR_PANEL, xres, yres)
  fill_rect(buf, x, y, w, 1, COLOR_BORDER, xres, yres)
  fill_rect(buf, x, y + h - 1, w, 1, COLOR_BORDER, xres, yres)
  fill_rect(buf, x, y, 1, h, COLOR_BORDER, xres, yres)
  fill_rect(buf, x + w - 1, y, 1, h, COLOR_BORDER, xres, yres)

def draw_bar(buf: *uint32, x: int32, y: int32, w: int32, h: int32, percent: int32, color: int32, xres: int32, yres: int32):
  # Draw background
  fill_rect(buf, x, y, w, h, 0x3A3A3A, xres, yres)
  # Draw border
  fill_rect(buf, x, y, w, 1, COLOR_BORDER, xres, yres)
  fill_rect(buf, x, y + h - 1, w, 1, COLOR_BORDER, xres, yres)
  fill_rect(buf, x, y, 1, h, COLOR_BORDER, xres, yres)
  fill_rect(buf, x + w - 1, y, 1, h, COLOR_BORDER, xres, yres)

  # Draw filled portion
  fill_w: int32 = (w - 4) * percent / 100
  if fill_w > w - 4:
    fill_w = w - 4
  if fill_w > 0:
    fill_rect(buf, x + 2, y + 2, fill_w, h - 4, color, xres, yres)

# ============ Main ============

def main():
  print_str(cast[*uint8]("System Monitor starting...\n"))

  # Open framebuffer
  fb_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/fb0"), O_RDWR)
  if fb_fd < 0:
    print_str(cast[*uint8]("Error: Cannot open /dev/fb0\n"))
    _ = syscall1(SYS_exit, 1)

  # Get screen info
  old_brk: int32 = syscall1(SYS_brk, 0)
  _ = syscall1(SYS_brk, old_brk + 16384)
  vinfo: *uint32 = cast[*uint32](old_brk)
  num_buf: *uint8 = cast[*uint8](old_brk + 256)
  user: *int32 = cast[*int32](old_brk + 512)
  nice: *int32 = cast[*int32](old_brk + 516)
  system: *int32 = cast[*int32](old_brk + 520)
  idle: *int32 = cast[*int32](old_brk + 524)
  mem_total: *int32 = cast[*int32](old_brk + 528)
  mem_free: *int32 = cast[*int32](old_brk + 532)
  mem_available: *int32 = cast[*int32](old_brk + 536)
  mem_buffers: *int32 = cast[*int32](old_brk + 540)
  mem_cached: *int32 = cast[*int32](old_brk + 544)
  load1: *int32 = cast[*int32](old_brk + 548)
  load5: *int32 = cast[*int32](old_brk + 552)
  load15: *int32 = cast[*int32](old_brk + 556)
  proc_pids: *int32 = cast[*int32](old_brk + 1024)
  proc_cpus: *int32 = cast[*int32](old_brk + 1124)
  proc_names: *uint8 = cast[*uint8](old_brk + 1224)
  proc_count: *int32 = cast[*int32](old_brk + 2000)

  _ = syscall3(SYS_ioctl, fb_fd, FBIOGET_VSCREENINFO, cast[int32](vinfo))
  xres: int32 = cast[int32](vinfo[0])
  yres: int32 = cast[int32](vinfo[1])

  print_str(cast[*uint8]("Screen: "))
  len: int32 = int_to_str(xres, num_buf)
  print_str(num_buf)
  print_str(cast[*uint8]("x"))
  len = int_to_str(yres, num_buf)
  print_str(num_buf)
  print_str(cast[*uint8]("\n"))

  # mmap framebuffer
  buf_size: int32 = xres * yres * 4
  mmap_result: int32 = syscall6(SYS_mmap2, 0, buf_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0)
  framebuffer: *uint32 = cast[*uint32](0)

  mmap_unsigned: uint32 = cast[uint32](mmap_result)
  if mmap_unsigned >= cast[uint32](0xFFFFF000):
    print_str(cast[*uint8]("Error: mmap failed\n"))
    _ = syscall1(SYS_exit, 1)

  framebuffer = cast[*uint32](mmap_result)

  # Open mouse for input (non-blocking)
  mouse_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/mice"), O_RDWR)
  if mouse_fd >= 0:
    flags: int32 = syscall2(SYS_fcntl, mouse_fd, F_GETFL)
    _ = syscall3(SYS_fcntl, mouse_fd, F_SETFL, flags | O_NONBLOCK)

  # Open keyboard for input (non-blocking)
  kbd_fd: int32 = syscall2(SYS_open, cast[int32]("/dev/input/event0"), O_RDWR)
  if kbd_fd >= 0:
    flags: int32 = syscall2(SYS_fcntl, kbd_fd, F_GETFL)
    _ = syscall3(SYS_fcntl, kbd_fd, F_SETFL, flags | O_NONBLOCK)

  running: int32 = 1
  mouse_buf: *uint8 = cast[*uint8](old_brk + 8192)

  # Initialize previous CPU stats
  _ = read_cpu_stats(user, nice, system, idle)
  g_prev_total = user[0] + nice[0] + system[0] + idle[0]
  g_prev_idle = idle[0]

  while running != 0:
    # Clear screen
    fill_rect(framebuffer, 0, 0, xres, yres, COLOR_BG, xres, yres)

    # Draw title
    draw_text(framebuffer, 20, 20, cast[*uint8]("SYSTEM MONITOR"), COLOR_TEXT, COLOR_BG, xres, yres)

    panel_y: int32 = 50
    panel_w: int32 = xres - PANEL_MARGIN * 2

    # CPU Panel
    draw_panel(framebuffer, PANEL_MARGIN, panel_y, panel_w, 80, xres, yres)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING, cast[*uint8]("CPU USAGE"), COLOR_LABEL, COLOR_PANEL, xres, yres)

    # Read CPU stats
    _ = read_cpu_stats(user, nice, system, idle)
    total: int32 = user[0] + nice[0] + system[0] + idle[0]
    total_delta: int32 = total - g_prev_total
    idle_delta: int32 = idle[0] - g_prev_idle
    cpu_percent: int32 = 0
    if total_delta > 0:
      cpu_percent = (total_delta - idle_delta) * 100 / total_delta
    g_prev_total = total
    g_prev_idle = idle[0]

    # Draw CPU percentage
    len: int32 = int_to_str(cpu_percent, num_buf)
    i: int32 = len
    num_buf[i] = cast[uint8](37)  # %
    num_buf[i + 1] = cast[uint8](0)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 16, num_buf, COLOR_TEXT, COLOR_PANEL, xres, yres)

    # Draw CPU bar
    draw_bar(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 32, panel_w - PANEL_PADDING * 2, BAR_HEIGHT, cpu_percent, COLOR_CPU_BAR, xres, yres)

    panel_y = panel_y + 90

    # Memory Panel
    draw_panel(framebuffer, PANEL_MARGIN, panel_y, panel_w, 100, xres, yres)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING, cast[*uint8]("MEMORY"), COLOR_LABEL, COLOR_PANEL, xres, yres)

    # Read memory stats
    _ = read_mem_info(mem_total, mem_free, mem_available, mem_buffers, mem_cached)
    mem_used: int32 = mem_total[0] - mem_free[0] - mem_buffers[0] - mem_cached[0]
    mem_percent: int32 = 0
    if mem_total[0] > 0:
      mem_percent = mem_used * 100 / mem_total[0]

    # Draw memory info
    len = int_to_str(mem_used / 1024, num_buf)
    i = len
    num_buf[i] = cast[uint8](47)  # /
    i = i + 1
    total_mb: int32 = mem_total[0] / 1024
    total_len: int32 = int_to_str(total_mb, cast[*uint8](cast[int32](num_buf) + i))
    i = i + total_len
    num_buf[i] = cast[uint8](32)  # space
    num_buf[i + 1] = cast[uint8](77)  # M
    num_buf[i + 2] = cast[uint8](66)  # B
    num_buf[i + 3] = cast[uint8](32)  # space
    num_buf[i + 4] = cast[uint8](40)  # (
    i = i + 5
    percent_len: int32 = int_to_str(mem_percent, cast[*uint8](cast[int32](num_buf) + i))
    i = i + percent_len
    num_buf[i] = cast[uint8](37)  # %
    num_buf[i + 1] = cast[uint8](41)  # )
    num_buf[i + 2] = cast[uint8](0)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 16, num_buf, COLOR_TEXT, COLOR_PANEL, xres, yres)

    # Draw memory bar
    draw_bar(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 32, panel_w - PANEL_PADDING * 2, BAR_HEIGHT, mem_percent, COLOR_MEM_BAR, xres, yres)

    # Draw available memory
    len = int_to_str(mem_available[0] / 1024, num_buf)
    i = len
    num_buf[i] = cast[uint8](32)  # space
    num_buf[i + 1] = cast[uint8](77)  # M
    num_buf[i + 2] = cast[uint8](66)  # B
    num_buf[i + 3] = cast[uint8](32)  # space
    num_buf[i + 4] = cast[uint8](97)  # a
    num_buf[i + 5] = cast[uint8](118)  # v
    num_buf[i + 6] = cast[uint8](97)  # a
    num_buf[i + 7] = cast[uint8](105)  # i
    num_buf[i + 8] = cast[uint8](108)  # l
    num_buf[i + 9] = cast[uint8](0)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 60, num_buf, COLOR_LABEL, COLOR_PANEL, xres, yres)

    panel_y = panel_y + 110

    # Load Average Panel
    draw_panel(framebuffer, PANEL_MARGIN, panel_y, panel_w, 50, xres, yres)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING, cast[*uint8]("LOAD AVERAGE"), COLOR_LABEL, COLOR_PANEL, xres, yres)

    # Read load average
    _ = read_load_avg(load1, load5, load15)

    # Format: 0.05, 0.10, 0.15
    len = int_to_str(load1[0] / 100, num_buf)
    i = len
    num_buf[i] = cast[uint8](46)  # .
    i = i + 1
    decimal: int32 = load1[0] % 100
    if decimal < 10:
      num_buf[i] = cast[uint8](48)
      i = i + 1
      num_buf[i] = cast[uint8](48 + decimal)
      i = i + 1
    else:
      d_len: int32 = int_to_str(decimal, cast[*uint8](cast[int32](num_buf) + i))
      i = i + d_len

    num_buf[i] = cast[uint8](44)  # ,
    num_buf[i + 1] = cast[uint8](32)  # space
    i = i + 2

    l5_len: int32 = int_to_str(load5[0] / 100, cast[*uint8](cast[int32](num_buf) + i))
    i = i + l5_len
    num_buf[i] = cast[uint8](46)  # .
    i = i + 1
    decimal = load5[0] % 100
    if decimal < 10:
      num_buf[i] = cast[uint8](48)
      i = i + 1
      num_buf[i] = cast[uint8](48 + decimal)
      i = i + 1
    else:
      d_len: int32 = int_to_str(decimal, cast[*uint8](cast[int32](num_buf) + i))
      i = i + d_len

    num_buf[i] = cast[uint8](44)  # ,
    num_buf[i + 1] = cast[uint8](32)  # space
    i = i + 2

    l15_len: int32 = int_to_str(load15[0] / 100, cast[*uint8](cast[int32](num_buf) + i))
    i = i + l15_len
    num_buf[i] = cast[uint8](46)  # .
    i = i + 1
    decimal = load15[0] % 100
    if decimal < 10:
      num_buf[i] = cast[uint8](48)
      i = i + 1
      num_buf[i] = cast[uint8](48 + decimal)
      i = i + 1
    else:
      d_len: int32 = int_to_str(decimal, cast[*uint8](cast[int32](num_buf) + i))
      i = i + d_len
    num_buf[i] = cast[uint8](0)

    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING + 16, num_buf, COLOR_TEXT, COLOR_PANEL, xres, yres)

    panel_y = panel_y + 60

    # Top Processes Panel
    proc_panel_h: int32 = 40 + MAX_PROCESSES * 16
    draw_panel(framebuffer, PANEL_MARGIN, panel_y, panel_w, proc_panel_h, xres, yres)
    draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, panel_y + PANEL_PADDING, cast[*uint8]("TOP PROCESSES"), COLOR_LABEL, COLOR_PANEL, xres, yres)

    # Read processes
    _ = read_top_processes(proc_pids, proc_names, proc_cpus, proc_count)

    # Display up to MAX_PROCESSES
    proc_y: int32 = panel_y + PANEL_PADDING + 24
    i = 0
    while i < proc_count[0] and i < MAX_PROCESSES:
      # Draw PID
      len = int_to_str(proc_pids[i], num_buf)
      j: int32 = len
      while j < 6:
        num_buf[j] = cast[uint8](32)
        j = j + 1
      # Copy name
      name_ptr: *uint8 = cast[*uint8](cast[int32](proc_names) + i * 16)
      j = 0
      while name_ptr[j] != cast[uint8](0) and j < 15:
        num_buf[6 + j] = name_ptr[j]
        j = j + 1
      num_buf[6 + j] = cast[uint8](0)

      draw_text(framebuffer, PANEL_MARGIN + PANEL_PADDING, proc_y, num_buf, COLOR_TEXT, COLOR_PANEL, xres, yres)

      proc_y = proc_y + 16
      i = i + 1

    # Check for mouse click or keyboard input
    if mouse_fd >= 0:
      bytes: int32 = syscall3(SYS_read, mouse_fd, cast[int32](mouse_buf), 4)
      if bytes >= 3:
        btns: int32 = cast[int32](mouse_buf[0])
        if (btns & 0x07) != 0:
          running = 0

    if kbd_fd >= 0:
      bytes: int32 = syscall3(SYS_read, kbd_fd, cast[int32](mouse_buf), 24)
      if bytes > 0:
        running = 0

    # Sleep for 1 second
    sleep_ms(1000)

  # Cleanup
  if mouse_fd >= 0:
    _ = syscall1(SYS_close, mouse_fd)
  if kbd_fd >= 0:
    _ = syscall1(SYS_close, kbd_fd)
  _ = syscall1(SYS_close, fb_fd)

  print_str(cast[*uint8]("System Monitor exiting...\n"))
  _ = syscall1(SYS_exit, 0)

main()
