# x509.bh - X.509 Certificate Parsing for BrainhairOS
# Implements basic X.509 certificate parsing for TLS certificate validation
#
# X.509 certificates use ASN.1 DER encoding
# This library provides:
# - ASN.1 DER decoder
# - Certificate structure parsing
# - Public key extraction
# - Basic validation helpers

from lib.syscalls import *
from lib.ed25519 import *
from lib.sha256 import *

# ===========================================================================
# ASN.1 Tag Constants
# ===========================================================================

ASN1_BOOLEAN: Final[int32] = 0x01
ASN1_INTEGER: Final[int32] = 0x02
ASN1_BIT_STRING: Final[int32] = 0x03
ASN1_OCTET_STRING: Final[int32] = 0x04
ASN1_NULL: Final[int32] = 0x05
ASN1_OID: Final[int32] = 0x06
ASN1_UTF8_STRING: Final[int32] = 0x0C
ASN1_PRINTABLE_STRING: Final[int32] = 0x13
ASN1_IA5_STRING: Final[int32] = 0x16
ASN1_UTC_TIME: Final[int32] = 0x17
ASN1_GENERALIZED_TIME: Final[int32] = 0x18
ASN1_SEQUENCE: Final[int32] = 0x30
ASN1_SET: Final[int32] = 0x31

# Context-specific tags (constructed)
ASN1_CONTEXT_0: Final[int32] = 0xA0
ASN1_CONTEXT_1: Final[int32] = 0xA1
ASN1_CONTEXT_2: Final[int32] = 0xA2
ASN1_CONTEXT_3: Final[int32] = 0xA3

# ===========================================================================
# OID Constants (commonly used in X.509)
# ===========================================================================

# Signature algorithms
# 1.2.840.113549.1.1.11 = sha256WithRSAEncryption
# 1.2.840.10045.4.3.2 = ecdsa-with-SHA256
# 1.3.101.112 = Ed25519

# Key types
# 1.2.840.113549.1.1.1 = rsaEncryption
# 1.2.840.10045.2.1 = id-ecPublicKey
# 1.3.101.110 = X25519
# 1.3.101.112 = Ed25519

# X.509 extension OIDs
# 2.5.29.14 = subjectKeyIdentifier
# 2.5.29.15 = keyUsage
# 2.5.29.17 = subjectAltName
# 2.5.29.19 = basicConstraints
# 2.5.29.35 = authorityKeyIdentifier

# ===========================================================================
# ASN.1 Parser Types
# ===========================================================================

class ASN1Element:
    tag: int32
    length: int32
    data: Ptr[uint8]
    header_len: int32      # Size of tag + length bytes

class ASN1Parser:
    data: Ptr[uint8]
    length: int32
    offset: int32

# ===========================================================================
# X.509 Certificate Types
# ===========================================================================

X509_MAX_NAME_LEN: Final[int32] = 256
X509_MAX_EXTENSIONS: Final[int32] = 16

class X509Name:
    common_name: Array[128, uint8]
    common_name_len: int32
    organization: Array[128, uint8]
    organization_len: int32
    country: Array[8, uint8]
    country_len: int32

class X509Validity:
    not_before_year: int32
    not_before_month: int32
    not_before_day: int32
    not_after_year: int32
    not_after_month: int32
    not_after_day: int32

class X509PublicKey:
    algorithm: int32       # 0=RSA, 1=ECDSA, 2=Ed25519, 3=X25519
    key_data: Array[256, uint8]
    key_len: int32

class X509Extension:
    oid: Array[16, uint8]
    oid_len: int32
    critical: int32
    value: Ptr[uint8]
    value_len: int32

class X509Certificate:
    # Version (0=v1, 1=v2, 2=v3)
    version: int32

    # Serial number
    serial: Array[20, uint8]
    serial_len: int32

    # Signature algorithm
    sig_algorithm: int32

    # Issuer and subject
    issuer: X509Name
    subject: X509Name

    # Validity period
    validity: X509Validity

    # Public key
    public_key: X509PublicKey

    # Extensions (v3 only)
    extensions: Array[16, X509Extension]
    extension_count: int32

    # Is this a CA certificate?
    is_ca: int32

    # Raw TBS (To Be Signed) data for signature verification
    tbs_data: Ptr[uint8]
    tbs_len: int32

    # Signature
    signature: Array[512, uint8]
    signature_len: int32

# ===========================================================================
# ASN.1 Parser Functions
# ===========================================================================

# Initialize ASN.1 parser
def asn1_init(parser: Ptr[ASN1Parser], data: Ptr[uint8], length: int32):
    parser.data = data
    parser.length = length
    parser.offset = 0

# Parse ASN.1 element header (tag and length)
# Returns 0 on success, -1 on error
def asn1_parse_element(parser: Ptr[ASN1Parser], elem: Ptr[ASN1Element]) -> int32:
    if parser.offset >= parser.length:
        return -1

    offset: int32 = parser.offset

    # Read tag
    elem.tag = cast[int32](parser.data[offset])
    offset = offset + 1

    if offset >= parser.length:
        return -1

    # Read length
    len_byte: int32 = cast[int32](parser.data[offset])
    offset = offset + 1

    if len_byte < 128:
        # Short form
        elem.length = len_byte
    else:
        # Long form
        num_bytes: int32 = len_byte & 0x7F
        if num_bytes > 4:
            return -1  # Too long

        elem.length = 0
        i: int32 = 0
        while i < num_bytes:
            if offset >= parser.length:
                return -1
            elem.length = (elem.length * 256) + cast[int32](parser.data[offset])
            offset = offset + 1
            i = i + 1

    elem.header_len = offset - parser.offset
    elem.data = cast[Ptr[uint8]](cast[int32](parser.data) + offset)

    # Validate length
    if offset + elem.length > parser.length:
        return -1

    return 0

# Skip to next element
def asn1_next(parser: Ptr[ASN1Parser], elem: Ptr[ASN1Element]):
    parser.offset = parser.offset + elem.header_len + elem.length

# Enter a constructed element (SEQUENCE, SET, etc.)
def asn1_enter(parser: Ptr[ASN1Parser], elem: Ptr[ASN1Element]):
    parser.offset = parser.offset + elem.header_len

# Parse an INTEGER and return value (for small integers)
def asn1_parse_small_int(data: Ptr[uint8], length: int32) -> int32:
    result: int32 = 0
    i: int32 = 0
    while i < length and i < 4:
        result = (result * 256) + cast[int32](data[i])
        i = i + 1
    return result

# Compare OID bytes
def oid_equals(a: Ptr[uint8], a_len: int32, b: Ptr[uint8], b_len: int32) -> int32:
    if a_len != b_len:
        return 0
    i: int32 = 0
    while i < a_len:
        if a[i] != b[i]:
            return 0
        i = i + 1
    return 1

# ===========================================================================
# X.509 Parsing Functions
# ===========================================================================

# Parse UTC time (YYMMDDHHMMSSZ)
def parse_utc_time(data: Ptr[uint8], length: int32,
                   year: Ptr[int32], month: Ptr[int32], day: Ptr[int32]) -> int32:
    if length < 12:
        return -1

    # Parse year (2 digits)
    y: int32 = ((cast[int32](data[0]) - 0x30) * 10) + (cast[int32](data[1]) - 0x30)
    if y >= 50:
        year[0] = 1900 + y
    else:
        year[0] = 2000 + y

    # Parse month
    month[0] = ((cast[int32](data[2]) - 0x30) * 10) + (cast[int32](data[3]) - 0x30)

    # Parse day
    day[0] = ((cast[int32](data[4]) - 0x30) * 10) + (cast[int32](data[5]) - 0x30)

    return 0

# Parse a Name (issuer or subject)
def x509_parse_name(data: Ptr[uint8], length: int32, name: Ptr[X509Name]) -> int32:
    parser: ASN1Parser
    asn1_init(addr(parser), data, length)

    name.common_name_len = 0
    name.organization_len = 0
    name.country_len = 0

    # Name is a SEQUENCE of RelativeDistinguishedName (SET of AttributeTypeAndValue)
    while parser.offset < parser.length:
        set_elem: ASN1Element
        if asn1_parse_element(addr(parser), addr(set_elem)) < 0:
            break

        if set_elem.tag != ASN1_SET:
            asn1_next(addr(parser), addr(set_elem))
            continue

        # Parse SET contents
        set_parser: ASN1Parser
        asn1_init(addr(set_parser), set_elem.data, set_elem.length)

        seq_elem: ASN1Element
        if asn1_parse_element(addr(set_parser), addr(seq_elem)) == 0:
            if seq_elem.tag == ASN1_SEQUENCE:
                # Parse AttributeTypeAndValue
                attr_parser: ASN1Parser
                asn1_init(addr(attr_parser), seq_elem.data, seq_elem.length)

                oid_elem: ASN1Element
                val_elem: ASN1Element

                if asn1_parse_element(addr(attr_parser), addr(oid_elem)) == 0:
                    if oid_elem.tag == ASN1_OID:
                        asn1_next(addr(attr_parser), addr(oid_elem))

                        if asn1_parse_element(addr(attr_parser), addr(val_elem)) == 0:
                            # Check OID and copy value
                            # 2.5.4.3 = commonName (OID: 55 04 03)
                            # 2.5.4.6 = countryName (OID: 55 04 06)
                            # 2.5.4.10 = organizationName (OID: 55 04 0A)

                            if oid_elem.length >= 3:
                                if oid_elem.data[0] == 0x55 and oid_elem.data[1] == 0x04:
                                    attr_type: int32 = cast[int32](oid_elem.data[2])

                                    if attr_type == 0x03:  # commonName
                                        i: int32 = 0
                                        while i < val_elem.length and i < 127:
                                            name.common_name[i] = val_elem.data[i]
                                            i = i + 1
                                        name.common_name[i] = 0
                                        name.common_name_len = val_elem.length
                                    elif attr_type == 0x06:  # countryName
                                        i: int32 = 0
                                        while i < val_elem.length and i < 7:
                                            name.country[i] = val_elem.data[i]
                                            i = i + 1
                                        name.country[i] = 0
                                        name.country_len = val_elem.length
                                    elif attr_type == 0x0A:  # organizationName
                                        i: int32 = 0
                                        while i < val_elem.length and i < 127:
                                            name.organization[i] = val_elem.data[i]
                                            i = i + 1
                                        name.organization[i] = 0
                                        name.organization_len = val_elem.length

        asn1_next(addr(parser), addr(set_elem))

    return 0

# Parse SubjectPublicKeyInfo
def x509_parse_public_key(data: Ptr[uint8], length: int32,
                          key: Ptr[X509PublicKey]) -> int32:
    parser: ASN1Parser
    asn1_init(addr(parser), data, length)

    # SEQUENCE { algorithm, subjectPublicKey }
    seq_elem: ASN1Element
    if asn1_parse_element(addr(parser), addr(seq_elem)) < 0:
        return -1

    if seq_elem.tag != ASN1_SEQUENCE:
        return -1

    inner_parser: ASN1Parser
    asn1_init(addr(inner_parser), seq_elem.data, seq_elem.length)

    # AlgorithmIdentifier SEQUENCE
    alg_elem: ASN1Element
    if asn1_parse_element(addr(inner_parser), addr(alg_elem)) < 0:
        return -1

    if alg_elem.tag == ASN1_SEQUENCE:
        # Parse algorithm OID
        alg_parser: ASN1Parser
        asn1_init(addr(alg_parser), alg_elem.data, alg_elem.length)

        oid_elem: ASN1Element
        if asn1_parse_element(addr(alg_parser), addr(oid_elem)) == 0:
            if oid_elem.tag == ASN1_OID:
                # Check for Ed25519: 1.3.101.112 (06 03 2B 65 70)
                if oid_elem.length == 3 and oid_elem.data[0] == 0x2B and oid_elem.data[1] == 0x65 and oid_elem.data[2] == 0x70:
                    key.algorithm = 2  # Ed25519
                # Check for X25519: 1.3.101.110 (06 03 2B 65 6E)
                elif oid_elem.length == 3 and oid_elem.data[0] == 0x2B and oid_elem.data[1] == 0x65 and oid_elem.data[2] == 0x6E:
                    key.algorithm = 3  # X25519
                # RSA: 1.2.840.113549.1.1.1
                elif oid_elem.length >= 9 and oid_elem.data[0] == 0x2A and oid_elem.data[1] == 0x86 and oid_elem.data[2] == 0x48:
                    key.algorithm = 0  # RSA
                else:
                    key.algorithm = 1  # Assume ECDSA for other

    asn1_next(addr(inner_parser), addr(alg_elem))

    # BIT STRING containing the key
    key_elem: ASN1Element
    if asn1_parse_element(addr(inner_parser), addr(key_elem)) < 0:
        return -1

    if key_elem.tag == ASN1_BIT_STRING:
        # Skip the "unused bits" byte
        key_start: int32 = 1
        key_length: int32 = key_elem.length - 1

        if key_length > 256:
            key_length = 256

        i: int32 = 0
        while i < key_length:
            key.key_data[i] = key_elem.data[key_start + i]
            i = i + 1
        key.key_len = key_length

    return 0

# Parse X.509 certificate
def x509_parse(data: Ptr[uint8], length: int32, cert: Ptr[X509Certificate]) -> int32:
    parser: ASN1Parser
    asn1_init(addr(parser), data, length)

    # Initialize cert
    cert.version = 0
    cert.serial_len = 0
    cert.extension_count = 0
    cert.is_ca = 0
    cert.signature_len = 0

    # Certificate SEQUENCE
    cert_seq: ASN1Element
    if asn1_parse_element(addr(parser), addr(cert_seq)) < 0:
        return -1

    if cert_seq.tag != ASN1_SEQUENCE:
        return -1

    cert_parser: ASN1Parser
    asn1_init(addr(cert_parser), cert_seq.data, cert_seq.length)

    # TBSCertificate SEQUENCE
    tbs_elem: ASN1Element
    if asn1_parse_element(addr(cert_parser), addr(tbs_elem)) < 0:
        return -1

    if tbs_elem.tag != ASN1_SEQUENCE:
        return -1

    # Save TBS for signature verification
    cert.tbs_data = cast[Ptr[uint8]](cast[int32](cert_parser.data) + cert_parser.offset - tbs_elem.header_len)
    cert.tbs_len = tbs_elem.header_len + tbs_elem.length

    # Parse TBS contents
    tbs_parser: ASN1Parser
    asn1_init(addr(tbs_parser), tbs_elem.data, tbs_elem.length)

    # Version (optional, context tag 0)
    elem: ASN1Element
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1

    if elem.tag == ASN1_CONTEXT_0:
        # Parse version integer
        ver_parser: ASN1Parser
        asn1_init(addr(ver_parser), elem.data, elem.length)
        ver_elem: ASN1Element
        if asn1_parse_element(addr(ver_parser), addr(ver_elem)) == 0:
            if ver_elem.tag == ASN1_INTEGER and ver_elem.length > 0:
                cert.version = cast[int32](ver_elem.data[0])
        asn1_next(addr(tbs_parser), addr(elem))
        if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
            return -1

    # Serial number (INTEGER)
    if elem.tag == ASN1_INTEGER:
        i: int32 = 0
        while i < elem.length and i < 20:
            cert.serial[i] = elem.data[i]
            i = i + 1
        cert.serial_len = elem.length
        if cert.serial_len > 20:
            cert.serial_len = 20
        asn1_next(addr(tbs_parser), addr(elem))

    # Signature algorithm (SEQUENCE)
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1
    asn1_next(addr(tbs_parser), addr(elem))

    # Issuer (SEQUENCE/Name)
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1
    if elem.tag == ASN1_SEQUENCE:
        x509_parse_name(elem.data, elem.length, addr(cert.issuer))
    asn1_next(addr(tbs_parser), addr(elem))

    # Validity (SEQUENCE)
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1
    if elem.tag == ASN1_SEQUENCE:
        val_parser: ASN1Parser
        asn1_init(addr(val_parser), elem.data, elem.length)

        time_elem: ASN1Element
        # notBefore
        if asn1_parse_element(addr(val_parser), addr(time_elem)) == 0:
            if time_elem.tag == ASN1_UTC_TIME:
                parse_utc_time(time_elem.data, time_elem.length,
                               addr(cert.validity.not_before_year),
                               addr(cert.validity.not_before_month),
                               addr(cert.validity.not_before_day))
            asn1_next(addr(val_parser), addr(time_elem))
        # notAfter
        if asn1_parse_element(addr(val_parser), addr(time_elem)) == 0:
            if time_elem.tag == ASN1_UTC_TIME:
                parse_utc_time(time_elem.data, time_elem.length,
                               addr(cert.validity.not_after_year),
                               addr(cert.validity.not_after_month),
                               addr(cert.validity.not_after_day))
    asn1_next(addr(tbs_parser), addr(elem))

    # Subject (SEQUENCE/Name)
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1
    if elem.tag == ASN1_SEQUENCE:
        x509_parse_name(elem.data, elem.length, addr(cert.subject))
    asn1_next(addr(tbs_parser), addr(elem))

    # SubjectPublicKeyInfo (SEQUENCE)
    if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
        return -1
    if elem.tag == ASN1_SEQUENCE:
        x509_parse_public_key(cast[Ptr[uint8]](cast[int32](tbs_parser.data) + tbs_parser.offset - elem.header_len),
                              elem.header_len + elem.length,
                              addr(cert.public_key))
    asn1_next(addr(tbs_parser), addr(elem))

    # Extensions (optional, context tag 3) - for v3 certificates
    while tbs_parser.offset < tbs_parser.length:
        if asn1_parse_element(addr(tbs_parser), addr(elem)) < 0:
            break

        if elem.tag == ASN1_CONTEXT_3:
            # Parse extensions sequence
            ext_outer: ASN1Parser
            asn1_init(addr(ext_outer), elem.data, elem.length)

            ext_seq: ASN1Element
            if asn1_parse_element(addr(ext_outer), addr(ext_seq)) == 0:
                if ext_seq.tag == ASN1_SEQUENCE:
                    ext_parser: ASN1Parser
                    asn1_init(addr(ext_parser), ext_seq.data, ext_seq.length)

                    while ext_parser.offset < ext_parser.length and cert.extension_count < 16:
                        ext_elem: ASN1Element
                        if asn1_parse_element(addr(ext_parser), addr(ext_elem)) < 0:
                            break

                        if ext_elem.tag == ASN1_SEQUENCE:
                            # Parse extension: OID, optional critical, value
                            single_ext: ASN1Parser
                            asn1_init(addr(single_ext), ext_elem.data, ext_elem.length)

                            oid_elem: ASN1Element
                            if asn1_parse_element(addr(single_ext), addr(oid_elem)) == 0:
                                if oid_elem.tag == ASN1_OID:
                                    # Check for basicConstraints: 2.5.29.19 (55 1D 13)
                                    if oid_elem.length == 3 and oid_elem.data[0] == 0x55 and oid_elem.data[1] == 0x1D and oid_elem.data[2] == 0x13:
                                        asn1_next(addr(single_ext), addr(oid_elem))

                                        # Skip optional critical boolean
                                        next_elem: ASN1Element
                                        if asn1_parse_element(addr(single_ext), addr(next_elem)) == 0:
                                            if next_elem.tag == ASN1_BOOLEAN:
                                                asn1_next(addr(single_ext), addr(next_elem))
                                                asn1_parse_element(addr(single_ext), addr(next_elem))

                                            # OCTET STRING containing BasicConstraints
                                            if next_elem.tag == ASN1_OCTET_STRING:
                                                bc_parser: ASN1Parser
                                                asn1_init(addr(bc_parser), next_elem.data, next_elem.length)

                                                bc_seq: ASN1Element
                                                if asn1_parse_element(addr(bc_parser), addr(bc_seq)) == 0:
                                                    if bc_seq.tag == ASN1_SEQUENCE and bc_seq.length > 0:
                                                        bc_inner: ASN1Parser
                                                        asn1_init(addr(bc_inner), bc_seq.data, bc_seq.length)

                                                        ca_elem: ASN1Element
                                                        if asn1_parse_element(addr(bc_inner), addr(ca_elem)) == 0:
                                                            if ca_elem.tag == ASN1_BOOLEAN and ca_elem.length > 0:
                                                                if ca_elem.data[0] != 0:
                                                                    cert.is_ca = 1

                        asn1_next(addr(ext_parser), addr(ext_elem))

        asn1_next(addr(tbs_parser), addr(elem))

    # Skip to signature in outer certificate
    asn1_next(addr(cert_parser), addr(tbs_elem))

    # SignatureAlgorithm (SEQUENCE)
    if asn1_parse_element(addr(cert_parser), addr(elem)) < 0:
        return 0  # Ok, signature is optional for parsing
    asn1_next(addr(cert_parser), addr(elem))

    # Signature (BIT STRING)
    if asn1_parse_element(addr(cert_parser), addr(elem)) == 0:
        if elem.tag == ASN1_BIT_STRING and elem.length > 1:
            sig_len: int32 = elem.length - 1  # Skip unused bits byte
            if sig_len > 512:
                sig_len = 512
            i: int32 = 0
            while i < sig_len:
                cert.signature[i] = elem.data[1 + i]
                i = i + 1
            cert.signature_len = sig_len

    return 0

# ===========================================================================
# Certificate Validation Functions
# ===========================================================================

# Verify certificate signature using issuer's public key
def x509_verify_signature(cert: Ptr[X509Certificate],
                          issuer_key: Ptr[X509PublicKey]) -> int32:
    if issuer_key.algorithm == 2:  # Ed25519
        # Verify Ed25519 signature
        pubkey: Ed25519PublicKey
        sig: Ed25519Signature

        i: int32 = 0
        while i < 32 and i < issuer_key.key_len:
            pubkey.data[i] = cast[int8](issuer_key.key_data[i])
            i = i + 1

        i = 0
        while i < 64 and i < cert.signature_len:
            sig.data[i] = cast[int8](cert.signature[i])
            i = i + 1

        return ed25519_verify(cast[Ptr[int8]](cert.tbs_data), cert.tbs_len,
                              addr(pubkey), addr(sig))

    # RSA/ECDSA verification would go here
    return -1  # Unsupported algorithm

# Check if certificate is currently valid (basic date check)
def x509_check_validity(cert: Ptr[X509Certificate],
                        current_year: int32, current_month: int32,
                        current_day: int32) -> int32:
    # Check not before
    if current_year < cert.validity.not_before_year:
        return -1
    elif current_year == cert.validity.not_before_year:
        if current_month < cert.validity.not_before_month:
            return -1
        elif current_month == cert.validity.not_before_month:
            if current_day < cert.validity.not_before_day:
                return -1

    # Check not after
    if current_year > cert.validity.not_after_year:
        return -1
    elif current_year == cert.validity.not_after_year:
        if current_month > cert.validity.not_after_month:
            return -1
        elif current_month == cert.validity.not_after_month:
            if current_day > cert.validity.not_after_day:
                return -1

    return 0

# Check if subject common name matches hostname
def x509_check_hostname(cert: Ptr[X509Certificate], hostname: Ptr[uint8]) -> int32:
    i: int32 = 0
    while i < cert.subject.common_name_len:
        if cert.subject.common_name[i] != hostname[i]:
            return -1
        i = i + 1

    if hostname[i] != 0:
        return -1

    return 0

# Get public key from certificate
def x509_get_public_key(cert: Ptr[X509Certificate], key: Ptr[uint8], max_len: int32) -> int32:
    len: int32 = cert.public_key.key_len
    if len > max_len:
        len = max_len

    i: int32 = 0
    while i < len:
        key[i] = cert.public_key.key_data[i]
        i = i + 1

    return len

# Check if certificate is a CA
def x509_is_ca(cert: Ptr[X509Certificate]) -> int32:
    return cert.is_ca

# Get certificate subject common name
def x509_get_subject_cn(cert: Ptr[X509Certificate], buffer: Ptr[uint8], max_len: int32) -> int32:
    len: int32 = cert.subject.common_name_len
    if len > max_len - 1:
        len = max_len - 1

    i: int32 = 0
    while i < len:
        buffer[i] = cert.subject.common_name[i]
        i = i + 1
    buffer[i] = 0

    return len

# Get certificate issuer common name
def x509_get_issuer_cn(cert: Ptr[X509Certificate], buffer: Ptr[uint8], max_len: int32) -> int32:
    len: int32 = cert.issuer.common_name_len
    if len > max_len - 1:
        len = max_len - 1

    i: int32 = 0
    while i < len:
        buffer[i] = cert.issuer.common_name[i]
        i = i + 1
    buffer[i] = 0

    return len
