# dict.bh - Hash Table (Dictionary) Implementation for Brainhair
# Provides a key-value store similar to Python's dict
#
# Uses open addressing with linear probing for collision resolution.
# Keys and values are stored as int32 (use cast for pointers).
#
# Usage:
#   table: Dict[int32, int32]
#   dict_init(addr(table), 16)
#   dict_set(addr(table), key, value)
#   val: int32 = dict_get(addr(table), key)
#   dict_free(addr(table))

from lib.memory import *

# Dict structure layout:
#   [0] keys: Ptr[int32]     - array of keys
#   [1] values: Ptr[int32]   - array of values
#   [2] flags: Ptr[uint8]    - array of slot flags (0=empty, 1=used, 2=deleted)
#   [3] cap: int32           - capacity (number of slots)
#   [4] len: int32           - number of entries

DICT_KEYS_OFFSET: Final[int32] = 0
DICT_VALUES_OFFSET: Final[int32] = 4
DICT_FLAGS_OFFSET: Final[int32] = 8
DICT_CAP_OFFSET: Final[int32] = 12
DICT_LEN_OFFSET: Final[int32] = 16
DICT_STRUCT_SIZE: Final[int32] = 20

# Slot flags
DICT_SLOT_EMPTY: Final[int32] = 0
DICT_SLOT_USED: Final[int32] = 1
DICT_SLOT_DELETED: Final[int32] = 2

# Default initial capacity
DICT_DEFAULT_CAP: Final[int32] = 16

# Load factor threshold (percent) - resize when len > cap * threshold / 100
DICT_LOAD_THRESHOLD: Final[int32] = 70

# Hash function for int32 keys (FNV-1a inspired)
def dict_hash(key: int32) -> int32:
    h: int32 = 2166136261
    h = h ^ (key & 255)
    h = h * 16777619
    h = h ^ ((key >> 8) & 255)
    h = h * 16777619
    h = h ^ ((key >> 16) & 255)
    h = h * 16777619
    h = h ^ ((key >> 24) & 255)
    h = h * 16777619
    # Make positive
    if h < 0:
        h = 0 - h
    return h

# Hash function for string keys
def dict_hash_str(s: Ptr[uint8]) -> int32:
    h: int32 = 2166136261
    i: int32 = 0
    while s[i] != 0:
        h = h ^ cast[int32](s[i])
        h = h * 16777619
        i = i + 1
    if h < 0:
        h = 0 - h
    return h

# Initialize a dict with given capacity
def dict_init(dict: Ptr[int32], initial_cap: int32):
    cap: int32 = initial_cap
    if cap < DICT_DEFAULT_CAP:
        cap = DICT_DEFAULT_CAP

    keys: Ptr[uint8] = alloc_zero(cap * 4)
    values: Ptr[uint8] = alloc_zero(cap * 4)
    flags: Ptr[uint8] = alloc_zero(cap)

    dict[0] = cast[int32](keys)
    dict[1] = cast[int32](values)
    dict[2] = cast[int32](flags)
    dict[3] = cap
    dict[4] = 0

# Initialize with default capacity
def dict_new(dict: Ptr[int32]):
    dict_init(dict, DICT_DEFAULT_CAP)

# Free dict memory
def dict_free(dict: Ptr[int32]):
    keys: Ptr[uint8] = Ptr[uint8](dict[0])
    values: Ptr[uint8] = Ptr[uint8](dict[1])
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    if cast[int32](keys) != 0:
        free(keys)
    if cast[int32](values) != 0:
        free(values)
    if cast[int32](flags) != 0:
        free(flags)

    dict[0] = 0
    dict[1] = 0
    dict[2] = 0
    dict[3] = 0
    dict[4] = 0

# Get dict length (number of entries)
def dict_len(dict: Ptr[int32]) -> int32:
    return dict[4]

# Get dict capacity
def dict_cap(dict: Ptr[int32]) -> int32:
    return dict[3]

# Check if dict is empty
def dict_empty(dict: Ptr[int32]) -> int32:
    if dict[4] == 0:
        return 1
    return 0

# Find slot for key (returns index or -1 if not found)
def dict_find_slot(dict: Ptr[int32], key: int32) -> int32:
    cap: int32 = dict[3]
    if cap == 0:
        return -1

    keys: Ptr[int32] = Ptr[int32](dict[0])
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    h: int32 = dict_hash(key)
    idx: int32 = h % cap
    start: int32 = idx

    # Linear probing
    while 1 == 1:
        flag: int32 = cast[int32](flags[idx])
        if flag == DICT_SLOT_EMPTY:
            return -1  # Not found, hit empty slot
        if flag == DICT_SLOT_USED:
            if keys[idx] == key:
                return idx  # Found
        # DELETED slots are skipped during search
        idx = (idx + 1) % cap
        if idx == start:
            return -1  # Wrapped around, not found

# Find slot for insertion (returns index for new or existing key)
def dict_find_insert_slot(dict: Ptr[int32], key: int32) -> int32:
    cap: int32 = dict[3]
    keys: Ptr[int32] = Ptr[int32](dict[0])
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    h: int32 = dict_hash(key)
    idx: int32 = h % cap
    start: int32 = idx
    first_deleted: int32 = -1

    while 1 == 1:
        flag: int32 = cast[int32](flags[idx])
        if flag == DICT_SLOT_EMPTY:
            # Use first deleted slot if we found one, otherwise this empty slot
            if first_deleted >= 0:
                return first_deleted
            return idx
        if flag == DICT_SLOT_DELETED:
            if first_deleted < 0:
                first_deleted = idx
        if flag == DICT_SLOT_USED:
            if keys[idx] == key:
                return idx  # Key already exists
        idx = (idx + 1) % cap
        if idx == start:
            # Table is full (shouldn't happen with proper resizing)
            if first_deleted >= 0:
                return first_deleted
            return -1

# Grow dict capacity
def dict_grow(dict: Ptr[int32]):
    old_cap: int32 = dict[3]
    old_keys: Ptr[int32] = Ptr[int32](dict[0])
    old_values: Ptr[int32] = Ptr[int32](dict[1])
    old_flags: Ptr[uint8] = Ptr[uint8](dict[2])

    new_cap: int32 = old_cap * 2

    # Allocate new arrays
    new_keys: Ptr[uint8] = alloc_zero(new_cap * 4)
    new_values: Ptr[uint8] = alloc_zero(new_cap * 4)
    new_flags: Ptr[uint8] = alloc_zero(new_cap)

    dict[0] = cast[int32](new_keys)
    dict[1] = cast[int32](new_values)
    dict[2] = cast[int32](new_flags)
    dict[3] = new_cap
    dict[4] = 0  # Will re-add all entries

    # Re-insert all entries
    i: int32 = 0
    while i < old_cap:
        if cast[int32](old_flags[i]) == DICT_SLOT_USED:
            dict_set(dict, old_keys[i], old_values[i])
        i = i + 1

    # Free old arrays
    free(Ptr[uint8](cast[int32](old_keys)))
    free(Ptr[uint8](cast[int32](old_values)))
    free(old_flags)

# Set key-value pair
def dict_set(dict: Ptr[int32], key: int32, value: int32):
    cap: int32 = dict[3]
    len: int32 = dict[4]

    # Check if we need to grow
    if (len * 100) >= (cap * DICT_LOAD_THRESHOLD):
        dict_grow(dict)

    idx: int32 = dict_find_insert_slot(dict, key)
    if idx < 0:
        return  # Table full (error case)

    keys: Ptr[int32] = Ptr[int32](dict[0])
    values: Ptr[int32] = Ptr[int32](dict[1])
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    # Check if this is a new entry
    if cast[int32](flags[idx]) != DICT_SLOT_USED:
        dict[4] = len + 1

    keys[idx] = key
    values[idx] = value
    flags[idx] = cast[uint8](DICT_SLOT_USED)

# Get value for key (returns 0 if not found)
def dict_get(dict: Ptr[int32], key: int32) -> int32:
    idx: int32 = dict_find_slot(dict, key)
    if idx < 0:
        return 0
    values: Ptr[int32] = Ptr[int32](dict[1])
    return values[idx]

# Get value with default if not found
def dict_get_default(dict: Ptr[int32], key: int32, default_val: int32) -> int32:
    idx: int32 = dict_find_slot(dict, key)
    if idx < 0:
        return default_val
    values: Ptr[int32] = Ptr[int32](dict[1])
    return values[idx]

# Check if key exists
def dict_contains(dict: Ptr[int32], key: int32) -> int32:
    if dict_find_slot(dict, key) >= 0:
        return 1
    return 0

# Remove key (returns 1 if found, 0 if not)
def dict_remove(dict: Ptr[int32], key: int32) -> int32:
    idx: int32 = dict_find_slot(dict, key)
    if idx < 0:
        return 0

    flags: Ptr[uint8] = Ptr[uint8](dict[2])
    flags[idx] = cast[uint8](DICT_SLOT_DELETED)
    dict[4] = dict[4] - 1
    return 1

# Clear all entries (keep capacity)
def dict_clear(dict: Ptr[int32]):
    cap: int32 = dict[3]
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    i: int32 = 0
    while i < cap:
        flags[i] = cast[uint8](DICT_SLOT_EMPTY)
        i = i + 1

    dict[4] = 0

# Iterate over dict - get key at iteration index
# Use with dict_iter_valid to check if index is valid
def dict_iter_key(dict: Ptr[int32], iter_idx: int32) -> int32:
    keys: Ptr[int32] = Ptr[int32](dict[0])
    return keys[iter_idx]

# Get value at iteration index
def dict_iter_value(dict: Ptr[int32], iter_idx: int32) -> int32:
    values: Ptr[int32] = Ptr[int32](dict[1])
    return values[iter_idx]

# Check if iteration index points to valid entry
def dict_iter_valid(dict: Ptr[int32], iter_idx: int32) -> int32:
    cap: int32 = dict[3]
    if iter_idx >= cap:
        return 0
    flags: Ptr[uint8] = Ptr[uint8](dict[2])
    if cast[int32](flags[iter_idx]) == DICT_SLOT_USED:
        return 1
    return 0

# Get next valid iteration index (or cap if done)
def dict_iter_next(dict: Ptr[int32], iter_idx: int32) -> int32:
    cap: int32 = dict[3]
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    i: int32 = iter_idx + 1
    while i < cap:
        if cast[int32](flags[i]) == DICT_SLOT_USED:
            return i
        i = i + 1
    return cap  # Done

# Get first valid iteration index (or cap if empty)
def dict_iter_start(dict: Ptr[int32]) -> int32:
    cap: int32 = dict[3]
    flags: Ptr[uint8] = Ptr[uint8](dict[2])

    i: int32 = 0
    while i < cap:
        if cast[int32](flags[i]) == DICT_SLOT_USED:
            return i
        i = i + 1
    return cap  # Empty

# String key operations (keys are string hashes, need separate key storage for equality)
# For full string key support, use dict_str.bh (TODO)

# Set with pointer key and value
def dict_set_ptr(dict: Ptr[int32], key: Ptr[uint8], value: Ptr[uint8]):
    dict_set(dict, cast[int32](key), cast[int32](value))

# Get pointer value for pointer key
def dict_get_ptr(dict: Ptr[int32], key: Ptr[uint8]) -> Ptr[uint8]:
    return Ptr[uint8](dict_get(dict, cast[int32](key)))
