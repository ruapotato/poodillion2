# BrainhairOS SHA-1 Library
# SHA-1 hash implementation for WebSocket handshake (RFC 3174)

from lib.syscalls import *

# SHA-1 constants
SHA1_BLOCK_SIZE: Final[int32] = 64
SHA1_DIGEST_SIZE: Final[int32] = 20

# SHA-1 state
sha1_state: Array[5, int32]
sha1_count: Array[2, int32]
sha1_buffer: Array[64, uint8]

# SHA-1 constants
sha1_k: Array[4, int32]

def sha1_init_constants():
    sha1_k[0] = 0x5A827999
    sha1_k[1] = 0x6ED9EBA1
    sha1_k[2] = 0x8F1BBCDC
    sha1_k[3] = 0xCA62C1D6

def sha1_rotl(x: int32, n: int32) -> int32:
    """Rotate left"""
    return ((x << n) | ((x >> (32 - n)) & ((1 << n) - 1)))

def sha1_init():
    """Initialize SHA-1 state"""
    sha1_init_constants()
    sha1_state[0] = 0x67452301
    sha1_state[1] = 0xEFCDAB89
    sha1_state[2] = 0x98BADCFE
    sha1_state[3] = 0x10325476
    sha1_state[4] = 0xC3D2E1F0
    sha1_count[0] = 0
    sha1_count[1] = 0

def sha1_transform(block: Ptr[uint8]):
    """Process a 64-byte block"""
    w: Array[80, int32]
    a: int32
    b: int32
    c: int32
    d: int32
    e: int32
    f: int32
    k: int32
    temp: int32
    i: int32

    # Prepare message schedule
    i = 0
    while i < 16:
        w[i] = (cast[int32](block[i * 4]) << 24) | (cast[int32](block[i * 4 + 1]) << 16) | (cast[int32](block[i * 4 + 2]) << 8) | cast[int32](block[i * 4 + 3])
        i = i + 1

    while i < 80:
        temp = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]
        w[i] = sha1_rotl(temp, 1)
        i = i + 1

    # Initialize working variables
    a = sha1_state[0]
    b = sha1_state[1]
    c = sha1_state[2]
    d = sha1_state[3]
    e = sha1_state[4]

    # Main loop
    i = 0
    while i < 80:
        if i < 20:
            f = (b & c) | ((~b) & d)
            k = sha1_k[0]
        elif i < 40:
            f = b ^ c ^ d
            k = sha1_k[1]
        elif i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = sha1_k[2]
        else:
            f = b ^ c ^ d
            k = sha1_k[3]

        temp = sha1_rotl(a, 5) + f + e + k + w[i]
        e = d
        d = c
        c = sha1_rotl(b, 30)
        b = a
        a = temp

        i = i + 1

    # Update state
    sha1_state[0] = sha1_state[0] + a
    sha1_state[1] = sha1_state[1] + b
    sha1_state[2] = sha1_state[2] + c
    sha1_state[3] = sha1_state[3] + d
    sha1_state[4] = sha1_state[4] + e

def sha1_update(data: Ptr[uint8], len: int32):
    """Update SHA-1 with more data"""
    i: int32 = 0
    j: int32 = (sha1_count[0] >> 3) & 63

    # Update bit count
    sha1_count[0] = sha1_count[0] + (len << 3)
    if sha1_count[0] < (len << 3):
        sha1_count[1] = sha1_count[1] + 1
    sha1_count[1] = sha1_count[1] + (len >> 29)

    # Process data
    while i < len:
        sha1_buffer[j] = data[i]
        j = j + 1
        if j == 64:
            sha1_transform(addr(sha1_buffer[0]))
            j = 0
        i = i + 1

def sha1_final(digest: Ptr[uint8]):
    """Finalize and get digest"""
    pad: Array[64, uint8]
    bits: Array[8, uint8]
    index: int32
    pad_len: int32
    i: int32

    # Store bit count (big endian)
    bits[0] = cast[uint8]((sha1_count[1] >> 24) & 0xFF)
    bits[1] = cast[uint8]((sha1_count[1] >> 16) & 0xFF)
    bits[2] = cast[uint8]((sha1_count[1] >> 8) & 0xFF)
    bits[3] = cast[uint8](sha1_count[1] & 0xFF)
    bits[4] = cast[uint8]((sha1_count[0] >> 24) & 0xFF)
    bits[5] = cast[uint8]((sha1_count[0] >> 16) & 0xFF)
    bits[6] = cast[uint8]((sha1_count[0] >> 8) & 0xFF)
    bits[7] = cast[uint8](sha1_count[0] & 0xFF)

    # Pad out to 56 mod 64
    index = (sha1_count[0] >> 3) & 63
    if index < 56:
        pad_len = 56 - index
    else:
        pad_len = 120 - index

    # Create padding
    pad[0] = 0x80
    i = 1
    while i < pad_len:
        pad[i] = 0
        i = i + 1

    sha1_update(addr(pad[0]), pad_len)
    sha1_update(addr(bits[0]), 8)

    # Output digest (big endian)
    i = 0
    while i < 5:
        digest[i * 4] = cast[uint8]((sha1_state[i] >> 24) & 0xFF)
        digest[i * 4 + 1] = cast[uint8]((sha1_state[i] >> 16) & 0xFF)
        digest[i * 4 + 2] = cast[uint8]((sha1_state[i] >> 8) & 0xFF)
        digest[i * 4 + 3] = cast[uint8](sha1_state[i] & 0xFF)
        i = i + 1

def sha1(data: Ptr[uint8], len: int32, digest: Ptr[uint8]):
    """Compute SHA-1 hash of data"""
    sha1_init()
    sha1_update(data, len)
    sha1_final(digest)
