# pthread.bh - POSIX-compatible pthread API for BrainhairOS
# Provides pthread_* functions that map to BrainhairOS threading primitives
# Implements 1:1 threading model (one kernel thread per pthread)

from lib.syscalls import *

# ============================================================================
# pthread Types
# ============================================================================

# pthread_attr_t - thread attributes (placeholder for now)
class pthread_attr_t:
    detachstate: int32    # PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE
    stacksize: int32      # Stack size (not implemented yet)

# ============================================================================
# pthread Constants
# ============================================================================

# Thread detach state
PTHREAD_CREATE_JOINABLE: Final[int32] = 0
PTHREAD_CREATE_DETACHED: Final[int32] = 1

# Return values
PTHREAD_SUCCESS: Final[int32] = 0
PTHREAD_ERROR: Final[int32] = -1

# ============================================================================
# pthread Attribute Functions
# ============================================================================

# Initialize thread attributes to default values
def pthread_attr_init(attr: Ptr[pthread_attr_t]) -> int32:
    attr.detachstate = PTHREAD_CREATE_JOINABLE
    attr.stacksize = 0  # Use default
    return PTHREAD_SUCCESS

# Destroy thread attributes (no-op for now)
def pthread_attr_destroy(attr: Ptr[pthread_attr_t]) -> int32:
    return PTHREAD_SUCCESS

# Set detach state
def pthread_attr_setdetachstate(attr: Ptr[pthread_attr_t], detachstate: int32) -> int32:
    if detachstate != PTHREAD_CREATE_JOINABLE and detachstate != PTHREAD_CREATE_DETACHED:
        return PTHREAD_ERROR
    attr.detachstate = detachstate
    return PTHREAD_SUCCESS

# Get detach state
def pthread_attr_getdetachstate(attr: Ptr[pthread_attr_t], detachstate: Ptr[int32]) -> int32:
    detachstate[0] = attr.detachstate
    return PTHREAD_SUCCESS

# ============================================================================
# pthread Thread Management Functions
# ============================================================================

# Thread wrapper structure to pass both function and argument
class pthread_start_info:
    start_routine: int32  # Function pointer
    arg: int32            # User argument

# Internal thread entry point wrapper
def pthread_entry_wrapper(info_ptr: int32) -> int32:
    # Cast info_ptr to pthread_start_info pointer
    info: Ptr[pthread_start_info] = cast[Ptr[pthread_start_info]](info_ptr)

    # Get the actual start routine and argument
    start_routine: int32 = info.start_routine
    arg: int32 = info.arg

    # For now, return 0 - users should call pthread_exit explicitly
    return 0

# Create a new thread
def pthread_create(thread: Ptr[int32], attr: Ptr[pthread_attr_t],
                   start_routine: int32, arg: int32) -> int32:
    tid: int32 = thread_create(start_routine, arg)
    if tid < 0:
        return PTHREAD_ERROR

    # Store thread ID
    thread[0] = tid

    # If detached attribute is set, detach the thread
    if attr != cast[Ptr[pthread_attr_t]](0):
        if attr.detachstate == PTHREAD_CREATE_DETACHED:
            thread_detach(tid)

    return PTHREAD_SUCCESS

# Wait for thread to terminate
def pthread_join(thread: int32, retval: Ptr[int32]) -> int32:
    status: int32 = 0
    result: int32 = thread_join(thread, addr(status))

    if result < 0:
        return PTHREAD_ERROR

    # Store return value if pointer provided
    if retval != cast[Ptr[int32]](0):
        retval[0] = status

    return PTHREAD_SUCCESS

# Exit the calling thread
def pthread_exit(retval: int32):
    thread_exit(retval)

# Get ID of calling thread
def pthread_self() -> int32:
    return thread_self()

# Compare thread IDs
def pthread_equal(t1: int32, t2: int32) -> int32:
    if t1 == t2:
        return 1
    return 0

# Detach a thread (make it clean up automatically on exit)
def pthread_detach(thread: int32) -> int32:
    result: int32 = thread_detach(thread)
    if result < 0:
        return PTHREAD_ERROR
    return PTHREAD_SUCCESS

# Yield CPU to other threads
def pthread_yield() -> int32:
    thread_yield()
    return PTHREAD_SUCCESS

# ============================================================================
# Helper Functions
# ============================================================================

# Print pthread error messages
def pthread_perror(msg: Ptr[uint8]):
    perror(msg)
