# sync.bh - Userland Synchronization Library for BrainhairOS
# Provides high-level synchronization primitives using kernel spinlocks
# Foundation for multi-threaded userland applications (Phase 3.2)

from lib.syscalls import *

# ===========================================================================
# Syscall Numbers for Synchronization
# ===========================================================================

# Spinlock syscalls (to be implemented in kernel)
SYS_spinlock_init: Final[int32] = 210
SYS_spinlock_lock: Final[int32] = 211
SYS_spinlock_unlock: Final[int32] = 212
SYS_spinlock_trylock: Final[int32] = 213
SYS_atomic_add: Final[int32] = 214
SYS_atomic_cmpxchg: Final[int32] = 215
SYS_atomic_load: Final[int32] = 216
SYS_atomic_store: Final[int32] = 217

# ===========================================================================
# Low-Level Atomic Operations
# ===========================================================================

# Atomically load a 32-bit value
def atomic_load(p: Ptr[int32]) -> int32:
    return syscall1(SYS_atomic_load, cast[int32](p))

# Atomically store a 32-bit value
def atomic_store(p: Ptr[int32], value: int32):
    syscall2(SYS_atomic_store, cast[int32](p), value)

# Atomically add to a value and return the old value
def atomic_add(p: Ptr[int32], value: int32) -> int32:
    return syscall2(SYS_atomic_add, cast[int32](p), value)

# Atomically increment and return the old value
def atomic_inc(p: Ptr[int32]) -> int32:
    return atomic_add(p, 1)

# Atomically decrement and return the old value
def atomic_dec(p: Ptr[int32]) -> int32:
    return atomic_add(p, -1)

# Atomic compare-and-swap
# If *ptr == expected, then *ptr = new_value and return 1
# Otherwise, return 0
def atomic_cmpxchg(p: Ptr[int32], expected: int32, new_value: int32) -> int32:
    return syscall3(SYS_atomic_cmpxchg, cast[int32](p), expected, new_value)

# ===========================================================================
# Spinlock Implementation
# ===========================================================================

# Spinlock is just a 32-bit integer: 0 = unlocked, 1 = locked

# Initialize a spinlock (must be called before use)
def spinlock_init(lock: Ptr[int32]):
    syscall1(SYS_spinlock_init, cast[int32](lock))

# Acquire a spinlock (blocking)
# Spins until the lock is acquired
def spinlock_lock(lock: Ptr[int32]):
    syscall1(SYS_spinlock_lock, cast[int32](lock))

# Release a spinlock
def spinlock_unlock(lock: Ptr[int32]):
    syscall1(SYS_spinlock_unlock, cast[int32](lock))

# Try to acquire a spinlock (non-blocking)
# Returns 1 if lock acquired, 0 if already held
def spinlock_trylock(lock: Ptr[int32]) -> int32:
    return syscall1(SYS_spinlock_trylock, cast[int32](lock))

# ===========================================================================
# Mutex Implementation (using spinlocks for now)
# ===========================================================================

# Mutex structure
# For now, this is just a spinlock. In the future, we can implement
# proper sleeping mutexes using futex-style syscalls.
class Mutex:
    lock: int32
    owner: int32      # Thread ID of owner (0 if unlocked)
    count: int32      # Recursion count for recursive mutexes

# Initialize a mutex
def mutex_init(mtx: Ptr[Mutex]):
    spinlock_init(addr(mtx.lock))
    mtx.owner = 0
    mtx.count = 0

# Lock a mutex
# For now, this is a spinlock. TODO: Implement sleeping locks.
def mutex_lock(mtx: Ptr[Mutex]):
    spinlock_lock(addr(mtx.lock))
    # TODO: Set owner to current thread ID when we have thread syscalls
    mtx.owner = 1
    mtx.count = 1

# Unlock a mutex
def mutex_unlock(mtx: Ptr[Mutex]):
    mtx.owner = 0
    mtx.count = 0
    spinlock_unlock(addr(mtx.lock))

# Try to lock a mutex (non-blocking)
# Returns 1 if lock acquired, 0 if already held
def mutex_trylock(mtx: Ptr[Mutex]) -> int32:
    result: int32 = spinlock_trylock(addr(mtx.lock))
    if result == 1:
        mtx.owner = 1
        mtx.count = 1
    return result

# ===========================================================================
# Read-Write Lock (simplified implementation)
# ===========================================================================

# Read-write lock structure
# Allows multiple readers OR one writer
class RWLock:
    lock: int32           # Protects the state
    readers: int32        # Number of active readers
    writer: int32         # 1 if writer is active, 0 otherwise
    waiting_writers: int32 # Number of waiting writers

# Initialize a read-write lock
def rwlock_init(rwl: Ptr[RWLock]):
    spinlock_init(addr(rwl.lock))
    rwl.readers = 0
    rwl.writer = 0
    rwl.waiting_writers = 0

# Acquire read lock
def rwlock_read_lock(rwl: Ptr[RWLock]):
    while 1 == 1:
        spinlock_lock(addr(rwl.lock))

        # Can acquire read lock if no writer and no waiting writers
        if rwl.writer == 0 and rwl.waiting_writers == 0:
            rwl.readers = rwl.readers + 1
            spinlock_unlock(addr(rwl.lock))
            return

        spinlock_unlock(addr(rwl.lock))
        # TODO: Sleep instead of spinning
        # For now, yield or just spin

# Release read lock
def rwlock_read_unlock(rwl: Ptr[RWLock]):
    spinlock_lock(addr(rwl.lock))
    rwl.readers = rwl.readers - 1
    spinlock_unlock(addr(rwl.lock))

# Acquire write lock
def rwlock_write_lock(rwl: Ptr[RWLock]):
    spinlock_lock(addr(rwl.lock))
    rwl.waiting_writers = rwl.waiting_writers + 1
    spinlock_unlock(addr(rwl.lock))

    while 1 == 1:
        spinlock_lock(addr(rwl.lock))

        # Can acquire write lock if no readers and no writer
        if rwl.readers == 0 and rwl.writer == 0:
            rwl.writer = 1
            rwl.waiting_writers = rwl.waiting_writers - 1
            spinlock_unlock(addr(rwl.lock))
            return

        spinlock_unlock(addr(rwl.lock))
        # TODO: Sleep instead of spinning

# Release write lock
def rwlock_write_unlock(rwl: Ptr[RWLock]):
    spinlock_lock(addr(rwl.lock))
    rwl.writer = 0
    spinlock_unlock(addr(rwl.lock))

# ===========================================================================
# Semaphore Implementation (counting semaphore)
# ===========================================================================

# Semaphore structure
class Semaphore:
    lock: int32
    count: int32      # Available resources
    max_count: int32  # Maximum count (for bounded semaphores)

# Initialize a semaphore with initial count
def semaphore_init(sem: Ptr[Semaphore], initial: int32, max_count: int32):
    spinlock_init(addr(sem.lock))
    sem.count = initial
    sem.max_count = max_count

# Wait on semaphore (decrement, blocking if count == 0)
def semaphore_wait(sem: Ptr[Semaphore]):
    while 1 == 1:
        spinlock_lock(addr(sem.lock))

        if sem.count > 0:
            sem.count = sem.count - 1
            spinlock_unlock(addr(sem.lock))
            return

        spinlock_unlock(addr(sem.lock))
        # TODO: Sleep instead of spinning

# Try to wait on semaphore (non-blocking)
# Returns 1 if acquired, 0 if count was 0
def semaphore_trywait(sem: Ptr[Semaphore]) -> int32:
    spinlock_lock(addr(sem.lock))

    if sem.count > 0:
        sem.count = sem.count - 1
        spinlock_unlock(addr(sem.lock))
        return 1

    spinlock_unlock(addr(sem.lock))
    return 0

# Post to semaphore (increment)
def semaphore_post(sem: Ptr[Semaphore]):
    spinlock_lock(addr(sem.lock))

    if sem.count < sem.max_count:
        sem.count = sem.count + 1

    spinlock_unlock(addr(sem.lock))

# Get current semaphore count
def semaphore_getvalue(sem: Ptr[Semaphore]) -> int32:
    spinlock_lock(addr(sem.lock))
    value: int32 = sem.count
    spinlock_unlock(addr(sem.lock))
    return value

# ===========================================================================
# Condition Variable (simplified, requires mutex)
# ===========================================================================

# Condition variable structure
class CondVar:
    lock: int32
    waiters: int32    # Number of waiting threads

# Initialize a condition variable
def condvar_init(cond: Ptr[CondVar]):
    spinlock_init(addr(cond.lock))
    cond.waiters = 0

# Wait on condition variable
# NOTE: This is a simplified implementation. A proper implementation
# would atomically release the mutex and wait.
def condvar_wait(cond: Ptr[CondVar], mtx: Ptr[Mutex]):
    spinlock_lock(addr(cond.lock))
    cond.waiters = cond.waiters + 1
    spinlock_unlock(addr(cond.lock))

    # Release mutex
    mutex_unlock(mtx)

    # TODO: Actual blocking wait (futex-style)
    # For now, just spin-wait (very inefficient!)
    while 1 == 1:
        spinlock_lock(addr(cond.lock))
        if cond.waiters == 0:
            spinlock_unlock(addr(cond.lock))
            break
        spinlock_unlock(addr(cond.lock))

    # Re-acquire mutex
    mutex_lock(mtx)

# Signal one waiting thread
def condvar_signal(cond: Ptr[CondVar]):
    spinlock_lock(addr(cond.lock))
    if cond.waiters > 0:
        cond.waiters = cond.waiters - 1
    spinlock_unlock(addr(cond.lock))

# Broadcast to all waiting threads
def condvar_broadcast(cond: Ptr[CondVar]):
    spinlock_lock(addr(cond.lock))
    cond.waiters = 0
    spinlock_unlock(addr(cond.lock))

# ===========================================================================
# Barrier (thread synchronization point)
# ===========================================================================

# Barrier structure
class Barrier:
    lock: int32
    threshold: int32  # Number of threads that must wait
    count: int32      # Current number of waiting threads
    generation: int32 # Generation number (to handle reuse)

# Initialize a barrier
def barrier_init(bar: Ptr[Barrier], thread_count: int32):
    spinlock_init(addr(bar.lock))
    bar.threshold = thread_count
    bar.count = 0
    bar.generation = 0

# Wait at barrier
# All threads block until threshold threads arrive
def barrier_wait(bar: Ptr[Barrier]):
    spinlock_lock(addr(bar.lock))

    current_gen: int32 = bar.generation
    bar.count = bar.count + 1

    if bar.count >= bar.threshold:
        # Last thread to arrive - reset and wake all
        bar.count = 0
        bar.generation = bar.generation + 1
        spinlock_unlock(addr(bar.lock))
        return

    spinlock_unlock(addr(bar.lock))

    # Wait for generation to change
    while 1 == 1:
        spinlock_lock(addr(bar.lock))
        if bar.generation != current_gen:
            spinlock_unlock(addr(bar.lock))
            return
        spinlock_unlock(addr(bar.lock))
        # TODO: Sleep instead of spinning

# ===========================================================================
# Atomic Flag (simple lock-free flag)
# ===========================================================================

# Initialize atomic flag to false
def atomic_flag_clear(flag: Ptr[int32]):
    atomic_store(flag, 0)

# Test and set atomic flag
# Returns 1 if flag was already set, 0 if it was clear (and now set)
def atomic_flag_test_and_set(flag: Ptr[int32]) -> int32:
    return atomic_cmpxchg(flag, 0, 1)

# ===========================================================================
# Lock-Free Counter (using atomic operations)
# ===========================================================================

# Initialize counter
def atomic_counter_init(counter: Ptr[int32], initial: int32):
    atomic_store(counter, initial)

# Increment counter and return new value
def atomic_counter_inc(counter: Ptr[int32]) -> int32:
    return atomic_add(counter, 1) + 1

# Decrement counter and return new value
def atomic_counter_dec(counter: Ptr[int32]) -> int32:
    return atomic_add(counter, -1) - 1

# Get current counter value
def atomic_counter_get(counter: Ptr[int32]) -> int32:
    return atomic_load(counter)

# Set counter value
def atomic_counter_set(counter: Ptr[int32], value: int32):
    atomic_store(counter, value)

# Add to counter and return new value
def atomic_counter_add(counter: Ptr[int32], value: int32) -> int32:
    return atomic_add(counter, value) + value

# ===========================================================================
# Helper Functions
# ===========================================================================

# Yield CPU (for spin loops)
# TODO: Implement proper yield syscall
def sync_yield():
    # For now, just a no-op
    # In the future, call thread_yield() syscall
    pass

# Memory barrier (ensure all memory operations complete)
# On x86, this is often implicit, but we can add explicit barriers
def sync_memory_barrier():
    # TODO: Implement memory_barrier syscall or inline assembly
    pass

# ===========================================================================
# Futex Syscall Numbers
# ===========================================================================

SYS_FUTEX_WAIT: Final[int32] = 250
SYS_FUTEX_WAKE: Final[int32] = 251
SYS_FUTEX_REQUEUE: Final[int32] = 252

# ===========================================================================
# Low-Level Futex Operations
# ===========================================================================

# Wait on a futex address if value matches expected
# Returns: 0 on success, -1 if value changed, -2 on error
def futex_wait(address: Ptr[int32], expected: int32, timeout: int32) -> int32:
    return syscall3(SYS_FUTEX_WAIT, cast[int32](address), expected, timeout)

# Wake up waiters on a futex address
# count: number to wake (0 = all)
# Returns: number of waiters woken
def futex_wake(address: Ptr[int32], count: int32) -> int32:
    return syscall2(SYS_FUTEX_WAKE, cast[int32](address), count)

# Move waiters from one address to another
def futex_requeue(src: Ptr[int32], dst: Ptr[int32],
                  wake_count: int32, requeue_count: int32) -> int32:
    return syscall4(SYS_FUTEX_REQUEUE, cast[int32](src), cast[int32](dst),
                    wake_count, requeue_count)

# ===========================================================================
# Sleeping Mutex (Futex-based)
# ===========================================================================

# Sleeping mutex state values
FUTEX_MUTEX_UNLOCKED: Final[int32] = 0    # Not locked
FUTEX_MUTEX_LOCKED: Final[int32] = 1      # Locked, no waiters
FUTEX_MUTEX_CONTENDED: Final[int32] = 2   # Locked with waiters

# Futex-based mutex structure
# This mutex sleeps instead of spinning, saving CPU
class FutexMutex:
    state: int32          # UNLOCKED, LOCKED, or CONTENDED

# Initialize a futex mutex
def futex_mutex_init(mtx: Ptr[FutexMutex]):
    mtx.state = FUTEX_MUTEX_UNLOCKED

# Lock a futex mutex (blocks efficiently)
def futex_mutex_lock(mtx: Ptr[FutexMutex]):
    # Fast path: try to acquire unlocked mutex
    if atomic_cmpxchg(addr(mtx.state), FUTEX_MUTEX_UNLOCKED,
                      FUTEX_MUTEX_LOCKED) == 1:
        return

    # Slow path: mutex was locked, set contended and wait
    while 1 == 1:
        # Set state to contended (if not already)
        old: int32 = atomic_load(addr(mtx.state))
        if old == FUTEX_MUTEX_UNLOCKED:
            # Became unlocked - try to acquire
            if atomic_cmpxchg(addr(mtx.state), FUTEX_MUTEX_UNLOCKED,
                              FUTEX_MUTEX_CONTENDED) == 1:
                return

        # Mark as contended and wait
        if old != FUTEX_MUTEX_CONTENDED:
            atomic_cmpxchg(addr(mtx.state), old, FUTEX_MUTEX_CONTENDED)

        # Sleep until woken (state should be CONTENDED)
        futex_wait(addr(mtx.state), FUTEX_MUTEX_CONTENDED, 0)

        # Woke up - try to acquire
        if atomic_cmpxchg(addr(mtx.state), FUTEX_MUTEX_UNLOCKED,
                          FUTEX_MUTEX_CONTENDED) == 1:
            return

# Unlock a futex mutex
def futex_mutex_unlock(mtx: Ptr[FutexMutex]):
    # Fast path: no waiters, just unlock
    if atomic_cmpxchg(addr(mtx.state), FUTEX_MUTEX_LOCKED,
                      FUTEX_MUTEX_UNLOCKED) == 1:
        return

    # Slow path: there were waiters, wake one
    atomic_store(addr(mtx.state), FUTEX_MUTEX_UNLOCKED)
    futex_wake(addr(mtx.state), 1)

# Try to lock a futex mutex (non-blocking)
def futex_mutex_trylock(mtx: Ptr[FutexMutex]) -> int32:
    if atomic_cmpxchg(addr(mtx.state), FUTEX_MUTEX_UNLOCKED,
                      FUTEX_MUTEX_LOCKED) == 1:
        return 1
    return 0

# ===========================================================================
# Sleeping Semaphore (Futex-based)
# ===========================================================================

# Futex-based semaphore structure
class FutexSemaphore:
    count: int32          # Available resources
    max_count: int32      # Maximum count

# Initialize a futex semaphore
def futex_semaphore_init(sem: Ptr[FutexSemaphore], initial: int32, max_val: int32):
    sem.count = initial
    sem.max_count = max_val

# Wait on semaphore (decrement, blocking if count == 0)
def futex_semaphore_wait(sem: Ptr[FutexSemaphore]):
    while 1 == 1:
        c: int32 = atomic_load(addr(sem.count))
        if c > 0:
            if atomic_cmpxchg(addr(sem.count), c, c - 1) == 1:
                return
        else:
            # Count is 0 - sleep until signaled
            futex_wait(addr(sem.count), 0, 0)

# Post to semaphore (increment)
def futex_semaphore_post(sem: Ptr[FutexSemaphore]):
    while 1 == 1:
        c: int32 = atomic_load(addr(sem.count))
        if c >= sem.max_count:
            return  # Already at max

        if atomic_cmpxchg(addr(sem.count), c, c + 1) == 1:
            # Successfully incremented - wake a waiter
            futex_wake(addr(sem.count), 1)
            return

# ===========================================================================
# Sleeping Condition Variable (Futex-based)
# ===========================================================================

# Futex-based condition variable
class FutexCondVar:
    seq: int32            # Sequence number for spurious wakeup detection

# Initialize a condition variable
def futex_condvar_init(cond: Ptr[FutexCondVar]):
    cond.seq = 0

# Wait on condition variable (with futex mutex)
def futex_condvar_wait(cond: Ptr[FutexCondVar], mtx: Ptr[FutexMutex]):
    seq: int32 = cond.seq

    # Release mutex
    futex_mutex_unlock(mtx)

    # Wait for signal (seq will change)
    futex_wait(addr(cond.seq), seq, 0)

    # Re-acquire mutex
    futex_mutex_lock(mtx)

# Signal one waiter
def futex_condvar_signal(cond: Ptr[FutexCondVar]):
    # Increment sequence to wake waiter
    atomic_add(addr(cond.seq), 1)
    futex_wake(addr(cond.seq), 1)

# Broadcast to all waiters
def futex_condvar_broadcast(cond: Ptr[FutexCondVar]):
    # Increment sequence and wake all
    atomic_add(addr(cond.seq), 1)
    futex_wake(addr(cond.seq), 0)  # 0 = wake all

# ===========================================================================
# Once (Run Initialization Once)
# ===========================================================================

ONCE_INIT: Final[int32] = 0
ONCE_RUNNING: Final[int32] = 1
ONCE_DONE: Final[int32] = 2

# Once control structure
class Once:
    state: int32

# Initialize once control
def once_init(once: Ptr[Once]):
    once.state = ONCE_INIT

# Call init_func exactly once, even with concurrent callers
# Returns: 1 if this call ran the function, 0 if already done
def call_once(once: Ptr[Once], init_func: int32) -> int32:
    # Fast path: already done
    if atomic_load(addr(once.state)) == ONCE_DONE:
        return 0

    # Try to become the one that runs initialization
    if atomic_cmpxchg(addr(once.state), ONCE_INIT, ONCE_RUNNING) == 1:
        # We are the initializer - run the function
        # NOTE: Would need indirect call support
        # For now, just mark as done
        atomic_store(addr(once.state), ONCE_DONE)
        futex_wake(addr(once.state), 0)  # Wake all waiters
        return 1

    # Someone else is running initialization - wait
    while atomic_load(addr(once.state)) != ONCE_DONE:
        futex_wait(addr(once.state), ONCE_RUNNING, 0)

    return 0
