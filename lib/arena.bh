# Arena Allocator for Brainhair
#
# An arena (or region-based memory allocator) provides fast allocation
# with bulk deallocation. All memory allocated from an arena is freed
# at once when the arena is destroyed.
#
# Benefits:
# - O(1) allocation (just bump a pointer)
# - No individual free() calls needed
# - No fragmentation within the arena
# - Cache-friendly linear allocation
# - Deterministic cleanup (no GC)
#
# Usage:
#   arena: Array[16, uint8]
#   arena_init(addr(arena), 64 * 1024)  # 64KB arena
#   data: Ptr[MyStruct] = arena_alloc(addr(arena), 16)
#   # ... use data ...
#   arena_destroy(addr(arena))  # Free everything at once

SYS_brk: Final[int32] = 45
SYS_mmap: Final[int32] = 90
SYS_munmap: Final[int32] = 91

PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_PRIVATE: Final[int32] = 2
MAP_ANONYMOUS: Final[int32] = 32

extern def syscall1(num: int32, arg1: int32) -> int32
extern def syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32) -> int32

# Arena structure
# Fields:
#   base: Ptr[uint8]   - Base address of arena memory (offset 0)
#   size: int32        - Total size of arena (offset 4)
#   used: int32        - Bytes currently allocated (offset 8)
#   next: Ptr[Arena]   - Next arena in chain (for overflow) (offset 12)
# Total size: 16 bytes

ARENA_BASE_OFFSET: Final[int32] = 0
ARENA_SIZE_OFFSET: Final[int32] = 4
ARENA_USED_OFFSET: Final[int32] = 8
ARENA_NEXT_OFFSET: Final[int32] = 12
ARENA_STRUCT_SIZE: Final[int32] = 16

# Create a new arena with the given size
# Returns arena initialized at the provided pointer
def arena_init(arena: Ptr[uint8], size: int32):
    # Allocate memory using mmap
    mem: int32 = syscall6(SYS_mmap, 0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)

    if mem < 0:
        # Allocation failed, set base to 0
        base_ptr: Ptr[int32] = cast[Ptr[int32]](arena)
        base_ptr[0] = 0
        return

    # Initialize arena structure
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    arena32[0] = mem           # base
    arena32[1] = size          # size
    arena32[2] = 0             # used
    arena32[3] = 0             # next (no overflow arena yet)

# Allocate memory from arena
# Returns pointer to allocated memory, or 0 if arena is full
def arena_alloc(arena: Ptr[uint8], alloc_size: int32) -> Ptr[uint8]:
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)

    base: int32 = arena32[0]
    size: int32 = arena32[1]
    used: int32 = arena32[2]

    # Check if arena is valid
    if base == 0:
        return cast[Ptr[uint8]](0)

    # Align allocation to 4 bytes
    aligned_size: int32 = (alloc_size + 3) & -4

    # Check if we have space
    if used + aligned_size > size:
        # TODO: Could chain to overflow arena
        return cast[Ptr[uint8]](0)

    # Bump allocate
    result: int32 = base + used
    arena32[2] = used + aligned_size

    return cast[Ptr[uint8]](result)

# Allocate and zero memory from arena
def arena_alloc_zero(arena: Ptr[uint8], alloc_size: int32) -> Ptr[uint8]:
    p: Ptr[uint8] = arena_alloc(arena, alloc_size)

    if cast[int32](p) == 0:
        return p

    # Zero the memory
    i: int32 = 0
    while i < alloc_size:
        p[i] = 0
        i = i + 1

    return p

# Reset arena (free all allocations but keep the memory)
def arena_reset(arena: Ptr[uint8]):
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    arena32[2] = 0  # Reset used to 0

    # Reset any chained arenas too
    next: int32 = arena32[3]
    if next != 0:
        arena_reset(cast[Ptr[uint8]](next))

# Destroy arena (release all memory back to OS)
def arena_destroy(arena: Ptr[uint8]):
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)

    base: int32 = arena32[0]
    size: int32 = arena32[1]
    next: int32 = arena32[3]

    # Destroy chained arenas first
    if next != 0:
        arena_destroy(cast[Ptr[uint8]](next))

    # Release memory
    if base != 0:
        syscall6(SYS_munmap, base, size, 0, 0, 0, 0)

    # Clear the arena structure
    arena32[0] = 0
    arena32[1] = 0
    arena32[2] = 0
    arena32[3] = 0

# Get remaining space in arena
def arena_remaining(arena: Ptr[uint8]) -> int32:
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    size: int32 = arena32[1]
    used: int32 = arena32[2]
    return size - used

# Get total allocated bytes
def arena_used(arena: Ptr[uint8]) -> int32:
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    return arena32[2]

# Check if arena is valid (has memory)
def arena_is_valid(arena: Ptr[uint8]) -> bool:
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    return arena32[0] != 0

# Save current allocation point (for temporary allocations)
def arena_save(arena: Ptr[uint8]) -> int32:
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    return arena32[2]

# Restore to saved allocation point (free temporary allocations)
def arena_restore(arena: Ptr[uint8], saved: int32):
    arena32: Ptr[int32] = cast[Ptr[int32]](arena)
    arena32[2] = saved
