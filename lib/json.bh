from lib.syscalls import *

JSON_MAX_DEPTH: Final[int32] = 16
JSON_MAX_STRING_LEN: Final[int32] = 256
JSON_MAX_TOKENS: Final[int32] = 64
JSON_BUILD_BUF_SIZE: Final[int32] = 4096
JSON_NULL: Final[int32] = 0
JSON_BOOL: Final[int32] = 1
JSON_NUMBER: Final[int32] = 2
JSON_STRING: Final[int32] = 3
JSON_ARRAY: Final[int32] = 4
JSON_OBJECT: Final[int32] = 5
JSON_ERROR: Final[int32] = -1

token_types: Array[64, int32]

token_starts: Array[64, int32]

token_lengths: Array[64, int32]

token_parents: Array[64, int32]

token_count: int32 = 0

parse_pos: int32 = 0

parse_input: Ptr[uint8] = Ptr[uint8](0)

parse_len: int32 = 0

parse_error: int32 = 0

json_build_buf: Array[4096, uint8]

json_build_pos: int32 = 0

def json_clear():
    json_build_pos = 0
    json_build_buf[0] = cast[uint8](0)

def json_append(s: Ptr[uint8]) -> int32:
    i: int32 = 0
    while ((cast[int32](s[i]) != 0) and (json_build_pos < (JSON_BUILD_BUF_SIZE - 1))):
        json_build_buf[json_build_pos] = s[i]
        json_build_pos = (json_build_pos + 1)
        i = (i + 1)
    json_build_buf[json_build_pos] = cast[uint8](0)
    return json_build_pos

def json_append_char(c: int32) -> int32:
    if (json_build_pos < (JSON_BUILD_BUF_SIZE - 1)):
        json_build_buf[json_build_pos] = cast[uint8](c)
        json_build_pos = (json_build_pos + 1)
        json_build_buf[json_build_pos] = cast[uint8](0)
    return json_build_pos

def json_append_int(n: int32) -> int32:
    buf: Array[16, uint8]
    itoa(n, addr(buf[0]))
    return json_append(addr(buf[0]))

def json_get() -> Ptr[uint8]:
    return addr(json_build_buf[0])

def json_len() -> int32:
    return json_build_pos

def json_object_start() -> int32:
    return json_append_char(123)

def json_object_end() -> int32:
    if ((json_build_pos > 0) and (cast[int32](json_build_buf[(json_build_pos - 1)]) == 44)):
        json_build_pos = (json_build_pos - 1)
    return json_append_char(125)

def json_array_start() -> int32:
    return json_append_char(91)

def json_array_end() -> int32:
    if ((json_build_pos > 0) and (cast[int32](json_build_buf[(json_build_pos - 1)]) == 44)):
        json_build_pos = (json_build_pos - 1)
    return json_append_char(93)

def json_key(key: Ptr[uint8]) -> int32:
    json_append_char(34)
    json_append(key)
    json_append_char(34)
    return json_append_char(58)

def json_string(val: Ptr[uint8]) -> int32:
    json_append_char(34)
    i: int32 = 0
    while ((cast[int32](val[i]) != 0) and (json_build_pos < (JSON_BUILD_BUF_SIZE - 3))):
        c: int32 = cast[int32](val[i])
        if (c == 34):

            json_append_char(92)

            json_append_char(34)
        elif (c == 92):

            json_append_char(92)

            json_append_char(92)
        elif (c == 10):

            json_append_char(92)

            json_append_char(110)
        elif (c == 13):

            json_append_char(92)

            json_append_char(114)
        elif (c == 9):

            json_append_char(92)

            json_append_char(116)
        else:

            json_append_char(c)
        i = (i + 1)
    json_append_char(34)
    return json_append_char(44)

def json_int(val: int32) -> int32:
    json_append_int(val)
    return json_append_char(44)

def json_bool(val: int32) -> int32:
    if (val != 0):

        json_append(Ptr[uint8]("true"))
    else:

        json_append(Ptr[uint8]("false"))
    return json_append_char(44)

def json_null() -> int32:
    json_append(Ptr[uint8]("null"))
    return json_append_char(44)

def json_raw(val: Ptr[uint8]) -> int32:
    json_append(val)
    return json_append_char(44)

def json_kv_string(key: Ptr[uint8], val: Ptr[uint8]) -> int32:
    json_key(key)
    return json_string(val)

def json_kv_int(key: Ptr[uint8], val: int32) -> int32:
    json_key(key)
    return json_int(val)

def json_kv_bool(key: Ptr[uint8], val: int32) -> int32:
    json_key(key)
    return json_bool(val)

def json_kv_null(key: Ptr[uint8]) -> int32:
    json_key(key)
    return json_null()

def json_skip_ws():
    while (parse_pos < parse_len):
        c: int32 = cast[int32](parse_input[parse_pos])
        if ((((c == 32) or (c == 9)) or (c == 10)) or (c == 13)):
            parse_pos = (parse_pos + 1)
        else:
            return

def json_peek() -> int32:
    if (parse_pos < parse_len):
        return cast[int32](parse_input[parse_pos])
    return 0

def json_advance() -> int32:
    if (parse_pos < parse_len):
        c: int32 = cast[int32](parse_input[parse_pos])
        parse_pos = (parse_pos + 1)
        return c
    return 0

def json_match(s: Ptr[uint8]) -> int32:
    i: int32 = 0
    while (cast[int32](s[i]) != 0):
        if ((parse_pos + i) >= parse_len):
            return 0
        if (cast[int32](parse_input[(parse_pos + i)]) != cast[int32](s[i])):
            return 0
        i = (i + 1)
    parse_pos = (parse_pos + i)
    return 1

def json_new_token(type_val: int32, start: int32, length: int32, parent: int32) -> int32:
    if (token_count >= JSON_MAX_TOKENS):
        parse_error = 1
        return -1
    idx: int32 = token_count
    token_types[idx] = type_val
    token_starts[idx] = start
    token_lengths[idx] = length
    token_parents[idx] = parent
    token_count = (token_count + 1)
    return idx

def json_parse_string(parent: int32) -> int32:
    if (json_peek() != 34):
        return -1
    json_advance()
    start: int32 = parse_pos
    while (parse_pos < parse_len):
        c: int32 = cast[int32](parse_input[parse_pos])
        if (c == 34):
            length: int32 = (parse_pos - start)

            json_advance()
            return json_new_token(JSON_STRING, start, length, parent)
        if (c == 92):
            parse_pos = (parse_pos + 2)
        else:
            parse_pos = (parse_pos + 1)
    parse_error = 1
    return -1

def json_parse_number(parent: int32) -> int32:
    start: int32 = parse_pos
    if (json_peek() == 45):

        json_advance()
    while (parse_pos < parse_len):
        c: int32 = cast[int32](parse_input[parse_pos])
        if ((c >= 48) and (c <= 57)):
            parse_pos = (parse_pos + 1)
        elif (c == 46):
            parse_pos = (parse_pos + 1)
        elif ((c == 101) or (c == 69)):
            parse_pos = (parse_pos + 1)
            if ((json_peek() == 43) or (json_peek() == 45)):
                parse_pos = (parse_pos + 1)
        else:
            break
    length: int32 = (parse_pos - start)
    if (length == 0):
        parse_error = 1
        return -1
    return json_new_token(JSON_NUMBER, start, length, parent)

def json_parse_array(parent: int32) -> int32:
    if (json_peek() != 91):
        return -1
    json_advance()
    start: int32 = (parse_pos - 1)
    arr_token: int32 = json_new_token(JSON_ARRAY, start, 0, parent)
    if (arr_token < 0):
        return -1
    json_skip_ws()
    if (json_peek() == 93):

        json_advance()
        token_lengths[arr_token] = (parse_pos - start)
        return arr_token
    while 1:
        elem: int32 = json_parse_value(arr_token)
        if (elem < 0):
            return -1
        json_skip_ws()
        c: int32 = json_peek()
        if (c == 93):

            json_advance()
            token_lengths[arr_token] = (parse_pos - start)
            return arr_token
        if (c == 44):

            json_advance()
            json_skip_ws()
        else:
            parse_error = 1
            return -1
    return -1

def json_parse_object(parent: int32) -> int32:
    if (json_peek() != 123):
        return -1
    json_advance()
    start: int32 = (parse_pos - 1)
    obj_token: int32 = json_new_token(JSON_OBJECT, start, 0, parent)
    if (obj_token < 0):
        return -1
    json_skip_ws()
    if (json_peek() == 125):

        json_advance()
        token_lengths[obj_token] = (parse_pos - start)
        return obj_token
    while 1:
        json_skip_ws()
        key: int32 = json_parse_string(obj_token)
        if (key < 0):
            return -1
        json_skip_ws()
        if (json_peek() != 58):
            parse_error = 1
            return -1

        json_advance()
        json_skip_ws()
        val: int32 = json_parse_value(obj_token)
        if (val < 0):
            return -1
        json_skip_ws()
        c: int32 = json_peek()
        if (c == 125):

            json_advance()
            token_lengths[obj_token] = (parse_pos - start)
            return obj_token
        if (c == 44):

            json_advance()
        else:
            parse_error = 1
            return -1
    return -1

def json_parse_value(parent: int32) -> int32:
    json_skip_ws()
    c: int32 = json_peek()
    if (c == 34):
        return json_parse_string(parent)
    if (c == 123):
        return json_parse_object(parent)
    if (c == 91):
        return json_parse_array(parent)
    if (c == 116):
        if (json_match(Ptr[uint8]("true")) == 1):
            return json_new_token(JSON_BOOL, (parse_pos - 4), 4, parent)
        parse_error = 1
        return -1
    if (c == 102):
        if (json_match(Ptr[uint8]("false")) == 1):
            return json_new_token(JSON_BOOL, (parse_pos - 5), 5, parent)
        parse_error = 1
        return -1
    if (c == 110):
        if (json_match(Ptr[uint8]("null")) == 1):
            return json_new_token(JSON_NULL, (parse_pos - 4), 4, parent)
        parse_error = 1
        return -1
    if ((c == 45) or ((c >= 48) and (c <= 57))):
        return json_parse_number(parent)
    parse_error = 1
    return -1

def json_parse(input: Ptr[uint8], length: int32) -> int32:
    token_count = 0
    parse_pos = 0
    parse_input = input
    parse_len = length
    parse_error = 0
    if (length <= 0):
        return -1
    result: int32 = json_parse_value(-1)
    if ((result < 0) or (parse_error != 0)):
        return -1
    return token_count

def json_parse_str(input: Ptr[uint8]) -> int32:
    len: int32 = strlen(input)
    return json_parse(input, len)

def json_token_count() -> int32:
    return token_count

def json_token_type(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return -1
    return token_types[idx]

def json_token_start(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return -1
    return token_starts[idx]

def json_token_length(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return 0
    return token_lengths[idx]

def json_token_parent(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return -1
    return token_parents[idx]

def json_token_value(idx: int32, buf: Ptr[uint8], max_len: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        buf[0] = cast[uint8](0)
        return 0
    start: int32 = token_starts[idx]
    length: int32 = token_lengths[idx]
    if (length > (max_len - 1)):
        length = (max_len - 1)
    i: int32 = 0
    while (i < length):
        buf[i] = parse_input[(start + i)]
        i = (i + 1)
    buf[length] = cast[uint8](0)
    return length

def json_token_eq(idx: int32, s: Ptr[uint8]) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return 0
    start: int32 = token_starts[idx]
    length: int32 = token_lengths[idx]
    i: int32 = 0
    while ((i < length) and (cast[int32](s[i]) != 0)):
        if (cast[int32](parse_input[(start + i)]) != cast[int32](s[i])):
            return 0
        i = (i + 1)
    if ((i < length) or (cast[int32](s[i]) != 0)):
        return 0
    return 1

def json_token_int(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return 0
    if (token_types[idx] != JSON_NUMBER):
        return 0
    buf: Array[32, uint8]
    json_token_value(idx, addr(buf[0]), 32)
    return atoi(addr(buf[0]))

def json_token_bool(idx: int32) -> int32:
    if ((idx < 0) or (idx >= token_count)):
        return 0
    if (token_types[idx] != JSON_BOOL):
        return 0
    start: int32 = token_starts[idx]
    if (parse_input[start] == 116):
        return 1
    return 0

def json_get_key(obj_idx: int32, key: Ptr[uint8]) -> int32:
    if ((obj_idx < 0) or (obj_idx >= token_count)):
        return -1
    if (token_types[obj_idx] != JSON_OBJECT):
        return -1
    i: int32 = (obj_idx + 1)
    found_key: int32 = 0
    while (i < token_count):
        if (token_parents[i] == obj_idx):
            if ((token_types[i] == JSON_STRING) and (found_key == 0)):
                if (json_token_eq(i, key) == 1):
                    found_key = 1
                i = (i + 1)
                continue
            elif (found_key == 1):
                return i
            else:
                found_key = 0
        elif (token_parents[i] < obj_idx):
            break
        i = (i + 1)
    return -1

def json_get_string(obj_idx: int32, key: Ptr[uint8], buf: Ptr[uint8], max_len: int32) -> int32:
    val_idx: int32 = json_get_key(obj_idx, key)
    if (val_idx < 0):
        buf[0] = cast[uint8](0)
        return 0
    if (token_types[val_idx] != JSON_STRING):
        buf[0] = cast[uint8](0)
        return 0
    return json_token_value(val_idx, buf, max_len)

def json_get_int(obj_idx: int32, key: Ptr[uint8]) -> int32:
    val_idx: int32 = json_get_key(obj_idx, key)
    if (val_idx < 0):
        return 0
    return json_token_int(val_idx)

def json_get_bool(obj_idx: int32, key: Ptr[uint8]) -> int32:
    val_idx: int32 = json_get_key(obj_idx, key)
    if (val_idx < 0):
        return 0
    return json_token_bool(val_idx)

def json_array_get(arr_idx: int32, elem_idx: int32) -> int32:
    if ((arr_idx < 0) or (arr_idx >= token_count)):
        return -1
    if (token_types[arr_idx] != JSON_ARRAY):
        return -1
    i: int32 = (arr_idx + 1)
    count: int32 = 0
    while (i < token_count):
        if (token_parents[i] == arr_idx):
            if (count == elem_idx):
                return i
            count = (count + 1)
        elif (token_parents[i] < arr_idx):
            break
        i = (i + 1)
    return -1

def json_array_length(arr_idx: int32) -> int32:
    if ((arr_idx < 0) or (arr_idx >= token_count)):
        return 0
    if (token_types[arr_idx] != JSON_ARRAY):
        return 0
    i: int32 = (arr_idx + 1)
    count: int32 = 0
    while (i < token_count):
        if (token_parents[i] == arr_idx):
            count = (count + 1)
        elif (token_parents[i] < arr_idx):
            break
        i = (i + 1)
    return count