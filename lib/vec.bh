# Dynamic Array (Vector) Module for Brainhair
#
# Provides a dynamically-resizing array with O(1) amortized push.
# Uses generics for type-safe element access.
#
# Vec structure (12 bytes):
#   data: Ptr[T]      - Pointer to element data (offset 0)
#   len: int32        - Number of elements (offset 4)
#   cap: int32        - Capacity in elements (offset 8)

VEC_DATA_OFFSET: Final[int32] = 0
VEC_LEN_OFFSET: Final[int32] = 4
VEC_CAP_OFFSET: Final[int32] = 8
VEC_STRUCT_SIZE: Final[int32] = 12

# Default initial capacity
VEC_DEFAULT_CAP: Final[int32] = 8

# Memory allocation (inline to avoid circular deps)
SYS_mmap: Final[int32] = 90
SYS_munmap: Final[int32] = 91
PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_PRIVATE: Final[int32] = 2
MAP_ANONYMOUS: Final[int32] = 32

extern def syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32) -> int32

def vec_mmap(size: int32) -> Ptr[uint8]:
    mem: int32 = syscall6(SYS_mmap, 0, size,
                          PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    if mem < 0:
        return cast[Ptr[uint8]](0)
    return cast[Ptr[uint8]](mem)

def vec_munmap(p: Ptr[uint8], size: int32):
    if cast[int32](p) != 0:
        syscall6(SYS_munmap, cast[int32](p), size, 0, 0, 0, 0)

# ============================================================================
# Generic Vec operations using int32 as generic element type
# For other sizes, users should adapt these or use type-specific versions
# ============================================================================

# Initialize an empty vector for 4-byte elements (int32, ptr)
def vec_init(v: Ptr[uint8], initial_cap: int32):
    cap: int32 = initial_cap
    if cap < VEC_DEFAULT_CAP:
        cap = VEC_DEFAULT_CAP

    # Allocate data for cap elements (4 bytes each)
    data_size: int32 = cap * 4
    data: Ptr[uint8] = vec_mmap(data_size)

    v32: Ptr[int32] = cast[Ptr[int32]](v)
    v32[0] = cast[int32](data)  # data pointer
    v32[1] = 0                   # len = 0
    v32[2] = cap                 # capacity

# Free vector memory
def vec_free(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: int32 = v32[0]
    cap: int32 = v32[2]

    if data != 0:
        vec_munmap(cast[Ptr[uint8]](data), cap * 4)

    v32[0] = 0
    v32[1] = 0
    v32[2] = 0

# Get vector length
def vec_len(v: Ptr[uint8]) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    return v32[1]

# Get vector capacity
def vec_cap(v: Ptr[uint8]) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    return v32[2]

# Check if vector is empty
def vec_is_empty(v: Ptr[uint8]) -> bool:
    return vec_len(v) == 0

# Grow vector capacity (double it)
def vec_grow(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    old_data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]
    old_cap: int32 = v32[2]

    new_cap: int32 = old_cap * 2
    if new_cap < VEC_DEFAULT_CAP:
        new_cap = VEC_DEFAULT_CAP

    # Allocate new buffer
    new_data: Ptr[uint8] = vec_mmap(new_cap * 4)
    if cast[int32](new_data) == 0:
        return  # Allocation failed

    # Copy existing elements
    new_data32: Ptr[int32] = cast[Ptr[int32]](new_data)
    i: int32 = 0
    while i < length:
        new_data32[i] = old_data[i]
        i = i + 1

    # Free old buffer
    vec_munmap(cast[Ptr[uint8]](old_data), old_cap * 4)

    # Update vector
    v32[0] = cast[int32](new_data)
    v32[2] = new_cap

# Reserve capacity
def vec_reserve(v: Ptr[uint8], min_cap: int32):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    cap: int32 = v32[2]

    if min_cap <= cap:
        return

    old_data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    # Calculate new capacity
    new_cap: int32 = cap
    while new_cap < min_cap:
        new_cap = new_cap * 2

    # Allocate and copy
    new_data: Ptr[uint8] = vec_mmap(new_cap * 4)
    if cast[int32](new_data) == 0:
        return

    new_data32: Ptr[int32] = cast[Ptr[int32]](new_data)
    i: int32 = 0
    while i < length:
        new_data32[i] = old_data[i]
        i = i + 1

    vec_munmap(cast[Ptr[uint8]](old_data), cap * 4)
    v32[0] = cast[int32](new_data)
    v32[2] = new_cap

# Push element (int32)
def vec_push_i32(v: Ptr[uint8], value: int32):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]
    cap: int32 = v32[2]

    if length >= cap:
        vec_grow(v)
        data = cast[Ptr[int32]](v32[0])

    data[length] = value
    v32[1] = length + 1

# Get element (int32)
def vec_get_i32(v: Ptr[uint8], index: int32) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    return data[index]

# Set element (int32)
def vec_set_i32(v: Ptr[uint8], index: int32, value: int32):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    data[index] = value

# Pop last element
def vec_pop_i32(v: Ptr[uint8]) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    if length == 0:
        return 0  # Empty vector

    value: int32 = data[length - 1]
    v32[1] = length - 1
    return value

# Get last element without removing
def vec_last_i32(v: Ptr[uint8]) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    if length == 0:
        return 0
    return data[length - 1]

# Get first element
def vec_first_i32(v: Ptr[uint8]) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    if length == 0:
        return 0
    return data[0]

# Clear vector (keep capacity)
def vec_clear(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    v32[1] = 0

# Get raw data pointer
def vec_data(v: Ptr[uint8]) -> Ptr[int32]:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    return cast[Ptr[int32]](v32[0])

# Insert element at index (shifts elements right)
def vec_insert_i32(v: Ptr[uint8], index: int32, value: int32):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]
    cap: int32 = v32[2]

    if length >= cap:
        vec_grow(v)
        data = cast[Ptr[int32]](v32[0])

    # Shift elements right
    i: int32 = length
    while i > index:
        data[i] = data[i - 1]
        i = i - 1

    data[index] = value
    v32[1] = length + 1

# Remove element at index (shifts elements left)
def vec_remove_i32(v: Ptr[uint8], index: int32) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    value: int32 = data[index]

    # Shift elements left
    i: int32 = index
    while i < length - 1:
        data[i] = data[i + 1]
        i = i + 1

    v32[1] = length - 1
    return value

# Swap remove (O(1) - swaps with last element)
def vec_swap_remove_i32(v: Ptr[uint8], index: int32) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    value: int32 = data[index]
    data[index] = data[length - 1]
    v32[1] = length - 1
    return value

# Find index of value (returns -1 if not found)
def vec_find_i32(v: Ptr[uint8], value: int32) -> int32:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    i: int32 = 0
    while i < length:
        if data[i] == value:
            return i
        i = i + 1
    return -1

# Check if vector contains value
def vec_contains_i32(v: Ptr[uint8], value: int32) -> bool:
    return vec_find_i32(v, value) >= 0

# Reverse vector in place
def vec_reverse(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[int32] = cast[Ptr[int32]](v32[0])
    length: int32 = v32[1]

    left: int32 = 0
    right: int32 = length - 1
    while left < right:
        tmp: int32 = data[left]
        data[left] = data[right]
        data[right] = tmp
        left = left + 1
        right = right - 1

# ============================================================================
# Byte vector operations (for uint8 arrays)
# ============================================================================

# Initialize byte vector
def vec_init_u8(v: Ptr[uint8], initial_cap: int32):
    cap: int32 = initial_cap
    if cap < VEC_DEFAULT_CAP:
        cap = VEC_DEFAULT_CAP

    data: Ptr[uint8] = vec_mmap(cap)

    v32: Ptr[int32] = cast[Ptr[int32]](v)
    v32[0] = cast[int32](data)
    v32[1] = 0
    v32[2] = cap

# Free byte vector
def vec_free_u8(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: int32 = v32[0]
    cap: int32 = v32[2]

    if data != 0:
        vec_munmap(cast[Ptr[uint8]](data), cap)

    v32[0] = 0
    v32[1] = 0
    v32[2] = 0

# Grow byte vector
def vec_grow_u8(v: Ptr[uint8]):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    old_data: Ptr[uint8] = cast[Ptr[uint8]](v32[0])
    length: int32 = v32[1]
    old_cap: int32 = v32[2]

    new_cap: int32 = old_cap * 2

    new_data: Ptr[uint8] = vec_mmap(new_cap)
    if cast[int32](new_data) == 0:
        return

    i: int32 = 0
    while i < length:
        new_data[i] = old_data[i]
        i = i + 1

    vec_munmap(old_data, old_cap)
    v32[0] = cast[int32](new_data)
    v32[2] = new_cap

# Push byte
def vec_push_u8(v: Ptr[uint8], value: uint8):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[uint8] = cast[Ptr[uint8]](v32[0])
    length: int32 = v32[1]
    cap: int32 = v32[2]

    if length >= cap:
        vec_grow_u8(v)
        data = cast[Ptr[uint8]](v32[0])

    data[length] = value
    v32[1] = length + 1

# Get byte
def vec_get_u8(v: Ptr[uint8], index: int32) -> uint8:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[uint8] = cast[Ptr[uint8]](v32[0])
    return data[index]

# Set byte
def vec_set_u8(v: Ptr[uint8], index: int32, value: uint8):
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[uint8] = cast[Ptr[uint8]](v32[0])
    data[index] = value

# Pop byte
def vec_pop_u8(v: Ptr[uint8]) -> uint8:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    data: Ptr[uint8] = cast[Ptr[uint8]](v32[0])
    length: int32 = v32[1]

    if length == 0:
        return 0

    value: uint8 = data[length - 1]
    v32[1] = length - 1
    return value

# Get byte data pointer
def vec_data_u8(v: Ptr[uint8]) -> Ptr[uint8]:
    v32: Ptr[int32] = cast[Ptr[int32]](v)
    return cast[Ptr[uint8]](v32[0])

# Extend byte vector with another byte array
def vec_extend_u8(v: Ptr[uint8], src: Ptr[uint8], count: int32):
    i: int32 = 0
    while i < count:
        vec_push_u8(v, src[i])
        i = i + 1
