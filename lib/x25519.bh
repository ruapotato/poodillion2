# x25519.bh - X25519 Elliptic Curve Diffie-Hellman for BrainhairOS
# High-level API for X25519 key exchange (RFC 7748)
#
# X25519 is an elliptic curve Diffie-Hellman key exchange algorithm
# - Uses Curve25519 (Montgomery curve over 2^255 - 19)
# - Provides 128-bit security level
# - Perfect for TLS 1.3 key exchange
#
# Usage:
#   1. Both parties generate keypairs using x25519_keypair()
#   2. Exchange public keys
#   3. Compute shared secret using x25519_compute_shared()
#   4. The shared secrets will be identical

from lib.syscalls import *
from lib.random import *

# ===========================================================================
# X25519 Constants
# ===========================================================================

X25519_KEY_SIZE: Final[int32] = 32       # Key size in bytes
X25519_SHARED_SIZE: Final[int32] = 32    # Shared secret size in bytes

# ===========================================================================
# X25519 Types
# ===========================================================================

# X25519 keypair structure
class X25519Keypair:
    private_key: Array[32, uint8]       # Private key (32 random bytes)
    public_key: Array[32, uint8]        # Public key (computed)

# ===========================================================================
# Low-Level Kernel Functions (extern)
# ===========================================================================

# These are implemented in kernel/x25519.asm

# x25519_scalarmult(result: Ptr[uint8], scalar: Ptr[uint8], point: Ptr[uint8])
# Scalar multiplication on Curve25519

# x25519_base(result: Ptr[uint8], scalar: Ptr[uint8])
# Scalar multiplication with base point (x=9)

# x25519_keygen(public: Ptr[uint8], private: Ptr[uint8])
# Generate keypair from private key

# x25519_shared(shared: Ptr[uint8], our_private: Ptr[uint8], their_public: Ptr[uint8])
# Compute shared secret

# ===========================================================================
# High-Level API
# ===========================================================================

# Generate a new X25519 keypair
# keypair: output keypair structure
# Returns: 0 on success, -1 on error
def x25519_keypair(keypair: Ptr[X25519Keypair]) -> int32:
    # Generate 32 random bytes for private key
    result: int32 = random_bytes(addr(keypair.private_key[0]), 32)
    if result < 0:
        return -1

    # Clamp private key (required by X25519 spec)
    # Clear bottom 3 bits, set bit 254, clear bit 255
    keypair.private_key[0] = keypair.private_key[0] & 0xF8
    keypair.private_key[31] = keypair.private_key[31] & 0x7F
    keypair.private_key[31] = keypair.private_key[31] | 0x40

    # Compute public key = private * basepoint
    # Using syscall to kernel x25519_keygen
    priv_ptr: int32 = cast[int32](addr(keypair.private_key[0]))
    pub_ptr: int32 = cast[int32](addr(keypair.public_key[0]))

    # Syscall 240: x25519_keygen(public_key_ptr, private_key_ptr)
    result = syscall2(240, pub_ptr, priv_ptr)
    if result < 0:
        return -1

    return 0

# Compute shared secret from our private key and their public key
# shared: output buffer (32 bytes)
# our_private: our private key (32 bytes)
# their_public: their public key (32 bytes)
# Returns: 0 on success, -1 on error
def x25519_compute_shared(shared: Ptr[uint8], our_private: Ptr[uint8],
                          their_public: Ptr[uint8]) -> int32:
    shared_ptr: int32 = cast[int32](shared)
    priv_ptr: int32 = cast[int32](our_private)
    pub_ptr: int32 = cast[int32](their_public)

    # Syscall 241: x25519_shared(shared_ptr, our_private_ptr, their_public_ptr)
    result: int32 = syscall3(241, shared_ptr, priv_ptr, pub_ptr)
    if result < 0:
        return -1

    # Check for all-zero result (invalid public key)
    i: int32 = 0
    is_zero: int32 = 1
    while i < 32:
        if shared[i] != 0:
            is_zero = 0
            break
        i = i + 1

    if is_zero == 1:
        return -1  # Invalid - would be identity point

    return 0

# Compute shared secret from keypair structure
# shared: output buffer (32 bytes)
# our_keypair: our keypair
# their_public: their public key (32 bytes)
# Returns: 0 on success, -1 on error
def x25519_shared_from_keypair(shared: Ptr[uint8], our_keypair: Ptr[X25519Keypair],
                               their_public: Ptr[uint8]) -> int32:
    return x25519_compute_shared(shared, addr(our_keypair.private_key[0]),
                                 their_public)

# ===========================================================================
# Utility Functions
# ===========================================================================

# Copy key bytes
def x25519_copy_key(dest: Ptr[uint8], src: Ptr[uint8]):
    i: int32 = 0
    while i < 32:
        dest[i] = src[i]
        i = i + 1

# Compare keys for equality (constant-time)
def x25519_compare_keys(a: Ptr[uint8], b: Ptr[uint8]) -> int32:
    diff: int32 = 0
    i: int32 = 0
    while i < 32:
        diff = diff | (cast[int32](a[i]) ^ cast[int32](b[i]))
        i = i + 1

    if diff == 0:
        return 1  # Equal
    return 0    # Not equal

# Print key as hex (for debugging)
def x25519_print_key(key: Ptr[uint8]):
    hex: Ptr[uint8] = cast[Ptr[uint8]]("0123456789abcdef")
    i: int32 = 0
    while i < 32:
        b: int32 = cast[int32](key[i])
        hi: int32 = (b / 16) & 0x0F
        lo: int32 = b & 0x0F
        print_char(hex[hi])
        print_char(hex[lo])
        i = i + 1

# Zero out a key (for security)
def x25519_wipe_key(key: Ptr[uint8]):
    i: int32 = 0
    while i < 32:
        key[i] = 0
        i = i + 1

# Wipe keypair (for security)
def x25519_wipe_keypair(keypair: Ptr[X25519Keypair]):
    x25519_wipe_key(addr(keypair.private_key[0]))
    x25519_wipe_key(addr(keypair.public_key[0]))

# ===========================================================================
# Simplified Key Exchange Protocol
# ===========================================================================

# Perform key exchange (for Alice's perspective)
# Generates keypair, returns public key for sending
# Caller must call x25519_finalize_exchange with Bob's public key
def x25519_init_exchange(keypair: Ptr[X25519Keypair],
                         our_public_to_send: Ptr[uint8]) -> int32:
    # Generate our keypair
    result: int32 = x25519_keypair(keypair)
    if result < 0:
        return -1

    # Copy public key for sending
    x25519_copy_key(our_public_to_send, addr(keypair.public_key[0]))
    return 0

# Finalize key exchange with received public key
# shared: output shared secret (32 bytes)
# our_keypair: our previously generated keypair
# their_public: received public key from other party
def x25519_finalize_exchange(shared: Ptr[uint8], our_keypair: Ptr[X25519Keypair],
                             their_public: Ptr[uint8]) -> int32:
    return x25519_shared_from_keypair(shared, our_keypair, their_public)

# ===========================================================================
# Key Derivation Helpers
# ===========================================================================

# Derive encryption key from shared secret using SHA-256
# This is commonly done in TLS/protocols to get separate keys
# output_key: output buffer (32 bytes)
# shared_secret: input shared secret (32 bytes)
# context: context string for key derivation
# context_len: length of context
def x25519_derive_key(output_key: Ptr[uint8], shared_secret: Ptr[uint8],
                      context: Ptr[uint8], context_len: int32) -> int32:
    # Use SHA-256(shared_secret || context) for key derivation
    # This is a simplified KDF - proper HKDF should be used for TLS

    # For now, just copy the shared secret
    # TODO: Implement proper HKDF when SHA-256 is available
    x25519_copy_key(output_key, shared_secret)
    return 0

# ===========================================================================
# Usage Example (commented out):
# ===========================================================================
#
# def main():
#   alice_keypair: X25519Keypair
#   bob_keypair: X25519Keypair
#   alice_public: Array[32, uint8]
#   bob_public: Array[32, uint8]
#   alice_shared: Array[32, uint8]
#   bob_shared: Array[32, uint8]
#
#   print(cast[Ptr[uint8]]("X25519 Key Exchange Demo\n"))
#   print(cast[Ptr[uint8]]("========================\n\n"))
#
#   # Alice initiates
#   print(cast[Ptr[uint8]]("Alice generating keypair...\n"))
#   if x25519_init_exchange(addr(alice_keypair), addr(alice_public[0])) < 0:
#     print(cast[Ptr[uint8]]("Failed to generate Alice's keypair\n"))
#     return
#
#   # Bob initiates
#   print(cast[Ptr[uint8]]("Bob generating keypair...\n"))
#   if x25519_init_exchange(addr(bob_keypair), addr(bob_public[0])) < 0:
#     print(cast[Ptr[uint8]]("Failed to generate Bob's keypair\n"))
#     return
#
#   print(cast[Ptr[uint8]]("\nAlice's public key: "))
#   x25519_print_key(addr(alice_public[0]))
#   newline()
#
#   print(cast[Ptr[uint8]]("Bob's public key:   "))
#   x25519_print_key(addr(bob_public[0]))
#   newline()
#
#   # Exchange public keys and compute shared secrets
#   print(cast[Ptr[uint8]]("\nComputing shared secrets...\n"))
#
#   if x25519_finalize_exchange(addr(alice_shared[0]), addr(alice_keypair),
#                                addr(bob_public[0])) < 0:
#     print(cast[Ptr[uint8]]("Alice failed to compute shared secret\n"))
#     return
#
#   if x25519_finalize_exchange(addr(bob_shared[0]), addr(bob_keypair),
#                                addr(alice_public[0])) < 0:
#     print(cast[Ptr[uint8]]("Bob failed to compute shared secret\n"))
#     return
#
#   print(cast[Ptr[uint8]]("Alice's shared:     "))
#   x25519_print_key(addr(alice_shared[0]))
#   newline()
#
#   print(cast[Ptr[uint8]]("Bob's shared:       "))
#   x25519_print_key(addr(bob_shared[0]))
#   newline()
#
#   # Verify they match
#   if x25519_compare_keys(addr(alice_shared[0]), addr(bob_shared[0])) == 1:
#     print(cast[Ptr[uint8]]("\nShared secrets MATCH!\n"))
#   else:
#     print(cast[Ptr[uint8]]("\nERROR: Shared secrets do NOT match!\n"))
#
#   # Clean up sensitive data
#   x25519_wipe_keypair(addr(alice_keypair))
#   x25519_wipe_keypair(addr(bob_keypair))
