# x25519.bh - X25519 Elliptic Curve Diffie-Hellman for BrainhairOS
# High-level API for X25519 key exchange (RFC 7748)
#
# X25519 is an elliptic curve Diffie-Hellman key exchange algorithm
# - Uses Curve25519 (Montgomery curve over 2^255 - 19)
# - Provides 128-bit security level
# - Perfect for TLS 1.3 key exchange
#
# Usage:
#   1. Both parties generate keypairs using x25519_keypair()
#   2. Exchange public keys
#   3. Compute shared secret using x25519_compute_shared()
#   4. The shared secrets will be identical

import "lib/syscalls"
import "lib/random"

# ===========================================================================
# X25519 Constants
# ===========================================================================

const X25519_KEY_SIZE: int32 = 32       # Key size in bytes
const X25519_SHARED_SIZE: int32 = 32    # Shared secret size in bytes

# ===========================================================================
# X25519 Types
# ===========================================================================

# X25519 keypair structure
type X25519Keypair = record
  private_key: array[32] of uint8       # Private key (32 random bytes)
  public_key: array[32] of uint8        # Public key (computed)

# ===========================================================================
# Low-Level Kernel Functions (extern)
# ===========================================================================

# These are implemented in kernel/x25519.asm

# x25519_scalarmult(result: ptr uint8, scalar: ptr uint8, point: ptr uint8)
# Scalar multiplication on Curve25519

# x25519_base(result: ptr uint8, scalar: ptr uint8)
# Scalar multiplication with base point (x=9)

# x25519_keygen(public: ptr uint8, private: ptr uint8)
# Generate keypair from private key

# x25519_shared(shared: ptr uint8, our_private: ptr uint8, their_public: ptr uint8)
# Compute shared secret

# ===========================================================================
# High-Level API
# ===========================================================================

# Generate a new X25519 keypair
# keypair: output keypair structure
# Returns: 0 on success, -1 on error
proc x25519_keypair(keypair: ptr X25519Keypair): int32 =
  # Generate 32 random bytes for private key
  var result: int32 = random_bytes(addr(keypair.private_key[0]), 32)
  if result < 0:
    return -1

  # Clamp private key (required by X25519 spec)
  # Clear bottom 3 bits, set bit 254, clear bit 255
  keypair.private_key[0] = keypair.private_key[0] and 0xF8
  keypair.private_key[31] = keypair.private_key[31] and 0x7F
  keypair.private_key[31] = keypair.private_key[31] or 0x40

  # Compute public key = private * basepoint
  # Using syscall to kernel x25519_keygen
  var priv_ptr: int32 = cast[int32](addr(keypair.private_key[0]))
  var pub_ptr: int32 = cast[int32](addr(keypair.public_key[0]))

  # Syscall 240: x25519_keygen(public_key_ptr, private_key_ptr)
  result = syscall2(240, pub_ptr, priv_ptr)
  if result < 0:
    return -1

  return 0

# Compute shared secret from our private key and their public key
# shared: output buffer (32 bytes)
# our_private: our private key (32 bytes)
# their_public: their public key (32 bytes)
# Returns: 0 on success, -1 on error
proc x25519_compute_shared(shared: ptr uint8, our_private: ptr uint8,
                           their_public: ptr uint8): int32 =
  var shared_ptr: int32 = cast[int32](shared)
  var priv_ptr: int32 = cast[int32](our_private)
  var pub_ptr: int32 = cast[int32](their_public)

  # Syscall 241: x25519_shared(shared_ptr, our_private_ptr, their_public_ptr)
  var result: int32 = syscall3(241, shared_ptr, priv_ptr, pub_ptr)
  if result < 0:
    return -1

  # Check for all-zero result (invalid public key)
  var i: int32 = 0
  var is_zero: int32 = 1
  while i < 32:
    if shared[i] != 0:
      is_zero = 0
      break
    i = i + 1

  if is_zero == 1:
    return -1  # Invalid - would be identity point

  return 0

# Compute shared secret from keypair structure
# shared: output buffer (32 bytes)
# our_keypair: our keypair
# their_public: their public key (32 bytes)
# Returns: 0 on success, -1 on error
proc x25519_shared_from_keypair(shared: ptr uint8, our_keypair: ptr X25519Keypair,
                                 their_public: ptr uint8): int32 =
  return x25519_compute_shared(shared, addr(our_keypair.private_key[0]),
                               their_public)

# ===========================================================================
# Utility Functions
# ===========================================================================

# Copy key bytes
proc x25519_copy_key(dest: ptr uint8, src: ptr uint8) =
  var i: int32 = 0
  while i < 32:
    dest[i] = src[i]
    i = i + 1

# Compare keys for equality (constant-time)
proc x25519_compare_keys(a: ptr uint8, b: ptr uint8): int32 =
  var diff: int32 = 0
  var i: int32 = 0
  while i < 32:
    diff = diff or (cast[int32](a[i]) xor cast[int32](b[i]))
    i = i + 1

  if diff == 0:
    return 1  # Equal
  return 0    # Not equal

# Print key as hex (for debugging)
proc x25519_print_key(key: ptr uint8) =
  var hex: ptr uint8 = cast[ptr uint8]("0123456789abcdef")
  var i: int32 = 0
  while i < 32:
    var b: int32 = cast[int32](key[i])
    var hi: int32 = (b / 16) and 0x0F
    var lo: int32 = b and 0x0F
    print_char(hex[hi])
    print_char(hex[lo])
    i = i + 1

# Zero out a key (for security)
proc x25519_wipe_key(key: ptr uint8) =
  var i: int32 = 0
  while i < 32:
    key[i] = 0
    i = i + 1

# Wipe keypair (for security)
proc x25519_wipe_keypair(keypair: ptr X25519Keypair) =
  x25519_wipe_key(addr(keypair.private_key[0]))
  x25519_wipe_key(addr(keypair.public_key[0]))

# ===========================================================================
# Simplified Key Exchange Protocol
# ===========================================================================

# Perform key exchange (for Alice's perspective)
# Generates keypair, returns public key for sending
# Caller must call x25519_finalize_exchange with Bob's public key
proc x25519_init_exchange(keypair: ptr X25519Keypair,
                          our_public_to_send: ptr uint8): int32 =
  # Generate our keypair
  var result: int32 = x25519_keypair(keypair)
  if result < 0:
    return -1

  # Copy public key for sending
  x25519_copy_key(our_public_to_send, addr(keypair.public_key[0]))
  return 0

# Finalize key exchange with received public key
# shared: output shared secret (32 bytes)
# our_keypair: our previously generated keypair
# their_public: received public key from other party
proc x25519_finalize_exchange(shared: ptr uint8, our_keypair: ptr X25519Keypair,
                               their_public: ptr uint8): int32 =
  return x25519_shared_from_keypair(shared, our_keypair, their_public)

# ===========================================================================
# Key Derivation Helpers
# ===========================================================================

# Derive encryption key from shared secret using SHA-256
# This is commonly done in TLS/protocols to get separate keys
# output_key: output buffer (32 bytes)
# shared_secret: input shared secret (32 bytes)
# context: context string for key derivation
# context_len: length of context
proc x25519_derive_key(output_key: ptr uint8, shared_secret: ptr uint8,
                       context: ptr uint8, context_len: int32): int32 =
  # Use SHA-256(shared_secret || context) for key derivation
  # This is a simplified KDF - proper HKDF should be used for TLS

  # For now, just copy the shared secret
  # TODO: Implement proper HKDF when SHA-256 is available
  x25519_copy_key(output_key, shared_secret)
  return 0

# ===========================================================================
# Usage Example (commented out):
# ===========================================================================
#
# proc main() =
#   var alice_keypair: X25519Keypair
#   var bob_keypair: X25519Keypair
#   var alice_public: array[32] of uint8
#   var bob_public: array[32] of uint8
#   var alice_shared: array[32] of uint8
#   var bob_shared: array[32] of uint8
#
#   print(cast[ptr uint8]("X25519 Key Exchange Demo\n"))
#   print(cast[ptr uint8]("========================\n\n"))
#
#   # Alice initiates
#   print(cast[ptr uint8]("Alice generating keypair...\n"))
#   if x25519_init_exchange(addr(alice_keypair), addr(alice_public[0])) < 0:
#     print(cast[ptr uint8]("Failed to generate Alice's keypair\n"))
#     return
#
#   # Bob initiates
#   print(cast[ptr uint8]("Bob generating keypair...\n"))
#   if x25519_init_exchange(addr(bob_keypair), addr(bob_public[0])) < 0:
#     print(cast[ptr uint8]("Failed to generate Bob's keypair\n"))
#     return
#
#   print(cast[ptr uint8]("\nAlice's public key: "))
#   x25519_print_key(addr(alice_public[0]))
#   newline()
#
#   print(cast[ptr uint8]("Bob's public key:   "))
#   x25519_print_key(addr(bob_public[0]))
#   newline()
#
#   # Exchange public keys and compute shared secrets
#   print(cast[ptr uint8]("\nComputing shared secrets...\n"))
#
#   if x25519_finalize_exchange(addr(alice_shared[0]), addr(alice_keypair),
#                                addr(bob_public[0])) < 0:
#     print(cast[ptr uint8]("Alice failed to compute shared secret\n"))
#     return
#
#   if x25519_finalize_exchange(addr(bob_shared[0]), addr(bob_keypair),
#                                addr(alice_public[0])) < 0:
#     print(cast[ptr uint8]("Bob failed to compute shared secret\n"))
#     return
#
#   print(cast[ptr uint8]("Alice's shared:     "))
#   x25519_print_key(addr(alice_shared[0]))
#   newline()
#
#   print(cast[ptr uint8]("Bob's shared:       "))
#   x25519_print_key(addr(bob_shared[0]))
#   newline()
#
#   # Verify they match
#   if x25519_compare_keys(addr(alice_shared[0]), addr(bob_shared[0])) == 1:
#     print(cast[ptr uint8]("\nShared secrets MATCH!\n"))
#   else:
#     print(cast[ptr uint8]("\nERROR: Shared secrets do NOT match!\n"))
#
#   # Clean up sensitive data
#   x25519_wipe_keypair(addr(alice_keypair))
#   x25519_wipe_keypair(addr(bob_keypair))
