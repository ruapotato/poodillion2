# String Module for Brainhair
#
# Provides a dynamic String type with automatic memory management.
# Strings are stored with a length field (not null-terminated internally)
# but can be converted to C-style null-terminated strings.
#
# String structure:
#   data: Ptr[char]   - Pointer to character data
#   len: int32        - Length of string (excluding any null terminator)
#   cap: int32        - Capacity of allocated buffer
# Total: 12 bytes

STRING_DATA_OFFSET: Final[int32] = 0
STRING_LEN_OFFSET: Final[int32] = 4
STRING_CAP_OFFSET: Final[int32] = 8
STRING_STRUCT_SIZE: Final[int32] = 12

# Default initial capacity
STRING_DEFAULT_CAP: Final[int32] = 16

# Import memory functions
SYS_mmap: Final[int32] = 90
SYS_munmap: Final[int32] = 91
PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_PRIVATE: Final[int32] = 2
MAP_ANONYMOUS: Final[int32] = 32

extern def syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32) -> int32

# Helper: allocate memory
def str_alloc(size: int32) -> Ptr[uint8]:
    mem: int32 = syscall6(SYS_mmap, 0, size,
                          PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    if mem < 0:
        return cast[Ptr[uint8]](0)
    return cast[Ptr[uint8]](mem)

# Helper: free memory
def str_free(p: Ptr[uint8], size: int32):
    if cast[int32](p) != 0:
        syscall6(SYS_munmap, cast[int32](p), size, 0, 0, 0, 0)

# Helper: calculate C string length
def cstr_len(s: Ptr[uint8]) -> int32:
    length: int32 = 0
    while s[length] != 0:
        length = length + 1
    return length

# Initialize an empty string with given capacity
def string_init(s: Ptr[uint8], capacity: int32):
    cap: int32 = capacity
    if cap < STRING_DEFAULT_CAP:
        cap = STRING_DEFAULT_CAP

    data: Ptr[uint8] = str_alloc(cap)
    s32: Ptr[int32] = cast[Ptr[int32]](s)

    s32[0] = cast[int32](data)  # data pointer
    s32[1] = 0                   # len = 0
    s32[2] = cap                 # capacity

    # Null terminate for safety
    if cast[int32](data) != 0:
        data[0] = 0

# Initialize string from C string
def string_from_cstr(s: Ptr[uint8], cstr: Ptr[uint8]):
    length: int32 = cstr_len(cstr)
    cap: int32 = length + 1
    if cap < STRING_DEFAULT_CAP:
        cap = STRING_DEFAULT_CAP

    data: Ptr[uint8] = str_alloc(cap)
    s32: Ptr[int32] = cast[Ptr[int32]](s)

    s32[0] = cast[int32](data)
    s32[1] = length
    s32[2] = cap

    # Copy characters
    if cast[int32](data) != 0:
        i: int32 = 0
        while i < length:
            data[i] = cstr[i]
            i = i + 1
        data[length] = 0  # Null terminate

# Free string memory
def string_free(s: Ptr[uint8]):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: int32 = s32[0]
    cap: int32 = s32[2]

    if data != 0:
        str_free(cast[Ptr[uint8]](data), cap)

    s32[0] = 0
    s32[1] = 0
    s32[2] = 0

# Get string length
def string_len(s: Ptr[uint8]) -> int32:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    return s32[1]

# Get string capacity
def string_cap(s: Ptr[uint8]) -> int32:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    return s32[2]

# Get character at index (no bounds checking)
def string_get(s: Ptr[uint8], index: int32) -> uint8:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    return data[index]

# Set character at index (no bounds checking)
def string_set(s: Ptr[uint8], index: int32, c: uint8):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    data[index] = c

# Get null-terminated C string pointer
def string_cstr(s: Ptr[uint8]) -> Ptr[uint8]:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    return cast[Ptr[uint8]](s32[0])

# Ensure string has at least given capacity
def string_reserve(s: Ptr[uint8], new_cap: int32):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    old_data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]
    old_cap: int32 = s32[2]

    if new_cap <= old_cap:
        return  # Already have enough space

    # Allocate new buffer
    new_data: Ptr[uint8] = str_alloc(new_cap)
    if cast[int32](new_data) == 0:
        return  # Allocation failed

    # Copy existing data
    i: int32 = 0
    while i <= length:  # Include null terminator
        new_data[i] = old_data[i]
        i = i + 1

    # Free old buffer
    str_free(old_data, old_cap)

    # Update string
    s32[0] = cast[int32](new_data)
    s32[2] = new_cap

# Grow string capacity (double it)
def string_grow(s: Ptr[uint8]):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    cap: int32 = s32[2]
    new_cap: int32 = cap * 2
    if new_cap < STRING_DEFAULT_CAP:
        new_cap = STRING_DEFAULT_CAP
    string_reserve(s, new_cap)

# Append a single character
def string_push(s: Ptr[uint8], c: uint8):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]
    cap: int32 = s32[2]

    # Need space for char + null terminator
    if length + 2 > cap:
        string_grow(s)
        data = cast[Ptr[uint8]](s32[0])

    data[length] = c
    data[length + 1] = 0
    s32[1] = length + 1

# Append a C string
def string_append_cstr(s: Ptr[uint8], cstr: Ptr[uint8]):
    cstr_length: int32 = cstr_len(cstr)
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]
    cap: int32 = s32[2]

    # Ensure capacity
    needed: int32 = length + cstr_length + 1
    if needed > cap:
        new_cap: int32 = cap * 2
        while new_cap < needed:
            new_cap = new_cap * 2
        string_reserve(s, new_cap)
        data = cast[Ptr[uint8]](s32[0])

    # Copy characters
    i: int32 = 0
    while i < cstr_length:
        data[length + i] = cstr[i]
        i = i + 1
    data[length + cstr_length] = 0
    s32[1] = length + cstr_length

# Append another string
def string_append(s: Ptr[uint8], other: Ptr[uint8]):
    other32: Ptr[int32] = cast[Ptr[int32]](other)
    other_data: Ptr[uint8] = cast[Ptr[uint8]](other32[0])
    other_len: int32 = other32[1]

    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]
    cap: int32 = s32[2]

    # Ensure capacity
    needed: int32 = length + other_len + 1
    if needed > cap:
        new_cap: int32 = cap * 2
        while new_cap < needed:
            new_cap = new_cap * 2
        string_reserve(s, new_cap)
        data = cast[Ptr[uint8]](s32[0])

    # Copy characters
    i: int32 = 0
    while i < other_len:
        data[length + i] = other_data[i]
        i = i + 1
    data[length + other_len] = 0
    s32[1] = length + other_len

# Clear string (set length to 0)
def string_clear(s: Ptr[uint8]):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    s32[1] = 0
    if cast[int32](data) != 0:
        data[0] = 0

# Compare two strings
def string_cmp(s1: Ptr[uint8], s2: Ptr[uint8]) -> int32:
    s1_32: Ptr[int32] = cast[Ptr[int32]](s1)
    s2_32: Ptr[int32] = cast[Ptr[int32]](s2)

    data1: Ptr[uint8] = cast[Ptr[uint8]](s1_32[0])
    data2: Ptr[uint8] = cast[Ptr[uint8]](s2_32[0])
    len1: int32 = s1_32[1]
    len2: int32 = s2_32[1]

    min_len: int32 = len1
    if len2 < len1:
        min_len = len2

    i: int32 = 0
    while i < min_len:
        if data1[i] != data2[i]:
            if data1[i] < data2[i]:
                return -1
            return 1
        i = i + 1

    # Equal so far, shorter string is less
    if len1 < len2:
        return -1
    if len1 > len2:
        return 1
    return 0

# Check if strings are equal
def string_eq(s1: Ptr[uint8], s2: Ptr[uint8]) -> bool:
    return string_cmp(s1, s2) == 0

# Find first occurrence of character (returns -1 if not found)
def string_find_char(s: Ptr[uint8], c: uint8) -> int32:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]

    i: int32 = 0
    while i < length:
        if data[i] == c:
            return i
        i = i + 1
    return -1

# Find last occurrence of character (returns -1 if not found)
def string_rfind_char(s: Ptr[uint8], c: uint8) -> int32:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]

    i: int32 = length - 1
    while i >= 0:
        if data[i] == c:
            return i
        i = i - 1
    return -1

# Check if string starts with prefix
def string_starts_with(s: Ptr[uint8], prefix: Ptr[uint8]) -> bool:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    p32: Ptr[int32] = cast[Ptr[int32]](prefix)

    s_data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    p_data: Ptr[uint8] = cast[Ptr[uint8]](p32[0])
    s_len: int32 = s32[1]
    p_len: int32 = p32[1]

    if p_len > s_len:
        return False

    i: int32 = 0
    while i < p_len:
        if s_data[i] != p_data[i]:
            return False
        i = i + 1
    return True

# Check if string ends with suffix
def string_ends_with(s: Ptr[uint8], suffix: Ptr[uint8]) -> bool:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    x32: Ptr[int32] = cast[Ptr[int32]](suffix)

    s_data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    x_data: Ptr[uint8] = cast[Ptr[uint8]](x32[0])
    s_len: int32 = s32[1]
    x_len: int32 = x32[1]

    if x_len > s_len:
        return False

    offset: int32 = s_len - x_len
    i: int32 = 0
    while i < x_len:
        if s_data[offset + i] != x_data[i]:
            return False
        i = i + 1
    return True

# Get substring (creates new string)
def string_substr(dest: Ptr[uint8], src: Ptr[uint8], start: int32, length: int32):
    src32: Ptr[int32] = cast[Ptr[int32]](src)
    src_data: Ptr[uint8] = cast[Ptr[uint8]](src32[0])
    src_len: int32 = src32[1]

    # Clamp bounds
    actual_start: int32 = start
    if actual_start < 0:
        actual_start = 0
    if actual_start > src_len:
        actual_start = src_len

    actual_len: int32 = length
    if actual_start + actual_len > src_len:
        actual_len = src_len - actual_start
    if actual_len < 0:
        actual_len = 0

    # Initialize dest with appropriate capacity
    string_init(dest, actual_len + 1)

    # Copy substring
    dest32: Ptr[int32] = cast[Ptr[int32]](dest)
    dest_data: Ptr[uint8] = cast[Ptr[uint8]](dest32[0])

    i: int32 = 0
    while i < actual_len:
        dest_data[i] = src_data[actual_start + i]
        i = i + 1
    dest_data[actual_len] = 0
    dest32[1] = actual_len

# Copy string
def string_copy(dest: Ptr[uint8], src: Ptr[uint8]):
    src32: Ptr[int32] = cast[Ptr[int32]](src)
    src_len: int32 = src32[1]
    string_substr(dest, src, 0, src_len)

# Check if string is empty
def string_is_empty(s: Ptr[uint8]) -> bool:
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    return s32[1] == 0

# Trim leading whitespace (in place)
def string_ltrim(s: Ptr[uint8]):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]

    # Find first non-whitespace
    start: int32 = 0
    while start < length:
        c: uint8 = data[start]
        if c != 32 and c != 9 and c != 10 and c != 13:
            break
        start = start + 1

    if start == 0:
        return  # Nothing to trim

    # Shift characters
    new_len: int32 = length - start
    i: int32 = 0
    while i < new_len:
        data[i] = data[start + i]
        i = i + 1
    data[new_len] = 0
    s32[1] = new_len

# Trim trailing whitespace (in place)
def string_rtrim(s: Ptr[uint8]):
    s32: Ptr[int32] = cast[Ptr[int32]](s)
    data: Ptr[uint8] = cast[Ptr[uint8]](s32[0])
    length: int32 = s32[1]

    # Find last non-whitespace
    while length > 0:
        c: uint8 = data[length - 1]
        if c != 32 and c != 9 and c != 10 and c != 13:
            break
        length = length - 1

    data[length] = 0
    s32[1] = length

# Trim both ends
def string_trim(s: Ptr[uint8]):
    string_rtrim(s)
    string_ltrim(s)

# ============================================================================
# C-Style String Utilities
# ============================================================================

# Copy null-terminated string
def strcpy(dest: Ptr[uint8], src: Ptr[uint8]) -> Ptr[uint8]:
    i: int32 = 0
    while src[i] != 0:
        dest[i] = src[i]
        i = i + 1
    dest[i] = 0
    return dest

# Copy at most n characters
def strncpy(dest: Ptr[uint8], src: Ptr[uint8], n: int32) -> Ptr[uint8]:
    i: int32 = 0
    while i < n and src[i] != 0:
        dest[i] = src[i]
        i = i + 1
    while i < n:
        dest[i] = 0
        i = i + 1
    return dest

# Concatenate strings
def strcat(dest: Ptr[uint8], src: Ptr[uint8]) -> Ptr[uint8]:
    dest_len: int32 = cstr_len(dest)
    i: int32 = 0
    while src[i] != 0:
        dest[dest_len + i] = src[i]
        i = i + 1
    dest[dest_len + i] = 0
    return dest

# Concatenate at most n characters
def strncat(dest: Ptr[uint8], src: Ptr[uint8], n: int32) -> Ptr[uint8]:
    dest_len: int32 = cstr_len(dest)
    i: int32 = 0
    while i < n and src[i] != 0:
        dest[dest_len + i] = src[i]
        i = i + 1
    dest[dest_len + i] = 0
    return dest

# Compare strings
def strcmp(s1: Ptr[uint8], s2: Ptr[uint8]) -> int32:
    i: int32 = 0
    while s1[i] != 0 and s2[i] != 0:
        if s1[i] != s2[i]:
            return cast[int32](s1[i]) - cast[int32](s2[i])
        i = i + 1
    return cast[int32](s1[i]) - cast[int32](s2[i])

# Compare first n characters
def strncmp(s1: Ptr[uint8], s2: Ptr[uint8], n: int32) -> int32:
    i: int32 = 0
    while i < n and s1[i] != 0 and s2[i] != 0:
        if s1[i] != s2[i]:
            return cast[int32](s1[i]) - cast[int32](s2[i])
        i = i + 1
    if i == n:
        return 0
    return cast[int32](s1[i]) - cast[int32](s2[i])

# Case-insensitive comparison
def strcasecmp(s1: Ptr[uint8], s2: Ptr[uint8]) -> int32:
    i: int32 = 0
    while s1[i] != 0 and s2[i] != 0:
        c1: uint8 = s1[i]
        c2: uint8 = s2[i]
        if c1 >= 65 and c1 <= 90:
            c1 = c1 + 32
        if c2 >= 65 and c2 <= 90:
            c2 = c2 + 32
        if c1 != c2:
            return cast[int32](c1) - cast[int32](c2)
        i = i + 1
    return cast[int32](s1[i]) - cast[int32](s2[i])

# Find first occurrence of character
def strchr(s: Ptr[uint8], c: int32) -> Ptr[uint8]:
    i: int32 = 0
    while s[i] != 0:
        if cast[int32](s[i]) == c:
            return cast[Ptr[uint8]](cast[int32](s) + i)
        i = i + 1
    if c == 0:
        return cast[Ptr[uint8]](cast[int32](s) + i)
    return cast[Ptr[uint8]](0)

# Find last occurrence of character
def strrchr(s: Ptr[uint8], c: int32) -> Ptr[uint8]:
    length: int32 = cstr_len(s)
    i: int32 = length
    if c == 0:
        return cast[Ptr[uint8]](cast[int32](s) + length)
    while i >= 0:
        if cast[int32](s[i]) == c:
            return cast[Ptr[uint8]](cast[int32](s) + i)
        i = i - 1
    return cast[Ptr[uint8]](0)

# Find substring
def strstr(haystack: Ptr[uint8], needle: Ptr[uint8]) -> Ptr[uint8]:
    if needle[0] == 0:
        return haystack
    i: int32 = 0
    while haystack[i] != 0:
        j: int32 = 0
        while needle[j] != 0 and haystack[i + j] == needle[j]:
            j = j + 1
        if needle[j] == 0:
            return cast[Ptr[uint8]](cast[int32](haystack) + i)
        i = i + 1
    return cast[Ptr[uint8]](0)

# Check if string starts with prefix
def cstr_starts_with(s: Ptr[uint8], prefix: Ptr[uint8]) -> int32:
    i: int32 = 0
    while prefix[i] != 0:
        if s[i] == 0 or s[i] != prefix[i]:
            return 0
        i = i + 1
    return 1

# Check if string ends with suffix
def cstr_ends_with(s: Ptr[uint8], suffix: Ptr[uint8]) -> int32:
    s_len: int32 = cstr_len(s)
    suffix_len: int32 = cstr_len(suffix)
    if suffix_len > s_len:
        return 0
    i: int32 = 0
    while i < suffix_len:
        if s[s_len - suffix_len + i] != suffix[i]:
            return 0
        i = i + 1
    return 1

# ============================================================================
# Character Classification
# ============================================================================

def isdigit(c: int32) -> int32:
    return c >= 48 and c <= 57

def isalpha(c: int32) -> int32:
    return (c >= 65 and c <= 90) or (c >= 97 and c <= 122)

def isalnum(c: int32) -> int32:
    return isdigit(c) or isalpha(c)

def isspace(c: int32) -> int32:
    return c == 32 or c == 9 or c == 10 or c == 13 or c == 11 or c == 12

def isupper(c: int32) -> int32:
    return c >= 65 and c <= 90

def islower(c: int32) -> int32:
    return c >= 97 and c <= 122

def isxdigit(c: int32) -> int32:
    return isdigit(c) or (c >= 65 and c <= 70) or (c >= 97 and c <= 102)

def isprint(c: int32) -> int32:
    return c >= 32 and c <= 126

def toupper(c: int32) -> int32:
    if islower(c) != 0:
        return c - 32
    return c

def tolower(c: int32) -> int32:
    if isupper(c) != 0:
        return c + 32
    return c

# ============================================================================
# String Conversion
# ============================================================================

# Convert string to integer
def atoi(s: Ptr[uint8]) -> int32:
    result: int32 = 0
    sign: int32 = 1
    i: int32 = 0

    while isspace(cast[int32](s[i])) != 0:
        i = i + 1

    if s[i] == 45:
        sign = -1
        i = i + 1
    elif s[i] == 43:
        i = i + 1

    while isdigit(cast[int32](s[i])) != 0:
        result = result * 10 + (cast[int32](s[i]) - 48)
        i = i + 1

    return result * sign

# Convert integer to string
def itoa(value: int32, buf: Ptr[uint8]) -> Ptr[uint8]:
    i: int32 = 0
    negative: int32 = 0
    v: int32 = value

    if v == 0:
        buf[0] = 48
        buf[1] = 0
        return buf

    if v < 0:
        negative = 1
        v = -v

    while v > 0:
        buf[i] = cast[uint8](48 + (v % 10))
        v = v / 10
        i = i + 1

    if negative != 0:
        buf[i] = 45
        i = i + 1

    buf[i] = 0

    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        tmp: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = tmp
        j = j + 1
        k = k - 1

    return buf

# Convert integer to string with base
def itoa_base(value: int32, buf: Ptr[uint8], base: int32) -> Ptr[uint8]:
    if base < 2 or base > 36:
        buf[0] = 0
        return buf

    digits: Ptr[uint8] = cast[Ptr[uint8]]("0123456789abcdefghijklmnopqrstuvwxyz")
    i: int32 = 0
    negative: int32 = 0
    v: int32 = value

    if v == 0:
        buf[0] = 48
        buf[1] = 0
        return buf

    if v < 0 and base == 10:
        negative = 1
        v = -v

    while v > 0:
        buf[i] = digits[v % base]
        v = v / base
        i = i + 1

    if negative != 0:
        buf[i] = 45
        i = i + 1

    buf[i] = 0

    j: int32 = 0
    k: int32 = i - 1
    while j < k:
        tmp: uint8 = buf[j]
        buf[j] = buf[k]
        buf[k] = tmp
        j = j + 1
        k = k - 1

    return buf

# ============================================================================
# Memory Operations
# ============================================================================

# Fill memory with value
def memset(dest: Ptr[uint8], c: int32, n: int32) -> Ptr[uint8]:
    i: int32 = 0
    while i < n:
        dest[i] = cast[uint8](c)
        i = i + 1
    return dest

# Copy memory
def memcpy(dest: Ptr[uint8], src: Ptr[uint8], n: int32) -> Ptr[uint8]:
    i: int32 = 0
    while i < n:
        dest[i] = src[i]
        i = i + 1
    return dest

# Move memory (handles overlap)
def memmove(dest: Ptr[uint8], src: Ptr[uint8], n: int32) -> Ptr[uint8]:
    if cast[int32](dest) < cast[int32](src):
        i: int32 = 0
        while i < n:
            dest[i] = src[i]
            i = i + 1
    else:
        i: int32 = n - 1
        while i >= 0:
            dest[i] = src[i]
            i = i - 1
    return dest

# Compare memory
def memcmp(s1: Ptr[uint8], s2: Ptr[uint8], n: int32) -> int32:
    i: int32 = 0
    while i < n:
        if s1[i] != s2[i]:
            return cast[int32](s1[i]) - cast[int32](s2[i])
        i = i + 1
    return 0

# Find byte in memory
def memchr(s: Ptr[uint8], c: int32, n: int32) -> Ptr[uint8]:
    i: int32 = 0
    while i < n:
        if cast[int32](s[i]) == c:
            return cast[Ptr[uint8]](cast[int32](s) + i)
        i = i + 1
    return cast[Ptr[uint8]](0)

# ============================================================================
# Hex Encoding
# ============================================================================

# Encode bytes to hex string
def bytes_to_hex(input: Ptr[uint8], length: int32, output: Ptr[uint8]) -> int32:
    hex: Ptr[uint8] = cast[Ptr[uint8]]("0123456789abcdef")
    i: int32 = 0
    while i < length:
        b: uint8 = input[i]
        output[i * 2] = hex[cast[int32](b) / 16]
        output[i * 2 + 1] = hex[cast[int32](b) % 16]
        i = i + 1
    output[length * 2] = 0
    return length * 2

# Decode hex string to bytes
def hex_to_bytes(input: Ptr[uint8], output: Ptr[uint8]) -> int32:
    length: int32 = cstr_len(input)
    if length % 2 != 0:
        return -1

    i: int32 = 0
    while i < length:
        hi: int32 = 0
        lo: int32 = 0
        c1: int32 = cast[int32](input[i])
        c2: int32 = cast[int32](input[i + 1])

        if c1 >= 48 and c1 <= 57:
            hi = c1 - 48
        elif c1 >= 65 and c1 <= 70:
            hi = c1 - 55
        elif c1 >= 97 and c1 <= 102:
            hi = c1 - 87
        else:
            return -1

        if c2 >= 48 and c2 <= 57:
            lo = c2 - 48
        elif c2 >= 65 and c2 <= 70:
            lo = c2 - 55
        elif c2 >= 97 and c2 <= 102:
            lo = c2 - 87
        else:
            return -1

        output[i / 2] = cast[uint8](hi * 16 + lo)
        i = i + 2

    return length / 2

# ============================================================================
# String Formatting Helpers
# ============================================================================

# Convert string to uppercase in-place
def cstr_toupper(s: Ptr[uint8]) -> Ptr[uint8]:
    i: int32 = 0
    while s[i] != 0:
        if s[i] >= 97 and s[i] <= 122:
            s[i] = s[i] - 32
        i = i + 1
    return s

# Convert string to lowercase in-place
def cstr_tolower(s: Ptr[uint8]) -> Ptr[uint8]:
    i: int32 = 0
    while s[i] != 0:
        if s[i] >= 65 and s[i] <= 90:
            s[i] = s[i] + 32
        i = i + 1
    return s

# Reverse string in-place
def cstr_reverse(s: Ptr[uint8]) -> Ptr[uint8]:
    length: int32 = cstr_len(s)
    i: int32 = 0
    j: int32 = length - 1
    while i < j:
        tmp: uint8 = s[i]
        s[i] = s[j]
        s[j] = tmp
        i = i + 1
        j = j - 1
    return s

# Trim leading whitespace
def cstr_ltrim(s: Ptr[uint8]) -> Ptr[uint8]:
    while s[0] != 0 and isspace(cast[int32](s[0])) != 0:
        s = cast[Ptr[uint8]](cast[int32](s) + 1)
    return s

# Trim trailing whitespace
def cstr_rtrim(s: Ptr[uint8]) -> Ptr[uint8]:
    length: int32 = cstr_len(s)
    while length > 0 and isspace(cast[int32](s[length - 1])) != 0:
        length = length - 1
        s[length] = 0
    return s

# Count substring occurrences
def cstr_count(s: Ptr[uint8], substr: Ptr[uint8]) -> int32:
    count: int32 = 0
    pos: Ptr[uint8] = s

    while pos[0] != 0:
        found: Ptr[uint8] = strstr(pos, substr)
        if found == cast[Ptr[uint8]](0):
            return count
        count = count + 1
        pos = cast[Ptr[uint8]](cast[int32](found) + 1)

    return count

# Pad string left
def cstr_pad_left(s: Ptr[uint8], target_len: int32, pad: uint8, buf: Ptr[uint8], buf_size: int32) -> int32:
    s_len: int32 = cstr_len(s)
    if target_len <= s_len:
        strcpy(buf, s)
        return s_len

    pad_len: int32 = target_len - s_len
    if target_len + 1 > buf_size:
        return -1

    memset(buf, cast[int32](pad), pad_len)
    strcpy(cast[Ptr[uint8]](cast[int32](buf) + pad_len), s)
    return target_len

# Pad string right
def cstr_pad_right(s: Ptr[uint8], target_len: int32, pad: uint8, buf: Ptr[uint8], buf_size: int32) -> int32:
    s_len: int32 = cstr_len(s)
    if target_len <= s_len:
        strcpy(buf, s)
        return s_len

    if target_len + 1 > buf_size:
        return -1

    strcpy(buf, s)
    memset(cast[Ptr[uint8]](cast[int32](buf) + s_len), cast[int32](pad), target_len - s_len)
    buf[target_len] = 0
    return target_len

# ============================================================================
# Python-compatible string methods (for compiler self-hosting)
# ============================================================================

# Convert string to lowercase (in-place)
def str_lower(s: Ptr[uint8]) -> Ptr[uint8]:
    i: int32 = 0
    while s[i] != 0:
        c: int32 = cast[int32](s[i])
        if c >= 65 and c <= 90:
            s[i] = cast[uint8](c + 32)
        i = i + 1
    return s

# Check if string ends with suffix
def str_endswith(s: Ptr[uint8], suffix: Ptr[uint8]) -> bool:
    s_len: int32 = cstr_len(s)
    suffix_len: int32 = cstr_len(suffix)
    if suffix_len > s_len:
        return False
    i: int32 = 0
    start: int32 = s_len - suffix_len
    while i < suffix_len:
        if s[start + i] != suffix[i]:
            return False
        i = i + 1
    return True

# Check if string starts with prefix
def str_startswith(s: Ptr[uint8], prefix: Ptr[uint8]) -> bool:
    i: int32 = 0
    while prefix[i] != 0:
        if s[i] != prefix[i]:
            return False
        i = i + 1
    return True
