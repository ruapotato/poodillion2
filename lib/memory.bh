# Memory Allocation Module for Brainhair
#
# Provides general-purpose memory allocation on top of the arena system.
# For most uses, prefer arena allocation. Use these when you need
# individual object lifetimes.
#
# Memory layout uses a simple free-list allocator with headers.

# Import syscalls
SYS_brk: Final[int32] = 45
SYS_mmap: Final[int32] = 90
SYS_munmap: Final[int32] = 91

PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_PRIVATE: Final[int32] = 2
MAP_ANONYMOUS: Final[int32] = 32

extern def syscall1(num: int32, arg1: int32) -> int32
extern def syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32) -> int32

# Allocation header structure
# Fields:
#   size: int32        - Size of allocation (including header)
#   flags: int32       - Flags (1 = in use, 0 = free)
# Total: 8 bytes
ALLOC_HEADER_SIZE: Final[int32] = 8
ALLOC_FLAG_USED: Final[int32] = 1
ALLOC_FLAG_FREE: Final[int32] = 0

# Global heap state
# We use a simple bump allocator backed by mmap
# For a real implementation, we'd have a proper free list
heap_base: int32 = 0
heap_size: int32 = 0
heap_used: int32 = 0

DEFAULT_HEAP_SIZE: Final[int32] = 1048576  # 1 MB default heap

# Initialize the heap
def heap_init() -> int32:
    if heap_base != 0:
        return 1  # Already initialized

    # Allocate heap using mmap
    mem: int32 = syscall6(SYS_mmap, 0, DEFAULT_HEAP_SIZE,
                          PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)

    if mem < 0:
        return 0  # Failed

    heap_base = mem
    heap_size = DEFAULT_HEAP_SIZE
    heap_used = 0
    return 1

# Allocate memory from the heap
# Returns pointer to usable memory (after header)
def alloc(size: int32) -> Ptr[uint8]:
    # Initialize heap on first use
    if heap_base == 0:
        if heap_init() == 0:
            return Ptr[uint8](0)

    # Align size to 4 bytes
    aligned_size: int32 = (size + 3) & -4
    total_size: int32 = aligned_size + ALLOC_HEADER_SIZE

    # Check if we have space
    if heap_used + total_size > heap_size:
        return Ptr[uint8](0)  # Out of memory

    # Get header location
    header_ptr: Ptr[int32] = Ptr[int32](heap_base + heap_used)

    # Write header
    header_ptr[0] = total_size      # size
    header_ptr[1] = ALLOC_FLAG_USED # flags

    # Calculate data pointer (after header)
    data_ptr: int32 = heap_base + heap_used + ALLOC_HEADER_SIZE

    # Update used
    heap_used = heap_used + total_size

    return Ptr[uint8](data_ptr)

# Allocate and zero memory
def alloc_zero(size: int32) -> Ptr[uint8]:
    p: Ptr[uint8] = alloc(size)
    if cast[int32](p) == 0:
        return p

    # Zero the memory
    i: int32 = 0
    while i < size:
        p[i] = 0
        i = i + 1

    return p

# Free memory (marks as free for potential reuse)
# Note: In this simple allocator, memory is not actually reused
# A full implementation would maintain a free list
def free(p: Ptr[uint8]):
    if cast[int32](p) == 0:
        return

    # Get header (8 bytes before data)
    header_ptr: Ptr[int32] = Ptr[int32](cast[int32](p) - ALLOC_HEADER_SIZE)

    # Mark as free
    header_ptr[1] = ALLOC_FLAG_FREE

# Reallocate memory to a new size
def realloc(p: Ptr[uint8], old_size: int32, new_size: int32) -> Ptr[uint8]:
    if cast[int32](p) == 0:
        return alloc(new_size)

    if new_size == 0:
        free(p)
        return Ptr[uint8](0)

    # Allocate new block
    new_ptr: Ptr[uint8] = alloc(new_size)
    if cast[int32](new_ptr) == 0:
        return Ptr[uint8](0)

    # Copy data (minimum of old and new size)
    copy_size: int32 = old_size
    if new_size < old_size:
        copy_size = new_size

    i: int32 = 0
    while i < copy_size:
        new_ptr[i] = p[i]
        i = i + 1

    # Free old block
    free(p)

    return new_ptr

# Get the size of an allocation
def alloc_size(p: Ptr[uint8]) -> int32:
    if cast[int32](p) == 0:
        return 0

    # Get header
    header_ptr: Ptr[int32] = Ptr[int32](cast[int32](p) - ALLOC_HEADER_SIZE)

    # Return usable size (total size minus header)
    return header_ptr[0] - ALLOC_HEADER_SIZE

# Get total heap usage
def heap_usage() -> int32:
    return heap_used

# Get remaining heap space
def heap_remaining() -> int32:
    return heap_size - heap_used

# Reset heap (free all allocations)
# WARNING: Invalidates all pointers!
def heap_reset():
    heap_used = 0

# Destroy heap (release memory back to OS)
def heap_destroy():
    if heap_base != 0:
        syscall6(SYS_munmap, heap_base, heap_size, 0, 0, 0, 0)
        heap_base = 0
        heap_size = 0
        heap_used = 0

# Memory copy
def mem_copy(dest: Ptr[uint8], src: Ptr[uint8], n: int32):
    i: int32 = 0
    while i < n:
        dest[i] = src[i]
        i = i + 1

# Memory set
def mem_set(dest: Ptr[uint8], val: uint8, n: int32):
    i: int32 = 0
    while i < n:
        dest[i] = val
        i = i + 1

# Memory compare
def mem_cmp(s1: Ptr[uint8], s2: Ptr[uint8], n: int32) -> int32:
    i: int32 = 0
    while i < n:
        if s1[i] != s2[i]:
            if s1[i] < s2[i]:
                return -1
            return 1
        i = i + 1
    return 0

# Memory move (handles overlapping regions)
def mem_move(dest: Ptr[uint8], src: Ptr[uint8], n: int32):
    if cast[int32](dest) < cast[int32](src):
        # Copy forward
        i: int32 = 0
        while i < n:
            dest[i] = src[i]
            i = i + 1
    else:
        # Copy backward
        i: int32 = n - 1
        while i >= 0:
            dest[i] = src[i]
            i = i - 1

# Zero memory
def mem_zero(dest: Ptr[uint8], n: int32):
    mem_set(dest, 0, n)

# Duplicate memory (allocate and copy)
def mem_dup(src: Ptr[uint8], n: int32) -> Ptr[uint8]:
    dest: Ptr[uint8] = alloc(n)
    if cast[int32](dest) != 0:
        mem_copy(dest, src, n)
    return dest
