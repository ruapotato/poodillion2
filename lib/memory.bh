# Memory Allocation Module for Brainhair
#
# Provides general-purpose memory allocation on top of the arena system.
# For most uses, prefer arena allocation. Use these when you need
# individual object lifetimes.
#
# Memory layout uses a simple free-list allocator with headers.

# Import syscalls
const SYS_brk: int32 = 45
const SYS_mmap: int32 = 90
const SYS_munmap: int32 = 91

const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_PRIVATE: int32 = 2
const MAP_ANONYMOUS: int32 = 32

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

# Allocation header structure
# Fields:
#   size: int32        - Size of allocation (including header)
#   flags: int32       - Flags (1 = in use, 0 = free)
# Total: 8 bytes
const ALLOC_HEADER_SIZE: int32 = 8
const ALLOC_FLAG_USED: int32 = 1
const ALLOC_FLAG_FREE: int32 = 0

# Global heap state
# We use a simple bump allocator backed by mmap
# For a real implementation, we'd have a proper free list
var heap_base: int32 = 0
var heap_size: int32 = 0
var heap_used: int32 = 0

const DEFAULT_HEAP_SIZE: int32 = 1048576  # 1 MB default heap

# Initialize the heap
proc heap_init(): int32 =
    if heap_base != 0:
        return 1  # Already initialized

    # Allocate heap using mmap
    var mem: int32 = syscall6(SYS_mmap, 0, DEFAULT_HEAP_SIZE,
                              PROT_READ | PROT_WRITE,
                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)

    if mem < 0:
        return 0  # Failed

    heap_base = mem
    heap_size = DEFAULT_HEAP_SIZE
    heap_used = 0
    return 1

# Allocate memory from the heap
# Returns pointer to usable memory (after header)
proc alloc(size: int32): ptr uint8 =
    # Initialize heap on first use
    if heap_base == 0:
        if heap_init() == 0:
            return cast[ptr uint8](0)

    # Align size to 4 bytes
    var aligned_size: int32 = (size + 3) & -4
    var total_size: int32 = aligned_size + ALLOC_HEADER_SIZE

    # Check if we have space
    if heap_used + total_size > heap_size:
        return cast[ptr uint8](0)  # Out of memory

    # Get header location
    var header_ptr: ptr int32 = cast[ptr int32](heap_base + heap_used)

    # Write header
    header_ptr[0] = total_size      # size
    header_ptr[1] = ALLOC_FLAG_USED # flags

    # Calculate data pointer (after header)
    var data_ptr: int32 = heap_base + heap_used + ALLOC_HEADER_SIZE

    # Update used
    heap_used = heap_used + total_size

    return cast[ptr uint8](data_ptr)

# Allocate and zero memory
proc alloc_zero(size: int32): ptr uint8 =
    var ptr: ptr uint8 = alloc(size)
    if cast[int32](ptr) == 0:
        return ptr

    # Zero the memory
    var i: int32 = 0
    while i < size:
        ptr[i] = 0
        i = i + 1

    return ptr

# Free memory (marks as free for potential reuse)
# Note: In this simple allocator, memory is not actually reused
# A full implementation would maintain a free list
proc free(ptr: ptr uint8) =
    if cast[int32](ptr) == 0:
        return

    # Get header (8 bytes before data)
    var header_ptr: ptr int32 = cast[ptr int32](cast[int32](ptr) - ALLOC_HEADER_SIZE)

    # Mark as free
    header_ptr[1] = ALLOC_FLAG_FREE

# Reallocate memory to a new size
proc realloc(ptr: ptr uint8, old_size: int32, new_size: int32): ptr uint8 =
    if cast[int32](ptr) == 0:
        return alloc(new_size)

    if new_size == 0:
        free(ptr)
        return cast[ptr uint8](0)

    # Allocate new block
    var new_ptr: ptr uint8 = alloc(new_size)
    if cast[int32](new_ptr) == 0:
        return cast[ptr uint8](0)

    # Copy data (minimum of old and new size)
    var copy_size: int32 = old_size
    if new_size < old_size:
        copy_size = new_size

    var i: int32 = 0
    while i < copy_size:
        new_ptr[i] = ptr[i]
        i = i + 1

    # Free old block
    free(ptr)

    return new_ptr

# Get the size of an allocation
proc alloc_size(ptr: ptr uint8): int32 =
    if cast[int32](ptr) == 0:
        return 0

    # Get header
    var header_ptr: ptr int32 = cast[ptr int32](cast[int32](ptr) - ALLOC_HEADER_SIZE)

    # Return usable size (total size minus header)
    return header_ptr[0] - ALLOC_HEADER_SIZE

# Get total heap usage
proc heap_usage(): int32 =
    return heap_used

# Get remaining heap space
proc heap_remaining(): int32 =
    return heap_size - heap_used

# Reset heap (free all allocations)
# WARNING: Invalidates all pointers!
proc heap_reset() =
    heap_used = 0

# Destroy heap (release memory back to OS)
proc heap_destroy() =
    if heap_base != 0:
        discard syscall6(SYS_munmap, heap_base, heap_size, 0, 0, 0, 0)
        heap_base = 0
        heap_size = 0
        heap_used = 0

# Memory copy
proc mem_copy(dest: ptr uint8, src: ptr uint8, n: int32) =
    var i: int32 = 0
    while i < n:
        dest[i] = src[i]
        i = i + 1

# Memory set
proc mem_set(dest: ptr uint8, val: uint8, n: int32) =
    var i: int32 = 0
    while i < n:
        dest[i] = val
        i = i + 1

# Memory compare
proc mem_cmp(s1: ptr uint8, s2: ptr uint8, n: int32): int32 =
    var i: int32 = 0
    while i < n:
        if s1[i] != s2[i]:
            if s1[i] < s2[i]:
                return -1
            return 1
        i = i + 1
    return 0

# Memory move (handles overlapping regions)
proc mem_move(dest: ptr uint8, src: ptr uint8, n: int32) =
    if cast[int32](dest) < cast[int32](src):
        # Copy forward
        var i: int32 = 0
        while i < n:
            dest[i] = src[i]
            i = i + 1
    else:
        # Copy backward
        var i: int32 = n - 1
        while i >= 0:
            dest[i] = src[i]
            i = i - 1

# Zero memory
proc mem_zero(dest: ptr uint8, n: int32) =
    mem_set(dest, 0, n)

# Duplicate memory (allocate and copy)
proc mem_dup(src: ptr uint8, n: int32): ptr uint8 =
    var dest: ptr uint8 = alloc(n)
    if cast[int32](dest) != 0:
        mem_copy(dest, src, n)
    return dest
