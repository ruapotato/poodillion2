# File I/O Module for Brainhair
#
# Provides buffered file reading and writing operations.
# Builds on syscalls.bh for low-level system calls.

# Linux syscall numbers
SYS_read: Final[int32] = 3
SYS_write: Final[int32] = 4
SYS_open: Final[int32] = 5
SYS_close: Final[int32] = 6
SYS_lseek: Final[int32] = 19
SYS_stat: Final[int32] = 18
SYS_fstat: Final[int32] = 28

# File open flags
O_RDONLY: Final[int32] = 0
O_WRONLY: Final[int32] = 1
O_RDWR: Final[int32] = 2
O_CREAT: Final[int32] = 64
O_TRUNC: Final[int32] = 512
O_APPEND: Final[int32] = 1024
O_EXCL: Final[int32] = 128

# Seek modes
SEEK_SET: Final[int32] = 0
SEEK_CUR: Final[int32] = 1
SEEK_END: Final[int32] = 2

# Standard file descriptors
STDIN_FD: Final[int32] = 0
STDOUT_FD: Final[int32] = 1
STDERR_FD: Final[int32] = 2

# Default permissions for created files (0644)
FILE_MODE_DEFAULT: Final[int32] = 420

# Buffer size for buffered I/O
IO_BUFFER_SIZE: Final[int32] = 4096

# Memory allocation
SYS_mmap: Final[int32] = 90
SYS_munmap: Final[int32] = 91
PROT_READ: Final[int32] = 1
PROT_WRITE: Final[int32] = 2
MAP_PRIVATE: Final[int32] = 2
MAP_ANONYMOUS: Final[int32] = 32

extern def syscall1(num: int32, arg1: int32) -> int32
extern def syscall2(num: int32, arg1: int32, arg2: int32) -> int32
extern def syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32) -> int32
extern def syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32) -> int32

# Helper allocation
def io_alloc(size: int32) -> Ptr[uint8]:
    mem: int32 = syscall6(SYS_mmap, 0, size,
                          PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    if mem < 0:
        return cast[Ptr[uint8]](0)
    return cast[Ptr[uint8]](mem)

def io_free(p: Ptr[uint8], size: int32):
    if cast[int32](p) != 0:
        syscall6(SYS_munmap, cast[int32](p), size, 0, 0, 0, 0)

# ============================================================================
# File structure (buffered file handle)
# Fields:
#   fd: int32           - File descriptor (offset 0)
#   flags: int32        - Open flags (offset 4)
#   buffer: Ptr[uint8]  - I/O buffer (offset 8)
#   buf_pos: int32      - Current position in buffer (offset 12)
#   buf_len: int32      - Valid bytes in buffer (offset 16)
#   buf_cap: int32      - Buffer capacity (offset 20)
#   error: int32        - Error code (0 = no error) (offset 24)
# Total: 28 bytes
# ============================================================================

FILE_FD_OFFSET: Final[int32] = 0
FILE_FLAGS_OFFSET: Final[int32] = 4
FILE_BUFFER_OFFSET: Final[int32] = 8
FILE_BUF_POS_OFFSET: Final[int32] = 12
FILE_BUF_LEN_OFFSET: Final[int32] = 16
FILE_BUF_CAP_OFFSET: Final[int32] = 20
FILE_ERROR_OFFSET: Final[int32] = 24
FILE_STRUCT_SIZE: Final[int32] = 28

# File mode flags
FILE_MODE_READ: Final[int32] = 1
FILE_MODE_WRITE: Final[int32] = 2

# ============================================================================
# Basic file operations (unbuffered)
# ============================================================================

# Open a file (returns fd, or negative on error)
def file_open_raw(path: Ptr[uint8], flags: int32, mode: int32) -> int32:
    return syscall3(SYS_open, cast[int32](path), flags, mode)

# Close a file
def file_close_raw(fd: int32) -> int32:
    return syscall1(SYS_close, fd)

# Read from file
def file_read_raw(fd: int32, buf: Ptr[uint8], count: int32) -> int32:
    return syscall3(SYS_read, fd, cast[int32](buf), count)

# Write to file
def file_write_raw(fd: int32, buf: Ptr[uint8], count: int32) -> int32:
    return syscall3(SYS_write, fd, cast[int32](buf), count)

# Seek in file
def file_seek_raw(fd: int32, offset: int32, whence: int32) -> int32:
    return syscall3(SYS_lseek, fd, offset, whence)

# ============================================================================
# Buffered file operations
# ============================================================================

# Initialize file structure for reading
def file_open_read(f: Ptr[uint8], path: Ptr[uint8]) -> int32:
    fd: int32 = file_open_raw(path, O_RDONLY, 0)
    if fd < 0:
        return fd

    # Allocate buffer
    buffer: Ptr[uint8] = io_alloc(IO_BUFFER_SIZE)
    if cast[int32](buffer) == 0:
        file_close_raw(fd)
        return -1

    f32: Ptr[int32] = cast[Ptr[int32]](f)
    f32[0] = fd               # fd
    f32[1] = FILE_MODE_READ   # flags
    f32[2] = cast[int32](buffer)  # buffer
    f32[3] = 0                # buf_pos
    f32[4] = 0                # buf_len
    f32[5] = IO_BUFFER_SIZE   # buf_cap
    f32[6] = 0                # error

    return fd

# Initialize file structure for writing
def file_open_write(f: Ptr[uint8], path: Ptr[uint8]) -> int32:
    fd: int32 = file_open_raw(path, O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE_DEFAULT)
    if fd < 0:
        return fd

    # Allocate buffer
    buffer: Ptr[uint8] = io_alloc(IO_BUFFER_SIZE)
    if cast[int32](buffer) == 0:
        file_close_raw(fd)
        return -1

    f32: Ptr[int32] = cast[Ptr[int32]](f)
    f32[0] = fd               # fd
    f32[1] = FILE_MODE_WRITE  # flags
    f32[2] = cast[int32](buffer)  # buffer
    f32[3] = 0                # buf_pos
    f32[4] = 0                # buf_len (unused for write)
    f32[5] = IO_BUFFER_SIZE   # buf_cap
    f32[6] = 0                # error

    return fd

# Initialize file structure for appending
def file_open_append(f: Ptr[uint8], path: Ptr[uint8]) -> int32:
    fd: int32 = file_open_raw(path, O_WRONLY | O_CREAT | O_APPEND, FILE_MODE_DEFAULT)
    if fd < 0:
        return fd

    # Allocate buffer
    buffer: Ptr[uint8] = io_alloc(IO_BUFFER_SIZE)
    if cast[int32](buffer) == 0:
        file_close_raw(fd)
        return -1

    f32: Ptr[int32] = cast[Ptr[int32]](f)
    f32[0] = fd               # fd
    f32[1] = FILE_MODE_WRITE  # flags
    f32[2] = cast[int32](buffer)  # buffer
    f32[3] = 0                # buf_pos
    f32[4] = 0                # buf_len
    f32[5] = IO_BUFFER_SIZE   # buf_cap
    f32[6] = 0                # error

    return fd

# Flush write buffer to file
def file_flush(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    fd: int32 = f32[0]
    flags: int32 = f32[1]
    buffer: Ptr[uint8] = cast[Ptr[uint8]](f32[2])
    buf_pos: int32 = f32[3]

    if (flags & FILE_MODE_WRITE) == 0:
        return 0  # Not a write file

    if buf_pos == 0:
        return 0  # Nothing to flush

    # Write buffer to file
    written: int32 = file_write_raw(fd, buffer, buf_pos)
    if written < 0:
        f32[6] = written
        return written

    f32[3] = 0  # Reset buffer position
    return written

# Close file (flushes if needed)
def file_close(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    fd: int32 = f32[0]
    flags: int32 = f32[1]
    buffer: Ptr[uint8] = cast[Ptr[uint8]](f32[2])
    buf_cap: int32 = f32[5]

    # Flush if writing
    if (flags & FILE_MODE_WRITE) != 0:
        file_flush(f)

    # Free buffer
    if cast[int32](buffer) != 0:
        io_free(buffer, buf_cap)

    # Close fd
    result: int32 = file_close_raw(fd)

    # Clear structure
    f32[0] = -1
    f32[1] = 0
    f32[2] = 0
    f32[3] = 0
    f32[4] = 0
    f32[5] = 0
    f32[6] = 0

    return result

# Fill read buffer from file
def file_fill_buffer(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    fd: int32 = f32[0]
    buffer: Ptr[uint8] = cast[Ptr[uint8]](f32[2])
    buf_cap: int32 = f32[5]

    bytes_read: int32 = file_read_raw(fd, buffer, buf_cap)
    if bytes_read < 0:
        f32[6] = bytes_read
        return bytes_read

    f32[3] = 0             # Reset position
    f32[4] = bytes_read    # Set valid length
    return bytes_read

# Read a single byte (returns -1 on EOF or error)
def file_read_byte(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    buffer: Ptr[uint8] = cast[Ptr[uint8]](f32[2])
    buf_pos: int32 = f32[3]
    buf_len: int32 = f32[4]

    # Refill buffer if empty
    if buf_pos >= buf_len:
        filled: int32 = file_fill_buffer(f)
        if filled <= 0:
            return -1  # EOF or error
        buf_pos = 0
        buf_len = filled

    byte_val: uint8 = buffer[buf_pos]
    f32[3] = buf_pos + 1
    return cast[int32](byte_val)

# Read bytes into buffer (returns bytes read)
def file_read(f: Ptr[uint8], dest: Ptr[uint8], count: int32) -> int32:
    total: int32 = 0

    while total < count:
        byte_val: int32 = file_read_byte(f)
        if byte_val < 0:
            break
        dest[total] = cast[uint8](byte_val)
        total = total + 1

    return total

# Read a line (up to newline, not including newline)
# Returns number of characters read, or -1 on EOF
def file_read_line(f: Ptr[uint8], dest: Ptr[uint8], max_len: int32) -> int32:
    count: int32 = 0

    while count < max_len - 1:
        byte_val: int32 = file_read_byte(f)
        if byte_val < 0:
            # EOF
            if count == 0:
                return -1
            break
        if byte_val == 10:
            # Newline
            break
        dest[count] = cast[uint8](byte_val)
        count = count + 1

    dest[count] = 0  # Null terminate
    return count

# Write a single byte
def file_write_byte(f: Ptr[uint8], byte_val: uint8) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    buffer: Ptr[uint8] = cast[Ptr[uint8]](f32[2])
    buf_pos: int32 = f32[3]
    buf_cap: int32 = f32[5]

    # Flush if buffer full
    if buf_pos >= buf_cap:
        flushed: int32 = file_flush(f)
        if flushed < 0:
            return flushed
        buf_pos = 0

    buffer[buf_pos] = byte_val
    f32[3] = buf_pos + 1
    return 1

# Write bytes from buffer
def file_write(f: Ptr[uint8], src: Ptr[uint8], count: int32) -> int32:
    i: int32 = 0
    while i < count:
        result: int32 = file_write_byte(f, src[i])
        if result < 0:
            return result
        i = i + 1
    return count

# Write null-terminated string
def file_write_str(f: Ptr[uint8], s: Ptr[uint8]) -> int32:
    count: int32 = 0
    while s[count] != 0:
        result: int32 = file_write_byte(f, s[count])
        if result < 0:
            return result
        count = count + 1
    return count

# Write string followed by newline
def file_write_line(f: Ptr[uint8], s: Ptr[uint8]) -> int32:
    count: int32 = file_write_str(f, s)
    if count < 0:
        return count
    result: int32 = file_write_byte(f, 10)
    if result < 0:
        return result
    return count + 1

# Check for EOF
def file_eof(f: Ptr[uint8]) -> bool:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    buf_pos: int32 = f32[3]
    buf_len: int32 = f32[4]

    if buf_pos < buf_len:
        return False

    # Try to fill buffer
    filled: int32 = file_fill_buffer(f)
    return filled <= 0

# Check for error
def file_error(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    return f32[6]

# Get file descriptor
def file_fd(f: Ptr[uint8]) -> int32:
    f32: Ptr[int32] = cast[Ptr[int32]](f)
    return f32[0]

# ============================================================================
# Standard I/O convenience functions
# ============================================================================

# Print to stdout
def print_str(s: Ptr[uint8]):
    i: int32 = 0
    while s[i] != 0:
        i = i + 1
    file_write_raw(STDOUT_FD, s, i)

# Print line to stdout
def print_line(s: Ptr[uint8]):
    print_str(s)
    newline: uint8 = 10
    file_write_raw(STDOUT_FD, addr(newline), 1)

# Print integer to stdout
def print_int(n: int32):
    num: int32 = n
    negative: int32 = 0

    if num < 0:
        negative = 1
        num = 0 - num
        minus: uint8 = 45
        file_write_raw(STDOUT_FD, addr(minus), 1)

    if num == 0:
        zero: uint8 = 48
        file_write_raw(STDOUT_FD, addr(zero), 1)
        return

    # Reverse digits
    reversed: int32 = 0
    digits: int32 = 0
    while num > 0:
        reversed = reversed * 10 + (num % 10)
        num = num / 10
        digits = digits + 1

    # Print digits
    while digits > 0:
        d: uint8 = cast[uint8](48 + (reversed % 10))
        file_write_raw(STDOUT_FD, addr(d), 1)
        reversed = reversed / 10
        digits = digits - 1

# Print to stderr
def eprint_str(s: Ptr[uint8]):
    i: int32 = 0
    while s[i] != 0:
        i = i + 1
    file_write_raw(STDERR_FD, s, i)

# Print line to stderr
def eprint_line(s: Ptr[uint8]):
    eprint_str(s)
    newline: uint8 = 10
    file_write_raw(STDERR_FD, addr(newline), 1)

# Read line from stdin (returns bytes read, -1 on EOF)
def input_line(buf: Ptr[uint8], max_len: int32) -> int32:
    count: int32 = 0
    while count < max_len - 1:
        byte_val: int32 = 0
        result: int32 = file_read_raw(STDIN_FD, cast[Ptr[uint8]](addr(byte_val)), 1)
        if result <= 0:
            if count == 0:
                return -1
            break
        if byte_val == 10:
            break
        buf[count] = cast[uint8](byte_val)
        count = count + 1
    buf[count] = 0
    return count

# ============================================================================
# File utilities
# ============================================================================

# Read entire file into buffer (caller must free)
# Returns bytes read, or negative on error
def read_file(path: Ptr[uint8], out_buf: Ptr[int32], out_size: Ptr[int32]) -> int32:
    # Open file
    fd: int32 = file_open_raw(path, O_RDONLY, 0)
    if fd < 0:
        return fd

    # Get file size by seeking to end
    size: int32 = file_seek_raw(fd, 0, SEEK_END)
    if size < 0:
        file_close_raw(fd)
        return size

    # Seek back to start
    file_seek_raw(fd, 0, SEEK_SET)

    # Allocate buffer
    buffer: Ptr[uint8] = io_alloc(size + 1)
    if cast[int32](buffer) == 0:
        file_close_raw(fd)
        return -1

    # Read file
    total: int32 = 0
    while total < size:
        chunk: int32 = file_read_raw(fd, cast[Ptr[uint8]](cast[int32](buffer) + total), size - total)
        if chunk <= 0:
            break
        total = total + chunk

    # Null terminate
    buffer[total] = 0

    file_close_raw(fd)

    out_buf[0] = cast[int32](buffer)
    out_size[0] = total
    return total

# Write buffer to file
def write_file(path: Ptr[uint8], data: Ptr[uint8], size: int32) -> int32:
    fd: int32 = file_open_raw(path, O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE_DEFAULT)
    if fd < 0:
        return fd

    total: int32 = 0
    while total < size:
        written: int32 = file_write_raw(fd, cast[Ptr[uint8]](cast[int32](data) + total), size - total)
        if written <= 0:
            file_close_raw(fd)
            return written
        total = total + written

    file_close_raw(fd)
    return total

# Check if file exists
def file_exists(path: Ptr[uint8]) -> bool:
    fd: int32 = file_open_raw(path, O_RDONLY, 0)
    if fd < 0:
        return False
    file_close_raw(fd)
    return True
