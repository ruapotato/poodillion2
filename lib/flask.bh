from lib.net import *
from lib.syscalls import *

MAX_ROUTES: Final[int32] = 32
MAX_PATH_LEN: Final[int32] = 128
REQUEST_BUF_SIZE: Final[int32] = 2048
RESPONSE_BUF_SIZE: Final[int32] = 4096
REQ_METHOD: Final[int32] = 0
REQ_PATH: Final[int32] = 4
REQ_CONTENT_LEN: Final[int32] = 132
REQ_BODY: Final[int32] = 136
REQ_SIZE: Final[int32] = 140
METHOD_GET: Final[int32] = 0
METHOD_POST: Final[int32] = 1
METHOD_PUT: Final[int32] = 2
METHOD_DELETE: Final[int32] = 3
RES_STATUS: Final[int32] = 0
RES_CONTENT_TYPE: Final[int32] = 4
RES_BODY_LEN: Final[int32] = 68
RES_BODY: Final[int32] = 72
RES_SIZE: Final[int32] = 76

# POST body and query parameter storage
MAX_PARAMS: Final[int32] = 32
MAX_PARAM_NAME: Final[int32] = 64
MAX_PARAM_VALUE: Final[int32] = 256
MAX_BODY_LEN: Final[int32] = 8192

# Cookie storage
MAX_COOKIES: Final[int32] = 16
MAX_COOKIE_NAME: Final[int32] = 64
MAX_COOKIE_VALUE: Final[int32] = 256

# Query parameters (from URL ?key=value&...)
query_keys: Array[2048, uint8]
query_values: Array[8192, uint8]
query_count: int32 = 0

# POST body parameters (from form data)
post_keys: Array[2048, uint8]
post_values: Array[8192, uint8]
post_count: int32 = 0

# Raw request body
request_body: Array[8192, uint8]
request_body_len: int32 = 0

# Cookie storage (incoming)
cookie_names: Array[1024, uint8]
cookie_values: Array[4096, uint8]
cookie_count: int32 = 0

# Outgoing cookies (to set)
set_cookie_names: Array[1024, uint8]
set_cookie_values: Array[4096, uint8]
set_cookie_count: int32 = 0

route_paths: Array[4096, uint8]

route_handlers: Array[32, int32]

route_methods: Array[32, int32]

route_count: int32 = 0

def route(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, METHOD_GET, handler)

def route_method(path: Ptr[uint8], method: int32, handler: Ptr[uint8]) -> int32:
    if (route_count >= MAX_ROUTES):
        return -1
    path_offset: int32 = (route_count * MAX_PATH_LEN)
    i: int32 = 0
    while ((path[i] != 0) and (i < (MAX_PATH_LEN - 1))):
        route_paths[(path_offset + i)] = path[i]
        i = (i + 1)
    route_paths[(path_offset + i)] = 0
    route_handlers[route_count] = cast[int32](handler)
    route_methods[route_count] = method
    print(Ptr[uint8]("[Flask] route "))
    print(path)
    print(Ptr[uint8](" -> "))
    print_int(cast[int32](handler))
    println(Ptr[uint8](""))
    route_count = (route_count + 1)
    return 0

def get(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, METHOD_GET, handler)

def post(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, METHOD_POST, handler)

def put(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, METHOD_PUT, handler)

def delete(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, METHOD_DELETE, handler)

def any(path: Ptr[uint8], handler: Ptr[uint8]) -> int32:
    return route_method(path, -1, handler)

# =============================================================================
# Query Parameter Parsing
# =============================================================================

def clear_query_params():
    query_count = 0

def parse_query_string(query_start: Ptr[uint8]):
    """Parse query string like 'key1=val1&key2=val2' into query_keys/query_values"""
    query_count = 0
    if query_start[0] == 0:
        return

    i: int32 = 0
    # Skip leading '?' if present
    if query_start[0] == 63:
        i = 1

    while query_start[i] != 0 and query_count < MAX_PARAMS:
        # Parse key
        key_offset: int32 = query_count * MAX_PARAM_NAME
        key_len: int32 = 0
        while query_start[i] != 0 and query_start[i] != 61 and query_start[i] != 38:
            if key_len < MAX_PARAM_NAME - 1:
                query_keys[key_offset + key_len] = query_start[i]
                key_len = key_len + 1
            i = i + 1
        query_keys[key_offset + key_len] = 0

        # Skip '='
        if query_start[i] == 61:
            i = i + 1

        # Parse value
        val_offset: int32 = query_count * MAX_PARAM_VALUE
        val_len: int32 = 0
        while query_start[i] != 0 and query_start[i] != 38:
            if val_len < MAX_PARAM_VALUE - 1:
                query_values[val_offset + val_len] = query_start[i]
                val_len = val_len + 1
            i = i + 1
        query_values[val_offset + val_len] = 0

        query_count = query_count + 1

        # Skip '&'
        if query_start[i] == 38:
            i = i + 1

def get_query_param(key: Ptr[uint8]) -> Ptr[uint8]:
    """Get query parameter value by key name"""
    i: int32 = 0
    while i < query_count:
        key_offset: int32 = i * MAX_PARAM_NAME
        if strcmp(key, addr(query_keys[key_offset])) == 0:
            val_offset: int32 = i * MAX_PARAM_VALUE
            return addr(query_values[val_offset])
        i = i + 1
    return cast[Ptr[uint8]](0)

# =============================================================================
# POST Body Parsing
# =============================================================================

def clear_post_params():
    post_count = 0
    request_body_len = 0

def find_body_start(request: Ptr[uint8]) -> int32:
    """Find the start of the request body (after \\r\\n\\r\\n)"""
    i: int32 = 0
    while request[i] != 0:
        if request[i] == 13 and request[i+1] == 10 and request[i+2] == 13 and request[i+3] == 10:
            return i + 4
        i = i + 1
    return -1

def get_content_length(request: Ptr[uint8]) -> int32:
    """Extract Content-Length header value from request"""
    i: int32 = 0
    target: Ptr[uint8] = Ptr[uint8]("Content-Length:")
    target_len: int32 = 15

    while request[i] != 0:
        # Check for header name (case-insensitive simplified)
        matched: int32 = 1
        j: int32 = 0
        while j < target_len:
            c1: int32 = cast[int32](request[i + j])
            c2: int32 = cast[int32](target[j])
            # Convert to lowercase
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1

        if matched == 1:
            # Found header, skip to value
            i = i + target_len
            # Skip whitespace
            while request[i] == 32 or request[i] == 9:
                i = i + 1
            # Parse number
            result: int32 = 0
            while request[i] >= 48 and request[i] <= 57:
                result = result * 10 + (cast[int32](request[i]) - 48)
                i = i + 1
            return result

        # Skip to next line
        while request[i] != 0 and request[i] != 10:
            i = i + 1
        if request[i] == 10:
            i = i + 1

    return 0

def parse_form_urlencoded(body: Ptr[uint8], body_len: int32):
    """Parse application/x-www-form-urlencoded body into post_keys/post_values"""
    post_count = 0
    if body_len <= 0:
        return

    i: int32 = 0
    while i < body_len and post_count < MAX_PARAMS:
        # Parse key
        key_offset: int32 = post_count * MAX_PARAM_NAME
        key_len: int32 = 0
        while i < body_len and body[i] != 61 and body[i] != 38:
            if key_len < MAX_PARAM_NAME - 1:
                # URL decode '+' to space
                if body[i] == 43:
                    post_keys[key_offset + key_len] = 32
                else:
                    post_keys[key_offset + key_len] = body[i]
                key_len = key_len + 1
            i = i + 1
        post_keys[key_offset + key_len] = 0

        # Skip '='
        if i < body_len and body[i] == 61:
            i = i + 1

        # Parse value
        val_offset: int32 = post_count * MAX_PARAM_VALUE
        val_len: int32 = 0
        while i < body_len and body[i] != 38:
            if val_len < MAX_PARAM_VALUE - 1:
                # URL decode '+' to space
                if body[i] == 43:
                    post_values[val_offset + val_len] = 32
                else:
                    post_values[val_offset + val_len] = body[i]
                val_len = val_len + 1
            i = i + 1
        post_values[val_offset + val_len] = 0

        post_count = post_count + 1

        # Skip '&'
        if i < body_len and body[i] == 38:
            i = i + 1

def parse_body(request: Ptr[uint8]):
    """Parse the request body based on Content-Type"""
    body_start: int32 = find_body_start(request)
    if body_start < 0:
        request_body_len = 0
        return

    content_len: int32 = get_content_length(request)
    if content_len <= 0:
        request_body_len = 0
        return

    # Copy body to storage
    if content_len > MAX_BODY_LEN:
        content_len = MAX_BODY_LEN

    body_ptr: Ptr[uint8] = addr(request[body_start])
    i: int32 = 0
    while i < content_len:
        request_body[i] = body_ptr[i]
        i = i + 1
    request_body[content_len] = 0
    request_body_len = content_len

    # Parse as form data (default for POST)
    parse_form_urlencoded(addr(request_body[0]), request_body_len)

def get_post_param(key: Ptr[uint8]) -> Ptr[uint8]:
    """Get POST parameter value by key name"""
    i: int32 = 0
    while i < post_count:
        key_offset: int32 = i * MAX_PARAM_NAME
        if strcmp(key, addr(post_keys[key_offset])) == 0:
            val_offset: int32 = i * MAX_PARAM_VALUE
            return addr(post_values[val_offset])
        i = i + 1
    return cast[Ptr[uint8]](0)

def get_body() -> Ptr[uint8]:
    """Get raw request body"""
    return addr(request_body[0])

def get_body_length() -> int32:
    """Get length of request body"""
    return request_body_len

# =============================================================================
# Cookie Support
# =============================================================================

def clear_cookies():
    cookie_count = 0
    set_cookie_count = 0

def parse_cookies(request: Ptr[uint8]):
    """Parse Cookie header from request"""
    cookie_count = 0

    # Find Cookie: header
    i: int32 = 0
    target: Ptr[uint8] = Ptr[uint8]("Cookie:")
    target_len: int32 = 7

    while request[i] != 0:
        # Check for header name
        matched: int32 = 1
        j: int32 = 0
        while j < target_len:
            c1: int32 = cast[int32](request[i + j])
            c2: int32 = cast[int32](target[j])
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1

        if matched == 1:
            # Found Cookie header
            i = i + target_len
            # Skip whitespace
            while request[i] == 32 or request[i] == 9:
                i = i + 1

            # Parse cookies: name=value; name2=value2
            while request[i] != 0 and request[i] != 13 and request[i] != 10 and cookie_count < MAX_COOKIES:
                # Skip whitespace
                while request[i] == 32 or request[i] == 9:
                    i = i + 1

                # Parse name
                name_offset: int32 = cookie_count * MAX_COOKIE_NAME
                name_len: int32 = 0
                while request[i] != 0 and request[i] != 61 and request[i] != 59 and request[i] != 13:
                    if name_len < MAX_COOKIE_NAME - 1:
                        cookie_names[name_offset + name_len] = request[i]
                        name_len = name_len + 1
                    i = i + 1
                cookie_names[name_offset + name_len] = 0

                # Skip '='
                if request[i] == 61:
                    i = i + 1

                # Parse value
                val_offset: int32 = cookie_count * MAX_COOKIE_VALUE
                val_len: int32 = 0
                while request[i] != 0 and request[i] != 59 and request[i] != 13 and request[i] != 10:
                    if val_len < MAX_COOKIE_VALUE - 1:
                        cookie_values[val_offset + val_len] = request[i]
                        val_len = val_len + 1
                    i = i + 1
                cookie_values[val_offset + val_len] = 0

                cookie_count = cookie_count + 1

                # Skip '; '
                if request[i] == 59:
                    i = i + 1
                    while request[i] == 32:
                        i = i + 1

            return

        # Skip to next line
        while request[i] != 0 and request[i] != 10:
            i = i + 1
        if request[i] == 10:
            i = i + 1

def get_cookie(name: Ptr[uint8]) -> Ptr[uint8]:
    """Get cookie value by name"""
    i: int32 = 0
    while i < cookie_count:
        name_offset: int32 = i * MAX_COOKIE_NAME
        if strcmp(name, addr(cookie_names[name_offset])) == 0:
            val_offset: int32 = i * MAX_COOKIE_VALUE
            return addr(cookie_values[val_offset])
        i = i + 1
    return cast[Ptr[uint8]](0)

def set_cookie(name: Ptr[uint8], value: Ptr[uint8]):
    """Queue a cookie to be sent in the response"""
    if set_cookie_count >= MAX_COOKIES:
        return

    name_offset: int32 = set_cookie_count * MAX_COOKIE_NAME
    val_offset: int32 = set_cookie_count * MAX_COOKIE_VALUE

    # Copy name
    i: int32 = 0
    while name[i] != 0 and i < MAX_COOKIE_NAME - 1:
        set_cookie_names[name_offset + i] = name[i]
        i = i + 1
    set_cookie_names[name_offset + i] = 0

    # Copy value
    i = 0
    while value[i] != 0 and i < MAX_COOKIE_VALUE - 1:
        set_cookie_values[val_offset + i] = value[i]
        i = i + 1
    set_cookie_values[val_offset + i] = 0

    set_cookie_count = set_cookie_count + 1

def delete_cookie(name: Ptr[uint8]):
    """Delete a cookie by setting its value to empty with max-age=0"""
    # We'll handle this in send_response by checking for empty value
    set_cookie(name, Ptr[uint8](""))

# =============================================================================
# Request Header Access
# =============================================================================

def get_header(request: Ptr[uint8], header_name: Ptr[uint8], value_buf: Ptr[uint8], max_len: int32) -> int32:
    """Get HTTP header value by name"""
    i: int32 = 0
    name_len: int32 = strlen(header_name)

    # Skip request line
    while request[i] != 0 and request[i] != 10:
        i = i + 1
    if request[i] == 10:
        i = i + 1

    # Search headers
    while request[i] != 0:
        # End of headers?
        if request[i] == 13 and request[i + 1] == 10:
            break
        if request[i] == 10:
            break

        # Compare header name (case-insensitive)
        matched: int32 = 1
        j: int32 = 0
        while j < name_len:
            c1: int32 = cast[int32](request[i + j])
            c2: int32 = cast[int32](header_name[j])
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1

        if matched == 1 and request[i + name_len] == 58:
            # Found header
            i = i + name_len + 1
            # Skip whitespace
            while request[i] == 32 or request[i] == 9:
                i = i + 1
            # Copy value
            val_len: int32 = 0
            while request[i] != 0 and request[i] != 13 and request[i] != 10 and val_len < max_len - 1:
                value_buf[val_len] = request[i]
                val_len = val_len + 1
                i = i + 1
            value_buf[val_len] = 0
            return val_len

        # Skip to next line
        while request[i] != 0 and request[i] != 10:
            i = i + 1
        if request[i] == 10:
            i = i + 1

    return -1

# =============================================================================
# Response Helpers
# =============================================================================

def html(sock: int32, content: Ptr[uint8]):
    send_response(sock, 200, Ptr[uint8]("text/html"), content)

def text(sock: int32, content: Ptr[uint8]):
    send_response(sock, 200, Ptr[uint8]("text/plain"), content)

def json(sock: int32, content: Ptr[uint8]):
    send_response(sock, 200, Ptr[uint8]("application/json"), content)

def respond(sock: int32, status: int32, content: Ptr[uint8]):
    send_response(sock, status, Ptr[uint8]("text/html"), content)

def not_found(sock: int32):
    send_response(sock, 404, Ptr[uint8]("text/html"), Ptr[uint8]("<html><body><h1>404 Not Found</h1></body></html>"))

def server_error(sock: int32):
    send_response(sock, 500, Ptr[uint8]("text/html"), Ptr[uint8]("<html><body><h1>500 Internal Server Error</h1></body></html>"))

def redirect(sock: int32, url: Ptr[uint8]):
    net_send_str(sock, Ptr[uint8]("HTTP/1.0 302 Found\n"))
    net_send_str(sock, Ptr[uint8]("Location: "))
    net_send_str(sock, url)
    net_send_str(sock, Ptr[uint8]("\n\n"))

def send_response(sock: int32, status: int32, content_type: Ptr[uint8], body: Ptr[uint8]):
    println(Ptr[uint8]("[Flask] send_response enter"))
    response: Array[4096, uint8]
    pos: int32 = 0
    src: Ptr[uint8]
    src = Ptr[uint8]("HTTP/1.0 ")
    i: int32 = 0
    while (src[i] != 0):
        response[pos] = src[i]
        pos = (pos + 1)
        i = (i + 1)
    status_buf: Array[16, uint8]
    itoa(status, addr(status_buf[0]))
    i = 0
    while (status_buf[i] != 0):
        response[pos] = status_buf[i]
        pos = (pos + 1)
        i = (i + 1)
    if (status == 200):
        src = Ptr[uint8](" OK\n")
    elif (status == 302):
        src = Ptr[uint8](" Found\n")
    elif (status == 404):
        src = Ptr[uint8](" Not Found\n")
    elif (status == 500):
        src = Ptr[uint8](" Internal Server Error\n")
    else:
        src = Ptr[uint8](" Unknown\n")
    i = 0
    while (src[i] != 0):
        response[pos] = src[i]
        pos = (pos + 1)
        i = (i + 1)
    src = Ptr[uint8]("Content-Type: ")
    i = 0
    while (src[i] != 0):
        response[pos] = src[i]
        pos = (pos + 1)
        i = (i + 1)
    i = 0
    while (content_type[i] != 0):
        response[pos] = content_type[i]
        pos = (pos + 1)
        i = (i + 1)
    response[pos] = 13
    pos = (pos + 1)
    response[pos] = 10
    pos = (pos + 1)
    body_len: int32 = strlen(body)
    src = Ptr[uint8]("Content-Length: ")
    i = 0
    while (src[i] != 0):
        response[pos] = src[i]
        pos = (pos + 1)
        i = (i + 1)
    len_buf: Array[16, uint8]
    itoa(body_len, addr(len_buf[0]))
    i = 0
    while (len_buf[i] != 0):
        response[pos] = len_buf[i]
        pos = (pos + 1)
        i = (i + 1)
    response[pos] = 13
    pos = (pos + 1)
    response[pos] = 10
    pos = (pos + 1)
    src = Ptr[uint8]("Connection: close\r\n")
    i = 0
    while (src[i] != 0):
        response[pos] = src[i]
        pos = (pos + 1)
        i = (i + 1)

    # Add Set-Cookie headers
    cookie_idx: int32 = 0
    while cookie_idx < set_cookie_count:
        name_offset: int32 = cookie_idx * MAX_COOKIE_NAME
        val_offset: int32 = cookie_idx * MAX_COOKIE_VALUE

        src = Ptr[uint8]("Set-Cookie: ")
        i = 0
        while (src[i] != 0):
            response[pos] = src[i]
            pos = (pos + 1)
            i = (i + 1)

        # Cookie name
        i = 0
        while set_cookie_names[name_offset + i] != 0:
            response[pos] = set_cookie_names[name_offset + i]
            pos = (pos + 1)
            i = (i + 1)

        response[pos] = 61  # '='
        pos = (pos + 1)

        # Cookie value
        i = 0
        while set_cookie_values[val_offset + i] != 0:
            response[pos] = set_cookie_values[val_offset + i]
            pos = (pos + 1)
            i = (i + 1)

        # Add Path=/
        src = Ptr[uint8]("; Path=/")
        i = 0
        while (src[i] != 0):
            response[pos] = src[i]
            pos = (pos + 1)
            i = (i + 1)

        # If value is empty, set Max-Age=0 to delete
        if set_cookie_values[val_offset] == 0:
            src = Ptr[uint8]("; Max-Age=0")
            i = 0
            while (src[i] != 0):
                response[pos] = src[i]
                pos = (pos + 1)
                i = (i + 1)

        response[pos] = 13
        pos = (pos + 1)
        response[pos] = 10
        pos = (pos + 1)

        cookie_idx = cookie_idx + 1

    # Clear set cookies for next request
    set_cookie_count = 0

    # End headers
    response[pos] = 13
    pos = (pos + 1)
    response[pos] = 10
    pos = (pos + 1)
    i = 0
    while (i < body_len):
        response[pos] = body[i]
        pos = (pos + 1)
        i = (i + 1)
    println(Ptr[uint8]("[Flask] sending response"))
    print(Ptr[uint8]("[Flask] response size="))
    print_int(pos)
    println(Ptr[uint8](""))
    net_send(sock, addr(response[0]), pos)
    println(Ptr[uint8]("[Flask] send done"))

def parse_method(request: Ptr[uint8]) -> int32:
    if (((request[0] == 71) and (request[1] == 69)) and (request[2] == 84)):
        return METHOD_GET
    if ((((request[0] == 80) and (request[1] == 79)) and (request[2] == 83)) and (request[3] == 84)):
        return METHOD_POST
    if (((request[0] == 80) and (request[1] == 85)) and (request[2] == 84)):
        return METHOD_PUT
    if (((request[0] == 68) and (request[1] == 69)) and (request[2] == 76)):
        return METHOD_DELETE
    return -1

def parse_path(request: Ptr[uint8], path_buf: Ptr[uint8], max_len: int32) -> int32:
    i: int32 = 0
    while ((request[i] != 0) and (request[i] != 32)):
        i = (i + 1)
    if (request[i] == 0):
        return -1
    i = (i + 1)
    path_len: int32 = 0
    while ((((request[i] != 0) and (request[i] != 32)) and (request[i] != 63)) and (path_len < (max_len - 1))):
        path_buf[path_len] = request[i]
        path_len = (path_len + 1)
        i = (i + 1)
    path_buf[path_len] = 0

    # Parse query string if present
    if request[i] == 63:
        parse_query_string(addr(request[i]))
    else:
        clear_query_params()

    return path_len

def find_route(path: Ptr[uint8], method: int32) -> int32:
    i: int32 = 0
    while (i < route_count):
        route_path: Ptr[uint8] = addr(route_paths[(i * MAX_PATH_LEN)])
        if (strcmp(path, route_path) == 0):
            if ((route_methods[i] == -1) or (route_methods[i] == method)):
                return i
        i = (i + 1)
    return -1

def run(port: int32) -> int32:
    sock: int32 = net_listen(port)
    if (sock < 0):
        return -1
    print(Ptr[uint8](" * Running on http://0.0.0.0:"))
    print_int(port)
    println(Ptr[uint8]("/"))
    request_buf: Array[16384, uint8]
    path_buf: Array[128, uint8]
    while 1:
        net_poll()
        if (net_accept_ready(sock) == 1):
            println(Ptr[uint8]("[Flask] accept ready"))
            n: int32 = net_recv_blocking(sock, addr(request_buf[0]), 16383, 2000)
            print(Ptr[uint8]("[Flask] recv n="))
            print_int(n)
            println(Ptr[uint8](""))
            if (n > 0):
                request_buf[n] = 0
                method: int32 = parse_method(addr(request_buf[0]))

                # Parse path (also parses query string)
                parse_path(addr(request_buf[0]), addr(path_buf[0]), 128)

                # Parse cookies from request
                parse_cookies(addr(request_buf[0]))

                # Parse POST body if present
                if method == METHOD_POST or method == METHOD_PUT:
                    parse_body(addr(request_buf[0]))
                else:
                    clear_post_params()

                print(Ptr[uint8]("[Flask] method="))
                print_int(method)
                print(Ptr[uint8](" path="))
                println(addr(path_buf[0]))
                route_idx: int32 = find_route(addr(path_buf[0]), method)
                print(Ptr[uint8]("[Flask] route_idx="))
                print_int(route_idx)
                println(Ptr[uint8](""))
                if (route_idx >= 0):
                    handler: Ptr[uint8] = Ptr[uint8](route_handlers[route_idx])
                    print(Ptr[uint8]("[Flask] handler addr="))
                    print_int(cast[int32](handler))
                    println(Ptr[uint8](""))
                    call_handler(handler, sock, addr(request_buf[0]), addr(path_buf[0]))
                    println(Ptr[uint8]("[Flask] handler returned"))
                else:
                    println(Ptr[uint8]("[Flask] 404"))
                    not_found(sock)
            net_close(sock)
            sock = net_listen(port)
            if (sock < 0):
                return -1
    return 0

extern def call_handler(handler: Ptr[uint8], sock: int32, request: Ptr[uint8], path: Ptr[uint8])

def run_debug(port: int32) -> int32:
    sock: int32 = net_listen(port)
    if (sock < 0):
        println(Ptr[uint8](" * ERROR: Failed to bind to port"))
        return -1
    print(Ptr[uint8](" * Debug mode: on"))
    println(Ptr[uint8](""))
    print(Ptr[uint8](" * Running on http://0.0.0.0:"))
    print_int(port)
    println(Ptr[uint8]("/"))
    print(Ptr[uint8](" * Registered "))
    print_int(route_count)
    println(Ptr[uint8](" routes"))
    request_buf: Array[16384, uint8]
    path_buf: Array[128, uint8]
    while 1:
        net_poll()
        if (net_accept_ready(sock) == 1):
            n: int32 = net_recv_blocking(sock, addr(request_buf[0]), 16383, 2000)
            if (n > 0):
                request_buf[n] = 0
                method: int32 = parse_method(addr(request_buf[0]))

                # Parse path (also parses query string)
                parse_path(addr(request_buf[0]), addr(path_buf[0]), 128)

                # Parse cookies from request
                parse_cookies(addr(request_buf[0]))

                # Parse POST body if present
                if method == METHOD_POST or method == METHOD_PUT:
                    parse_body(addr(request_buf[0]))
                else:
                    clear_post_params()

                if (method == METHOD_GET):
                    print(Ptr[uint8](" * GET "))
                elif (method == METHOD_POST):
                    print(Ptr[uint8](" * POST "))
                elif (method == METHOD_PUT):
                    print(Ptr[uint8](" * PUT "))
                elif (method == METHOD_DELETE):
                    print(Ptr[uint8](" * DELETE "))
                else:
                    print(Ptr[uint8](" * ??? "))
                println(addr(path_buf[0]))
                route_idx: int32 = find_route(addr(path_buf[0]), method)
                if (route_idx >= 0):
                    handler: Ptr[uint8] = Ptr[uint8](route_handlers[route_idx])
                    call_handler(handler, sock, addr(request_buf[0]), addr(path_buf[0]))
                else:
                    println(Ptr[uint8]("   -> 404 Not Found"))
                    not_found(sock)
            net_close(sock)
            sock = net_listen(port)
            if (sock < 0):
                return -1
    return 0