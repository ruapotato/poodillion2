# BrainhairOS HTTPS Client Library
# Provides HTTPS client functionality using TLS 1.3

from lib.tls13 import *
from lib.dns import *

# Response storage
HTTPS_MAX_RESPONSE: Final[int32] = 32768

https_response_buf: Array[32768, uint8]
https_response_len: int32 = 0
https_status_code: int32 = 0

# =============================================================================
# HTTPS GET Request
# =============================================================================

def https_get(host: Ptr[uint8], path: Ptr[uint8]) -> int32:
    """
    Perform HTTPS GET request.
    
    host: hostname (e.g., "example.com")
    path: URL path (e.g., "/api/data")
    
    Returns: HTTP status code, or -1 on error
    Response body available via https_get_response()
    """
    https_response_len = 0
    https_status_code = 0

    # Resolve hostname
    ip: Array[4, uint8]
    if dns_lookup(host, addr(ip[0])) < 0:
        return -1

    # Use tls_https_get from TLS library
    result: int32 = tls_https_get(host, 443, path,
                                   addr(https_response_buf[0]),
                                   HTTPS_MAX_RESPONSE)

    if result < 0:
        return -1

    https_response_len = result

    # Parse status code from response
    https_status_code = https_parse_status(addr(https_response_buf[0]))

    return https_status_code

def https_get_port(host: Ptr[uint8], port: int32, path: Ptr[uint8]) -> int32:
    """
    Perform HTTPS GET request on custom port.
    
    host: hostname
    port: port number
    path: URL path
    
    Returns: HTTP status code, or -1 on error
    """
    https_response_len = 0
    https_status_code = 0

    result: int32 = tls_https_get(host, port, path,
                                   addr(https_response_buf[0]),
                                   HTTPS_MAX_RESPONSE)

    if result < 0:
        return -1

    https_response_len = result
    https_status_code = https_parse_status(addr(https_response_buf[0]))

    return https_status_code

# =============================================================================
# Response Accessors
# =============================================================================

def https_get_response() -> Ptr[uint8]:
    """Get the response body from the last request"""
    # Find end of headers
    i: int32 = 0
    while i < https_response_len - 3:
        if https_response_buf[i] == 13 and https_response_buf[i+1] == 10 and https_response_buf[i+2] == 13 and https_response_buf[i+3] == 10:
            return addr(https_response_buf[i + 4])
        i = i + 1
    return addr(https_response_buf[0])

def https_get_response_len() -> int32:
    """Get the length of response body"""
    # Find body start
    i: int32 = 0
    while i < https_response_len - 3:
        if https_response_buf[i] == 13 and https_response_buf[i+1] == 10 and https_response_buf[i+2] == 13 and https_response_buf[i+3] == 10:
            return https_response_len - i - 4
        i = i + 1
    return https_response_len

def https_get_raw_response() -> Ptr[uint8]:
    """Get the full raw response (headers + body)"""
    return addr(https_response_buf[0])

def https_get_raw_response_len() -> int32:
    """Get the full raw response length"""
    return https_response_len

def https_get_status() -> int32:
    """Get the HTTP status code from the last request"""
    return https_status_code

# =============================================================================
# Header Parsing
# =============================================================================

def https_parse_status(response: Ptr[uint8]) -> int32:
    """Parse HTTP status code from response"""
    # Skip "HTTP/1.x "
    i: int32 = 0
    while response[i] != 0 and response[i] != 32:
        i = i + 1
    if response[i] == 0:
        return -1
    i = i + 1

    # Parse 3-digit status code
    status: int32 = 0
    digits: int32 = 0
    while digits < 3 and response[i] >= 48 and response[i] <= 57:
        status = status * 10 + (cast[int32](response[i]) - 48)
        i = i + 1
        digits = digits + 1

    if digits != 3:
        return -1

    return status

def https_get_header(name: Ptr[uint8], value_buf: Ptr[uint8], max_len: int32) -> int32:
    """Get a header value from the response"""
    i: int32 = 0
    name_len: int32 = strlen(name)

    # Skip status line
    while https_response_buf[i] != 0 and https_response_buf[i] != 10:
        i = i + 1
    if https_response_buf[i] == 10:
        i = i + 1

    # Search headers
    while i < https_response_len:
        # End of headers?
        if https_response_buf[i] == 13 and https_response_buf[i+1] == 10:
            break
        if https_response_buf[i] == 10:
            break

        # Compare header name (case-insensitive)
        matched: int32 = 1
        j: int32 = 0
        while j < name_len:
            c1: int32 = cast[int32](https_response_buf[i + j])
            c2: int32 = cast[int32](name[j])
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1

        if matched == 1 and https_response_buf[i + name_len] == 58:  # ':'
            i = i + name_len + 1
            # Skip whitespace
            while https_response_buf[i] == 32 or https_response_buf[i] == 9:
                i = i + 1
            # Copy value
            val_len: int32 = 0
            while https_response_buf[i] != 0 and https_response_buf[i] != 13 and https_response_buf[i] != 10 and val_len < max_len - 1:
                value_buf[val_len] = https_response_buf[i]
                val_len = val_len + 1
                i = i + 1
            value_buf[val_len] = 0
            return val_len

        # Skip to next line
        while https_response_buf[i] != 0 and https_response_buf[i] != 10:
            i = i + 1
        if https_response_buf[i] == 10:
            i = i + 1

    return -1

# =============================================================================
# URL-based Requests
# =============================================================================

def https_fetch(url: Ptr[uint8]) -> int32:
    """
    Fetch content from HTTPS URL.
    
    url: full HTTPS URL (e.g., "https://example.com/api/data")
    
    Returns: HTTP status code, or -1 on error
    """
    # Parse URL
    i: int32 = 0

    # Skip "https://"
    if url[0] == 104 and url[1] == 116 and url[2] == 116 and url[3] == 112 and url[4] == 115:
        i = 8  # skip "https://"

    # Extract host
    host: Array[128, uint8]
    host_len: int32 = 0
    port: int32 = 443

    while url[i] != 0 and url[i] != 47 and url[i] != 58 and host_len < 127:
        host[host_len] = url[i]
        host_len = host_len + 1
        i = i + 1
    host[host_len] = 0

    # Check for port
    if url[i] == 58:  # ':'
        i = i + 1
        port = 0
        while url[i] >= 48 and url[i] <= 57:
            port = port * 10 + (cast[int32](url[i]) - 48)
            i = i + 1

    # Extract path
    path: Array[256, uint8]
    path_len: int32 = 0

    if url[i] == 47:  # '/'
        while url[i] != 0 and path_len < 255:
            path[path_len] = url[i]
            path_len = path_len + 1
            i = i + 1
    else:
        path[0] = 47  # '/'
        path_len = 1
    path[path_len] = 0

    return https_get_port(addr(host[0]), port, addr(path[0]))
