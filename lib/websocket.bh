# BrainhairOS WebSocket Library
# Provides WebSocket client and server functionality (RFC 6455)

from lib.syscalls import *
from lib.net import *
from lib.sha1 import *
from lib.base64 import *
from lib.random import *
from lib.dns import *

# WebSocket opcodes
WS_OPCODE_CONTINUATION: Final[int32] = 0
WS_OPCODE_TEXT: Final[int32] = 1
WS_OPCODE_BINARY: Final[int32] = 2
WS_OPCODE_CLOSE: Final[int32] = 8
WS_OPCODE_PING: Final[int32] = 9
WS_OPCODE_PONG: Final[int32] = 10

# WebSocket states
WS_STATE_CONNECTING: Final[int32] = 0
WS_STATE_OPEN: Final[int32] = 1
WS_STATE_CLOSING: Final[int32] = 2
WS_STATE_CLOSED: Final[int32] = 3

# WebSocket magic GUID for handshake
WS_GUID: Ptr[uint8] = Ptr[uint8]("258EAFA5-E914-47DA-95CA-C5AB0DC85B11")

# Buffer sizes
WS_MAX_PAYLOAD: Final[int32] = 65535
WS_HEADER_SIZE: Final[int32] = 14

# WebSocket connection state
class WebSocketConn:
    socket_id: int32
    state: int32
    is_client: int32  # 1 if client, 0 if server

# Frame buffers
ws_send_buf: Array[65549, uint8]
ws_recv_buf: Array[65549, uint8]
ws_mask_key: Array[4, uint8]

# =============================================================================
# WebSocket Handshake (Server)
# =============================================================================

def ws_generate_accept_key(client_key: Ptr[uint8], accept_key: Ptr[uint8]):
    """Generate Sec-WebSocket-Accept from Sec-WebSocket-Key"""
    # Concatenate client key with magic GUID
    combined: Array[128, uint8]
    i: int32 = 0
    j: int32 = 0

    # Copy client key
    while client_key[i] != 0 and i < 64:
        combined[i] = client_key[i]
        i = i + 1

    # Append GUID
    while WS_GUID[j] != 0 and i < 127:
        combined[i] = WS_GUID[j]
        i = i + 1
        j = j + 1
    combined[i] = 0

    # SHA-1 hash
    hash: Array[20, uint8]
    sha1(addr(combined[0]), i, addr(hash[0]))

    # Base64 encode
    base64_encode(addr(hash[0]), 20, accept_key)

def ws_parse_handshake_key(request: Ptr[uint8], key_buf: Ptr[uint8], max_len: int32) -> int32:
    """Extract Sec-WebSocket-Key from HTTP request"""
    target: Ptr[uint8] = Ptr[uint8]("Sec-WebSocket-Key:")
    target_len: int32 = 18
    i: int32 = 0

    while request[i] != 0:
        # Check for header match (case-insensitive)
        matched: int32 = 1
        j: int32 = 0
        while j < target_len:
            c1: int32 = cast[int32](request[i + j])
            c2: int32 = cast[int32](target[j])
            if c1 >= 65 and c1 <= 90:
                c1 = c1 + 32
            if c2 >= 65 and c2 <= 90:
                c2 = c2 + 32
            if c1 != c2:
                matched = 0
                break
            j = j + 1

        if matched == 1:
            # Found header
            i = i + target_len
            # Skip whitespace
            while request[i] == 32 or request[i] == 9:
                i = i + 1
            # Copy key
            key_len: int32 = 0
            while request[i] != 0 and request[i] != 13 and request[i] != 10 and key_len < max_len - 1:
                key_buf[key_len] = request[i]
                key_len = key_len + 1
                i = i + 1
            key_buf[key_len] = 0
            return key_len

        # Skip to next line
        while request[i] != 0 and request[i] != 10:
            i = i + 1
        if request[i] == 10:
            i = i + 1

    return -1

def ws_accept(sock: int32, request: Ptr[uint8]) -> int32:
    """Accept WebSocket upgrade request (server-side)"""
    # Parse Sec-WebSocket-Key
    client_key: Array[64, uint8]
    if ws_parse_handshake_key(request, addr(client_key[0]), 64) < 0:
        return -1

    # Generate accept key
    accept_key: Array[64, uint8]
    ws_generate_accept_key(addr(client_key[0]), addr(accept_key[0]))

    # Send upgrade response
    net_send_str(sock, Ptr[uint8]("HTTP/1.1 101 Switching Protocols\r\n"))
    net_send_str(sock, Ptr[uint8]("Upgrade: websocket\r\n"))
    net_send_str(sock, Ptr[uint8]("Connection: Upgrade\r\n"))
    net_send_str(sock, Ptr[uint8]("Sec-WebSocket-Accept: "))
    net_send_str(sock, addr(accept_key[0]))
    net_send_str(sock, Ptr[uint8]("\r\n\r\n"))

    return 0

# =============================================================================
# WebSocket Frame Handling
# =============================================================================

def ws_build_frame(opcode: int32, payload: Ptr[uint8], payload_len: int32,
                   mask: int32, output: Ptr[uint8]) -> int32:
    """Build a WebSocket frame"""
    pos: int32 = 0

    # First byte: FIN + opcode
    output[pos] = cast[uint8](0x80 | opcode)  # FIN=1
    pos = pos + 1

    # Second byte: MASK + payload length
    mask_bit: int32 = 0
    if mask != 0:
        mask_bit = 0x80

    if payload_len <= 125:
        output[pos] = cast[uint8](mask_bit | payload_len)
        pos = pos + 1
    elif payload_len <= 65535:
        output[pos] = cast[uint8](mask_bit | 126)
        pos = pos + 1
        output[pos] = cast[uint8]((payload_len >> 8) & 0xFF)
        pos = pos + 1
        output[pos] = cast[uint8](payload_len & 0xFF)
        pos = pos + 1
    else:
        # Extended payload length (not supported for simplicity)
        return -1

    # Masking key (for client->server messages)
    if mask != 0:
        # Generate random mask
        i: int32 = 0
        while i < 4:
            ws_mask_key[i] = cast[uint8](random_int() & 0xFF)
            output[pos] = ws_mask_key[i]
            pos = pos + 1
            i = i + 1

        # Masked payload
        i = 0
        while i < payload_len:
            output[pos] = payload[i] ^ ws_mask_key[i & 3]
            pos = pos + 1
            i = i + 1
    else:
        # Unmasked payload
        i: int32 = 0
        while i < payload_len:
            output[pos] = payload[i]
            pos = pos + 1
            i = i + 1

    return pos

def ws_parse_frame(input: Ptr[uint8], input_len: int32,
                   payload: Ptr[uint8], max_payload: int32) -> int32:
    """Parse a WebSocket frame, returns payload length or -1 on error"""
    if input_len < 2:
        return -1

    pos: int32 = 0

    # First byte: FIN + opcode
    fin: int32 = (cast[int32](input[pos]) >> 7) & 1
    opcode: int32 = cast[int32](input[pos]) & 0x0F
    pos = pos + 1

    # Second byte: MASK + payload length
    masked: int32 = (cast[int32](input[pos]) >> 7) & 1
    payload_len: int32 = cast[int32](input[pos]) & 0x7F
    pos = pos + 1

    # Extended payload length
    if payload_len == 126:
        if input_len < pos + 2:
            return -1
        payload_len = (cast[int32](input[pos]) << 8) | cast[int32](input[pos + 1])
        pos = pos + 2
    elif payload_len == 127:
        # 64-bit length not supported
        return -1

    # Masking key
    mask_key: Array[4, uint8]
    if masked == 1:
        if input_len < pos + 4:
            return -1
        mask_key[0] = input[pos]
        mask_key[1] = input[pos + 1]
        mask_key[2] = input[pos + 2]
        mask_key[3] = input[pos + 3]
        pos = pos + 4

    # Payload
    if payload_len > max_payload:
        payload_len = max_payload

    if input_len < pos + payload_len:
        return -1

    i: int32 = 0
    while i < payload_len:
        if masked == 1:
            payload[i] = input[pos + i] ^ mask_key[i & 3]
        else:
            payload[i] = input[pos + i]
        i = i + 1

    return payload_len

# =============================================================================
# WebSocket Send/Receive
# =============================================================================

def ws_send(sock: int32, is_client: int32, opcode: int32,
            payload: Ptr[uint8], payload_len: int32) -> int32:
    """Send a WebSocket frame"""
    # Clients must mask, servers must not
    mask: int32 = is_client

    frame_len: int32 = ws_build_frame(opcode, payload, payload_len, mask,
                                       addr(ws_send_buf[0]))
    if frame_len < 0:
        return -1

    return net_send(sock, addr(ws_send_buf[0]), frame_len)

def ws_send_text(sock: int32, is_client: int32, text: Ptr[uint8]) -> int32:
    """Send a text message"""
    text_len: int32 = strlen(text)
    return ws_send(sock, is_client, WS_OPCODE_TEXT, text, text_len)

def ws_send_binary(sock: int32, is_client: int32,
                   data: Ptr[uint8], len: int32) -> int32:
    """Send a binary message"""
    return ws_send(sock, is_client, WS_OPCODE_BINARY, data, len)

def ws_send_ping(sock: int32, is_client: int32) -> int32:
    """Send a ping frame"""
    empty: Array[1, uint8]
    empty[0] = 0
    return ws_send(sock, is_client, WS_OPCODE_PING, addr(empty[0]), 0)

def ws_send_pong(sock: int32, is_client: int32,
                 payload: Ptr[uint8], len: int32) -> int32:
    """Send a pong frame (response to ping)"""
    return ws_send(sock, is_client, WS_OPCODE_PONG, payload, len)

def ws_send_close(sock: int32, is_client: int32, code: int32) -> int32:
    """Send a close frame"""
    close_payload: Array[2, uint8]
    close_payload[0] = cast[uint8]((code >> 8) & 0xFF)
    close_payload[1] = cast[uint8](code & 0xFF)
    return ws_send(sock, is_client, WS_OPCODE_CLOSE, addr(close_payload[0]), 2)

def ws_recv(sock: int32, payload: Ptr[uint8], max_len: int32,
            opcode_out: Ptr[int32]) -> int32:
    """Receive a WebSocket frame
    
    Returns: payload length, or -1 on error
    opcode_out: receives the frame opcode
    """
    # Receive frame data
    n: int32 = net_recv_blocking(sock, addr(ws_recv_buf[0]), WS_MAX_PAYLOAD + WS_HEADER_SIZE, 5000)
    if n <= 0:
        return -1

    # Parse opcode
    opcode_out[0] = cast[int32](ws_recv_buf[0]) & 0x0F

    # Parse payload
    return ws_parse_frame(addr(ws_recv_buf[0]), n, payload, max_len)

# =============================================================================
# WebSocket Client Handshake
# =============================================================================

def ws_client_handshake(sock: int32, host: Ptr[uint8], path: Ptr[uint8]) -> int32:
    """Perform WebSocket client handshake"""
    # Generate random key
    key_bytes: Array[16, uint8]
    i: int32 = 0
    while i < 16:
        key_bytes[i] = cast[uint8](random_int() & 0xFF)
        i = i + 1

    # Base64 encode
    client_key: Array[32, uint8]
    base64_encode(addr(key_bytes[0]), 16, addr(client_key[0]))

    # Send handshake request
    net_send_str(sock, Ptr[uint8]("GET "))
    net_send_str(sock, path)
    net_send_str(sock, Ptr[uint8](" HTTP/1.1\r\n"))
    net_send_str(sock, Ptr[uint8]("Host: "))
    net_send_str(sock, host)
    net_send_str(sock, Ptr[uint8]("\r\n"))
    net_send_str(sock, Ptr[uint8]("Upgrade: websocket\r\n"))
    net_send_str(sock, Ptr[uint8]("Connection: Upgrade\r\n"))
    net_send_str(sock, Ptr[uint8]("Sec-WebSocket-Version: 13\r\n"))
    net_send_str(sock, Ptr[uint8]("Sec-WebSocket-Key: "))
    net_send_str(sock, addr(client_key[0]))
    net_send_str(sock, Ptr[uint8]("\r\n\r\n"))

    # Receive response
    response: Array[1024, uint8]
    n: int32 = net_recv_blocking(sock, addr(response[0]), 1023, 5000)
    if n <= 0:
        return -1
    response[n] = 0

    # Verify response (basic check for "101")
    if response[9] != 49 or response[10] != 48 or response[11] != 49:  # "101"
        return -1

    # TODO: Verify Sec-WebSocket-Accept matches expected value

    return 0

# =============================================================================
# Convenience Functions
# =============================================================================

def ws_connect(host: Ptr[uint8], port: int32, path: Ptr[uint8]) -> int32:
    """Connect to a WebSocket server
    
    Returns: socket ID on success, -1 on error
    """
    # Resolve hostname
    ip: Array[4, uint8]
    if dns_resolve(host, addr(ip[0])) < 0:
        return -1

    # Connect
    sock: int32 = net_connect(addr(ip[0]), port)
    if sock < 0:
        return -1

    # Wait for connection
    if net_wait_connected(sock, 5000) == 0:
        net_close(sock)
        return -1

    # Perform handshake
    if ws_client_handshake(sock, host, path) < 0:
        net_close(sock)
        return -1

    return sock
