# poly1305.bh - Poly1305 MAC in pure Brainhair
# Implements RFC 8439 Poly1305

# Constants
POLY1305_KEY_SIZE: Final[int32] = 32
POLY1305_TAG_SIZE: Final[int32] = 16
POLY1305_BLOCK_SIZE: Final[int32] = 16

# Poly1305 context - uses 5 limbs of 26 bits each for 130-bit arithmetic
class Poly1305Ctx:
    r: Array[5, uint32]      # Clamped r key in radix 2^26
    h: Array[5, uint32]      # Accumulator in radix 2^26
    pad: Array[4, uint32]    # s key (final pad)
    leftover: int32          # Remaining bytes in buffer
    buffer: Array[16, uint8] # Partial block buffer
    finalized: int32         # Flag for finalization

# Global context
g_poly_ctx: Poly1305Ctx

# Load 32-bit little-endian
def poly_load32_le(src: Ptr[uint8]) -> uint32:
    v: uint32 = cast[uint32](src[0])
    v = v | (cast[uint32](src[1]) << 8)
    v = v | (cast[uint32](src[2]) << 16)
    v = v | (cast[uint32](src[3]) << 24)
    return v

# Store 32-bit little-endian
def poly_store32_le(dst: Ptr[uint8], val: uint32):
    dst[0] = cast[uint8](val & cast[uint32](255))
    dst[1] = cast[uint8]((val >> 8) & cast[uint32](255))
    dst[2] = cast[uint8]((val >> 16) & cast[uint32](255))
    dst[3] = cast[uint8]((val >> 24) & cast[uint32](255))

# Initialize Poly1305 with 32-byte key
# Key format: r (16 bytes) || s (16 bytes)
def poly1305_init(key: Ptr[uint8]) -> int32:
    if key == cast[Ptr[uint8]](0):
        return -1

    # Load and clamp r
    # Clamping: clear bits 4,8,12,16 of each 32-bit word and top 4 bits
    t0: uint32 = poly_load32_le(key)
    t1: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 4))
    t2: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 8))
    t3: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 12))

    # Clamp r: AND with 0x0ffffffc0ffffffc0ffffffc0fffffff
    t0 = t0 & cast[uint32](0x0fffffff)
    t1 = t1 & cast[uint32](0x0ffffffc)
    t2 = t2 & cast[uint32](0x0ffffffc)
    t3 = t3 & cast[uint32](0x0ffffffc)

    # Convert to radix 2^26
    g_poly_ctx.r[0] = t0 & cast[uint32](0x3ffffff)
    g_poly_ctx.r[1] = ((t0 >> 26) | (t1 << 6)) & cast[uint32](0x3ffffff)
    g_poly_ctx.r[2] = ((t1 >> 20) | (t2 << 12)) & cast[uint32](0x3ffffff)
    g_poly_ctx.r[3] = ((t2 >> 14) | (t3 << 18)) & cast[uint32](0x3ffffff)
    g_poly_ctx.r[4] = (t3 >> 8) & cast[uint32](0x3ffffff)

    # Load s (pad)
    g_poly_ctx.pad[0] = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 16))
    g_poly_ctx.pad[1] = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 20))
    g_poly_ctx.pad[2] = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 24))
    g_poly_ctx.pad[3] = poly_load32_le(cast[Ptr[uint8]](cast[int32](key) + 28))

    # Initialize accumulator to 0
    g_poly_ctx.h[0] = cast[uint32](0)
    g_poly_ctx.h[1] = cast[uint32](0)
    g_poly_ctx.h[2] = cast[uint32](0)
    g_poly_ctx.h[3] = cast[uint32](0)
    g_poly_ctx.h[4] = cast[uint32](0)

    g_poly_ctx.leftover = 0
    g_poly_ctx.finalized = 0

    return 0

# Process one 16-byte block
def poly1305_block(block: Ptr[uint8], hibit: uint32):
    # Load block as 130-bit number in radix 2^26
    t0: uint32 = poly_load32_le(block)
    t1: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](block) + 4))
    t2: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](block) + 8))
    t3: uint32 = poly_load32_le(cast[Ptr[uint8]](cast[int32](block) + 12))

    h0: uint32 = g_poly_ctx.h[0] + (t0 & cast[uint32](0x3ffffff))
    h1: uint32 = g_poly_ctx.h[1] + (((t0 >> 26) | (t1 << 6)) & cast[uint32](0x3ffffff))
    h2: uint32 = g_poly_ctx.h[2] + (((t1 >> 20) | (t2 << 12)) & cast[uint32](0x3ffffff))
    h3: uint32 = g_poly_ctx.h[3] + (((t2 >> 14) | (t3 << 18)) & cast[uint32](0x3ffffff))
    h4: uint32 = g_poly_ctx.h[4] + ((t3 >> 8) | hibit)

    # Multiply h by r (with 5*r for reduction)
    r0: uint32 = g_poly_ctx.r[0]
    r1: uint32 = g_poly_ctx.r[1]
    r2: uint32 = g_poly_ctx.r[2]
    r3: uint32 = g_poly_ctx.r[3]
    r4: uint32 = g_poly_ctx.r[4]

    s1: uint32 = r1 * cast[uint32](5)
    s2: uint32 = r2 * cast[uint32](5)
    s3: uint32 = r3 * cast[uint32](5)
    s4: uint32 = r4 * cast[uint32](5)

    # Use 64-bit arithmetic for products (simulated with high/low)
    # d0 = h0*r0 + h1*s4 + h2*s3 + h3*s2 + h4*s1
    d0: uint64 = cast[uint64](h0) * cast[uint64](r0)
    d0 = d0 + (cast[uint64](h1) * cast[uint64](s4))
    d0 = d0 + (cast[uint64](h2) * cast[uint64](s3))
    d0 = d0 + (cast[uint64](h3) * cast[uint64](s2))
    d0 = d0 + (cast[uint64](h4) * cast[uint64](s1))

    # d1 = h0*r1 + h1*r0 + h2*s4 + h3*s3 + h4*s2
    d1: uint64 = cast[uint64](h0) * cast[uint64](r1)
    d1 = d1 + (cast[uint64](h1) * cast[uint64](r0))
    d1 = d1 + (cast[uint64](h2) * cast[uint64](s4))
    d1 = d1 + (cast[uint64](h3) * cast[uint64](s3))
    d1 = d1 + (cast[uint64](h4) * cast[uint64](s2))

    # d2 = h0*r2 + h1*r1 + h2*r0 + h3*s4 + h4*s3
    d2: uint64 = cast[uint64](h0) * cast[uint64](r2)
    d2 = d2 + (cast[uint64](h1) * cast[uint64](r1))
    d2 = d2 + (cast[uint64](h2) * cast[uint64](r0))
    d2 = d2 + (cast[uint64](h3) * cast[uint64](s4))
    d2 = d2 + (cast[uint64](h4) * cast[uint64](s3))

    # d3 = h0*r3 + h1*r2 + h2*r1 + h3*r0 + h4*s4
    d3: uint64 = cast[uint64](h0) * cast[uint64](r3)
    d3 = d3 + (cast[uint64](h1) * cast[uint64](r2))
    d3 = d3 + (cast[uint64](h2) * cast[uint64](r1))
    d3 = d3 + (cast[uint64](h3) * cast[uint64](r0))
    d3 = d3 + (cast[uint64](h4) * cast[uint64](s4))

    # d4 = h0*r4 + h1*r3 + h2*r2 + h3*r1 + h4*r0
    d4: uint64 = cast[uint64](h0) * cast[uint64](r4)
    d4 = d4 + (cast[uint64](h1) * cast[uint64](r3))
    d4 = d4 + (cast[uint64](h2) * cast[uint64](r2))
    d4 = d4 + (cast[uint64](h3) * cast[uint64](r1))
    d4 = d4 + (cast[uint64](h4) * cast[uint64](r0))

    # Carry propagation
    c: uint32 = cast[uint32](d0 >> 26)
    h0 = cast[uint32](d0) & cast[uint32](0x3ffffff)
    d1 = d1 + cast[uint64](c)

    c = cast[uint32](d1 >> 26)
    h1 = cast[uint32](d1) & cast[uint32](0x3ffffff)
    d2 = d2 + cast[uint64](c)

    c = cast[uint32](d2 >> 26)
    h2 = cast[uint32](d2) & cast[uint32](0x3ffffff)
    d3 = d3 + cast[uint64](c)

    c = cast[uint32](d3 >> 26)
    h3 = cast[uint32](d3) & cast[uint32](0x3ffffff)
    d4 = d4 + cast[uint64](c)

    c = cast[uint32](d4 >> 26)
    h4 = cast[uint32](d4) & cast[uint32](0x3ffffff)
    h0 = h0 + (c * cast[uint32](5))

    c = h0 >> 26
    h0 = h0 & cast[uint32](0x3ffffff)
    h1 = h1 + c

    # Store back
    g_poly_ctx.h[0] = h0
    g_poly_ctx.h[1] = h1
    g_poly_ctx.h[2] = h2
    g_poly_ctx.h[3] = h3
    g_poly_ctx.h[4] = h4

# Update with message data
def poly1305_update(msg: Ptr[uint8], length: int32):
    offset: int32 = 0

    # Handle leftover from previous call
    if g_poly_ctx.leftover > 0:
        want: int32 = 16 - g_poly_ctx.leftover
        if want > length:
            want = length
        i: int32 = 0
        while i < want:
            g_poly_ctx.buffer[g_poly_ctx.leftover + i] = msg[i]
            i = i + 1
        length = length - want
        offset = offset + want
        g_poly_ctx.leftover = g_poly_ctx.leftover + want
        if g_poly_ctx.leftover < 16:
            return
        poly1305_block(Ptr[uint8](addr(g_poly_ctx.buffer)), cast[uint32](1) << 24)
        g_poly_ctx.leftover = 0

    # Process full blocks
    while length >= 16:
        poly1305_block(cast[Ptr[uint8]](cast[int32](msg) + offset), cast[uint32](1) << 24)
        offset = offset + 16
        length = length - 16

    # Store leftover
    if length > 0:
        i: int32 = 0
        while i < length:
            g_poly_ctx.buffer[i] = msg[offset + i]
            i = i + 1
        g_poly_ctx.leftover = length

# Finalize and output tag
def poly1305_final(tag: Ptr[uint8]) -> int32:
    if tag == cast[Ptr[uint8]](0):
        return -1

    # Process remaining bytes with padding
    if g_poly_ctx.leftover > 0:
        g_poly_ctx.buffer[g_poly_ctx.leftover] = cast[uint8](1)
        i: int32 = g_poly_ctx.leftover + 1
        while i < 16:
            g_poly_ctx.buffer[i] = cast[uint8](0)
            i = i + 1
        poly1305_block(Ptr[uint8](addr(g_poly_ctx.buffer)), cast[uint32](0))

    # Final reduction
    h0: uint32 = g_poly_ctx.h[0]
    h1: uint32 = g_poly_ctx.h[1]
    h2: uint32 = g_poly_ctx.h[2]
    h3: uint32 = g_poly_ctx.h[3]
    h4: uint32 = g_poly_ctx.h[4]

    # Carry propagation
    c: uint32 = h1 >> 26
    h1 = h1 & cast[uint32](0x3ffffff)
    h2 = h2 + c

    c = h2 >> 26
    h2 = h2 & cast[uint32](0x3ffffff)
    h3 = h3 + c

    c = h3 >> 26
    h3 = h3 & cast[uint32](0x3ffffff)
    h4 = h4 + c

    c = h4 >> 26
    h4 = h4 & cast[uint32](0x3ffffff)
    h0 = h0 + (c * cast[uint32](5))

    c = h0 >> 26
    h0 = h0 & cast[uint32](0x3ffffff)
    h1 = h1 + c

    # Compute h - p
    g0: uint32 = h0 + cast[uint32](5)
    c = g0 >> 26
    g0 = g0 & cast[uint32](0x3ffffff)

    g1: uint32 = h1 + c
    c = g1 >> 26
    g1 = g1 & cast[uint32](0x3ffffff)

    g2: uint32 = h2 + c
    c = g2 >> 26
    g2 = g2 & cast[uint32](0x3ffffff)

    g3: uint32 = h3 + c
    c = g3 >> 26
    g3 = g3 & cast[uint32](0x3ffffff)

    g4: uint32 = (h4 + c) - (cast[uint32](1) << 26)

    # Select h if h < p, else h - p
    mask: uint32 = (g4 >> 31) - cast[uint32](1)
    g0 = g0 & mask
    g1 = g1 & mask
    g2 = g2 & mask
    g3 = g3 & mask
    g4 = g4 & mask
    mask = (cast[uint32](0) - cast[uint32](1)) ^ mask
    h0 = (h0 & mask) | g0
    h1 = (h1 & mask) | g1
    h2 = (h2 & mask) | g2
    h3 = (h3 & mask) | g3
    h4 = (h4 & mask) | g4

    # Convert to 128-bit and add s
    h0 = h0 | (h1 << 26)
    h1 = (h1 >> 6) | (h2 << 20)
    h2 = (h2 >> 12) | (h3 << 14)
    h3 = (h3 >> 18) | (h4 << 8)

    # Add s
    f: uint64 = cast[uint64](h0) + cast[uint64](g_poly_ctx.pad[0])
    h0 = cast[uint32](f)
    f = cast[uint64](h1) + cast[uint64](g_poly_ctx.pad[1]) + (f >> 32)
    h1 = cast[uint32](f)
    f = cast[uint64](h2) + cast[uint64](g_poly_ctx.pad[2]) + (f >> 32)
    h2 = cast[uint32](f)
    f = cast[uint64](h3) + cast[uint64](g_poly_ctx.pad[3]) + (f >> 32)
    h3 = cast[uint32](f)

    # Output tag
    poly_store32_le(tag, h0)
    poly_store32_le(cast[Ptr[uint8]](cast[int32](tag) + 4), h1)
    poly_store32_le(cast[Ptr[uint8]](cast[int32](tag) + 8), h2)
    poly_store32_le(cast[Ptr[uint8]](cast[int32](tag) + 12), h3)

    g_poly_ctx.finalized = 1
    return 0

# One-shot authentication
def poly1305_auth(tag: Ptr[uint8], msg: Ptr[uint8], length: int32, key: Ptr[uint8]) -> int32:
    result: int32 = poly1305_init(key)
    if result != 0:
        return result
    poly1305_update(msg, length)
    return poly1305_final(tag)

# Verify tag (constant-time comparison)
def poly1305_verify(tag1: Ptr[uint8], tag2: Ptr[uint8]) -> int32:
    diff: uint32 = cast[uint32](0)
    i: int32 = 0
    while i < 16:
        diff = diff | (cast[uint32](tag1[i]) ^ cast[uint32](tag2[i]))
        i = i + 1
    if diff == cast[uint32](0):
        return 1
    return 0
