# poly1305.bh - Poly1305 MAC Library for BrainhairOS
# Userland wrapper for Poly1305 message authentication code
# Implements Poly1305 as per RFC 8439
# Part of ChaCha20-Poly1305 AEAD cipher suite

# Poly1305 constants
POLY1305_KEY_SIZE: Final[int32] = 32   # 256-bit key (r||s)
POLY1305_TAG_SIZE: Final[int32] = 16   # 128-bit tag
POLY1305_BLOCK_SIZE: Final[int32] = 16 # 16-byte blocks

# External kernel functions from kernel/poly1305.asm
extern def poly1305_init(key: Ptr[uint8]) -> int32
extern def poly1305_update(msg: Ptr[uint8], length: int32)
extern def poly1305_final(tag: Ptr[uint8]) -> int32
extern def poly1305_auth(tag: Ptr[uint8], msg: Ptr[uint8], length: int32, key: Ptr[uint8]) -> int32

# External ChaCha20 functions for key generation
extern def chacha20_init(key: Ptr[uint8], nonce: Ptr[uint8], counter: int32)
extern def chacha20_block()
extern def chacha20_get_block() -> Ptr[uint8]

# ============================================================================
# Poly1305 Context Structure
# This is managed by the kernel, so we just need a placeholder
# The actual state is maintained in kernel BSS
# ============================================================================
class Poly1305Context:
    initialized: int32      # Flag to track if context is initialized

# ============================================================================
# poly1305_init_ctx - Initialize a Poly1305 context with key
# ctx: pointer to Poly1305 context
# key: pointer to 32-byte key (r||s format)
# Returns: 0 on success, -1 on error
#
# Key format:
#   Bytes 0-15:  r (multiplicand, will be clamped automatically)
#   Bytes 16-31: s (addend/nonce)
# ============================================================================
def poly1305_init_ctx(ctx: Ptr[Poly1305Context], key: Ptr[uint8]) -> int32:
    if ctx == cast[Ptr[Poly1305Context]](0):
        return -1

    if key == cast[Ptr[uint8]](0):
        return -1

    result: int32 = poly1305_init(key)
    if result == 0:
        ctx.initialized = 1

    return result

# ============================================================================
# poly1305_update_ctx - Add message data to context
# ctx: pointer to Poly1305 context
# msg: pointer to message data
# length: length of message data
# Returns: 0 on success, -1 on error
#
# Can be called multiple times to process message in chunks
# ============================================================================
def poly1305_update_ctx(ctx: Ptr[Poly1305Context], msg: Ptr[uint8], length: int32) -> int32:
    if ctx == cast[Ptr[Poly1305Context]](0):
        return -1

    if ctx.initialized != 1:
        return -1

    if msg == cast[Ptr[uint8]](0) and length > 0:
        return -1

    if length <= 0:
        return 0

    poly1305_update(msg, length)
    return 0

# ============================================================================
# poly1305_final_ctx - Finalize computation and output tag
# ctx: pointer to Poly1305 context
# tag: pointer to 16-byte output buffer for tag
# Returns: 0 on success, -1 on error
#
# After calling this, the context is invalidated
# ============================================================================
def poly1305_final_ctx(ctx: Ptr[Poly1305Context], tag: Ptr[uint8]) -> int32:
    if ctx == cast[Ptr[Poly1305Context]](0):
        return -1

    if ctx.initialized != 1:
        return -1

    if tag == cast[Ptr[uint8]](0):
        return -1

    result: int32 = poly1305_final(tag)
    ctx.initialized = 0
    return result

# ============================================================================
# poly1305_mac - One-shot MAC computation (convenience function)
# msg: pointer to message to authenticate
# length: length of message
# key: pointer to 32-byte key
# tag: pointer to 16-byte output buffer for tag
# Returns: 0 on success, -1 on error
#
# Example:
#   msg: Ptr[uint8] = cast[Ptr[uint8]]("Hello, World!")
#   key: Array[32, uint8]
#   tag: Array[16, uint8]
#   # ... initialize key ...
#   poly1305_mac(msg, 13, addr(key[0]), addr(tag[0]))
# ============================================================================
def poly1305_mac(msg: Ptr[uint8], length: int32, key: Ptr[uint8], tag: Ptr[uint8]) -> int32:
    return poly1305_auth(tag, msg, length, key)

# ============================================================================
# poly1305_verify - Verify a Poly1305 MAC tag
# msg: pointer to message
# length: length of message
# key: pointer to 32-byte key
# tag: pointer to 16-byte tag to verify
# Returns: 1 if tag is valid, 0 if invalid, -1 on error
#
# Uses constant-time comparison to prevent timing attacks
# ============================================================================
def poly1305_verify(msg: Ptr[uint8], length: int32, key: Ptr[uint8], tag: Ptr[uint8]) -> int32:
    if msg == cast[Ptr[uint8]](0) or key == cast[Ptr[uint8]](0) or tag == cast[Ptr[uint8]](0):
        return -1

    # Compute expected tag
    computed_tag: Array[16, uint8]
    result: int32 = poly1305_auth(addr(computed_tag[0]), msg, length, key)
    if result != 0:
        return -1

    # Constant-time comparison
    diff: int32 = 0
    i: int32 = 0
    while i < POLY1305_TAG_SIZE:
        diff = diff | (cast[int32](computed_tag[i]) ^ cast[int32](tag[i]))
        i = i + 1

    # Return 1 if tags match (diff == 0), 0 otherwise
    if diff == 0:
        return 1
    else:
        return 0

# ============================================================================
# poly1305_key_gen - Generate Poly1305 key from ChaCha20
# chacha_key: pointer to 32-byte ChaCha20 key
# nonce: pointer to 12-byte nonce
# poly_key: pointer to 32-byte output buffer for Poly1305 key
# Returns: 0 on success, -1 on error
#
# This implements the Poly1305 key generation from ChaCha20 as specified
# in RFC 8439 for the AEAD construction
# Uses ChaCha20 with counter=0 to generate the Poly1305 key
# ============================================================================
def poly1305_key_gen(chacha_key: Ptr[uint8], nonce: Ptr[uint8], poly_key: Ptr[uint8]) -> int32:
    if chacha_key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or poly_key == cast[Ptr[uint8]](0):
        return -1

    # Initialize ChaCha20 with counter=0
    chacha20_init(chacha_key, nonce, 0)

    # Generate one block (64 bytes) and take first 32 bytes as Poly1305 key
    chacha20_block()
    keystream: Ptr[uint8] = chacha20_get_block()

    # Copy first 32 bytes to output
    i: int32 = 0
    while i < POLY1305_KEY_SIZE:
        poly_key[i] = keystream[i]
        i = i + 1

    return 0

# ============================================================================
# poly1305_tag_to_hex - Convert Poly1305 tag to hexadecimal string
# tag: pointer to 16-byte tag
# output: pointer to 33-byte output buffer (32 hex chars + null terminator)
#
# Example:
#   tag: Array[16, uint8]
#   hex: Array[33, uint8]
#   poly1305_tag_to_hex(addr(tag[0]), addr(hex[0]))
# ============================================================================
def poly1305_tag_to_hex(tag: Ptr[uint8], output: Ptr[uint8]):
    if tag == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return

    hexchars: Ptr[uint8] = cast[Ptr[uint8]]("0123456789abcdef")
    i: int32 = 0
    pos: int32 = 0

    while i < POLY1305_TAG_SIZE:
        byte: int32 = cast[int32](tag[i])
        output[pos] = hexchars[(byte >> 4) & 15]
        pos = pos + 1
        output[pos] = hexchars[byte & 15]
        pos = pos + 1
        i = i + 1

    output[32] = cast[uint8](0)  # Null terminator

# ============================================================================
# poly1305_compare_tags - Compare two Poly1305 tags for equality
# tag1: pointer to first 16-byte tag
# tag2: pointer to second 16-byte tag
# Returns: 1 if equal, 0 if not equal
#
# Uses constant-time comparison to prevent timing attacks
# ============================================================================
def poly1305_compare_tags(tag1: Ptr[uint8], tag2: Ptr[uint8]) -> int32:
    if tag1 == cast[Ptr[uint8]](0) or tag2 == cast[Ptr[uint8]](0):
        return 0

    diff: int32 = 0
    i: int32 = 0
    while i < POLY1305_TAG_SIZE:
        diff = diff | (cast[int32](tag1[i]) ^ cast[int32](tag2[i]))
        i = i + 1

    if diff == 0:
        return 1
    else:
        return 0
