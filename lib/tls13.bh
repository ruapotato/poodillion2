# tls13.bh - TLS 1.3 Implementation for BrainhairOS
# Implements TLS 1.3 (RFC 8446) for secure communications
#
# This library provides:
# - TLS 1.3 handshake (ClientHello, ServerHello, etc.)
# - Key derivation using HKDF
# - Record layer encryption with ChaCha20-Poly1305
# - Session management
#
# Supported cipher suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)

import "lib/syscalls"
import "lib/sha256"
import "lib/x25519"
import "lib/chacha20"
import "lib/poly1305"
import "lib/aead"
import "lib/random"
import "lib/net"

# ===========================================================================
# TLS 1.3 Constants
# ===========================================================================

# TLS versions
const TLS_VERSION_12: int32 = 0x0303      # TLS 1.2 (for compatibility)
const TLS_VERSION_13: int32 = 0x0304      # TLS 1.3

# Content types
const TLS_CONTENT_CHANGE_CIPHER: int32 = 20
const TLS_CONTENT_ALERT: int32 = 21
const TLS_CONTENT_HANDSHAKE: int32 = 22
const TLS_CONTENT_APPLICATION: int32 = 23

# Handshake types
const TLS_HS_CLIENT_HELLO: int32 = 1
const TLS_HS_SERVER_HELLO: int32 = 2
const TLS_HS_NEW_SESSION_TICKET: int32 = 4
const TLS_HS_END_OF_EARLY_DATA: int32 = 5
const TLS_HS_ENCRYPTED_EXTENSIONS: int32 = 8
const TLS_HS_CERTIFICATE: int32 = 11
const TLS_HS_CERTIFICATE_REQUEST: int32 = 13
const TLS_HS_CERTIFICATE_VERIFY: int32 = 15
const TLS_HS_FINISHED: int32 = 20
const TLS_HS_KEY_UPDATE: int32 = 24

# Alert levels
const TLS_ALERT_WARNING: int32 = 1
const TLS_ALERT_FATAL: int32 = 2

# Alert descriptions
const TLS_ALERT_CLOSE_NOTIFY: int32 = 0
const TLS_ALERT_UNEXPECTED_MESSAGE: int32 = 10
const TLS_ALERT_BAD_RECORD_MAC: int32 = 20
const TLS_ALERT_RECORD_OVERFLOW: int32 = 22
const TLS_ALERT_HANDSHAKE_FAILURE: int32 = 40
const TLS_ALERT_BAD_CERTIFICATE: int32 = 42
const TLS_ALERT_CERTIFICATE_EXPIRED: int32 = 45
const TLS_ALERT_UNKNOWN_CA: int32 = 48
const TLS_ALERT_DECODE_ERROR: int32 = 50
const TLS_ALERT_DECRYPT_ERROR: int32 = 51
const TLS_ALERT_PROTOCOL_VERSION: int32 = 70
const TLS_ALERT_INTERNAL_ERROR: int32 = 80
const TLS_ALERT_MISSING_EXTENSION: int32 = 109

# Extensions
const TLS_EXT_SERVER_NAME: int32 = 0
const TLS_EXT_SUPPORTED_GROUPS: int32 = 10
const TLS_EXT_SIGNATURE_ALGORITHMS: int32 = 13
const TLS_EXT_SUPPORTED_VERSIONS: int32 = 43
const TLS_EXT_KEY_SHARE: int32 = 51

# Named groups
const TLS_GROUP_X25519: int32 = 0x001D

# Cipher suites
const TLS_CHACHA20_POLY1305_SHA256: int32 = 0x1303

# Connection states
const TLS_STATE_INIT: int32 = 0
const TLS_STATE_CLIENT_HELLO_SENT: int32 = 1
const TLS_STATE_SERVER_HELLO_RECEIVED: int32 = 2
const TLS_STATE_ENCRYPTED_EXTENSIONS: int32 = 3
const TLS_STATE_CERTIFICATE: int32 = 4
const TLS_STATE_CERTIFICATE_VERIFY: int32 = 5
const TLS_STATE_FINISHED: int32 = 6
const TLS_STATE_CONNECTED: int32 = 7
const TLS_STATE_CLOSED: int32 = 8
const TLS_STATE_ERROR: int32 = 9

# Buffer sizes
const TLS_MAX_RECORD_SIZE: int32 = 16384
const TLS_MAX_PLAINTEXT_SIZE: int32 = 16384
const TLS_RECORD_HEADER_SIZE: int32 = 5
const TLS_TAG_SIZE: int32 = 16

# ===========================================================================
# TLS 1.3 Data Structures
# ===========================================================================

# TLS record header (5 bytes)
type TLSRecordHeader = record
  content_type: uint8     # Content type
  version_major: uint8    # Version major (0x03)
  version_minor: uint8    # Version minor (0x03 for TLS 1.2 compat)
  length_high: uint8      # Length high byte
  length_low: uint8       # Length low byte

# TLS connection state
type TLSConnection = record
  # Socket
  socket_id: int32

  # Connection state
  state: int32
  is_client: int32        # 1 = client, 0 = server

  # Key exchange
  local_keypair: X25519Keypair
  peer_public_key: array[32] of uint8
  shared_secret: array[32] of uint8

  # Handshake transcript hash
  transcript_hash: array[32] of uint8

  # Traffic keys (after handshake)
  client_write_key: array[32] of uint8
  client_write_iv: array[12] of uint8
  server_write_key: array[32] of uint8
  server_write_iv: array[12] of uint8

  # Sequence numbers for nonce derivation
  client_seq: int32
  server_seq: int32

  # Server name (SNI)
  server_name: array[256] of uint8
  server_name_len: int32

  # Error information
  last_alert: int32

  # Receive buffer
  recv_buffer: array[16400] of uint8
  recv_len: int32

# ===========================================================================
# HKDF Functions (HMAC-based Key Derivation Function)
# ===========================================================================

# HKDF-Extract: Extract a pseudorandom key from input keying material
# salt: optional salt value (32 bytes or NULL)
# ikm: input keying material
# ikm_len: length of IKM
# prk: output pseudorandom key (32 bytes)
proc hkdf_extract(salt: ptr uint8, ikm: ptr uint8, ikm_len: int32,
                  prk: ptr uint8) =
  # PRK = HMAC-SHA256(salt, IKM)
  # If no salt, use zero-filled key
  var zero_salt: array[32] of uint8
  var i: int32 = 0
  while i < 32:
    zero_salt[i] = 0
    i = i + 1

  var actual_salt: ptr uint8 = salt
  if salt == cast[ptr uint8](0):
    actual_salt = addr(zero_salt[0])

  hmac_sha256(actual_salt, 32, ikm, ikm_len, prk)

# HKDF-Expand: Expand a PRK into output keying material
# prk: pseudorandom key (32 bytes)
# info: context/application-specific info
# info_len: length of info
# okm: output keying material buffer
# okm_len: desired output length
proc hkdf_expand(prk: ptr uint8, info: ptr uint8, info_len: int32,
                 okm: ptr uint8, okm_len: int32) =
  var counter: uint8 = 1
  var offset: int32 = 0
  var prev: array[32] of uint8
  var prev_len: int32 = 0

  while offset < okm_len:
    # T(n) = HMAC-SHA256(PRK, T(n-1) | info | counter)
    var msg: array[256] of uint8
    var msg_len: int32 = 0

    # Copy previous T (if not first iteration)
    var j: int32 = 0
    while j < prev_len:
      msg[msg_len] = prev[j]
      msg_len = msg_len + 1
      j = j + 1

    # Copy info
    j = 0
    while j < info_len:
      msg[msg_len] = info[j]
      msg_len = msg_len + 1
      j = j + 1

    # Append counter
    msg[msg_len] = counter
    msg_len = msg_len + 1

    # Compute HMAC
    var t: array[32] of uint8
    hmac_sha256(prk, 32, addr(msg[0]), msg_len, addr(t[0]))

    # Copy to output
    j = 0
    while j < 32 and offset < okm_len:
      okm[offset] = t[j]
      offset = offset + 1
      j = j + 1

    # Save for next iteration
    j = 0
    while j < 32:
      prev[j] = t[j]
      j = j + 1
    prev_len = 32

    counter = counter + 1

# HKDF-Expand-Label for TLS 1.3
# secret: base secret
# label: TLS 1.3 label (without "tls13 " prefix)
# context: hash transcript or empty
# context_len: length of context
# output: derived key material
# output_len: desired output length
proc hkdf_expand_label(secret: ptr uint8, label: ptr uint8, label_len: int32,
                       context: ptr uint8, context_len: int32,
                       output: ptr uint8, output_len: int32) =
  # HkdfLabel struct:
  # - uint16 length (output_len)
  # - opaque label<7..255> = "tls13 " + Label
  # - opaque context<0..255> = Context

  var info: array[256] of uint8
  var info_len: int32 = 0

  # Length (2 bytes, big-endian)
  info[0] = cast[uint8]((output_len / 256) and 0xFF)
  info[1] = cast[uint8](output_len and 0xFF)
  info_len = 2

  # Label length (1 byte) = 6 + actual label length
  info[info_len] = cast[uint8](6 + label_len)
  info_len = info_len + 1

  # "tls13 " prefix
  info[info_len] = 0x74  # 't'
  info_len = info_len + 1
  info[info_len] = 0x6C  # 'l'
  info_len = info_len + 1
  info[info_len] = 0x73  # 's'
  info_len = info_len + 1
  info[info_len] = 0x31  # '1'
  info_len = info_len + 1
  info[info_len] = 0x33  # '3'
  info_len = info_len + 1
  info[info_len] = 0x20  # ' '
  info_len = info_len + 1

  # Actual label
  var i: int32 = 0
  while i < label_len:
    info[info_len] = label[i]
    info_len = info_len + 1
    i = i + 1

  # Context length (1 byte)
  info[info_len] = cast[uint8](context_len)
  info_len = info_len + 1

  # Context
  i = 0
  while i < context_len:
    info[info_len] = context[i]
    info_len = info_len + 1
    i = i + 1

  hkdf_expand(secret, addr(info[0]), info_len, output, output_len)

# ===========================================================================
# Key Schedule Functions
# ===========================================================================

# Derive early secret (from PSK or zeros)
proc tls_derive_early_secret(conn: ptr TLSConnection, psk: ptr uint8,
                             early_secret: ptr uint8) =
  var zero_ikm: array[32] of uint8
  var i: int32 = 0
  while i < 32:
    zero_ikm[i] = 0
    i = i + 1

  var ikm: ptr uint8 = psk
  if psk == cast[ptr uint8](0):
    ikm = addr(zero_ikm[0])

  hkdf_extract(cast[ptr uint8](0), ikm, 32, early_secret)

# Derive handshake secret
proc tls_derive_handshake_secret(early_secret: ptr uint8,
                                  shared_secret: ptr uint8,
                                  handshake_secret: ptr uint8) =
  # Derive-Secret(Early Secret, "derived", "")
  var derived: array[32] of uint8
  var empty_hash: array[32] of uint8
  sha256_hash(cast[ptr uint8](0), 0, addr(empty_hash[0]))

  var label: ptr uint8 = cast[ptr uint8]("derived")
  hkdf_expand_label(early_secret, label, 7,
                    addr(empty_hash[0]), 32, addr(derived[0]), 32)

  # Extract with shared secret
  hkdf_extract(addr(derived[0]), shared_secret, 32, handshake_secret)

# Derive traffic keys from secret
proc tls_derive_traffic_keys(secret: ptr uint8, key: ptr uint8, iv: ptr uint8) =
  var empty_context: array[1] of uint8
  empty_context[0] = 0

  var key_label: ptr uint8 = cast[ptr uint8]("key")
  var iv_label: ptr uint8 = cast[ptr uint8]("iv")

  hkdf_expand_label(secret, key_label, 3, addr(empty_context[0]), 0, key, 32)
  hkdf_expand_label(secret, iv_label, 2, addr(empty_context[0]), 0, iv, 12)

# ===========================================================================
# Record Layer Functions
# ===========================================================================

# Encrypt a TLS record
proc tls_encrypt_record(conn: ptr TLSConnection, content_type: int32,
                        plaintext: ptr uint8, plaintext_len: int32,
                        ciphertext: ptr uint8): int32 =
  # Get the appropriate key and IV
  var key: ptr uint8 = addr(conn.client_write_key[0])
  var iv: ptr uint8 = addr(conn.client_write_iv[0])
  var seq: int32 = conn.client_seq

  if conn.is_client == 0:
    key = addr(conn.server_write_key[0])
    iv = addr(conn.server_write_iv[0])
    seq = conn.server_seq

  # Construct nonce: IV XOR sequence number (padded to 12 bytes)
  var nonce: array[12] of uint8
  var i: int32 = 0
  while i < 12:
    nonce[i] = iv[i]
    i = i + 1

  # XOR sequence number into last 8 bytes
  nonce[4] = nonce[4] xor cast[uint8]((seq / 16777216) and 0xFF)
  nonce[5] = nonce[5] xor cast[uint8]((seq / 65536) and 0xFF)
  nonce[6] = nonce[6] xor cast[uint8]((seq / 256) and 0xFF)
  nonce[7] = nonce[7] xor cast[uint8](seq and 0xFF)

  # Prepare inner plaintext: plaintext + content_type
  var inner: array[16400] of uint8
  i = 0
  while i < plaintext_len:
    inner[i] = plaintext[i]
    i = i + 1
  inner[plaintext_len] = cast[uint8](content_type)
  var inner_len: int32 = plaintext_len + 1

  # AAD for TLS 1.3: record header with encrypted length
  var aad: array[5] of uint8
  aad[0] = TLS_CONTENT_APPLICATION  # Always application_data for encrypted
  aad[1] = 0x03
  aad[2] = 0x03  # TLS 1.2 version in record header
  var encrypted_len: int32 = inner_len + TLS_TAG_SIZE
  aad[3] = cast[uint8]((encrypted_len / 256) and 0xFF)
  aad[4] = cast[uint8](encrypted_len and 0xFF)

  # Encrypt with AEAD
  discard aead_chacha20_poly1305_encrypt(key, addr(nonce[0]),
                                          addr(aad[0]), 5,
                                          addr(inner[0]), inner_len,
                                          ciphertext)

  # Increment sequence number
  if conn.is_client == 1:
    conn.client_seq = conn.client_seq + 1
  else:
    conn.server_seq = conn.server_seq + 1

  return encrypted_len

# Decrypt a TLS record
proc tls_decrypt_record(conn: ptr TLSConnection,
                        ciphertext: ptr uint8, ciphertext_len: int32,
                        plaintext: ptr uint8, content_type: ptr int32): int32 =
  # Get the appropriate key and IV
  var key: ptr uint8 = addr(conn.server_write_key[0])
  var iv: ptr uint8 = addr(conn.server_write_iv[0])
  var seq: int32 = conn.server_seq

  if conn.is_client == 0:
    key = addr(conn.client_write_key[0])
    iv = addr(conn.client_write_iv[0])
    seq = conn.client_seq

  # Construct nonce
  var nonce: array[12] of uint8
  var i: int32 = 0
  while i < 12:
    nonce[i] = iv[i]
    i = i + 1

  nonce[4] = nonce[4] xor cast[uint8]((seq / 16777216) and 0xFF)
  nonce[5] = nonce[5] xor cast[uint8]((seq / 65536) and 0xFF)
  nonce[6] = nonce[6] xor cast[uint8]((seq / 256) and 0xFF)
  nonce[7] = nonce[7] xor cast[uint8](seq and 0xFF)

  # AAD: record header
  var aad: array[5] of uint8
  aad[0] = TLS_CONTENT_APPLICATION
  aad[1] = 0x03
  aad[2] = 0x03
  aad[3] = cast[uint8]((ciphertext_len / 256) and 0xFF)
  aad[4] = cast[uint8](ciphertext_len and 0xFF)

  # Decrypt
  var inner_len: int32 = ciphertext_len - TLS_TAG_SIZE
  var result: int32 = aead_chacha20_poly1305_decrypt(key, addr(nonce[0]),
                                                      addr(aad[0]), 5,
                                                      ciphertext, ciphertext_len,
                                                      plaintext)
  if result < 0:
    return -1  # Decryption failed

  # Increment sequence number
  if conn.is_client == 1:
    conn.server_seq = conn.server_seq + 1
  else:
    conn.client_seq = conn.client_seq + 1

  # Extract content type from last byte
  content_type[0] = cast[int32](plaintext[inner_len - 1])

  return inner_len - 1

# ===========================================================================
# Handshake Message Functions
# ===========================================================================

# Build ClientHello message
proc tls_build_client_hello(conn: ptr TLSConnection,
                            buffer: ptr uint8): int32 =
  var offset: int32 = 0

  # Handshake type
  buffer[offset] = TLS_HS_CLIENT_HELLO
  offset = offset + 1

  # Length placeholder (3 bytes) - fill in later
  var length_offset: int32 = offset
  offset = offset + 3

  # Client version (TLS 1.2 for compatibility)
  buffer[offset] = 0x03
  offset = offset + 1
  buffer[offset] = 0x03
  offset = offset + 1

  # Random (32 bytes)
  discard random_bytes(addr(buffer[offset]), 32)
  offset = offset + 32

  # Session ID length (0 for TLS 1.3)
  buffer[offset] = 0
  offset = offset + 1

  # Cipher suites
  buffer[offset] = 0x00  # Length high
  offset = offset + 1
  buffer[offset] = 0x02  # Length low (2 bytes = 1 suite)
  offset = offset + 1
  buffer[offset] = 0x13  # TLS_CHACHA20_POLY1305_SHA256 high
  offset = offset + 1
  buffer[offset] = 0x03  # TLS_CHACHA20_POLY1305_SHA256 low
  offset = offset + 1

  # Compression methods (1 null)
  buffer[offset] = 0x01  # Length
  offset = offset + 1
  buffer[offset] = 0x00  # null compression
  offset = offset + 1

  # Extensions
  var ext_start: int32 = offset
  offset = offset + 2  # Extensions length placeholder

  # Supported versions extension
  buffer[offset] = 0x00  # Extension type high
  offset = offset + 1
  buffer[offset] = 0x2B  # Extension type low (43)
  offset = offset + 1
  buffer[offset] = 0x00  # Extension length high
  offset = offset + 1
  buffer[offset] = 0x03  # Extension length low
  offset = offset + 1
  buffer[offset] = 0x02  # Version list length
  offset = offset + 1
  buffer[offset] = 0x03  # TLS 1.3 major
  offset = offset + 1
  buffer[offset] = 0x04  # TLS 1.3 minor
  offset = offset + 1

  # Supported groups extension (x25519)
  buffer[offset] = 0x00  # Extension type high
  offset = offset + 1
  buffer[offset] = 0x0A  # Extension type low (10)
  offset = offset + 1
  buffer[offset] = 0x00  # Length high
  offset = offset + 1
  buffer[offset] = 0x04  # Length low
  offset = offset + 1
  buffer[offset] = 0x00  # Groups length high
  offset = offset + 1
  buffer[offset] = 0x02  # Groups length low
  offset = offset + 1
  buffer[offset] = 0x00  # x25519 high
  offset = offset + 1
  buffer[offset] = 0x1D  # x25519 low
  offset = offset + 1

  # Key share extension (our X25519 public key)
  buffer[offset] = 0x00  # Extension type high
  offset = offset + 1
  buffer[offset] = 0x33  # Extension type low (51)
  offset = offset + 1
  buffer[offset] = 0x00  # Length high
  offset = offset + 1
  buffer[offset] = 0x26  # Length low (38 = 2 + 2 + 2 + 32)
  offset = offset + 1
  buffer[offset] = 0x00  # Client key shares length high
  offset = offset + 1
  buffer[offset] = 0x24  # Client key shares length low (36)
  offset = offset + 1
  buffer[offset] = 0x00  # Group high (x25519)
  offset = offset + 1
  buffer[offset] = 0x1D  # Group low
  offset = offset + 1
  buffer[offset] = 0x00  # Key length high
  offset = offset + 1
  buffer[offset] = 0x20  # Key length low (32)
  offset = offset + 1

  # Copy our public key
  var i: int32 = 0
  while i < 32:
    buffer[offset] = conn.local_keypair.public_key[i]
    offset = offset + 1
    i = i + 1

  # Fill in extensions length
  var ext_len: int32 = offset - ext_start - 2
  buffer[ext_start] = cast[uint8]((ext_len / 256) and 0xFF)
  buffer[ext_start + 1] = cast[uint8](ext_len and 0xFF)

  # Fill in message length
  var msg_len: int32 = offset - 4
  buffer[length_offset] = cast[uint8]((msg_len / 65536) and 0xFF)
  buffer[length_offset + 1] = cast[uint8]((msg_len / 256) and 0xFF)
  buffer[length_offset + 2] = cast[uint8](msg_len and 0xFF)

  return offset

# ===========================================================================
# TLS Connection Functions
# ===========================================================================

# Initialize a TLS connection
proc tls_init(conn: ptr TLSConnection) =
  conn.state = TLS_STATE_INIT
  conn.socket_id = -1
  conn.is_client = 1
  conn.client_seq = 0
  conn.server_seq = 0
  conn.last_alert = 0
  conn.recv_len = 0
  conn.server_name_len = 0

  # Generate ephemeral X25519 keypair
  discard x25519_keypair(addr(conn.local_keypair))

# Set server name for SNI
proc tls_set_server_name(conn: ptr TLSConnection, name: ptr uint8, len: int32) =
  var i: int32 = 0
  while i < len and i < 255:
    conn.server_name[i] = name[i]
    i = i + 1
  conn.server_name[i] = 0
  conn.server_name_len = len

# Connect to a TLS server
proc tls_connect(conn: ptr TLSConnection, socket_id: int32): int32 =
  conn.socket_id = socket_id
  conn.is_client = 1
  conn.state = TLS_STATE_INIT

  # Build and send ClientHello
  var buffer: array[512] of uint8
  var msg_len: int32 = tls_build_client_hello(conn, addr(buffer[0]))

  # Wrap in record layer
  var record: array[520] of uint8
  record[0] = TLS_CONTENT_HANDSHAKE
  record[1] = 0x03
  record[2] = 0x01  # TLS 1.0 for ClientHello record
  record[3] = cast[uint8]((msg_len / 256) and 0xFF)
  record[4] = cast[uint8](msg_len and 0xFF)

  var i: int32 = 0
  while i < msg_len:
    record[5 + i] = buffer[i]
    i = i + 1

  # Send
  var sent: int32 = tcp_send(socket_id, addr(record[0]), 5 + msg_len)
  if sent < 0:
    conn.state = TLS_STATE_ERROR
    return -1

  # Update transcript hash with ClientHello
  sha256_hash(addr(buffer[0]), msg_len, addr(conn.transcript_hash[0]))

  conn.state = TLS_STATE_CLIENT_HELLO_SENT

  # TODO: Receive and process ServerHello
  # TODO: Derive keys and complete handshake

  return 0

# Send encrypted data
proc tls_send(conn: ptr TLSConnection, data: ptr uint8, len: int32): int32 =
  if conn.state != TLS_STATE_CONNECTED:
    return -1

  var ciphertext: array[16420] of uint8
  var ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_APPLICATION,
                                          data, len, addr(ciphertext[0]))

  # Build record header
  var record: array[16425] of uint8
  record[0] = TLS_CONTENT_APPLICATION
  record[1] = 0x03
  record[2] = 0x03
  record[3] = cast[uint8]((ct_len / 256) and 0xFF)
  record[4] = cast[uint8](ct_len and 0xFF)

  var i: int32 = 0
  while i < ct_len:
    record[5 + i] = ciphertext[i]
    i = i + 1

  return tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

# Receive and decrypt data
proc tls_recv(conn: ptr TLSConnection, buffer: ptr uint8, max_len: int32): int32 =
  if conn.state != TLS_STATE_CONNECTED:
    return -1

  # Receive record header
  var header: array[5] of uint8
  var received: int32 = tcp_recv(conn.socket_id, addr(header[0]), 5)
  if received != 5:
    return -1

  # Parse length
  var ct_len: int32 = (cast[int32](header[3]) * 256) + cast[int32](header[4])
  if ct_len > TLS_MAX_RECORD_SIZE:
    return -1

  # Receive ciphertext
  var ciphertext: array[16420] of uint8
  received = tcp_recv(conn.socket_id, addr(ciphertext[0]), ct_len)
  if received != ct_len:
    return -1

  # Decrypt
  var content_type: int32 = 0
  var pt_len: int32 = tls_decrypt_record(conn, addr(ciphertext[0]), ct_len,
                                          buffer, addr(content_type))
  if pt_len < 0:
    return -1

  # Check content type
  if content_type == TLS_CONTENT_ALERT:
    conn.state = TLS_STATE_ERROR
    return -1

  if content_type != TLS_CONTENT_APPLICATION:
    return -1

  return pt_len

# Close TLS connection
proc tls_close(conn: ptr TLSConnection) =
  if conn.state == TLS_STATE_CONNECTED:
    # Send close_notify alert
    var alert: array[2] of uint8
    alert[0] = TLS_ALERT_WARNING
    alert[1] = TLS_ALERT_CLOSE_NOTIFY

    var ciphertext: array[32] of uint8
    var ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_ALERT,
                                            addr(alert[0]), 2,
                                            addr(ciphertext[0]))

    var record: array[40] of uint8
    record[0] = TLS_CONTENT_APPLICATION
    record[1] = 0x03
    record[2] = 0x03
    record[3] = cast[uint8]((ct_len / 256) and 0xFF)
    record[4] = cast[uint8](ct_len and 0xFF)

    var i: int32 = 0
    while i < ct_len:
      record[5 + i] = ciphertext[i]
      i = i + 1

    discard tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

  conn.state = TLS_STATE_CLOSED

# Get connection state
proc tls_get_state(conn: ptr TLSConnection): int32 =
  return conn.state

# Check if connected
proc tls_is_connected(conn: ptr TLSConnection): int32 =
  if conn.state == TLS_STATE_CONNECTED:
    return 1
  return 0

# ===========================================================================
# ServerHello Processing
# ===========================================================================

# Parse ServerHello message and extract key share
# Returns 0 on success, -1 on error
proc tls_parse_server_hello(conn: ptr TLSConnection,
                            data: ptr uint8, len: int32): int32 =
  if len < 38:  # Minimum ServerHello size
    return -1

  var offset: int32 = 0

  # Check handshake type
  if data[offset] != TLS_HS_SERVER_HELLO:
    return -1
  offset = offset + 1

  # Skip length (3 bytes)
  offset = offset + 3

  # Check version (should be TLS 1.2 for compat, real version in extension)
  if data[offset] != 0x03 or data[offset + 1] != 0x03:
    return -1
  offset = offset + 2

  # Skip random (32 bytes)
  offset = offset + 32

  # Session ID length and data
  var session_id_len: int32 = cast[int32](data[offset])
  offset = offset + 1 + session_id_len

  # Cipher suite (2 bytes)
  var cipher_high: int32 = cast[int32](data[offset])
  var cipher_low: int32 = cast[int32](data[offset + 1])
  offset = offset + 2

  # Verify it's our cipher suite
  if cipher_high != 0x13 or cipher_low != 0x03:
    return -1  # Not TLS_CHACHA20_POLY1305_SHA256

  # Compression method (1 byte, must be 0)
  if data[offset] != 0:
    return -1
  offset = offset + 1

  # Extensions length
  if offset + 2 > len:
    return -1
  var ext_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
  offset = offset + 2

  # Parse extensions
  var ext_end: int32 = offset + ext_len
  while offset < ext_end:
    if offset + 4 > len:
      return -1

    var ext_type: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
    offset = offset + 2
    var this_ext_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
    offset = offset + 2

    if ext_type == TLS_EXT_KEY_SHARE:
      # Key share extension
      if this_ext_len < 36:  # 2 (group) + 2 (len) + 32 (key)
        return -1

      var group: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
      if group != TLS_GROUP_X25519:
        return -1
      offset = offset + 2

      var key_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
      if key_len != 32:
        return -1
      offset = offset + 2

      # Copy peer public key
      var i: int32 = 0
      while i < 32:
        conn.peer_public_key[i] = data[offset + i]
        i = i + 1

      offset = offset + 32
    else:
      # Skip other extensions
      offset = offset + this_ext_len

  return 0

# Derive handshake keys after receiving ServerHello
proc tls_derive_keys(conn: ptr TLSConnection): int32 =
  # Compute shared secret from X25519
  discard x25519_compute_shared(addr(conn.local_keypair),
                                 addr(conn.peer_public_key[0]),
                                 addr(conn.shared_secret[0]))

  # Derive early secret (no PSK, so use zeros)
  var early_secret: array[32] of uint8
  tls_derive_early_secret(conn, cast[ptr uint8](0), addr(early_secret[0]))

  # Derive handshake secret
  var handshake_secret: array[32] of uint8
  tls_derive_handshake_secret(addr(early_secret[0]),
                               addr(conn.shared_secret[0]),
                               addr(handshake_secret[0]))

  # Derive client handshake traffic secret
  var c_hs_label: ptr uint8 = cast[ptr uint8]("c hs traffic")
  var client_hs_secret: array[32] of uint8
  hkdf_expand_label(addr(handshake_secret[0]), c_hs_label, 12,
                    addr(conn.transcript_hash[0]), 32,
                    addr(client_hs_secret[0]), 32)

  # Derive server handshake traffic secret
  var s_hs_label: ptr uint8 = cast[ptr uint8]("s hs traffic")
  var server_hs_secret: array[32] of uint8
  hkdf_expand_label(addr(handshake_secret[0]), s_hs_label, 12,
                    addr(conn.transcript_hash[0]), 32,
                    addr(server_hs_secret[0]), 32)

  # Derive traffic keys
  tls_derive_traffic_keys(addr(client_hs_secret[0]),
                          addr(conn.client_write_key[0]),
                          addr(conn.client_write_iv[0]))

  tls_derive_traffic_keys(addr(server_hs_secret[0]),
                          addr(conn.server_write_key[0]),
                          addr(conn.server_write_iv[0]))

  return 0

# Build Finished message
proc tls_build_finished(conn: ptr TLSConnection, buffer: ptr uint8): int32 =
  var offset: int32 = 0

  # Handshake type
  buffer[offset] = TLS_HS_FINISHED
  offset = offset + 1

  # Length (32 bytes for verify data)
  buffer[offset] = 0
  offset = offset + 1
  buffer[offset] = 0
  offset = offset + 1
  buffer[offset] = 32
  offset = offset + 1

  # Compute verify data: HMAC(finished_key, transcript_hash)
  var finished_key: array[32] of uint8
  var finished_label: ptr uint8 = cast[ptr uint8]("finished")
  var empty: array[1] of uint8
  empty[0] = 0
  hkdf_expand_label(addr(conn.client_write_key[0]), finished_label, 8,
                    addr(empty[0]), 0, addr(finished_key[0]), 32)

  hmac_sha256(addr(finished_key[0]), 32,
              addr(conn.transcript_hash[0]), 32,
              addr(buffer[offset]))
  offset = offset + 32

  return offset

# Receive and process a TLS record during handshake
proc tls_recv_handshake_record(conn: ptr TLSConnection,
                                buffer: ptr uint8, max_len: int32): int32 =
  # Receive record header (5 bytes)
  var header: array[5] of uint8
  var received: int32 = tcp_recv(conn.socket_id, addr(header[0]), 5)
  if received != 5:
    return -1

  var content_type: int32 = cast[int32](header[0])
  var record_len: int32 = (cast[int32](header[3]) * 256) + cast[int32](header[4])

  if record_len > max_len:
    return -1

  # Receive record data
  received = tcp_recv(conn.socket_id, buffer, record_len)
  if received != record_len:
    return -1

  return record_len

# Complete TLS handshake (after ClientHello sent)
proc tls_complete_handshake(conn: ptr TLSConnection): int32 =
  var buffer: array[4096] of uint8

  # Receive ServerHello
  var len: int32 = tls_recv_handshake_record(conn, addr(buffer[0]), 4096)
  if len < 0:
    conn.state = TLS_STATE_ERROR
    return -1

  if tls_parse_server_hello(conn, addr(buffer[0]), len) < 0:
    conn.state = TLS_STATE_ERROR
    return -1

  conn.state = TLS_STATE_SERVER_HELLO_RECEIVED

  # Derive handshake keys
  if tls_derive_keys(conn) < 0:
    conn.state = TLS_STATE_ERROR
    return -1

  # Now we can receive encrypted handshake messages
  # Skip EncryptedExtensions, Certificate, CertificateVerify for now
  # (Would need proper X.509 parsing for full implementation)

  # Receive and process remaining encrypted handshake messages
  var messages_received: int32 = 0
  while messages_received < 3:  # Expect ~3 messages before Finished
    len = tls_recv_handshake_record(conn, addr(buffer[0]), 4096)
    if len < 0:
      break

    # For encrypted records, decrypt first
    if buffer[0] == TLS_CONTENT_APPLICATION:
      var plaintext: array[4096] of uint8
      var ct: int32 = 0
      var pt_len: int32 = tls_decrypt_record(conn, addr(buffer[0]), len,
                                              addr(plaintext[0]), addr(ct))
      if pt_len < 0:
        conn.state = TLS_STATE_ERROR
        return -1

      # Check for Finished message
      if plaintext[0] == TLS_HS_FINISHED:
        conn.state = TLS_STATE_FINISHED
        break

    messages_received = messages_received + 1

  # Send our Finished message
  var finished: array[64] of uint8
  var finished_len: int32 = tls_build_finished(conn, addr(finished[0]))

  # Encrypt Finished
  var ciphertext: array[100] of uint8
  var ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_HANDSHAKE,
                                          addr(finished[0]), finished_len,
                                          addr(ciphertext[0]))

  # Send encrypted Finished
  var record: array[110] of uint8
  record[0] = TLS_CONTENT_APPLICATION
  record[1] = 0x03
  record[2] = 0x03
  record[3] = cast[uint8]((ct_len / 256) and 0xFF)
  record[4] = cast[uint8](ct_len and 0xFF)

  var i: int32 = 0
  while i < ct_len:
    record[5 + i] = ciphertext[i]
    i = i + 1

  discard tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

  # Derive application traffic keys
  # For full implementation, would re-derive from master secret
  # For now, continue using handshake keys

  conn.state = TLS_STATE_CONNECTED
  return 0

# ===========================================================================
# High-Level TLS API
# ===========================================================================

# Connect to a server with TLS
proc tls_connect_full(conn: ptr TLSConnection, host: ptr uint8,
                      port: int32): int32 =
  # Create TCP connection first
  var socket_id: int32 = tcp_connect(host, port)
  if socket_id < 0:
    return -1

  # Initialize TLS
  tls_init(conn)
  tls_set_server_name(conn, host, 0)  # TODO: proper length

  # Start handshake
  if tls_connect(conn, socket_id) < 0:
    return -1

  # Complete handshake
  if tls_complete_handshake(conn) < 0:
    return -1

  return 0

# Convenience function: HTTPS GET request
proc tls_https_get(host: ptr uint8, port: int32, path: ptr uint8,
                   response: ptr uint8, max_len: int32): int32 =
  var conn: TLSConnection

  if tls_connect_full(addr(conn), host, port) < 0:
    return -1

  # Build HTTP request
  var request: array[512] of uint8
  var req_len: int32 = 0

  # "GET "
  request[req_len] = 0x47  # G
  req_len = req_len + 1
  request[req_len] = 0x45  # E
  req_len = req_len + 1
  request[req_len] = 0x54  # T
  req_len = req_len + 1
  request[req_len] = 0x20  # space
  req_len = req_len + 1

  # Path
  var i: int32 = 0
  while path[i] != 0:
    request[req_len] = path[i]
    req_len = req_len + 1
    i = i + 1

  # " HTTP/1.1\r\nHost: "
  var http_header: ptr uint8 = cast[ptr uint8](" HTTP/1.1\r\nHost: ")
  i = 0
  while http_header[i] != 0:
    request[req_len] = http_header[i]
    req_len = req_len + 1
    i = i + 1

  # Host
  i = 0
  while host[i] != 0:
    request[req_len] = host[i]
    req_len = req_len + 1
    i = i + 1

  # "\r\nConnection: close\r\n\r\n"
  var http_end: ptr uint8 = cast[ptr uint8]("\r\nConnection: close\r\n\r\n")
  i = 0
  while http_end[i] != 0:
    request[req_len] = http_end[i]
    req_len = req_len + 1
    i = i + 1

  # Send request
  if tls_send(addr(conn), addr(request[0]), req_len) < 0:
    tls_close(addr(conn))
    return -1

  # Receive response
  var total: int32 = 0
  var received: int32 = tls_recv(addr(conn), response, max_len)
  while received > 0 and total < max_len:
    total = total + received
    received = tls_recv(addr(conn), addr(response[total]), max_len - total)

  tls_close(addr(conn))
  return total
