# tls13.bh - TLS 1.3 Implementation for BrainhairOS
# Implements TLS 1.3 (RFC 8446) for secure communications
#
# This library provides:
# - TLS 1.3 handshake (ClientHello, ServerHello, etc.)
# - Key derivation using HKDF
# - Record layer encryption with ChaCha20-Poly1305
# - Session management
#
# Supported cipher suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)

from lib.syscalls import *
from lib.sha256 import *
from lib.hmac import *
from lib.x25519 import *
from lib.chacha20 import *
from lib.poly1305 import *
from lib.aead import *
from lib.random import *
from lib.net import *

# ===========================================================================
# TLS 1.3 Constants
# ===========================================================================

# TLS versions
TLS_VERSION_12: Final[int32] = 0x0303      # TLS 1.2 (for compatibility)
TLS_VERSION_13: Final[int32] = 0x0304      # TLS 1.3

# Content types
TLS_CONTENT_CHANGE_CIPHER: Final[int32] = 20
TLS_CONTENT_ALERT: Final[int32] = 21
TLS_CONTENT_HANDSHAKE: Final[int32] = 22
TLS_CONTENT_APPLICATION: Final[int32] = 23

# Handshake types
TLS_HS_CLIENT_HELLO: Final[int32] = 1
TLS_HS_SERVER_HELLO: Final[int32] = 2
TLS_HS_NEW_SESSION_TICKET: Final[int32] = 4
TLS_HS_END_OF_EARLY_DATA: Final[int32] = 5
TLS_HS_ENCRYPTED_EXTENSIONS: Final[int32] = 8
TLS_HS_CERTIFICATE: Final[int32] = 11
TLS_HS_CERTIFICATE_REQUEST: Final[int32] = 13
TLS_HS_CERTIFICATE_VERIFY: Final[int32] = 15
TLS_HS_FINISHED: Final[int32] = 20
TLS_HS_KEY_UPDATE: Final[int32] = 24

# Alert levels
TLS_ALERT_WARNING: Final[int32] = 1
TLS_ALERT_FATAL: Final[int32] = 2

# Alert descriptions
TLS_ALERT_CLOSE_NOTIFY: Final[int32] = 0
TLS_ALERT_UNEXPECTED_MESSAGE: Final[int32] = 10
TLS_ALERT_BAD_RECORD_MAC: Final[int32] = 20
TLS_ALERT_RECORD_OVERFLOW: Final[int32] = 22
TLS_ALERT_HANDSHAKE_FAILURE: Final[int32] = 40
TLS_ALERT_BAD_CERTIFICATE: Final[int32] = 42
TLS_ALERT_CERTIFICATE_EXPIRED: Final[int32] = 45
TLS_ALERT_UNKNOWN_CA: Final[int32] = 48
TLS_ALERT_DECODE_ERROR: Final[int32] = 50
TLS_ALERT_DECRYPT_ERROR: Final[int32] = 51
TLS_ALERT_PROTOCOL_VERSION: Final[int32] = 70
TLS_ALERT_INTERNAL_ERROR: Final[int32] = 80
TLS_ALERT_MISSING_EXTENSION: Final[int32] = 109

# Extensions
TLS_EXT_SERVER_NAME: Final[int32] = 0
TLS_EXT_SUPPORTED_GROUPS: Final[int32] = 10
TLS_EXT_SIGNATURE_ALGORITHMS: Final[int32] = 13
TLS_EXT_SUPPORTED_VERSIONS: Final[int32] = 43
TLS_EXT_KEY_SHARE: Final[int32] = 51

# Named groups
TLS_GROUP_X25519: Final[int32] = 0x001D

# Cipher suites
TLS_CHACHA20_POLY1305_SHA256: Final[int32] = 0x1303

# Connection states
TLS_STATE_INIT: Final[int32] = 0
TLS_STATE_CLIENT_HELLO_SENT: Final[int32] = 1
TLS_STATE_SERVER_HELLO_RECEIVED: Final[int32] = 2
TLS_STATE_ENCRYPTED_EXTENSIONS: Final[int32] = 3
TLS_STATE_CERTIFICATE: Final[int32] = 4
TLS_STATE_CERTIFICATE_VERIFY: Final[int32] = 5
TLS_STATE_FINISHED: Final[int32] = 6
TLS_STATE_CONNECTED: Final[int32] = 7
TLS_STATE_CLOSED: Final[int32] = 8
TLS_STATE_ERROR: Final[int32] = 9

# Buffer sizes
TLS_MAX_RECORD_SIZE: Final[int32] = 16384
TLS_MAX_PLAINTEXT_SIZE: Final[int32] = 16384
TLS_RECORD_HEADER_SIZE: Final[int32] = 5
TLS_TAG_SIZE: Final[int32] = 16

# ===========================================================================
# TLS 1.3 Data Structures
# ===========================================================================

# TLS record header (5 bytes)
class TLSRecordHeader:
    content_type: uint8     # Content type
    version_major: uint8    # Version major (0x03)
    version_minor: uint8    # Version minor (0x03 for TLS 1.2 compat)
    length_high: uint8      # Length high byte
    length_low: uint8       # Length low byte

# TLS connection state
class TLSConnection:
    # Socket
    socket_id: int32

    # Connection state
    state: int32
    is_client: int32        # 1 = client, 0 = server

    # Key exchange
    local_keypair: X25519Keypair
    peer_public_key: Array[32, uint8]
    shared_secret: Array[32, uint8]

    # Handshake transcript hash
    transcript_hash: Array[32, uint8]

    # Traffic keys (after handshake)
    client_write_key: Array[32, uint8]
    client_write_iv: Array[12, uint8]
    server_write_key: Array[32, uint8]
    server_write_iv: Array[12, uint8]

    # Sequence numbers for nonce derivation
    client_seq: int32
    server_seq: int32

    # Server name (SNI)
    server_name: Array[256, uint8]
    server_name_len: int32

    # Error information
    last_alert: int32

    # Receive buffer
    recv_buffer: Array[16400, uint8]
    recv_len: int32

# ===========================================================================
# HKDF Functions (HMAC-based Key Derivation Function)
# ===========================================================================

# HKDF-Extract: Extract a pseudorandom key from input keying material
# salt: optional salt value (32 bytes or NULL)
# ikm: input keying material
# ikm_len: length of IKM
# prk: output pseudorandom key (32 bytes)
def hkdf_extract(salt: Ptr[uint8], ikm: Ptr[uint8], ikm_len: int32,
                 prk: Ptr[uint8]):
    # PRK = HMAC-SHA256(salt, IKM)
    # If no salt, use zero-filled key
    zero_salt: Array[32, uint8]
    i: int32 = 0
    while i < 32:
        zero_salt[i] = 0
        i = i + 1

    actual_salt: Ptr[uint8] = salt
    if salt == cast[Ptr[uint8]](0):
        actual_salt = addr(zero_salt[0])

    hmac_sha256(actual_salt, 32, ikm, ikm_len, prk)

# HKDF-Expand: Expand a PRK into output keying material
# prk: pseudorandom key (32 bytes)
# info: context/application-specific info
# info_len: length of info
# okm: output keying material buffer
# okm_len: desired output length
def hkdf_expand(prk: Ptr[uint8], info: Ptr[uint8], info_len: int32,
                okm: Ptr[uint8], okm_len: int32):
    counter: uint8 = 1
    offset: int32 = 0
    prev: Array[32, uint8]
    prev_len: int32 = 0

    while offset < okm_len:
        # T(n) = HMAC-SHA256(PRK, T(n-1) | info | counter)
        msg: Array[256, uint8]
        msg_len: int32 = 0

        # Copy previous T (if not first iteration)
        j: int32 = 0
        while j < prev_len:
            msg[msg_len] = prev[j]
            msg_len = msg_len + 1
            j = j + 1

        # Copy info
        j = 0
        while j < info_len:
            msg[msg_len] = info[j]
            msg_len = msg_len + 1
            j = j + 1

        # Append counter
        msg[msg_len] = counter
        msg_len = msg_len + 1

        # Compute HMAC
        t: Array[32, uint8]
        hmac_sha256(prk, 32, addr(msg[0]), msg_len, addr(t[0]))

        # Copy to output
        j = 0
        while j < 32 and offset < okm_len:
            okm[offset] = t[j]
            offset = offset + 1
            j = j + 1

        # Save for next iteration
        j = 0
        while j < 32:
            prev[j] = t[j]
            j = j + 1
        prev_len = 32

        counter = counter + 1

# HKDF-Expand-Label for TLS 1.3
# secret: base secret
# label: TLS 1.3 label (without "tls13 " prefix)
# context: hash transcript or empty
# context_len: length of context
# output: derived key material
# output_len: desired output length
def hkdf_expand_label(secret: Ptr[uint8], label: Ptr[uint8], label_len: int32,
                      context: Ptr[uint8], context_len: int32,
                      output: Ptr[uint8], output_len: int32):
    # HkdfLabel struct:
    # - uint16 length (output_len)
    # - opaque label<7..255> = "tls13 " + Label
    # - opaque context<0..255> = Context

    info: Array[256, uint8]
    info_len: int32 = 0

    # Length (2 bytes, big-endian)
    info[0] = cast[uint8]((output_len / 256) & 0xFF)
    info[1] = cast[uint8](output_len & 0xFF)
    info_len = 2

    # Label length (1 byte) = 6 + actual label length
    info[info_len] = cast[uint8](6 + label_len)
    info_len = info_len + 1

    # "tls13 " prefix
    info[info_len] = 0x74  # 't'
    info_len = info_len + 1
    info[info_len] = 0x6C  # 'l'
    info_len = info_len + 1
    info[info_len] = 0x73  # 's'
    info_len = info_len + 1
    info[info_len] = 0x31  # '1'
    info_len = info_len + 1
    info[info_len] = 0x33  # '3'
    info_len = info_len + 1
    info[info_len] = 0x20  # ' '
    info_len = info_len + 1

    # Actual label
    i: int32 = 0
    while i < label_len:
        info[info_len] = label[i]
        info_len = info_len + 1
        i = i + 1

    # Context length (1 byte)
    info[info_len] = cast[uint8](context_len)
    info_len = info_len + 1

    # Context
    i = 0
    while i < context_len:
        info[info_len] = context[i]
        info_len = info_len + 1
        i = i + 1

    hkdf_expand(secret, addr(info[0]), info_len, output, output_len)

# ===========================================================================
# Key Schedule Functions
# ===========================================================================

# Derive early secret (from PSK or zeros)
def tls_derive_early_secret(conn: Ptr[TLSConnection], psk: Ptr[uint8],
                            early_secret: Ptr[uint8]):
    zero_ikm: Array[32, uint8]
    i: int32 = 0
    while i < 32:
        zero_ikm[i] = 0
        i = i + 1

    ikm: Ptr[uint8] = psk
    if psk == cast[Ptr[uint8]](0):
        ikm = addr(zero_ikm[0])

    hkdf_extract(cast[Ptr[uint8]](0), ikm, 32, early_secret)

# Derive handshake secret
def tls_derive_handshake_secret(early_secret: Ptr[uint8],
                                shared_secret: Ptr[uint8],
                                handshake_secret: Ptr[uint8]):
    # Derive-Secret(Early Secret, "derived", "")
    derived: Array[32, uint8]
    empty_hash: Array[32, uint8]
    sha256_hash(cast[Ptr[uint8]](0), 0, addr(empty_hash[0]))

    label: Ptr[uint8] = cast[Ptr[uint8]]("derived")
    hkdf_expand_label(early_secret, label, 7,
                      addr(empty_hash[0]), 32, addr(derived[0]), 32)

    # Extract with shared secret
    hkdf_extract(addr(derived[0]), shared_secret, 32, handshake_secret)

# Derive traffic keys from secret
def tls_derive_traffic_keys(secret: Ptr[uint8], key: Ptr[uint8], iv: Ptr[uint8]):
    empty_context: Array[1, uint8]
    empty_context[0] = 0

    key_label: Ptr[uint8] = cast[Ptr[uint8]]("key")
    iv_label: Ptr[uint8] = cast[Ptr[uint8]]("iv")

    hkdf_expand_label(secret, key_label, 3, addr(empty_context[0]), 0, key, 32)
    hkdf_expand_label(secret, iv_label, 2, addr(empty_context[0]), 0, iv, 12)

# ===========================================================================
# Record Layer Functions
# ===========================================================================

# Encrypt a TLS record
def tls_encrypt_record(conn: Ptr[TLSConnection], content_type: int32,
                       plaintext: Ptr[uint8], plaintext_len: int32,
                       ciphertext: Ptr[uint8]) -> int32:
    # Get the appropriate key and IV
    key: Ptr[uint8] = addr(conn.client_write_key[0])
    iv: Ptr[uint8] = addr(conn.client_write_iv[0])
    seq: int32 = conn.client_seq

    if conn.is_client == 0:
        key = addr(conn.server_write_key[0])
        iv = addr(conn.server_write_iv[0])
        seq = conn.server_seq

    # Construct nonce: IV XOR sequence number (padded to 12 bytes)
    nonce: Array[12, uint8]
    i: int32 = 0
    while i < 12:
        nonce[i] = iv[i]
        i = i + 1

    # XOR sequence number into last 8 bytes
    nonce[4] = cast[uint8](cast[int32](nonce[4]) ^ ((seq / 16777216) & 0xFF))
    nonce[5] = cast[uint8](cast[int32](nonce[5]) ^ ((seq / 65536) & 0xFF))
    nonce[6] = cast[uint8](cast[int32](nonce[6]) ^ ((seq / 256) & 0xFF))
    nonce[7] = cast[uint8](cast[int32](nonce[7]) ^ (seq & 0xFF))

    # Prepare inner plaintext: plaintext + content_type
    inner: Array[16400, uint8]
    i = 0
    while i < plaintext_len:
        inner[i] = plaintext[i]
        i = i + 1
    inner[plaintext_len] = cast[uint8](content_type)
    inner_len: int32 = plaintext_len + 1

    # AAD for TLS 1.3: record header with encrypted length
    aad: Array[5, uint8]
    aad[0] = cast[uint8](TLS_CONTENT_APPLICATION)  # Always application_data for encrypted
    aad[1] = 0x03
    aad[2] = 0x03  # TLS 1.2 version in record header
    encrypted_len: int32 = inner_len + TLS_TAG_SIZE
    aad[3] = cast[uint8]((encrypted_len / 256) & 0xFF)
    aad[4] = cast[uint8](encrypted_len & 0xFF)

    # Encrypt with AEAD
    aead_chacha20_poly1305_encrypt(key, addr(nonce[0]),
                                   addr(aad[0]), 5,
                                   addr(inner[0]), inner_len,
                                   ciphertext)

    # Increment sequence number
    if conn.is_client == 1:
        conn.client_seq = conn.client_seq + 1
    else:
        conn.server_seq = conn.server_seq + 1

    return encrypted_len

# Decrypt a TLS record
def tls_decrypt_record(conn: Ptr[TLSConnection],
                       ciphertext: Ptr[uint8], ciphertext_len: int32,
                       plaintext: Ptr[uint8], content_type: Ptr[int32]) -> int32:
    # Get the appropriate key and IV
    key: Ptr[uint8] = addr(conn.server_write_key[0])
    iv: Ptr[uint8] = addr(conn.server_write_iv[0])
    seq: int32 = conn.server_seq

    if conn.is_client == 0:
        key = addr(conn.client_write_key[0])
        iv = addr(conn.client_write_iv[0])
        seq = conn.client_seq

    # Construct nonce
    nonce: Array[12, uint8]
    i: int32 = 0
    while i < 12:
        nonce[i] = iv[i]
        i = i + 1

    nonce[4] = cast[uint8](cast[int32](nonce[4]) ^ ((seq / 16777216) & 0xFF))
    nonce[5] = cast[uint8](cast[int32](nonce[5]) ^ ((seq / 65536) & 0xFF))
    nonce[6] = cast[uint8](cast[int32](nonce[6]) ^ ((seq / 256) & 0xFF))
    nonce[7] = cast[uint8](cast[int32](nonce[7]) ^ (seq & 0xFF))

    # AAD: record header
    aad: Array[5, uint8]
    aad[0] = cast[uint8](TLS_CONTENT_APPLICATION)
    aad[1] = 0x03
    aad[2] = 0x03
    aad[3] = cast[uint8]((ciphertext_len / 256) & 0xFF)
    aad[4] = cast[uint8](ciphertext_len & 0xFF)

    # Decrypt
    inner_len: int32 = ciphertext_len - TLS_TAG_SIZE
    result: int32 = aead_chacha20_poly1305_decrypt(key, addr(nonce[0]),
                                                   addr(aad[0]), 5,
                                                   ciphertext, ciphertext_len,
                                                   plaintext)
    if result < 0:
        return -1  # Decryption failed

    # Increment sequence number
    if conn.is_client == 1:
        conn.server_seq = conn.server_seq + 1
    else:
        conn.client_seq = conn.client_seq + 1

    # Extract content type from last byte
    content_type[0] = cast[int32](plaintext[inner_len - 1])

    return inner_len - 1

# ===========================================================================
# Handshake Message Functions
# ===========================================================================

# Build ClientHello message
def tls_build_client_hello(conn: Ptr[TLSConnection],
                           buffer: Ptr[uint8]) -> int32:
    offset: int32 = 0

    # Handshake type
    buffer[offset] = cast[uint8](TLS_HS_CLIENT_HELLO)
    offset = offset + 1

    # Length placeholder (3 bytes) - fill in later
    length_offset: int32 = offset
    offset = offset + 3

    # Client version (TLS 1.2 for compatibility)
    buffer[offset] = 0x03
    offset = offset + 1
    buffer[offset] = 0x03
    offset = offset + 1

    # Random (32 bytes)
    random_bytes(addr(buffer[offset]), 32)
    offset = offset + 32

    # Session ID length (0 for TLS 1.3)
    buffer[offset] = 0
    offset = offset + 1

    # Cipher suites
    buffer[offset] = 0x00  # Length high
    offset = offset + 1
    buffer[offset] = 0x02  # Length low (2 bytes = 1 suite)
    offset = offset + 1
    buffer[offset] = 0x13  # TLS_CHACHA20_POLY1305_SHA256 high
    offset = offset + 1
    buffer[offset] = 0x03  # TLS_CHACHA20_POLY1305_SHA256 low
    offset = offset + 1

    # Compression methods (1 null)
    buffer[offset] = 0x01  # Length
    offset = offset + 1
    buffer[offset] = 0x00  # null compression
    offset = offset + 1

    # Extensions
    ext_start: int32 = offset
    offset = offset + 2  # Extensions length placeholder

    # Supported versions extension
    buffer[offset] = 0x00  # Extension type high
    offset = offset + 1
    buffer[offset] = 0x2B  # Extension type low (43)
    offset = offset + 1
    buffer[offset] = 0x00  # Extension length high
    offset = offset + 1
    buffer[offset] = 0x03  # Extension length low
    offset = offset + 1
    buffer[offset] = 0x02  # Version list length
    offset = offset + 1
    buffer[offset] = 0x03  # TLS 1.3 major
    offset = offset + 1
    buffer[offset] = 0x04  # TLS 1.3 minor
    offset = offset + 1

    # Supported groups extension (x25519)
    buffer[offset] = 0x00  # Extension type high
    offset = offset + 1
    buffer[offset] = 0x0A  # Extension type low (10)
    offset = offset + 1
    buffer[offset] = 0x00  # Length high
    offset = offset + 1
    buffer[offset] = 0x04  # Length low
    offset = offset + 1
    buffer[offset] = 0x00  # Groups length high
    offset = offset + 1
    buffer[offset] = 0x02  # Groups length low
    offset = offset + 1
    buffer[offset] = 0x00  # x25519 high
    offset = offset + 1
    buffer[offset] = 0x1D  # x25519 low
    offset = offset + 1

    # Key share extension (our X25519 public key)
    buffer[offset] = 0x00  # Extension type high
    offset = offset + 1
    buffer[offset] = 0x33  # Extension type low (51)
    offset = offset + 1
    buffer[offset] = 0x00  # Length high
    offset = offset + 1
    buffer[offset] = 0x26  # Length low (38 = 2 + 2 + 2 + 32)
    offset = offset + 1
    buffer[offset] = 0x00  # Client key shares length high
    offset = offset + 1
    buffer[offset] = 0x24  # Client key shares length low (36)
    offset = offset + 1
    buffer[offset] = 0x00  # Group high (x25519)
    offset = offset + 1
    buffer[offset] = 0x1D  # Group low
    offset = offset + 1
    buffer[offset] = 0x00  # Key length high
    offset = offset + 1
    buffer[offset] = 0x20  # Key length low (32)
    offset = offset + 1

    # Copy our public key
    i: int32 = 0
    while i < 32:
        buffer[offset] = conn.local_keypair.public_key[i]
        offset = offset + 1
        i = i + 1

    # Fill in extensions length
    ext_len: int32 = offset - ext_start - 2
    buffer[ext_start] = cast[uint8]((ext_len / 256) & 0xFF)
    buffer[ext_start + 1] = cast[uint8](ext_len & 0xFF)

    # Fill in message length
    msg_len: int32 = offset - 4
    buffer[length_offset] = cast[uint8]((msg_len / 65536) & 0xFF)
    buffer[length_offset + 1] = cast[uint8]((msg_len / 256) & 0xFF)
    buffer[length_offset + 2] = cast[uint8](msg_len & 0xFF)

    return offset

# ===========================================================================
# TLS Connection Functions
# ===========================================================================

# Initialize a TLS connection
def tls_init(conn: Ptr[TLSConnection]):
    conn.state = TLS_STATE_INIT
    conn.socket_id = -1
    conn.is_client = 1
    conn.client_seq = 0
    conn.server_seq = 0
    conn.last_alert = 0
    conn.recv_len = 0
    conn.server_name_len = 0

    # Generate ephemeral X25519 keypair
    x25519_keypair(addr(conn.local_keypair))

# Set server name for SNI
def tls_set_server_name(conn: Ptr[TLSConnection], name: Ptr[uint8], len: int32):
    i: int32 = 0
    while i < len and i < 255:
        conn.server_name[i] = name[i]
        i = i + 1
    conn.server_name[i] = 0
    conn.server_name_len = len

# Connect to a TLS server
def tls_connect(conn: Ptr[TLSConnection], socket_id: int32) -> int32:
    conn.socket_id = socket_id
    conn.is_client = 1
    conn.state = TLS_STATE_INIT

    # Build and send ClientHello
    buffer: Array[512, uint8]
    msg_len: int32 = tls_build_client_hello(conn, addr(buffer[0]))

    # Wrap in record layer
    record: Array[520, uint8]
    record[0] = cast[uint8](TLS_CONTENT_HANDSHAKE)
    record[1] = 0x03
    record[2] = 0x01  # TLS 1.0 for ClientHello record
    record[3] = cast[uint8]((msg_len / 256) & 0xFF)
    record[4] = cast[uint8](msg_len & 0xFF)

    i: int32 = 0
    while i < msg_len:
        record[5 + i] = buffer[i]
        i = i + 1

    # Send
    sent: int32 = tcp_send(socket_id, addr(record[0]), 5 + msg_len)
    if sent < 0:
        conn.state = TLS_STATE_ERROR
        return -1

    # Update transcript hash with ClientHello
    sha256_hash(addr(buffer[0]), msg_len, addr(conn.transcript_hash[0]))

    conn.state = TLS_STATE_CLIENT_HELLO_SENT

    # TODO: Receive and process ServerHello
    # TODO: Derive keys and complete handshake

    return 0

# Send encrypted data
def tls_send(conn: Ptr[TLSConnection], data: Ptr[uint8], len: int32) -> int32:
    if conn.state != TLS_STATE_CONNECTED:
        return -1

    ciphertext: Array[16420, uint8]
    ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_APPLICATION,
                                        data, len, addr(ciphertext[0]))

    # Build record header
    record: Array[16425, uint8]
    record[0] = cast[uint8](TLS_CONTENT_APPLICATION)
    record[1] = 0x03
    record[2] = 0x03
    record[3] = cast[uint8]((ct_len / 256) & 0xFF)
    record[4] = cast[uint8](ct_len & 0xFF)

    i: int32 = 0
    while i < ct_len:
        record[5 + i] = ciphertext[i]
        i = i + 1

    return tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

# Receive and decrypt data
def tls_recv(conn: Ptr[TLSConnection], buffer: Ptr[uint8], max_len: int32) -> int32:
    if conn.state != TLS_STATE_CONNECTED:
        return -1

    # Receive record header
    header: Array[5, uint8]
    received: int32 = tcp_recv(conn.socket_id, addr(header[0]), 5)
    if received != 5:
        return -1

    # Parse length
    ct_len: int32 = (cast[int32](header[3]) * 256) + cast[int32](header[4])
    if ct_len > TLS_MAX_RECORD_SIZE:
        return -1

    # Receive ciphertext
    ciphertext: Array[16420, uint8]
    received = tcp_recv(conn.socket_id, addr(ciphertext[0]), ct_len)
    if received != ct_len:
        return -1

    # Decrypt
    content_type: int32 = 0
    pt_len: int32 = tls_decrypt_record(conn, addr(ciphertext[0]), ct_len,
                                        buffer, addr(content_type))
    if pt_len < 0:
        return -1

    # Check content type
    if content_type == TLS_CONTENT_ALERT:
        conn.state = TLS_STATE_ERROR
        return -1

    if content_type != TLS_CONTENT_APPLICATION:
        return -1

    return pt_len

# Close TLS connection
def tls_close(conn: Ptr[TLSConnection]):
    if conn.state == TLS_STATE_CONNECTED:
        # Send close_notify alert
        alert: Array[2, uint8]
        alert[0] = cast[uint8](TLS_ALERT_WARNING)
        alert[1] = cast[uint8](TLS_ALERT_CLOSE_NOTIFY)

        ciphertext: Array[32, uint8]
        ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_ALERT,
                                            addr(alert[0]), 2,
                                            addr(ciphertext[0]))

        record: Array[40, uint8]
        record[0] = cast[uint8](TLS_CONTENT_APPLICATION)
        record[1] = 0x03
        record[2] = 0x03
        record[3] = cast[uint8]((ct_len / 256) & 0xFF)
        record[4] = cast[uint8](ct_len & 0xFF)

        i: int32 = 0
        while i < ct_len:
            record[5 + i] = ciphertext[i]
            i = i + 1

        tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

    conn.state = TLS_STATE_CLOSED

# Get connection state
def tls_get_state(conn: Ptr[TLSConnection]) -> int32:
    return conn.state

# Check if connected
def tls_is_connected(conn: Ptr[TLSConnection]) -> int32:
    if conn.state == TLS_STATE_CONNECTED:
        return 1
    return 0

# ===========================================================================
# ServerHello Processing
# ===========================================================================

# Parse ServerHello message and extract key share
# Returns 0 on success, -1 on error
def tls_parse_server_hello(conn: Ptr[TLSConnection],
                           data: Ptr[uint8], len: int32) -> int32:
    if len < 38:  # Minimum ServerHello size
        return -1

    offset: int32 = 0

    # Check handshake type
    if data[offset] != TLS_HS_SERVER_HELLO:
        return -1
    offset = offset + 1

    # Skip length (3 bytes)
    offset = offset + 3

    # Check version (should be TLS 1.2 for compat, real version in extension)
    if data[offset] != 0x03 or data[offset + 1] != 0x03:
        return -1
    offset = offset + 2

    # Skip random (32 bytes)
    offset = offset + 32

    # Session ID length and data
    session_id_len: int32 = cast[int32](data[offset])
    offset = offset + 1 + session_id_len

    # Cipher suite (2 bytes)
    cipher_high: int32 = cast[int32](data[offset])
    cipher_low: int32 = cast[int32](data[offset + 1])
    offset = offset + 2

    # Verify it's our cipher suite
    if cipher_high != 0x13 or cipher_low != 0x03:
        return -1  # Not TLS_CHACHA20_POLY1305_SHA256

    # Compression method (1 byte, must be 0)
    if data[offset] != 0:
        return -1
    offset = offset + 1

    # Extensions length
    if offset + 2 > len:
        return -1
    ext_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
    offset = offset + 2

    # Parse extensions
    ext_end: int32 = offset + ext_len
    while offset < ext_end:
        if offset + 4 > len:
            return -1

        ext_type: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
        offset = offset + 2
        this_ext_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
        offset = offset + 2

        if ext_type == TLS_EXT_KEY_SHARE:
            # Key share extension
            if this_ext_len < 36:  # 2 (group) + 2 (len) + 32 (key)
                return -1

            group: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
            if group != TLS_GROUP_X25519:
                return -1
            offset = offset + 2

            key_len: int32 = (cast[int32](data[offset]) * 256) + cast[int32](data[offset + 1])
            if key_len != 32:
                return -1
            offset = offset + 2

            # Copy peer public key
            i: int32 = 0
            while i < 32:
                conn.peer_public_key[i] = data[offset + i]
                i = i + 1

            offset = offset + 32
        else:
            # Skip other extensions
            offset = offset + this_ext_len

    return 0

# Derive handshake keys after receiving ServerHello
def tls_derive_keys(conn: Ptr[TLSConnection]) -> int32:
    # Compute shared secret from X25519
    x25519_compute_shared(addr(conn.shared_secret[0]),
                          addr(conn.local_keypair.private_key[0]),
                          addr(conn.peer_public_key[0]))

    # Derive early secret (no PSK, so use zeros)
    early_secret: Array[32, uint8]
    tls_derive_early_secret(conn, cast[Ptr[uint8]](0), addr(early_secret[0]))

    # Derive handshake secret
    handshake_secret: Array[32, uint8]
    tls_derive_handshake_secret(addr(early_secret[0]),
                                addr(conn.shared_secret[0]),
                                addr(handshake_secret[0]))

    # Derive client handshake traffic secret
    c_hs_label: Ptr[uint8] = cast[Ptr[uint8]]("c hs traffic")
    client_hs_secret: Array[32, uint8]
    hkdf_expand_label(addr(handshake_secret[0]), c_hs_label, 12,
                      addr(conn.transcript_hash[0]), 32,
                      addr(client_hs_secret[0]), 32)

    # Derive server handshake traffic secret
    s_hs_label: Ptr[uint8] = cast[Ptr[uint8]]("s hs traffic")
    server_hs_secret: Array[32, uint8]
    hkdf_expand_label(addr(handshake_secret[0]), s_hs_label, 12,
                      addr(conn.transcript_hash[0]), 32,
                      addr(server_hs_secret[0]), 32)

    # Derive traffic keys
    tls_derive_traffic_keys(addr(client_hs_secret[0]),
                            addr(conn.client_write_key[0]),
                            addr(conn.client_write_iv[0]))

    tls_derive_traffic_keys(addr(server_hs_secret[0]),
                            addr(conn.server_write_key[0]),
                            addr(conn.server_write_iv[0]))

    return 0

# Build Finished message
def tls_build_finished(conn: Ptr[TLSConnection], buffer: Ptr[uint8]) -> int32:
    offset: int32 = 0

    # Handshake type
    buffer[offset] = cast[uint8](TLS_HS_FINISHED)
    offset = offset + 1

    # Length (32 bytes for verify data)
    buffer[offset] = 0
    offset = offset + 1
    buffer[offset] = 0
    offset = offset + 1
    buffer[offset] = 32
    offset = offset + 1

    # Compute verify data: HMAC(finished_key, transcript_hash)
    finished_key: Array[32, uint8]
    finished_label: Ptr[uint8] = cast[Ptr[uint8]]("finished")
    empty: Array[1, uint8]
    empty[0] = 0
    hkdf_expand_label(addr(conn.client_write_key[0]), finished_label, 8,
                      addr(empty[0]), 0, addr(finished_key[0]), 32)

    hmac_sha256(addr(finished_key[0]), 32,
                addr(conn.transcript_hash[0]), 32,
                addr(buffer[offset]))
    offset = offset + 32

    return offset

# Receive and process a TLS record during handshake
def tls_recv_handshake_record(conn: Ptr[TLSConnection],
                              buffer: Ptr[uint8], max_len: int32) -> int32:
    # Receive record header (5 bytes)
    header: Array[5, uint8]
    received: int32 = tcp_recv(conn.socket_id, addr(header[0]), 5)
    if received != 5:
        return -1

    content_type: int32 = cast[int32](header[0])
    record_len: int32 = (cast[int32](header[3]) * 256) + cast[int32](header[4])

    if record_len > max_len:
        return -1

    # Receive record data
    received = tcp_recv(conn.socket_id, buffer, record_len)
    if received != record_len:
        return -1

    return record_len

# Complete TLS handshake (after ClientHello sent)
def tls_complete_handshake(conn: Ptr[TLSConnection]) -> int32:
    buffer: Array[4096, uint8]

    # Receive ServerHello
    len: int32 = tls_recv_handshake_record(conn, addr(buffer[0]), 4096)
    if len < 0:
        conn.state = TLS_STATE_ERROR
        return -1

    if tls_parse_server_hello(conn, addr(buffer[0]), len) < 0:
        conn.state = TLS_STATE_ERROR
        return -1

    conn.state = TLS_STATE_SERVER_HELLO_RECEIVED

    # Derive handshake keys
    if tls_derive_keys(conn) < 0:
        conn.state = TLS_STATE_ERROR
        return -1

    # Now we can receive encrypted handshake messages
    # Skip EncryptedExtensions, Certificate, CertificateVerify for now
    # (Would need proper X.509 parsing for full implementation)

    # Receive and process remaining encrypted handshake messages
    messages_received: int32 = 0
    while messages_received < 3:  # Expect ~3 messages before Finished
        len = tls_recv_handshake_record(conn, addr(buffer[0]), 4096)
        if len < 0:
            break

        # For encrypted records, decrypt first
        if buffer[0] == TLS_CONTENT_APPLICATION:
            plaintext: Array[4096, uint8]
            ct: int32 = 0
            pt_len: int32 = tls_decrypt_record(conn, addr(buffer[0]), len,
                                                addr(plaintext[0]), addr(ct))
            if pt_len < 0:
                conn.state = TLS_STATE_ERROR
                return -1

            # Check for Finished message
            if plaintext[0] == TLS_HS_FINISHED:
                conn.state = TLS_STATE_FINISHED
                break

        messages_received = messages_received + 1

    # Send our Finished message
    finished: Array[64, uint8]
    finished_len: int32 = tls_build_finished(conn, addr(finished[0]))

    # Encrypt Finished
    ciphertext: Array[100, uint8]
    ct_len: int32 = tls_encrypt_record(conn, TLS_CONTENT_HANDSHAKE,
                                        addr(finished[0]), finished_len,
                                        addr(ciphertext[0]))

    # Send encrypted Finished
    record: Array[110, uint8]
    record[0] = cast[uint8](TLS_CONTENT_APPLICATION)
    record[1] = 0x03
    record[2] = 0x03
    record[3] = cast[uint8]((ct_len / 256) & 0xFF)
    record[4] = cast[uint8](ct_len & 0xFF)

    i: int32 = 0
    while i < ct_len:
        record[5 + i] = ciphertext[i]
        i = i + 1

    tcp_send(conn.socket_id, addr(record[0]), 5 + ct_len)

    # Derive application traffic keys
    # For full implementation, would re-derive from master secret
    # For now, continue using handshake keys

    conn.state = TLS_STATE_CONNECTED
    return 0

# ===========================================================================
# High-Level TLS API
# ===========================================================================

# Connect to a server with TLS
def tls_connect_full(conn: Ptr[TLSConnection], host: Ptr[uint8],
                     port: int32) -> int32:
    # Create TCP connection first
    socket_id: int32 = tcp_connect(host, port)
    if socket_id < 0:
        return -1

    # Initialize TLS
    tls_init(conn)
    tls_set_server_name(conn, host, 0)  # TODO: proper length

    # Start handshake
    if tls_connect(conn, socket_id) < 0:
        return -1

    # Complete handshake
    if tls_complete_handshake(conn) < 0:
        return -1

    return 0

# Convenience function: HTTPS GET request
def tls_https_get(host: Ptr[uint8], port: int32, path: Ptr[uint8],
                  response: Ptr[uint8], max_len: int32) -> int32:
    conn: TLSConnection

    if tls_connect_full(addr(conn), host, port) < 0:
        return -1

    # Build HTTP request
    request: Array[512, uint8]
    req_len: int32 = 0

    # "GET "
    request[req_len] = 0x47  # G
    req_len = req_len + 1
    request[req_len] = 0x45  # E
    req_len = req_len + 1
    request[req_len] = 0x54  # T
    req_len = req_len + 1
    request[req_len] = 0x20  # space
    req_len = req_len + 1

    # Path
    i: int32 = 0
    while path[i] != 0:
        request[req_len] = path[i]
        req_len = req_len + 1
        i = i + 1

    # " HTTP/1.1\r\nHost: "
    http_header: Ptr[uint8] = cast[Ptr[uint8]](" HTTP/1.1\r\nHost: ")
    i = 0
    while http_header[i] != 0:
        request[req_len] = http_header[i]
        req_len = req_len + 1
        i = i + 1

    # Host
    i = 0
    while host[i] != 0:
        request[req_len] = host[i]
        req_len = req_len + 1
        i = i + 1

    # "\r\nConnection: close\r\n\r\n"
    http_end: Ptr[uint8] = cast[Ptr[uint8]]("\r\nConnection: close\r\n\r\n")
    i = 0
    while http_end[i] != 0:
        request[req_len] = http_end[i]
        req_len = req_len + 1
        i = i + 1

    # Send request
    if tls_send(addr(conn), addr(request[0]), req_len) < 0:
        tls_close(addr(conn))
        return -1

    # Receive response
    total: int32 = 0
    received: int32 = tls_recv(addr(conn), response, max_len)
    while received > 0 and total < max_len:
        total = total + received
        received = tls_recv(addr(conn), addr(response[total]), max_len - total)

    tls_close(addr(conn))
    return total
