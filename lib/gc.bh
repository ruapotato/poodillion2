from lib.syscalls import syscall1, syscall3, syscall6, SYS_mmap2, SYS_munmap, SYS_brk, SYS_write
from lib.syscalls import PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANONYMOUS

# Stack pointer global
gc_stack_bottom_value: int32 = 0
gc_stack_approx: int32 = 0

# Get current stack pointer (approximation using local variable address)
def gc_get_stack_pointer() -> int32:
    local_var: int32 = 0
    return cast[int32](addr(local_var))

# Get stack bottom (stored global)
def gc_get_stack_bottom() -> int32:
    return gc_stack_bottom_value

# Set stack bottom
def gc_set_stack_bottom(address: int32):
    gc_stack_bottom_value = address

# Scan stack for pointers (simplified - just return 0)
def gc_scan_stack(callback: int32, context: int32) -> int32:
    return 0

# Memory barrier (no-op for single-threaded userspace)
def gc_memory_barrier():
    gc_stack_approx = gc_stack_approx

# Atomic set (non-atomic version for single-threaded)
def gc_atomic_set(ptr_addr: Ptr[int32], value: int32):
    ptr_addr[0] = value

# Atomic get (non-atomic version for single-threaded)
def gc_atomic_get(ptr_addr: Ptr[int32]) -> int32:
    return ptr_addr[0]

# Atomic compare-and-swap (non-atomic version for single-threaded)
def gc_atomic_cas(ptr_addr: Ptr[int32], expected: int32, new_val: int32) -> int32:
    old: int32 = ptr_addr[0]
    if old == expected:
        ptr_addr[0] = new_val
        return 1
    return 0
GC_HEADER_SIZE: Final[int32] = 16
GC_MARK_BIT: Final[int32] = 1
GC_TYPE_MASK: Final[int32] = -2
GC_DEFAULT_HEAP_SIZE: Final[int32] = 4194304
GC_MIN_COLLECT_SIZE: Final[int32] = 262144
GC_MAX_ROOTS: Final[int32] = 256

gc_heap_base: int32 = 0

gc_heap_size: int32 = 0

gc_heap_used: int32 = 0

gc_object_list: int32 = 0

gc_object_count: int32 = 0

gc_bytes_since_collect: int32 = 0

gc_enabled: int32 = 1

gc_initialized: int32 = 0

gc_total_allocations: int32 = 0

gc_total_collections: int32 = 0

gc_total_freed: int32 = 0

gc_root_addrs: Array[256, int32]

gc_root_count: int32 = 0

gc_free_list: int32 = 0

gc_padding1: Array[16, uint8]

gc_padding2: int32 = 0

def gc_debug_write(msg: Ptr[uint8], len: int32):
    syscall3(SYS_write, 1, cast[int32](msg), len)

def gc_debug_hex(n: int32):
    gc_padding1[0] = 48
    gc_padding1[1] = 120
    i: int32 = 0
    while (i < 8):
        nibble: int32 = ((n >> (28 - (i * 4))) & 15)
        if (nibble < 10):
            gc_padding1[(i + 2)] = cast[uint8]((48 + nibble))
        else:
            gc_padding1[(i + 2)] = cast[uint8](((97 + nibble) - 10))
        i = (i + 1)
    syscall3(SYS_write, 1, cast[int32](addr(gc_padding1)), 10)

def gc_init() -> int32:
    if (gc_initialized != 0):
        return 1
    gc_heap_base = syscall6(SYS_mmap2, 0, GC_DEFAULT_HEAP_SIZE, (PROT_READ | PROT_WRITE), (MAP_PRIVATE | MAP_ANONYMOUS), -1, 0)
    gc_heap_size = GC_DEFAULT_HEAP_SIZE
    gc_heap_used = 0
    gc_object_list = 0
    gc_object_count = 0
    gc_bytes_since_collect = 0
    gc_free_list = 0
    gc_root_count = 0
    gc_set_stack_bottom((gc_get_stack_pointer() + 65536))
    gc_initialized = 1
    return 1

def gc_alloc(size: int32) -> Ptr[uint8]:
    if (gc_initialized == 0):
        if (gc_init() == 0):
            return Ptr[uint8](0)
    aligned_size: int32 = ((size + 3) & -4)
    total_size: int32 = (aligned_size + GC_HEADER_SIZE)
    prev_ptr: int32 = 0
    curr: int32 = gc_free_list
    while (curr != 0):
        header: Ptr[int32] = Ptr[int32](curr)
        block_size: int32 = header[1]
        if (block_size >= total_size):
            next_free: int32 = header[2]
            if (prev_ptr == 0):
                gc_free_list = next_free
            else:
                prev_header: Ptr[int32] = Ptr[int32](prev_ptr)
                prev_header[2] = next_free
            header[0] = 0
            header[2] = gc_object_list
            header[3] = 0
            if (gc_object_list != 0):
                old_head: Ptr[int32] = Ptr[int32](gc_object_list)
                old_head[3] = curr
            gc_object_list = curr
            gc_object_count = (gc_object_count + 1)
            gc_total_allocations = (gc_total_allocations + 1)
            data_ptr: Ptr[uint8] = Ptr[uint8]((curr + GC_HEADER_SIZE))
            i: int32 = 0
            while (i < aligned_size):
                data_ptr[i] = 0
                i = (i + 1)
            return data_ptr
        prev_ptr = curr
        curr = header[2]
    obj_addr: int32 = (gc_heap_base + gc_heap_used)
    header: Ptr[int32] = Ptr[int32](obj_addr)
    header[0] = 0
    header[1] = total_size
    header[2] = gc_object_list
    header[3] = 0
    if (gc_object_list != 0):
        old_head: Ptr[int32] = Ptr[int32](gc_object_list)
        old_head[3] = obj_addr
    gc_object_list = obj_addr
    gc_object_count = (gc_object_count + 1)
    gc_heap_used = (gc_heap_used + total_size)
    gc_bytes_since_collect = (gc_bytes_since_collect + total_size)
    gc_total_allocations = (gc_total_allocations + 1)
    data_ptr: int32 = (obj_addr + GC_HEADER_SIZE)
    data: Ptr[uint8] = Ptr[uint8](data_ptr)
    i: int32 = 0
    while (i < aligned_size):
        data[i] = 0
        i = (i + 1)
    return Ptr[uint8](data_ptr)

def gc_alloc_typed(size: int32, type_id: int32) -> Ptr[uint8]:
    result: Ptr[uint8] = gc_alloc(size)
    if (cast[int32](result) == 0):
        return result
    header_addr: int32 = (cast[int32](result) - GC_HEADER_SIZE)
    header: Ptr[int32] = Ptr[int32](header_addr)
    header[0] = ((type_id << 1) & -2)
    return result

def gc_register_root(root_addr: Ptr[int32]) -> int32:
    if (gc_root_count >= GC_MAX_ROOTS):
        return 0
    gc_root_addrs[gc_root_count] = cast[int32](root_addr)
    gc_root_count = (gc_root_count + 1)
    return 1

def gc_unregister_root(root_addr: Ptr[int32]) -> int32:
    i: int32 = 0
    while (i < gc_root_count):
        if (gc_root_addrs[i] == cast[int32](root_addr)):
            j: int32 = i
            while (j < (gc_root_count - 1)):
                gc_root_addrs[j] = gc_root_addrs[(j + 1)]
                j = (j + 1)
            gc_root_count = (gc_root_count - 1)
            return 1
        i = (i + 1)
    return 0

def gc_is_valid_pointer(address: int32) -> int32:
    if (gc_heap_base == 0):
        return 0
    if (gc_heap_used == 0):
        return 0
    if (address < gc_heap_base):
        return 0
    if (address >= (gc_heap_base + gc_heap_used)):
        return 0
    curr: int32 = gc_object_list
    while (curr != 0):
        data_addr: int32 = (curr + GC_HEADER_SIZE)
        header: Ptr[int32] = Ptr[int32](curr)
        obj_size: int32 = (header[1] - GC_HEADER_SIZE)
        if (address >= data_addr):
            if (address < (data_addr + obj_size)):
                return curr
        curr = header[2]
    return 0

def gc_mark_object(header_addr: int32):
    if (header_addr == 0):
        return
    header: Ptr[int32] = Ptr[int32](header_addr)
    if ((header[0] & GC_MARK_BIT) != 0):
        return
    header[0] = (header[0] | GC_MARK_BIT)
    data_addr: int32 = (header_addr + GC_HEADER_SIZE)
    data_size: int32 = (header[1] - GC_HEADER_SIZE)
    data: Ptr[int32] = Ptr[int32](data_addr)
    word_count: int32 = (data_size / 4)
    i: int32 = 0
    while (i < word_count):
        potential_ptr: int32 = data[i]
        ref_header: int32 = gc_is_valid_pointer(potential_ptr)
        if (ref_header != 0):
            gc_mark_object(ref_header)
        i = (i + 1)

def gc_mark_root(root_value: int32):
    header: int32 = gc_is_valid_pointer(root_value)
    if (header != 0):
        gc_mark_object(header)

def gc_mark():
    i: int32 = 0
    while (i < gc_root_count):
        root_addr: Ptr[int32] = Ptr[int32](gc_root_addrs[i])
        root_value: int32 = root_addr[0]
        gc_mark_root(root_value)
        i = (i + 1)
    0

def gc_sweep() -> int32:
    freed: int32 = 0
    curr: int32 = gc_object_list
    while (curr != 0):
        header: Ptr[int32] = Ptr[int32](curr)
        next: int32 = header[2]
        if ((header[0] & GC_MARK_BIT) != 0):
            header[0] = (header[0] & -2)
        else:
            prev: int32 = header[3]
            obj_size: int32 = header[1]
            if (prev != 0):
                prev_header: Ptr[int32] = Ptr[int32](prev)
                prev_header[2] = next
            else:
                gc_object_list = next
            if (next != 0):
                next_header: Ptr[int32] = Ptr[int32](next)
                next_header[3] = prev
            header[2] = gc_free_list
            gc_free_list = curr
            gc_object_count = (gc_object_count - 1)
            freed = (freed + obj_size)
            gc_total_freed = (gc_total_freed + obj_size)
        curr = next
    return freed

def gc_collect() -> int32:
    if (gc_initialized == 0):
        return 0
    gc_memory_barrier()
    gc_mark()
    freed: int32 = gc_sweep()
    gc_bytes_since_collect = 0
    gc_total_collections = (gc_total_collections + 1)
    gc_memory_barrier()
    return freed

def gc_enable():
    gc_enabled = 1

def gc_disable():
    gc_enabled = 0

def gc_get_heap_used() -> int32:
    return gc_heap_used

def gc_get_heap_size() -> int32:
    return gc_heap_size

def gc_get_object_count() -> int32:
    return gc_object_count

def gc_get_total_allocations() -> int32:
    return gc_total_allocations

def gc_get_total_collections() -> int32:
    return gc_total_collections

def gc_get_total_freed() -> int32:
    return gc_total_freed

def gc_destroy():
    if (gc_initialized != 0):

        syscall6(SYS_munmap, gc_heap_base, gc_heap_size, 0, 0, 0, 0)
        gc_heap_base = 0
        gc_heap_size = 0
        gc_heap_used = 0
        gc_object_list = 0
        gc_free_list = 0
        gc_object_count = 0
        gc_root_count = 0
        gc_initialized = 0