# crypto.bh - Unified Cryptography Library for BrainhairOS
# High-level API that brings together all crypto primitives
#
# Provides:
# - Symmetric encryption (AES, ChaCha20)
# - AEAD encryption (ChaCha20-Poly1305, AES-GCM concept)
# - Hashing (SHA-256, SHA-512)
# - Message authentication (HMAC)
# - Key exchange (X25519)
# - Digital signatures (Ed25519)
# - Key derivation (HKDF, PBKDF2)
# - Random number generation
# - Base64/Hex encoding

from lib.syscalls import *

# ===========================================================================
# Crypto Constants
# ===========================================================================

# Key sizes in bytes
CRYPTO_KEY_128: Final[int32] = 16
CRYPTO_KEY_192: Final[int32] = 24
CRYPTO_KEY_256: Final[int32] = 32
CRYPTO_KEY_512: Final[int32] = 64

# Hash output sizes
CRYPTO_SHA256_SIZE: Final[int32] = 32
CRYPTO_SHA512_SIZE: Final[int32] = 64

# Signature/key sizes
CRYPTO_ED25519_PUBKEY_SIZE: Final[int32] = 32
CRYPTO_ED25519_PRIVKEY_SIZE: Final[int32] = 64
CRYPTO_ED25519_SIGNATURE_SIZE: Final[int32] = 64
CRYPTO_X25519_KEY_SIZE: Final[int32] = 32

# Nonce/IV sizes
CRYPTO_AES_IV_SIZE: Final[int32] = 16
CRYPTO_CHACHA20_NONCE_SIZE: Final[int32] = 12
CRYPTO_POLY1305_TAG_SIZE: Final[int32] = 16

# ===========================================================================
# Error Codes
# ===========================================================================

CRYPTO_OK: Final[int32] = 0
CRYPTO_ERR_NULL_PTR: Final[int32] = -1
CRYPTO_ERR_INVALID_SIZE: Final[int32] = -2
CRYPTO_ERR_AUTH_FAILED: Final[int32] = -3
CRYPTO_ERR_KEY_INVALID: Final[int32] = -4
CRYPTO_ERR_BUFFER_TOO_SMALL: Final[int32] = -5

# ===========================================================================
# External Functions from Kernel/Libraries
# ===========================================================================

# SHA-256
extern def sha256_init(ctx: Ptr[uint8]) -> int32
extern def sha256_update(ctx: Ptr[uint8], data: Ptr[uint8], len: int32) -> int32
extern def sha256_final(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32
extern def sha256_hash(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32

# SHA-512 syscalls
def sha512_init_syscall(ctx: Ptr[uint8]) -> int32:
    return syscall3(260, cast[int32](ctx), 0, 0)

def sha512_update_syscall(ctx: Ptr[uint8], data: Ptr[uint8], len: int32) -> int32:
    return syscall3(261, cast[int32](ctx), cast[int32](data), len)

def sha512_final_syscall(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32:
    return syscall3(262, cast[int32](ctx), cast[int32](output), 0)

# AES
extern def aes_set_key(ctx: Ptr[uint8], key: Ptr[uint8], key_len: int32) -> int32
extern def aes_encrypt_block(ctx: Ptr[uint8], input: Ptr[uint8], output: Ptr[uint8]) -> int32
extern def aes_decrypt_block(ctx: Ptr[uint8], input: Ptr[uint8], output: Ptr[uint8]) -> int32

# ChaCha20
extern def chacha20_init(ctx: Ptr[uint8], key: Ptr[uint8], nonce: Ptr[uint8], counter: int32) -> int32
extern def chacha20_encrypt(ctx: Ptr[uint8], plaintext: Ptr[uint8], ciphertext: Ptr[uint8], len: int32) -> int32

# Poly1305
extern def poly1305_init(ctx: Ptr[uint8], key: Ptr[uint8]) -> int32
extern def poly1305_update(ctx: Ptr[uint8], data: Ptr[uint8], len: int32) -> int32
extern def poly1305_final(ctx: Ptr[uint8], tag: Ptr[uint8]) -> int32

# X25519
def x25519_keygen_syscall(private_key: Ptr[uint8], public_key: Ptr[uint8]) -> int32:
    return syscall2(240, cast[int32](private_key), cast[int32](public_key))

def x25519_shared_syscall(shared: Ptr[uint8], private: Ptr[uint8], public: Ptr[uint8]) -> int32:
    return syscall3(241, cast[int32](shared), cast[int32](private), cast[int32](public))

# Ed25519
def ed25519_keygen_syscall(seed: Ptr[uint8], public: Ptr[uint8], private: Ptr[uint8]) -> int32:
    return syscall3(270, cast[int32](seed), cast[int32](public), cast[int32](private))

def ed25519_sign_syscall(sig: Ptr[uint8], msg: Ptr[uint8], msg_len: int32, priv: Ptr[uint8]) -> int32:
    return syscall4(271, cast[int32](sig), cast[int32](msg), msg_len, cast[int32](priv))

def ed25519_verify_syscall(sig: Ptr[uint8], msg: Ptr[uint8], msg_len: int32, pub: Ptr[uint8]) -> int32:
    return syscall4(272, cast[int32](sig), cast[int32](msg), msg_len, cast[int32](pub))

# Random
def getrandom_syscall(buf: Ptr[uint8], len: int32) -> int32:
    return syscall2(80, cast[int32](buf), len)

# ===========================================================================
# Hash Functions
# ===========================================================================

# One-shot SHA-256 hash
def crypto_sha256(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    if data == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR
    return sha256_hash(data, len, output)

# One-shot SHA-512 hash
def crypto_sha512(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    if data == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    ctx: Array[256, uint8]
    sha512_init_syscall(addr(ctx[0]))
    sha512_update_syscall(addr(ctx[0]), data, len)
    return sha512_final_syscall(addr(ctx[0]), output)

# ===========================================================================
# HMAC Functions
# ===========================================================================

# HMAC-SHA256
def crypto_hmac_sha256(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    if key == cast[Ptr[uint8]](0) or data == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    ipad: Array[64, uint8]
    opad: Array[64, uint8]
    key_block: Array[64, uint8]
    i: int32 = 0

    # Prepare key block
    if key_len > 64:
        sha256_hash(key, key_len, addr(key_block[0]))
        i = 32
        while i < 64:
            key_block[i] = 0
            i = i + 1
    else:
        i = 0
        while i < key_len:
            key_block[i] = key[i]
            i = i + 1
        while i < 64:
            key_block[i] = 0
            i = i + 1

    # Create ipad and opad
    i = 0
    while i < 64:
        ipad[i] = cast[uint8](cast[int32](key_block[i]) ^ 0x36)
        opad[i] = cast[uint8](cast[int32](key_block[i]) ^ 0x5c)
        i = i + 1

    # Inner hash
    ctx: Array[128, uint8]
    inner_hash: Array[32, uint8]
    sha256_init(addr(ctx[0]))
    sha256_update(addr(ctx[0]), addr(ipad[0]), 64)
    sha256_update(addr(ctx[0]), data, data_len)
    sha256_final(addr(ctx[0]), addr(inner_hash[0]))

    # Outer hash
    sha256_init(addr(ctx[0]))
    sha256_update(addr(ctx[0]), addr(opad[0]), 64)
    sha256_update(addr(ctx[0]), addr(inner_hash[0]), 32)
    sha256_final(addr(ctx[0]), output)

    return CRYPTO_OK

# HMAC-SHA512
def crypto_hmac_sha512(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    if key == cast[Ptr[uint8]](0) or data == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    ipad: Array[128, uint8]
    opad: Array[128, uint8]
    key_block: Array[128, uint8]
    i: int32 = 0

    # Prepare key block
    if key_len > 128:
        crypto_sha512(key, key_len, addr(key_block[0]))
        i = 64
        while i < 128:
            key_block[i] = 0
            i = i + 1
    else:
        i = 0
        while i < key_len:
            key_block[i] = key[i]
            i = i + 1
        while i < 128:
            key_block[i] = 0
            i = i + 1

    i = 0
    while i < 128:
        ipad[i] = cast[uint8](cast[int32](key_block[i]) ^ 0x36)
        opad[i] = cast[uint8](cast[int32](key_block[i]) ^ 0x5c)
        i = i + 1

    ctx: Array[256, uint8]
    inner_hash: Array[64, uint8]
    sha512_init_syscall(addr(ctx[0]))
    sha512_update_syscall(addr(ctx[0]), addr(ipad[0]), 128)
    sha512_update_syscall(addr(ctx[0]), data, data_len)
    sha512_final_syscall(addr(ctx[0]), addr(inner_hash[0]))

    sha512_init_syscall(addr(ctx[0]))
    sha512_update_syscall(addr(ctx[0]), addr(opad[0]), 128)
    sha512_update_syscall(addr(ctx[0]), addr(inner_hash[0]), 64)
    sha512_final_syscall(addr(ctx[0]), output)

    return CRYPTO_OK

# ===========================================================================
# Random Number Generation
# ===========================================================================

# Fill buffer with cryptographically secure random bytes
def crypto_random_bytes(buf: Ptr[uint8], len: int32) -> int32:
    if buf == cast[Ptr[uint8]](0) or len <= 0:
        return CRYPTO_ERR_NULL_PTR
    return getrandom_syscall(buf, len)

# Generate a random 32-bit integer
def crypto_random_int() -> int32:
    buf: Array[4, uint8]
    getrandom_syscall(addr(buf[0]), 4)
    return cast[int32](buf[0]) | (cast[int32](buf[1]) * 256) | (cast[int32](buf[2]) * 65536) | (cast[int32](buf[3]) * 16777216)

# Generate a random integer in range [0, max)
def crypto_random_range(max: int32) -> int32:
    if max <= 0:
        return 0
    r: int32 = crypto_random_int()
    if r < 0:
        r = 0 - r  # Make positive
    return r % max

# ===========================================================================
# Key Exchange (X25519)
# ===========================================================================

# Generate X25519 key pair
# private_key: 32-byte buffer for private key
# public_key: 32-byte buffer for public key
def crypto_x25519_keypair(private_key: Ptr[uint8], public_key: Ptr[uint8]) -> int32:
    if private_key == cast[Ptr[uint8]](0) or public_key == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR
    return x25519_keygen_syscall(private_key, public_key)

# Compute X25519 shared secret
# shared: 32-byte buffer for shared secret
# private_key: our 32-byte private key
# public_key: their 32-byte public key
def crypto_x25519_shared(shared: Ptr[uint8], private_key: Ptr[uint8], public_key: Ptr[uint8]) -> int32:
    if shared == cast[Ptr[uint8]](0) or private_key == cast[Ptr[uint8]](0) or public_key == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR
    return x25519_shared_syscall(shared, private_key, public_key)

# ===========================================================================
# Digital Signatures (Ed25519)
# ===========================================================================

# Generate Ed25519 key pair
# seed: 32-byte random seed (or null to auto-generate)
# public_key: 32-byte buffer for public key
# private_key: 64-byte buffer for private key (seed || public_key)
def crypto_ed25519_keypair(seed: Ptr[uint8], public_key: Ptr[uint8], private_key: Ptr[uint8]) -> int32:
    if public_key == cast[Ptr[uint8]](0) or private_key == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    actual_seed: Array[32, uint8]
    if seed == cast[Ptr[uint8]](0):
        getrandom_syscall(addr(actual_seed[0]), 32)
        return ed25519_keygen_syscall(addr(actual_seed[0]), public_key, private_key)
    else:
        return ed25519_keygen_syscall(seed, public_key, private_key)

# Sign a message with Ed25519
# signature: 64-byte buffer for signature
# message: message to sign
# message_len: length of message
# private_key: 64-byte private key
def crypto_ed25519_sign(signature: Ptr[uint8], message: Ptr[uint8], message_len: int32, private_key: Ptr[uint8]) -> int32:
    if signature == cast[Ptr[uint8]](0) or message == cast[Ptr[uint8]](0) or private_key == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR
    return ed25519_sign_syscall(signature, message, message_len, private_key)

# Verify an Ed25519 signature
# Returns: CRYPTO_OK if valid, CRYPTO_ERR_AUTH_FAILED if invalid
def crypto_ed25519_verify(signature: Ptr[uint8], message: Ptr[uint8], message_len: int32, public_key: Ptr[uint8]) -> int32:
    if signature == cast[Ptr[uint8]](0) or message == cast[Ptr[uint8]](0) or public_key == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    result: int32 = ed25519_verify_syscall(signature, message, message_len, public_key)
    if result == 1:
        return CRYPTO_OK
    return CRYPTO_ERR_AUTH_FAILED

# ===========================================================================
# Symmetric Encryption (ChaCha20)
# ===========================================================================

# ChaCha20 encryption (same as decryption - XOR cipher)
# key: 32-byte key
# nonce: 12-byte nonce (must be unique per message with same key!)
# input: plaintext or ciphertext
# output: ciphertext or plaintext
# len: length of data
def crypto_chacha20(key: Ptr[uint8], nonce: Ptr[uint8], input: Ptr[uint8], output: Ptr[uint8], len: int32) -> int32:
    if key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    ctx: Array[128, uint8]
    chacha20_init(addr(ctx[0]), key, nonce, 1)
    chacha20_encrypt(addr(ctx[0]), input, output, len)
    return CRYPTO_OK

# ===========================================================================
# AEAD Encryption (ChaCha20-Poly1305)
# ===========================================================================

# Authenticated encryption with ChaCha20-Poly1305
# key: 32-byte key
# nonce: 12-byte nonce (must be unique!)
# plaintext: data to encrypt
# plaintext_len: length of plaintext
# aad: additional authenticated data (can be null)
# aad_len: length of AAD
# ciphertext: output buffer (must be plaintext_len + 16 bytes for tag)
# Returns: length of ciphertext (plaintext_len + 16) on success
def crypto_aead_encrypt(key: Ptr[uint8], nonce: Ptr[uint8], plaintext: Ptr[uint8], plaintext_len: int32, aad: Ptr[uint8], aad_len: int32, ciphertext: Ptr[uint8]) -> int32:
    if key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or plaintext == cast[Ptr[uint8]](0) or ciphertext == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    # Generate Poly1305 key from ChaCha20 with counter=0
    poly_key: Array[32, uint8]
    zero_block: Array[64, uint8]
    poly_ctx: Array[128, uint8]
    i: int32 = 0
    while i < 64:
        zero_block[i] = 0
        i = i + 1

    chacha_ctx: Array[128, uint8]
    chacha20_init(addr(chacha_ctx[0]), key, nonce, 0)
    chacha20_encrypt(addr(chacha_ctx[0]), addr(zero_block[0]), addr(poly_key[0]), 32)

    # Encrypt with ChaCha20 (counter=1)
    chacha20_init(addr(chacha_ctx[0]), key, nonce, 1)
    chacha20_encrypt(addr(chacha_ctx[0]), plaintext, ciphertext, plaintext_len)

    # Compute Poly1305 tag over AAD and ciphertext
    poly1305_init(addr(poly_ctx[0]), addr(poly_key[0]))

    # Add AAD with padding
    if aad != cast[Ptr[uint8]](0) and aad_len > 0:
        poly1305_update(addr(poly_ctx[0]), aad, aad_len)
        # Pad to 16 bytes
        pad_len: int32 = (16 - (aad_len % 16)) % 16
        padding: Array[16, uint8]
        i = 0
        while i < 16:
            padding[i] = 0
            i = i + 1
        if pad_len > 0:
            poly1305_update(addr(poly_ctx[0]), addr(padding[0]), pad_len)

    # Add ciphertext with padding
    poly1305_update(addr(poly_ctx[0]), ciphertext, plaintext_len)
    ct_pad_len: int32 = (16 - (plaintext_len % 16)) % 16
    ct_padding: Array[16, uint8]
    i = 0
    while i < 16:
        ct_padding[i] = 0
        i = i + 1
    if ct_pad_len > 0:
        poly1305_update(addr(poly_ctx[0]), addr(ct_padding[0]), ct_pad_len)

    # Add lengths (little-endian 64-bit)
    lengths: Array[16, uint8]
    i = 0
    while i < 16:
        lengths[i] = 0
        i = i + 1
    lengths[0] = cast[uint8](aad_len & 0xFF)
    lengths[1] = cast[uint8]((aad_len / 256) & 0xFF)
    lengths[2] = cast[uint8]((aad_len / 65536) & 0xFF)
    lengths[3] = cast[uint8]((aad_len / 16777216) & 0xFF)
    lengths[8] = cast[uint8](plaintext_len & 0xFF)
    lengths[9] = cast[uint8]((plaintext_len / 256) & 0xFF)
    lengths[10] = cast[uint8]((plaintext_len / 65536) & 0xFF)
    lengths[11] = cast[uint8]((plaintext_len / 16777216) & 0xFF)
    poly1305_update(addr(poly_ctx[0]), addr(lengths[0]), 16)

    # Append tag to ciphertext
    poly1305_final(addr(poly_ctx[0]), addr(ciphertext[plaintext_len]))

    return plaintext_len + 16

# Authenticated decryption with ChaCha20-Poly1305
# key: 32-byte key
# nonce: 12-byte nonce
# ciphertext: encrypted data with 16-byte tag at end
# ciphertext_len: total length including tag
# aad: additional authenticated data
# aad_len: length of AAD
# plaintext: output buffer (ciphertext_len - 16 bytes)
# Returns: length of plaintext on success, CRYPTO_ERR_AUTH_FAILED if tag invalid
def crypto_aead_decrypt(key: Ptr[uint8], nonce: Ptr[uint8], ciphertext: Ptr[uint8], ciphertext_len: int32, aad: Ptr[uint8], aad_len: int32, plaintext: Ptr[uint8]) -> int32:
    if key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or ciphertext == cast[Ptr[uint8]](0) or plaintext == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    if ciphertext_len < 16:
        return CRYPTO_ERR_INVALID_SIZE

    data_len: int32 = ciphertext_len - 16

    # Generate Poly1305 key
    poly_key: Array[32, uint8]
    zero_block: Array[64, uint8]
    poly_ctx: Array[128, uint8]
    i: int32 = 0
    while i < 64:
        zero_block[i] = 0
        i = i + 1

    chacha_ctx: Array[128, uint8]
    chacha20_init(addr(chacha_ctx[0]), key, nonce, 0)
    chacha20_encrypt(addr(chacha_ctx[0]), addr(zero_block[0]), addr(poly_key[0]), 32)

    # Compute expected tag
    poly1305_init(addr(poly_ctx[0]), addr(poly_key[0]))

    if aad != cast[Ptr[uint8]](0) and aad_len > 0:
        poly1305_update(addr(poly_ctx[0]), aad, aad_len)
        pad_len: int32 = (16 - (aad_len % 16)) % 16
        padding: Array[16, uint8]
        i = 0
        while i < 16:
            padding[i] = 0
            i = i + 1
        if pad_len > 0:
            poly1305_update(addr(poly_ctx[0]), addr(padding[0]), pad_len)

    poly1305_update(addr(poly_ctx[0]), ciphertext, data_len)
    ct_pad_len: int32 = (16 - (data_len % 16)) % 16
    ct_padding: Array[16, uint8]
    i = 0
    while i < 16:
        ct_padding[i] = 0
        i = i + 1
    if ct_pad_len > 0:
        poly1305_update(addr(poly_ctx[0]), addr(ct_padding[0]), ct_pad_len)

    lengths: Array[16, uint8]
    i = 0
    while i < 16:
        lengths[i] = 0
        i = i + 1
    lengths[0] = cast[uint8](aad_len & 0xFF)
    lengths[1] = cast[uint8]((aad_len / 256) & 0xFF)
    lengths[2] = cast[uint8]((aad_len / 65536) & 0xFF)
    lengths[3] = cast[uint8]((aad_len / 16777216) & 0xFF)
    lengths[8] = cast[uint8](data_len & 0xFF)
    lengths[9] = cast[uint8]((data_len / 256) & 0xFF)
    lengths[10] = cast[uint8]((data_len / 65536) & 0xFF)
    lengths[11] = cast[uint8]((data_len / 16777216) & 0xFF)
    poly1305_update(addr(poly_ctx[0]), addr(lengths[0]), 16)

    expected_tag: Array[16, uint8]
    poly1305_final(addr(poly_ctx[0]), addr(expected_tag[0]))

    # Constant-time tag comparison
    diff: int32 = 0
    i = 0
    while i < 16:
        diff = diff | (cast[int32](ciphertext[data_len + i]) ^ cast[int32](expected_tag[i]))
        i = i + 1

    if diff != 0:
        return CRYPTO_ERR_AUTH_FAILED

    # Decrypt
    chacha20_init(addr(chacha_ctx[0]), key, nonce, 1)
    chacha20_encrypt(addr(chacha_ctx[0]), ciphertext, plaintext, data_len)

    return data_len

# ===========================================================================
# Key Derivation
# ===========================================================================

# HKDF-SHA256 one-shot
# salt: optional salt (can be null)
# salt_len: salt length
# ikm: input keying material
# ikm_len: IKM length
# info: optional context info
# info_len: info length
# okm: output keying material
# okm_len: desired output length (max 8160)
def crypto_hkdf_sha256(salt: Ptr[uint8], salt_len: int32, ikm: Ptr[uint8], ikm_len: int32, info: Ptr[uint8], info_len: int32, okm: Ptr[uint8], okm_len: int32) -> int32:
    if ikm == cast[Ptr[uint8]](0) or okm == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    if okm_len <= 0 or okm_len > 8160:
        return CRYPTO_ERR_INVALID_SIZE

    # Extract
    prk: Array[32, uint8]
    zero_salt: Array[32, uint8]
    actual_salt: Ptr[uint8] = salt
    actual_salt_len: int32 = salt_len

    if salt == cast[Ptr[uint8]](0) or salt_len == 0:
        i: int32 = 0
        while i < 32:
            zero_salt[i] = 0
            i = i + 1
        actual_salt = addr(zero_salt[0])
        actual_salt_len = 32

    crypto_hmac_sha256(actual_salt, actual_salt_len, ikm, ikm_len, addr(prk[0]))

    # Expand
    t: Array[32, uint8]
    t_len: int32 = 0
    pos: int32 = 0
    n: int32 = (okm_len + 31) / 32
    i: int32 = 1

    while i <= n:
        # Build input: T(i-1) || info || counter
        input: Array[256, uint8]
        input_len: int32 = 0

        if t_len > 0:
            j: int32 = 0
            while j < t_len:
                input[input_len] = t[j]
                input_len = input_len + 1
                j = j + 1

        if info != cast[Ptr[uint8]](0) and info_len > 0:
            j: int32 = 0
            while j < info_len and input_len < 250:
                input[input_len] = info[j]
                input_len = input_len + 1
                j = j + 1

        input[input_len] = cast[uint8](i)
        input_len = input_len + 1

        crypto_hmac_sha256(addr(prk[0]), 32, addr(input[0]), input_len, addr(t[0]))
        t_len = 32

        copy_len: int32 = 32
        if pos + copy_len > okm_len:
            copy_len = okm_len - pos

        j: int32 = 0
        while j < copy_len:
            okm[pos] = t[j]
            pos = pos + 1
            j = j + 1

        i = i + 1

    return CRYPTO_OK

# PBKDF2-SHA256
# password: password bytes
# pass_len: password length
# salt: salt bytes
# salt_len: salt length
# iterations: iteration count (recommend 100000+)
# output: derived key output
# output_len: desired output length
def crypto_pbkdf2_sha256(password: Ptr[uint8], pass_len: int32, salt: Ptr[uint8], salt_len: int32, iterations: int32, output: Ptr[uint8], output_len: int32) -> int32:
    if password == cast[Ptr[uint8]](0) or salt == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    if iterations < 1 or output_len < 1:
        return CRYPTO_ERR_INVALID_SIZE

    blocks_needed: int32 = (output_len + 31) / 32
    pos: int32 = 0
    block_num: int32 = 1

    salt_block: Array[1024, uint8]
    i: int32 = 0
    while i < salt_len and i < 1020:
        salt_block[i] = salt[i]
        i = i + 1

    while block_num <= blocks_needed:
        # Append block number as big-endian
        salt_block[salt_len] = cast[uint8]((block_num / 16777216) & 0xFF)
        salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) & 0xFF)
        salt_block[salt_len + 2] = cast[uint8]((block_num / 256) & 0xFF)
        salt_block[salt_len + 3] = cast[uint8](block_num & 0xFF)

        u: Array[32, uint8]
        result: Array[32, uint8]
        crypto_hmac_sha256(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

        i = 0
        while i < 32:
            result[i] = u[i]
            i = i + 1

        iter: int32 = 1
        while iter < iterations:
            crypto_hmac_sha256(password, pass_len, addr(u[0]), 32, addr(u[0]))
            i = 0
            while i < 32:
                result[i] = cast[uint8](cast[int32](result[i]) ^ cast[int32](u[i]))
                i = i + 1
            iter = iter + 1

        copy_len: int32 = 32
        if pos + copy_len > output_len:
            copy_len = output_len - pos

        i = 0
        while i < copy_len:
            output[pos] = result[i]
            pos = pos + 1
            i = i + 1

        block_num = block_num + 1

    return CRYPTO_OK

# ===========================================================================
# Encoding Utilities
# ===========================================================================

hex_chars: Ptr[uint8] = cast[Ptr[uint8]]("0123456789abcdef")

# Convert bytes to hex string
# input: bytes to encode
# len: number of bytes
# output: hex string output (must be 2*len + 1 bytes)
def crypto_to_hex(input: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    i: int32 = 0
    pos: int32 = 0
    while i < len:
        b: int32 = cast[int32](input[i])
        output[pos] = hex_chars[(b / 16) & 0x0F]
        output[pos + 1] = hex_chars[b & 0x0F]
        pos = pos + 2
        i = i + 1

    output[pos] = 0
    return pos

# Convert hex string to bytes
# input: hex string
# len: length of hex string (must be even)
# output: bytes output
# Returns: number of bytes written, or error
def crypto_from_hex(input: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return CRYPTO_ERR_NULL_PTR

    if (len & 1) != 0:
        return CRYPTO_ERR_INVALID_SIZE

    i: int32 = 0
    pos: int32 = 0

    while i < len:
        high: int32 = 0
        low: int32 = 0
        c: int32 = cast[int32](input[i])

        if c >= 48 and c <= 57:
            high = c - 48
        elif c >= 65 and c <= 70:
            high = c - 55
        elif c >= 97 and c <= 102:
            high = c - 87
        else:
            return CRYPTO_ERR_INVALID_SIZE

        c = cast[int32](input[i + 1])
        if c >= 48 and c <= 57:
            low = c - 48
        elif c >= 65 and c <= 70:
            low = c - 55
        elif c >= 97 and c <= 102:
            low = c - 87
        else:
            return CRYPTO_ERR_INVALID_SIZE

        output[pos] = cast[uint8]((high * 16) + low)
        pos = pos + 1
        i = i + 2

    return pos

# ===========================================================================
# Utility Functions
# ===========================================================================

# Constant-time comparison (prevents timing attacks)
# Returns: 1 if equal, 0 if not
def crypto_compare(a: Ptr[uint8], b: Ptr[uint8], len: int32) -> int32:
    if a == cast[Ptr[uint8]](0) or b == cast[Ptr[uint8]](0):
        return 0

    diff: int32 = 0
    i: int32 = 0
    while i < len:
        diff = diff | (cast[int32](a[i]) ^ cast[int32](b[i]))
        i = i + 1

    if diff == 0:
        return 1
    return 0

# Securely zero memory (prevents compiler optimization)
def crypto_zero(buf: Ptr[uint8], len: int32):
    if buf == cast[Ptr[uint8]](0):
        return

    i: int32 = 0
    while i < len:
        buf[i] = 0
        i = i + 1

    # Memory barrier to prevent optimization
    # (In practice, would use volatile or asm)
