# crypto.bh - Unified Cryptography Library for BrainhairOS
# High-level API that brings together all crypto primitives
#
# Provides:
# - Symmetric encryption (AES, ChaCha20)
# - AEAD encryption (ChaCha20-Poly1305, AES-GCM concept)
# - Hashing (SHA-256, SHA-512)
# - Message authentication (HMAC)
# - Key exchange (X25519)
# - Digital signatures (Ed25519)
# - Key derivation (HKDF, PBKDF2)
# - Random number generation
# - Base64/Hex encoding

import "lib/syscalls"

# ===========================================================================
# Crypto Constants
# ===========================================================================

# Key sizes in bytes
const CRYPTO_KEY_128: int32 = 16
const CRYPTO_KEY_192: int32 = 24
const CRYPTO_KEY_256: int32 = 32
const CRYPTO_KEY_512: int32 = 64

# Hash output sizes
const CRYPTO_SHA256_SIZE: int32 = 32
const CRYPTO_SHA512_SIZE: int32 = 64

# Signature/key sizes
const CRYPTO_ED25519_PUBKEY_SIZE: int32 = 32
const CRYPTO_ED25519_PRIVKEY_SIZE: int32 = 64
const CRYPTO_ED25519_SIGNATURE_SIZE: int32 = 64
const CRYPTO_X25519_KEY_SIZE: int32 = 32

# Nonce/IV sizes
const CRYPTO_AES_IV_SIZE: int32 = 16
const CRYPTO_CHACHA20_NONCE_SIZE: int32 = 12
const CRYPTO_POLY1305_TAG_SIZE: int32 = 16

# ===========================================================================
# Error Codes
# ===========================================================================

const CRYPTO_OK: int32 = 0
const CRYPTO_ERR_NULL_PTR: int32 = -1
const CRYPTO_ERR_INVALID_SIZE: int32 = -2
const CRYPTO_ERR_AUTH_FAILED: int32 = -3
const CRYPTO_ERR_KEY_INVALID: int32 = -4
const CRYPTO_ERR_BUFFER_TOO_SMALL: int32 = -5

# ===========================================================================
# External Functions from Kernel/Libraries
# ===========================================================================

# SHA-256
extern sha256_init(ctx: ptr uint8): int32
extern sha256_update(ctx: ptr uint8, data: ptr uint8, len: int32): int32
extern sha256_final(ctx: ptr uint8, output: ptr uint8): int32
extern sha256_hash(data: ptr uint8, len: int32, output: ptr uint8): int32

# SHA-512 syscalls
proc sha512_init_syscall(ctx: ptr uint8): int32 =
  return syscall3(260, cast[int32](ctx), 0, 0)

proc sha512_update_syscall(ctx: ptr uint8, data: ptr uint8, len: int32): int32 =
  return syscall3(261, cast[int32](ctx), cast[int32](data), len)

proc sha512_final_syscall(ctx: ptr uint8, output: ptr uint8): int32 =
  return syscall3(262, cast[int32](ctx), cast[int32](output), 0)

# AES
extern aes_set_key(ctx: ptr uint8, key: ptr uint8, key_len: int32): int32
extern aes_encrypt_block(ctx: ptr uint8, input: ptr uint8, output: ptr uint8): int32
extern aes_decrypt_block(ctx: ptr uint8, input: ptr uint8, output: ptr uint8): int32

# ChaCha20
extern chacha20_init(ctx: ptr uint8, key: ptr uint8, nonce: ptr uint8, counter: int32): int32
extern chacha20_encrypt(ctx: ptr uint8, plaintext: ptr uint8, ciphertext: ptr uint8, len: int32): int32

# Poly1305
extern poly1305_init(ctx: ptr uint8, key: ptr uint8): int32
extern poly1305_update(ctx: ptr uint8, data: ptr uint8, len: int32): int32
extern poly1305_final(ctx: ptr uint8, tag: ptr uint8): int32

# X25519
proc x25519_keygen_syscall(private_key: ptr uint8, public_key: ptr uint8): int32 =
  return syscall2(240, cast[int32](private_key), cast[int32](public_key))

proc x25519_shared_syscall(shared: ptr uint8, private: ptr uint8, public: ptr uint8): int32 =
  return syscall3(241, cast[int32](shared), cast[int32](private), cast[int32](public))

# Ed25519
proc ed25519_keygen_syscall(seed: ptr uint8, public: ptr uint8, private: ptr uint8): int32 =
  return syscall3(270, cast[int32](seed), cast[int32](public), cast[int32](private))

proc ed25519_sign_syscall(sig: ptr uint8, msg: ptr uint8, msg_len: int32, priv: ptr uint8): int32 =
  return syscall4(271, cast[int32](sig), cast[int32](msg), msg_len, cast[int32](priv))

proc ed25519_verify_syscall(sig: ptr uint8, msg: ptr uint8, msg_len: int32, pub: ptr uint8): int32 =
  return syscall4(272, cast[int32](sig), cast[int32](msg), msg_len, cast[int32](pub))

# Random
proc getrandom_syscall(buf: ptr uint8, len: int32): int32 =
  return syscall2(80, cast[int32](buf), len)

# ===========================================================================
# Hash Functions
# ===========================================================================

# One-shot SHA-256 hash
proc crypto_sha256(data: ptr uint8, len: int32, output: ptr uint8): int32 =
  if data == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR
  return sha256_hash(data, len, output)

# One-shot SHA-512 hash
proc crypto_sha512(data: ptr uint8, len: int32, output: ptr uint8): int32 =
  if data == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var ctx: array[256, uint8]
  sha512_init_syscall(addr(ctx[0]))
  sha512_update_syscall(addr(ctx[0]), data, len)
  return sha512_final_syscall(addr(ctx[0]), output)

# ===========================================================================
# HMAC Functions
# ===========================================================================

# HMAC-SHA256
proc crypto_hmac_sha256(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, output: ptr uint8): int32 =
  if key == cast[ptr uint8](0) or data == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var ipad: array[64, uint8]
  var opad: array[64, uint8]
  var key_block: array[64, uint8]
  var i: int32 = 0

  # Prepare key block
  if key_len > 64:
    sha256_hash(key, key_len, addr(key_block[0]))
    i = 32
    while i < 64:
      key_block[i] = 0
      i = i + 1
  else:
    i = 0
    while i < key_len:
      key_block[i] = key[i]
      i = i + 1
    while i < 64:
      key_block[i] = 0
      i = i + 1

  # Create ipad and opad
  i = 0
  while i < 64:
    ipad[i] = cast[uint8](cast[int32](key_block[i]) xor 0x36)
    opad[i] = cast[uint8](cast[int32](key_block[i]) xor 0x5c)
    i = i + 1

  # Inner hash
  var ctx: array[128, uint8]
  var inner_hash: array[32, uint8]
  sha256_init(addr(ctx[0]))
  sha256_update(addr(ctx[0]), addr(ipad[0]), 64)
  sha256_update(addr(ctx[0]), data, data_len)
  sha256_final(addr(ctx[0]), addr(inner_hash[0]))

  # Outer hash
  sha256_init(addr(ctx[0]))
  sha256_update(addr(ctx[0]), addr(opad[0]), 64)
  sha256_update(addr(ctx[0]), addr(inner_hash[0]), 32)
  sha256_final(addr(ctx[0]), output)

  return CRYPTO_OK

# HMAC-SHA512
proc crypto_hmac_sha512(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, output: ptr uint8): int32 =
  if key == cast[ptr uint8](0) or data == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var ipad: array[128, uint8]
  var opad: array[128, uint8]
  var key_block: array[128, uint8]
  var i: int32 = 0

  # Prepare key block
  if key_len > 128:
    crypto_sha512(key, key_len, addr(key_block[0]))
    i = 64
    while i < 128:
      key_block[i] = 0
      i = i + 1
  else:
    i = 0
    while i < key_len:
      key_block[i] = key[i]
      i = i + 1
    while i < 128:
      key_block[i] = 0
      i = i + 1

  i = 0
  while i < 128:
    ipad[i] = cast[uint8](cast[int32](key_block[i]) xor 0x36)
    opad[i] = cast[uint8](cast[int32](key_block[i]) xor 0x5c)
    i = i + 1

  var ctx: array[256, uint8]
  var inner_hash: array[64, uint8]
  sha512_init_syscall(addr(ctx[0]))
  sha512_update_syscall(addr(ctx[0]), addr(ipad[0]), 128)
  sha512_update_syscall(addr(ctx[0]), data, data_len)
  sha512_final_syscall(addr(ctx[0]), addr(inner_hash[0]))

  sha512_init_syscall(addr(ctx[0]))
  sha512_update_syscall(addr(ctx[0]), addr(opad[0]), 128)
  sha512_update_syscall(addr(ctx[0]), addr(inner_hash[0]), 64)
  sha512_final_syscall(addr(ctx[0]), output)

  return CRYPTO_OK

# ===========================================================================
# Random Number Generation
# ===========================================================================

# Fill buffer with cryptographically secure random bytes
proc crypto_random_bytes(buf: ptr uint8, len: int32): int32 =
  if buf == cast[ptr uint8](0) or len <= 0:
    return CRYPTO_ERR_NULL_PTR
  return getrandom_syscall(buf, len)

# Generate a random 32-bit integer
proc crypto_random_int(): int32 =
  var buf: array[4, uint8]
  getrandom_syscall(addr(buf[0]), 4)
  return cast[int32](buf[0]) or (cast[int32](buf[1]) * 256) or (cast[int32](buf[2]) * 65536) or (cast[int32](buf[3]) * 16777216)

# Generate a random integer in range [0, max)
proc crypto_random_range(max: int32): int32 =
  if max <= 0:
    return 0
  var r: int32 = crypto_random_int()
  if r < 0:
    r = 0 - r  # Make positive
  return r mod max

# ===========================================================================
# Key Exchange (X25519)
# ===========================================================================

# Generate X25519 key pair
# private_key: 32-byte buffer for private key
# public_key: 32-byte buffer for public key
proc crypto_x25519_keypair(private_key: ptr uint8, public_key: ptr uint8): int32 =
  if private_key == cast[ptr uint8](0) or public_key == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR
  return x25519_keygen_syscall(private_key, public_key)

# Compute X25519 shared secret
# shared: 32-byte buffer for shared secret
# private_key: our 32-byte private key
# public_key: their 32-byte public key
proc crypto_x25519_shared(shared: ptr uint8, private_key: ptr uint8, public_key: ptr uint8): int32 =
  if shared == cast[ptr uint8](0) or private_key == cast[ptr uint8](0) or public_key == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR
  return x25519_shared_syscall(shared, private_key, public_key)

# ===========================================================================
# Digital Signatures (Ed25519)
# ===========================================================================

# Generate Ed25519 key pair
# seed: 32-byte random seed (or null to auto-generate)
# public_key: 32-byte buffer for public key
# private_key: 64-byte buffer for private key (seed || public_key)
proc crypto_ed25519_keypair(seed: ptr uint8, public_key: ptr uint8, private_key: ptr uint8): int32 =
  if public_key == cast[ptr uint8](0) or private_key == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var actual_seed: array[32, uint8]
  if seed == cast[ptr uint8](0):
    getrandom_syscall(addr(actual_seed[0]), 32)
    return ed25519_keygen_syscall(addr(actual_seed[0]), public_key, private_key)
  else:
    return ed25519_keygen_syscall(seed, public_key, private_key)

# Sign a message with Ed25519
# signature: 64-byte buffer for signature
# message: message to sign
# message_len: length of message
# private_key: 64-byte private key
proc crypto_ed25519_sign(signature: ptr uint8, message: ptr uint8, message_len: int32, private_key: ptr uint8): int32 =
  if signature == cast[ptr uint8](0) or message == cast[ptr uint8](0) or private_key == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR
  return ed25519_sign_syscall(signature, message, message_len, private_key)

# Verify an Ed25519 signature
# Returns: CRYPTO_OK if valid, CRYPTO_ERR_AUTH_FAILED if invalid
proc crypto_ed25519_verify(signature: ptr uint8, message: ptr uint8, message_len: int32, public_key: ptr uint8): int32 =
  if signature == cast[ptr uint8](0) or message == cast[ptr uint8](0) or public_key == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var result: int32 = ed25519_verify_syscall(signature, message, message_len, public_key)
  if result == 1:
    return CRYPTO_OK
  return CRYPTO_ERR_AUTH_FAILED

# ===========================================================================
# Symmetric Encryption (ChaCha20)
# ===========================================================================

# ChaCha20 encryption (same as decryption - XOR cipher)
# key: 32-byte key
# nonce: 12-byte nonce (must be unique per message with same key!)
# input: plaintext or ciphertext
# output: ciphertext or plaintext
# len: length of data
proc crypto_chacha20(key: ptr uint8, nonce: ptr uint8, input: ptr uint8, output: ptr uint8, len: int32): int32 =
  if key == cast[ptr uint8](0) or nonce == cast[ptr uint8](0) or input == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var ctx: array[128, uint8]
  chacha20_init(addr(ctx[0]), key, nonce, 1)
  chacha20_encrypt(addr(ctx[0]), input, output, len)
  return CRYPTO_OK

# ===========================================================================
# AEAD Encryption (ChaCha20-Poly1305)
# ===========================================================================

# Authenticated encryption with ChaCha20-Poly1305
# key: 32-byte key
# nonce: 12-byte nonce (must be unique!)
# plaintext: data to encrypt
# plaintext_len: length of plaintext
# aad: additional authenticated data (can be null)
# aad_len: length of AAD
# ciphertext: output buffer (must be plaintext_len + 16 bytes for tag)
# Returns: length of ciphertext (plaintext_len + 16) on success
proc crypto_aead_encrypt(key: ptr uint8, nonce: ptr uint8, plaintext: ptr uint8, plaintext_len: int32, aad: ptr uint8, aad_len: int32, ciphertext: ptr uint8): int32 =
  if key == cast[ptr uint8](0) or nonce == cast[ptr uint8](0) or plaintext == cast[ptr uint8](0) or ciphertext == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  # Generate Poly1305 key from ChaCha20 with counter=0
  var poly_key: array[32, uint8]
  var zero_block: array[64, uint8]
  var poly_ctx: array[128, uint8]
  var i: int32 = 0
  while i < 64:
    zero_block[i] = 0
    i = i + 1

  var chacha_ctx: array[128, uint8]
  chacha20_init(addr(chacha_ctx[0]), key, nonce, 0)
  chacha20_encrypt(addr(chacha_ctx[0]), addr(zero_block[0]), addr(poly_key[0]), 32)

  # Encrypt with ChaCha20 (counter=1)
  chacha20_init(addr(chacha_ctx[0]), key, nonce, 1)
  chacha20_encrypt(addr(chacha_ctx[0]), plaintext, ciphertext, plaintext_len)

  # Compute Poly1305 tag over AAD and ciphertext
  poly1305_init(addr(poly_ctx[0]), addr(poly_key[0]))

  # Add AAD with padding
  if aad != cast[ptr uint8](0) and aad_len > 0:
    poly1305_update(addr(poly_ctx[0]), aad, aad_len)
    # Pad to 16 bytes
    var pad_len: int32 = (16 - (aad_len mod 16)) mod 16
    var padding: array[16, uint8]
    i = 0
    while i < 16:
      padding[i] = 0
      i = i + 1
    if pad_len > 0:
      poly1305_update(addr(poly_ctx[0]), addr(padding[0]), pad_len)

  # Add ciphertext with padding
  poly1305_update(addr(poly_ctx[0]), ciphertext, plaintext_len)
  var ct_pad_len: int32 = (16 - (plaintext_len mod 16)) mod 16
  var ct_padding: array[16, uint8]
  i = 0
  while i < 16:
    ct_padding[i] = 0
    i = i + 1
  if ct_pad_len > 0:
    poly1305_update(addr(poly_ctx[0]), addr(ct_padding[0]), ct_pad_len)

  # Add lengths (little-endian 64-bit)
  var lengths: array[16, uint8]
  i = 0
  while i < 16:
    lengths[i] = 0
    i = i + 1
  lengths[0] = cast[uint8](aad_len and 0xFF)
  lengths[1] = cast[uint8]((aad_len / 256) and 0xFF)
  lengths[2] = cast[uint8]((aad_len / 65536) and 0xFF)
  lengths[3] = cast[uint8]((aad_len / 16777216) and 0xFF)
  lengths[8] = cast[uint8](plaintext_len and 0xFF)
  lengths[9] = cast[uint8]((plaintext_len / 256) and 0xFF)
  lengths[10] = cast[uint8]((plaintext_len / 65536) and 0xFF)
  lengths[11] = cast[uint8]((plaintext_len / 16777216) and 0xFF)
  poly1305_update(addr(poly_ctx[0]), addr(lengths[0]), 16)

  # Append tag to ciphertext
  poly1305_final(addr(poly_ctx[0]), addr(ciphertext[plaintext_len]))

  return plaintext_len + 16

# Authenticated decryption with ChaCha20-Poly1305
# key: 32-byte key
# nonce: 12-byte nonce
# ciphertext: encrypted data with 16-byte tag at end
# ciphertext_len: total length including tag
# aad: additional authenticated data
# aad_len: length of AAD
# plaintext: output buffer (ciphertext_len - 16 bytes)
# Returns: length of plaintext on success, CRYPTO_ERR_AUTH_FAILED if tag invalid
proc crypto_aead_decrypt(key: ptr uint8, nonce: ptr uint8, ciphertext: ptr uint8, ciphertext_len: int32, aad: ptr uint8, aad_len: int32, plaintext: ptr uint8): int32 =
  if key == cast[ptr uint8](0) or nonce == cast[ptr uint8](0) or ciphertext == cast[ptr uint8](0) or plaintext == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  if ciphertext_len < 16:
    return CRYPTO_ERR_INVALID_SIZE

  var data_len: int32 = ciphertext_len - 16

  # Generate Poly1305 key
  var poly_key: array[32, uint8]
  var zero_block: array[64, uint8]
  var poly_ctx: array[128, uint8]
  var i: int32 = 0
  while i < 64:
    zero_block[i] = 0
    i = i + 1

  var chacha_ctx: array[128, uint8]
  chacha20_init(addr(chacha_ctx[0]), key, nonce, 0)
  chacha20_encrypt(addr(chacha_ctx[0]), addr(zero_block[0]), addr(poly_key[0]), 32)

  # Compute expected tag
  poly1305_init(addr(poly_ctx[0]), addr(poly_key[0]))

  if aad != cast[ptr uint8](0) and aad_len > 0:
    poly1305_update(addr(poly_ctx[0]), aad, aad_len)
    var pad_len: int32 = (16 - (aad_len mod 16)) mod 16
    var padding: array[16, uint8]
    i = 0
    while i < 16:
      padding[i] = 0
      i = i + 1
    if pad_len > 0:
      poly1305_update(addr(poly_ctx[0]), addr(padding[0]), pad_len)

  poly1305_update(addr(poly_ctx[0]), ciphertext, data_len)
  var ct_pad_len: int32 = (16 - (data_len mod 16)) mod 16
  var ct_padding: array[16, uint8]
  i = 0
  while i < 16:
    ct_padding[i] = 0
    i = i + 1
  if ct_pad_len > 0:
    poly1305_update(addr(poly_ctx[0]), addr(ct_padding[0]), ct_pad_len)

  var lengths: array[16, uint8]
  i = 0
  while i < 16:
    lengths[i] = 0
    i = i + 1
  lengths[0] = cast[uint8](aad_len and 0xFF)
  lengths[1] = cast[uint8]((aad_len / 256) and 0xFF)
  lengths[2] = cast[uint8]((aad_len / 65536) and 0xFF)
  lengths[3] = cast[uint8]((aad_len / 16777216) and 0xFF)
  lengths[8] = cast[uint8](data_len and 0xFF)
  lengths[9] = cast[uint8]((data_len / 256) and 0xFF)
  lengths[10] = cast[uint8]((data_len / 65536) and 0xFF)
  lengths[11] = cast[uint8]((data_len / 16777216) and 0xFF)
  poly1305_update(addr(poly_ctx[0]), addr(lengths[0]), 16)

  var expected_tag: array[16, uint8]
  poly1305_final(addr(poly_ctx[0]), addr(expected_tag[0]))

  # Constant-time tag comparison
  var diff: int32 = 0
  i = 0
  while i < 16:
    diff = diff or (cast[int32](ciphertext[data_len + i]) xor cast[int32](expected_tag[i]))
    i = i + 1

  if diff != 0:
    return CRYPTO_ERR_AUTH_FAILED

  # Decrypt
  chacha20_init(addr(chacha_ctx[0]), key, nonce, 1)
  chacha20_encrypt(addr(chacha_ctx[0]), ciphertext, plaintext, data_len)

  return data_len

# ===========================================================================
# Key Derivation
# ===========================================================================

# HKDF-SHA256 one-shot
# salt: optional salt (can be null)
# salt_len: salt length
# ikm: input keying material
# ikm_len: IKM length
# info: optional context info
# info_len: info length
# okm: output keying material
# okm_len: desired output length (max 8160)
proc crypto_hkdf_sha256(salt: ptr uint8, salt_len: int32, ikm: ptr uint8, ikm_len: int32, info: ptr uint8, info_len: int32, okm: ptr uint8, okm_len: int32): int32 =
  if ikm == cast[ptr uint8](0) or okm == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  if okm_len <= 0 or okm_len > 8160:
    return CRYPTO_ERR_INVALID_SIZE

  # Extract
  var prk: array[32, uint8]
  var zero_salt: array[32, uint8]
  var actual_salt: ptr uint8 = salt
  var actual_salt_len: int32 = salt_len

  if salt == cast[ptr uint8](0) or salt_len == 0:
    var i: int32 = 0
    while i < 32:
      zero_salt[i] = 0
      i = i + 1
    actual_salt = addr(zero_salt[0])
    actual_salt_len = 32

  crypto_hmac_sha256(actual_salt, actual_salt_len, ikm, ikm_len, addr(prk[0]))

  # Expand
  var t: array[32, uint8]
  var t_len: int32 = 0
  var pos: int32 = 0
  var n: int32 = (okm_len + 31) / 32
  var i: int32 = 1

  while i <= n:
    # Build input: T(i-1) || info || counter
    var input: array[256, uint8]
    var input_len: int32 = 0

    if t_len > 0:
      var j: int32 = 0
      while j < t_len:
        input[input_len] = t[j]
        input_len = input_len + 1
        j = j + 1

    if info != cast[ptr uint8](0) and info_len > 0:
      var j: int32 = 0
      while j < info_len and input_len < 250:
        input[input_len] = info[j]
        input_len = input_len + 1
        j = j + 1

    input[input_len] = cast[uint8](i)
    input_len = input_len + 1

    crypto_hmac_sha256(addr(prk[0]), 32, addr(input[0]), input_len, addr(t[0]))
    t_len = 32

    var copy_len: int32 = 32
    if pos + copy_len > okm_len:
      copy_len = okm_len - pos

    var j: int32 = 0
    while j < copy_len:
      okm[pos] = t[j]
      pos = pos + 1
      j = j + 1

    i = i + 1

  return CRYPTO_OK

# PBKDF2-SHA256
# password: password bytes
# pass_len: password length
# salt: salt bytes
# salt_len: salt length
# iterations: iteration count (recommend 100000+)
# output: derived key output
# output_len: desired output length
proc crypto_pbkdf2_sha256(password: ptr uint8, pass_len: int32, salt: ptr uint8, salt_len: int32, iterations: int32, output: ptr uint8, output_len: int32): int32 =
  if password == cast[ptr uint8](0) or salt == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  if iterations < 1 or output_len < 1:
    return CRYPTO_ERR_INVALID_SIZE

  var blocks_needed: int32 = (output_len + 31) / 32
  var pos: int32 = 0
  var block_num: int32 = 1

  var salt_block: array[1024, uint8]
  var i: int32 = 0
  while i < salt_len and i < 1020:
    salt_block[i] = salt[i]
    i = i + 1

  while block_num <= blocks_needed:
    # Append block number as big-endian
    salt_block[salt_len] = cast[uint8]((block_num / 16777216) and 0xFF)
    salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) and 0xFF)
    salt_block[salt_len + 2] = cast[uint8]((block_num / 256) and 0xFF)
    salt_block[salt_len + 3] = cast[uint8](block_num and 0xFF)

    var u: array[32, uint8]
    var result: array[32, uint8]
    crypto_hmac_sha256(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

    i = 0
    while i < 32:
      result[i] = u[i]
      i = i + 1

    var iter: int32 = 1
    while iter < iterations:
      crypto_hmac_sha256(password, pass_len, addr(u[0]), 32, addr(u[0]))
      i = 0
      while i < 32:
        result[i] = cast[uint8](cast[int32](result[i]) xor cast[int32](u[i]))
        i = i + 1
      iter = iter + 1

    var copy_len: int32 = 32
    if pos + copy_len > output_len:
      copy_len = output_len - pos

    i = 0
    while i < copy_len:
      output[pos] = result[i]
      pos = pos + 1
      i = i + 1

    block_num = block_num + 1

  return CRYPTO_OK

# ===========================================================================
# Encoding Utilities
# ===========================================================================

var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789abcdef")

# Convert bytes to hex string
# input: bytes to encode
# len: number of bytes
# output: hex string output (must be 2*len + 1 bytes)
proc crypto_to_hex(input: ptr uint8, len: int32, output: ptr uint8): int32 =
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  var i: int32 = 0
  var pos: int32 = 0
  while i < len:
    var b: int32 = cast[int32](input[i])
    output[pos] = hex_chars[(b / 16) and 0x0F]
    output[pos + 1] = hex_chars[b and 0x0F]
    pos = pos + 2
    i = i + 1

  output[pos] = 0
  return pos

# Convert hex string to bytes
# input: hex string
# len: length of hex string (must be even)
# output: bytes output
# Returns: number of bytes written, or error
proc crypto_from_hex(input: ptr uint8, len: int32, output: ptr uint8): int32 =
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return CRYPTO_ERR_NULL_PTR

  if (len and 1) != 0:
    return CRYPTO_ERR_INVALID_SIZE

  var i: int32 = 0
  var pos: int32 = 0

  while i < len:
    var high: int32 = 0
    var low: int32 = 0
    var c: int32 = cast[int32](input[i])

    if c >= 48 and c <= 57:
      high = c - 48
    elif c >= 65 and c <= 70:
      high = c - 55
    elif c >= 97 and c <= 102:
      high = c - 87
    else:
      return CRYPTO_ERR_INVALID_SIZE

    c = cast[int32](input[i + 1])
    if c >= 48 and c <= 57:
      low = c - 48
    elif c >= 65 and c <= 70:
      low = c - 55
    elif c >= 97 and c <= 102:
      low = c - 87
    else:
      return CRYPTO_ERR_INVALID_SIZE

    output[pos] = cast[uint8]((high * 16) + low)
    pos = pos + 1
    i = i + 2

  return pos

# ===========================================================================
# Utility Functions
# ===========================================================================

# Constant-time comparison (prevents timing attacks)
# Returns: 1 if equal, 0 if not
proc crypto_compare(a: ptr uint8, b: ptr uint8, len: int32): int32 =
  if a == cast[ptr uint8](0) or b == cast[ptr uint8](0):
    return 0

  var diff: int32 = 0
  var i: int32 = 0
  while i < len:
    diff = diff or (cast[int32](a[i]) xor cast[int32](b[i]))
    i = i + 1

  if diff == 0:
    return 1
  return 0

# Securely zero memory (prevents compiler optimization)
proc crypto_zero(buf: ptr uint8, len: int32) =
  if buf == cast[ptr uint8](0):
    return

  var i: int32 = 0
  while i < len:
    buf[i] = 0
    i = i + 1

  # Memory barrier to prevent optimization
  # (In practice, would use volatile or asm)
