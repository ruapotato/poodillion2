from lib.syscalls import *

RSA_1024_LIMBS: Final[int32] = 32

RSA_2048_LIMBS: Final[int32] = 64

RSA_MAX_LIMBS: Final[int32] = 64

RSA_E_65537: Final[int32] = 65537

RSA_OK: int32 = 0

RSA_ERR_NULL: int32 = (0 - 1)

RSA_ERR_SIZE: int32 = (0 - 2)

RSA_ERR_PADDING: int32 = (0 - 3)

RSA_ERR_OVERFLOW: int32 = (0 - 4)

def bigint_zero(a: Ptr[int32], limbs: int32):
    i: int32 = 0
    while (i < limbs):
        a[i] = 0
        i = (i + 1)

def bigint_copy(dest: Ptr[int32], src: Ptr[int32], limbs: int32):
    i: int32 = 0
    while (i < limbs):
        dest[i] = src[i]
        i = (i + 1)

def bigint_cmp(a: Ptr[int32], b: Ptr[int32], limbs: int32) -> int32:
    i: int32 = (limbs - 1)
    while (i >= 0):
        av: int32 = a[i]
        bv: int32 = b[i]
        a_hi: int32 = 0
        b_hi: int32 = 0
        if (av < 0):
            a_hi = 1
        if (bv < 0):
            b_hi = 1
        if (a_hi > b_hi):
            return 1
        if (a_hi < b_hi):
            return -1
        a_low: int32 = (av & 2147483647)
        b_low: int32 = (bv & 2147483647)
        if (a_low > b_low):
            return 1
        if (a_low < b_low):
            return -1
        i = (i - 1)
    return 0

def bigint_add(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], limbs: int32) -> int32:
    carry: int32 = 0
    i: int32 = 0
    while (i < limbs):
        av: int32 = a[i]
        bv: int32 = b[i]
        a_lo: int32 = (av & 65535)
        a_hi: int32 = ((av / 65536) & 65535)
        b_lo: int32 = (bv & 65535)
        b_hi: int32 = ((bv / 65536) & 65535)
        sum_lo: int32 = ((a_lo + b_lo) + carry)
        carry = (sum_lo / 65536)
        sum_lo = (sum_lo & 65535)
        sum_hi: int32 = ((a_hi + b_hi) + carry)
        carry = (sum_hi / 65536)
        sum_hi = (sum_hi & 65535)
        result[i] = (sum_lo + (sum_hi * 65536))
        i = (i + 1)
    return carry

def bigint_sub(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], limbs: int32) -> int32:
    borrow: int32 = 0
    i: int32 = 0
    while (i < limbs):
        av: int32 = a[i]
        bv: int32 = b[i]
        a_lo: int32 = (av & 65535)
        a_hi: int32 = ((av / 65536) & 65535)
        b_lo: int32 = (bv & 65535)
        b_hi: int32 = ((bv / 65536) & 65535)
        diff_lo: int32 = ((a_lo - b_lo) - borrow)
        if (diff_lo < 0):
            diff_lo = (diff_lo + 65536)
            borrow = 1
        else:
            borrow = 0
        diff_hi: int32 = ((a_hi - b_hi) - borrow)
        if (diff_hi < 0):
            diff_hi = (diff_hi + 65536)
            borrow = 1
        else:
            borrow = 0
        result[i] = (diff_lo + (diff_hi * 65536))
        i = (i + 1)
    return borrow

def bigint_shl1(a: Ptr[int32], limbs: int32) -> int32:
    carry: int32 = 0
    i: int32 = 0
    while (i < limbs):
        val: int32 = a[i]
        new_carry: int32 = 0
        if (val < 0):
            new_carry = 1
        low: int32 = (val & 2147483647)
        shifted: int32 = ((low * 2) + carry)
        a[i] = shifted
        carry = new_carry
        i = (i + 1)
    return carry

def bigint_shr1(a: Ptr[int32], limbs: int32):
    carry: int32 = 0
    i: int32 = (limbs - 1)
    while (i >= 0):
        val: int32 = a[i]
        new_carry: int32 = (val & 1)
        shifted: int32 = 0
        if (val >= 0):
            shifted = (val / 2)
        else:
            shifted = (((val & 2147483647) / 2) + 1073741824)
        shifted = (shifted + (carry * 1073741824))
        a[i] = shifted
        carry = new_carry
        i = (i - 1)

def bigint_is_zero(a: Ptr[int32], limbs: int32) -> int32:
    i: int32 = 0
    while (i < limbs):
        if (a[i] != 0):
            return 0
        i = (i + 1)
    return 1

def bigint_is_odd(a: Ptr[int32]) -> int32:
    return (a[0] & 1)

mod_tmp1: Array[65, int32]

mod_tmp2: Array[65, int32]

mod_tmp3: Array[130, int32]

def bigint_mod(result: Ptr[int32], a: Ptr[int32], n: Ptr[int32], limbs: int32):
    bigint_copy(result, a, limbs)
    while (bigint_cmp(result, n, limbs) >= 0):
        pass
        bigint_sub(result, result, n, limbs)

def bigint_addmod(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], n: Ptr[int32], limbs: int32):
    carry: int32 = bigint_add(result, a, b, limbs)
    while ((carry != 0) or (bigint_cmp(result, n, limbs) >= 0)):
        pass
        bigint_sub(result, result, n, limbs)
        carry = 0

def bigint_submod(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], n: Ptr[int32], limbs: int32):
    borrow: int32 = bigint_sub(result, a, b, limbs)
    if (borrow != 0):
        pass
        bigint_add(result, result, n, limbs)

def limb_mul(a: int32, b: int32, lo_out: Ptr[int32], hi_out: Ptr[int32]):
    a_lo: int32 = (a & 65535)
    a_hi: int32 = ((a / 65536) & 65535)
    b_lo: int32 = (b & 65535)
    b_hi: int32 = ((b / 65536) & 65535)
    ll: int32 = (a_lo * b_lo)
    lh: int32 = (a_lo * b_hi)
    hl: int32 = (a_hi * b_lo)
    hh: int32 = (a_hi * b_hi)
    mid: int32 = (lh + hl)
    mid_lo: int32 = (mid & 65535)
    mid_hi: int32 = ((mid / 65536) & 65535)
    if (mid < lh):
        mid_hi = (mid_hi + 1)
    lo: int32 = (ll + (mid_lo * 65536))
    carry: int32 = 0
    ll_hi: int32 = (ll / 65536)
    if ((ll_hi + mid_lo) >= 65536):
        carry = 1
    hi: int32 = ((hh + mid_hi) + carry)
    lo_out[0] = lo
    hi_out[0] = hi

def bigint_mul(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], limbs: int32):
    i: int32 = 0
    j: int32 = 0
    i = 0
    while (i < (limbs * 2)):
        result[i] = 0
        i = (i + 1)
    i = 0
    while (i < limbs):
        carry: int32 = 0
        j = 0
        while (j < limbs):
            lo: int32 = 0
            hi: int32 = 0
            limb_mul(a[i], b[j], addr(lo), addr(hi))
            pos: int32 = (i + j)
            sum: int32 = result[pos]
            lo_sum: int32 = ((lo + sum) + carry)
            new_carry: int32 = hi
            if ((lo_sum < lo) or (lo_sum < sum)):
                new_carry = (new_carry + 1)
            result[pos] = lo_sum
            carry = new_carry
            j = (j + 1)
        result[(i + limbs)] = (result[(i + limbs)] + carry)
        i = (i + 1)

def bigint_mulmod(result: Ptr[int32], a: Ptr[int32], b: Ptr[int32], n: Ptr[int32], limbs: int32):
    bigint_mul(addr(mod_tmp3[0]), a, b, limbs)
    bigint_copy(result, addr(mod_tmp3[0]), limbs)
    i: int32 = 0
    while (i < 1000):
        if (bigint_cmp(result, n, limbs) < 0):
            break
        pass
        bigint_sub(result, result, n, limbs)
        i = (i + 1)

exp_base: Array[65, int32]

exp_result: Array[65, int32]

exp_tmp: Array[65, int32]

def bigint_powmod(result: Ptr[int32], base: Ptr[int32], exp: Ptr[int32], n: Ptr[int32], limbs: int32):
    bigint_zero(result, limbs)
    result[0] = 1
    bigint_copy(addr(exp_base[0]), base, limbs)
    bigint_copy(addr(exp_tmp[0]), exp, limbs)
    while (bigint_is_zero(addr(exp_tmp[0]), limbs) == 0):
        if (bigint_is_odd(addr(exp_tmp[0])) == 1):
            bigint_mulmod(addr(exp_result[0]), result, addr(exp_base[0]), n, limbs)
            bigint_copy(result, addr(exp_result[0]), limbs)
        bigint_mulmod(addr(exp_result[0]), addr(exp_base[0]), addr(exp_base[0]), n, limbs)
        bigint_copy(addr(exp_base[0]), addr(exp_result[0]), limbs)
        bigint_shr1(addr(exp_tmp[0]), limbs)

def bigint_powmod_small(result: Ptr[int32], base: Ptr[int32], exp_val: int32, n: Ptr[int32], limbs: int32):
    bigint_zero(result, limbs)
    result[0] = 1
    bigint_copy(addr(exp_base[0]), base, limbs)
    e: int32 = exp_val
    while (e > 0):
        if ((e & 1) == 1):
            bigint_mulmod(addr(exp_result[0]), result, addr(exp_base[0]), n, limbs)
            bigint_copy(result, addr(exp_result[0]), limbs)
        bigint_mulmod(addr(exp_result[0]), addr(exp_base[0]), addr(exp_base[0]), n, limbs)
        bigint_copy(addr(exp_base[0]), addr(exp_result[0]), limbs)
        e = (e / 2)

rsa_n: Array[65, int32]

rsa_e: int32 = 65537

rsa_d: Array[65, int32]

rsa_limbs: int32 = 32

def rsa_load_n(data: Ptr[uint8], len: int32) -> int32:
    if (len > 256):
        return RSA_ERR_SIZE
    rsa_limbs = ((len + 3) / 4)
    if (rsa_limbs > RSA_MAX_LIMBS):
        rsa_limbs = RSA_MAX_LIMBS
    bigint_zero(addr(rsa_n[0]), rsa_limbs)
    i: int32 = 0
    byte_pos: int32 = (len - 1)
    while (byte_pos >= 0):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        rsa_n[limb_idx] = (rsa_n[limb_idx] + (cast[int32](data[byte_pos]) * (1 << shift)))
        i = (i + 1)
        byte_pos = (byte_pos - 1)
    return RSA_OK

def rsa_load_d(data: Ptr[uint8], len: int32) -> int32:
    if (len > 256):
        return RSA_ERR_SIZE
    bigint_zero(addr(rsa_d[0]), rsa_limbs)
    i: int32 = 0
    byte_pos: int32 = (len - 1)
    while (byte_pos >= 0):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        if (limb_idx < rsa_limbs):
            rsa_d[limb_idx] = (rsa_d[limb_idx] + (cast[int32](data[byte_pos]) * (1 << shift)))
        i = (i + 1)
        byte_pos = (byte_pos - 1)
    return RSA_OK

def rsa_set_e(e: int32):
    rsa_e = e

rsa_msg: Array[65, int32]

rsa_result: Array[65, int32]

def rsa_public(output: Ptr[uint8], input: Ptr[uint8], len: int32) -> int32:
    if (len > (rsa_limbs * 4)):
        return RSA_ERR_SIZE
    bigint_zero(addr(rsa_msg[0]), rsa_limbs)
    i: int32 = 0
    byte_pos: int32 = (len - 1)
    while (byte_pos >= 0):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        if (limb_idx < rsa_limbs):
            rsa_msg[limb_idx] = (rsa_msg[limb_idx] + (cast[int32](input[byte_pos]) * (1 << shift)))
        i = (i + 1)
        byte_pos = (byte_pos - 1)
    bigint_powmod_small(addr(rsa_result[0]), addr(rsa_msg[0]), rsa_e, addr(rsa_n[0]), rsa_limbs)
    out_len: int32 = (rsa_limbs * 4)
    i = 0
    while (i < out_len):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        byte_val: int32 = ((rsa_result[limb_idx] / (1 << shift)) & 255)
        output[((out_len - 1) - i)] = cast[uint8](byte_val)
        i = (i + 1)
    return out_len

def rsa_private(output: Ptr[uint8], input: Ptr[uint8], len: int32) -> int32:
    if (len > (rsa_limbs * 4)):
        return RSA_ERR_SIZE
    bigint_zero(addr(rsa_msg[0]), rsa_limbs)
    i: int32 = 0
    byte_pos: int32 = (len - 1)
    while (byte_pos >= 0):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        if (limb_idx < rsa_limbs):
            rsa_msg[limb_idx] = (rsa_msg[limb_idx] + (cast[int32](input[byte_pos]) * (1 << shift)))
        i = (i + 1)
        byte_pos = (byte_pos - 1)
    bigint_powmod(addr(rsa_result[0]), addr(rsa_msg[0]), addr(rsa_d[0]), addr(rsa_n[0]), rsa_limbs)
    out_len: int32 = (rsa_limbs * 4)
    i = 0
    while (i < out_len):
        limb_idx: int32 = (i / 4)
        byte_in_limb: int32 = (i & 3)
        shift: int32 = (byte_in_limb * 8)
        byte_val: int32 = ((rsa_result[limb_idx] / (1 << shift)) & 255)
        output[((out_len - 1) - i)] = cast[uint8](byte_val)
        i = (i + 1)
    return out_len

def rsa_pkcs1_encrypt(output: Ptr[uint8], msg: Ptr[uint8], msg_len: int32) -> int32:
    key_bytes: int32 = (rsa_limbs * 4)
    if (msg_len > (key_bytes - 11)):
        return RSA_ERR_SIZE
    padded: Array[256, uint8]
    pad_len: int32 = ((key_bytes - msg_len) - 3)
    padded[0] = 0
    padded[1] = 2
    i: int32 = 2
    while (i < (2 + pad_len)):
        r: int32 = (((i * 1103515245) + 12345) & 255)
        if (r == 0):
            r = 1
        padded[i] = cast[uint8](r)
        i = (i + 1)
    padded[(2 + pad_len)] = 0
    i = 0
    while (i < msg_len):
        padded[((3 + pad_len) + i)] = msg[i]
        i = (i + 1)
    return rsa_public(output, addr(padded[0]), key_bytes)

def rsa_pkcs1_decrypt(output: Ptr[uint8], ciphertext: Ptr[uint8], ct_len: int32, out_len: Ptr[int32]) -> int32:
    key_bytes: int32 = (rsa_limbs * 4)
    if (ct_len != key_bytes):
        return RSA_ERR_SIZE
    decrypted: Array[256, uint8]
    dec_len: int32 = rsa_private(addr(decrypted[0]), ciphertext, ct_len)
    if (dec_len < 0):
        return dec_len
    if ((decrypted[0] != 0) or (decrypted[1] != 2)):
        return RSA_ERR_PADDING
    i: int32 = 2
    while (i < dec_len):
        if (decrypted[i] == 0):
            break
        i = (i + 1)
    if (i >= (dec_len - 1)):
        return RSA_ERR_PADDING
    i = (i + 1)
    msg_len: int32 = (dec_len - i)
    j: int32 = 0
    while (j < msg_len):
        output[j] = decrypted[(i + j)]
        j = (j + 1)
    out_len[0] = msg_len
    return RSA_OK

def rsa_sign(signature: Ptr[uint8], msg_hash: Ptr[uint8], hash_len: int32) -> int32:
    key_bytes: int32 = (rsa_limbs * 4)
    if (hash_len > (key_bytes - 11)):
        return RSA_ERR_SIZE
    padded: Array[256, uint8]
    pad_len: int32 = ((key_bytes - hash_len) - 3)
    padded[0] = 0
    padded[1] = 1
    i: int32 = 2
    while (i < (2 + pad_len)):
        padded[i] = 255
        i = (i + 1)
    padded[(2 + pad_len)] = 0
    i = 0
    while (i < hash_len):
        padded[((3 + pad_len) + i)] = msg_hash[i]
        i = (i + 1)
    return rsa_private(signature, addr(padded[0]), key_bytes)

def rsa_verify(msg_hash: Ptr[uint8], hash_len: int32, signature: Ptr[uint8], sig_len: int32) -> int32:
    key_bytes: int32 = (rsa_limbs * 4)
    if (sig_len != key_bytes):
        return RSA_ERR_SIZE
    decrypted: Array[256, uint8]
    dec_len: int32 = rsa_public(addr(decrypted[0]), signature, sig_len)
    if (dec_len < 0):
        return dec_len
    if ((decrypted[0] != 0) or (decrypted[1] != 1)):
        return RSA_ERR_PADDING
    i: int32 = 2
    while (i < dec_len):
        if (decrypted[i] != 255):
            break
        i = (i + 1)
    if ((i >= (dec_len - 1)) or (decrypted[i] != 0)):
        return RSA_ERR_PADDING
    i = (i + 1)
    msg_len: int32 = (dec_len - i)
    if (msg_len != hash_len):
        return RSA_ERR_PADDING
    j: int32 = 0
    while (j < hash_len):
        if (decrypted[(i + j)] != msg_hash[j]):
            return RSA_ERR_PADDING
        j = (j + 1)
    return RSA_OK