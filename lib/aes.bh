# aes.bh - AES Implementation in pure Brainhair
# Provides AES-128, AES-192, and AES-256 encryption/decryption
# Supports ECB and CBC modes

# Constants
AES_BLOCK_SIZE: Final[int32] = 16
AES_KEY_SIZE_128: Final[int32] = 16
AES_KEY_SIZE_192: Final[int32] = 24
AES_KEY_SIZE_256: Final[int32] = 32

# Error codes
AES_SUCCESS: Final[int32] = 0
AES_ERROR: Final[int32] = -1
AES_ERROR_INVALID_KEY: Final[int32] = -2
AES_ERROR_INVALID_LENGTH: Final[int32] = -3
AES_ERROR_NULL_POINTER: Final[int32] = -4

# AES Context
class AESCtx:
    round_keys: Array[240, uint8]  # Expanded key schedule
    num_rounds: int32              # Number of rounds (10, 12, or 14)
    key_len: int32                 # Original key length

# Global context
g_aes_ctx: AESCtx
g_aes_initialized: int32 = 0

# S-box lookup
def aes_sbox(i: int32) -> uint8:
    # AES S-box (first 64 values, rest below)
    if i == 0: return cast[uint8](0x63)
    if i == 1: return cast[uint8](0x7c)
    if i == 2: return cast[uint8](0x77)
    if i == 3: return cast[uint8](0x7b)
    if i == 4: return cast[uint8](0xf2)
    if i == 5: return cast[uint8](0x6b)
    if i == 6: return cast[uint8](0x6f)
    if i == 7: return cast[uint8](0xc5)
    if i == 8: return cast[uint8](0x30)
    if i == 9: return cast[uint8](0x01)
    if i == 10: return cast[uint8](0x67)
    if i == 11: return cast[uint8](0x2b)
    if i == 12: return cast[uint8](0xfe)
    if i == 13: return cast[uint8](0xd7)
    if i == 14: return cast[uint8](0xab)
    if i == 15: return cast[uint8](0x76)
    if i == 16: return cast[uint8](0xca)
    if i == 17: return cast[uint8](0x82)
    if i == 18: return cast[uint8](0xc9)
    if i == 19: return cast[uint8](0x7d)
    if i == 20: return cast[uint8](0xfa)
    if i == 21: return cast[uint8](0x59)
    if i == 22: return cast[uint8](0x47)
    if i == 23: return cast[uint8](0xf0)
    if i == 24: return cast[uint8](0xad)
    if i == 25: return cast[uint8](0xd4)
    if i == 26: return cast[uint8](0xa2)
    if i == 27: return cast[uint8](0xaf)
    if i == 28: return cast[uint8](0x9c)
    if i == 29: return cast[uint8](0xa4)
    if i == 30: return cast[uint8](0x72)
    if i == 31: return cast[uint8](0xc0)
    if i == 32: return cast[uint8](0xb7)
    if i == 33: return cast[uint8](0xfd)
    if i == 34: return cast[uint8](0x93)
    if i == 35: return cast[uint8](0x26)
    if i == 36: return cast[uint8](0x36)
    if i == 37: return cast[uint8](0x3f)
    if i == 38: return cast[uint8](0xf7)
    if i == 39: return cast[uint8](0xcc)
    if i == 40: return cast[uint8](0x34)
    if i == 41: return cast[uint8](0xa5)
    if i == 42: return cast[uint8](0xe5)
    if i == 43: return cast[uint8](0xf1)
    if i == 44: return cast[uint8](0x71)
    if i == 45: return cast[uint8](0xd8)
    if i == 46: return cast[uint8](0x31)
    if i == 47: return cast[uint8](0x15)
    if i == 48: return cast[uint8](0x04)
    if i == 49: return cast[uint8](0xc7)
    if i == 50: return cast[uint8](0x23)
    if i == 51: return cast[uint8](0xc3)
    if i == 52: return cast[uint8](0x18)
    if i == 53: return cast[uint8](0x96)
    if i == 54: return cast[uint8](0x05)
    if i == 55: return cast[uint8](0x9a)
    if i == 56: return cast[uint8](0x07)
    if i == 57: return cast[uint8](0x12)
    if i == 58: return cast[uint8](0x80)
    if i == 59: return cast[uint8](0xe2)
    if i == 60: return cast[uint8](0xeb)
    if i == 61: return cast[uint8](0x27)
    if i == 62: return cast[uint8](0xb2)
    if i == 63: return cast[uint8](0x75)
    if i == 64: return cast[uint8](0x09)
    if i == 65: return cast[uint8](0x83)
    if i == 66: return cast[uint8](0x2c)
    if i == 67: return cast[uint8](0x1a)
    if i == 68: return cast[uint8](0x1b)
    if i == 69: return cast[uint8](0x6e)
    if i == 70: return cast[uint8](0x5a)
    if i == 71: return cast[uint8](0xa0)
    if i == 72: return cast[uint8](0x52)
    if i == 73: return cast[uint8](0x3b)
    if i == 74: return cast[uint8](0xd6)
    if i == 75: return cast[uint8](0xb3)
    if i == 76: return cast[uint8](0x29)
    if i == 77: return cast[uint8](0xe3)
    if i == 78: return cast[uint8](0x2f)
    if i == 79: return cast[uint8](0x84)
    if i == 80: return cast[uint8](0x53)
    if i == 81: return cast[uint8](0xd1)
    if i == 82: return cast[uint8](0x00)
    if i == 83: return cast[uint8](0xed)
    if i == 84: return cast[uint8](0x20)
    if i == 85: return cast[uint8](0xfc)
    if i == 86: return cast[uint8](0xb1)
    if i == 87: return cast[uint8](0x5b)
    if i == 88: return cast[uint8](0x6a)
    if i == 89: return cast[uint8](0xcb)
    if i == 90: return cast[uint8](0xbe)
    if i == 91: return cast[uint8](0x39)
    if i == 92: return cast[uint8](0x4a)
    if i == 93: return cast[uint8](0x4c)
    if i == 94: return cast[uint8](0x58)
    if i == 95: return cast[uint8](0xcf)
    if i == 96: return cast[uint8](0xd0)
    if i == 97: return cast[uint8](0xef)
    if i == 98: return cast[uint8](0xaa)
    if i == 99: return cast[uint8](0xfb)
    if i == 100: return cast[uint8](0x43)
    if i == 101: return cast[uint8](0x4d)
    if i == 102: return cast[uint8](0x33)
    if i == 103: return cast[uint8](0x85)
    if i == 104: return cast[uint8](0x45)
    if i == 105: return cast[uint8](0xf9)
    if i == 106: return cast[uint8](0x02)
    if i == 107: return cast[uint8](0x7f)
    if i == 108: return cast[uint8](0x50)
    if i == 109: return cast[uint8](0x3c)
    if i == 110: return cast[uint8](0x9f)
    if i == 111: return cast[uint8](0xa8)
    if i == 112: return cast[uint8](0x51)
    if i == 113: return cast[uint8](0xa3)
    if i == 114: return cast[uint8](0x40)
    if i == 115: return cast[uint8](0x8f)
    if i == 116: return cast[uint8](0x92)
    if i == 117: return cast[uint8](0x9d)
    if i == 118: return cast[uint8](0x38)
    if i == 119: return cast[uint8](0xf5)
    if i == 120: return cast[uint8](0xbc)
    if i == 121: return cast[uint8](0xb6)
    if i == 122: return cast[uint8](0xda)
    if i == 123: return cast[uint8](0x21)
    if i == 124: return cast[uint8](0x10)
    if i == 125: return cast[uint8](0xff)
    if i == 126: return cast[uint8](0xf3)
    if i == 127: return cast[uint8](0xd2)
    if i == 128: return cast[uint8](0xcd)
    if i == 129: return cast[uint8](0x0c)
    if i == 130: return cast[uint8](0x13)
    if i == 131: return cast[uint8](0xec)
    if i == 132: return cast[uint8](0x5f)
    if i == 133: return cast[uint8](0x97)
    if i == 134: return cast[uint8](0x44)
    if i == 135: return cast[uint8](0x17)
    if i == 136: return cast[uint8](0xc4)
    if i == 137: return cast[uint8](0xa7)
    if i == 138: return cast[uint8](0x7e)
    if i == 139: return cast[uint8](0x3d)
    if i == 140: return cast[uint8](0x64)
    if i == 141: return cast[uint8](0x5d)
    if i == 142: return cast[uint8](0x19)
    if i == 143: return cast[uint8](0x73)
    if i == 144: return cast[uint8](0x60)
    if i == 145: return cast[uint8](0x81)
    if i == 146: return cast[uint8](0x4f)
    if i == 147: return cast[uint8](0xdc)
    if i == 148: return cast[uint8](0x22)
    if i == 149: return cast[uint8](0x2a)
    if i == 150: return cast[uint8](0x90)
    if i == 151: return cast[uint8](0x88)
    if i == 152: return cast[uint8](0x46)
    if i == 153: return cast[uint8](0xee)
    if i == 154: return cast[uint8](0xb8)
    if i == 155: return cast[uint8](0x14)
    if i == 156: return cast[uint8](0xde)
    if i == 157: return cast[uint8](0x5e)
    if i == 158: return cast[uint8](0x0b)
    if i == 159: return cast[uint8](0xdb)
    if i == 160: return cast[uint8](0xe0)
    if i == 161: return cast[uint8](0x32)
    if i == 162: return cast[uint8](0x3a)
    if i == 163: return cast[uint8](0x0a)
    if i == 164: return cast[uint8](0x49)
    if i == 165: return cast[uint8](0x06)
    if i == 166: return cast[uint8](0x24)
    if i == 167: return cast[uint8](0x5c)
    if i == 168: return cast[uint8](0xc2)
    if i == 169: return cast[uint8](0xd3)
    if i == 170: return cast[uint8](0xac)
    if i == 171: return cast[uint8](0x62)
    if i == 172: return cast[uint8](0x91)
    if i == 173: return cast[uint8](0x95)
    if i == 174: return cast[uint8](0xe4)
    if i == 175: return cast[uint8](0x79)
    if i == 176: return cast[uint8](0xe7)
    if i == 177: return cast[uint8](0xc8)
    if i == 178: return cast[uint8](0x37)
    if i == 179: return cast[uint8](0x6d)
    if i == 180: return cast[uint8](0x8d)
    if i == 181: return cast[uint8](0xd5)
    if i == 182: return cast[uint8](0x4e)
    if i == 183: return cast[uint8](0xa9)
    if i == 184: return cast[uint8](0x6c)
    if i == 185: return cast[uint8](0x56)
    if i == 186: return cast[uint8](0xf4)
    if i == 187: return cast[uint8](0xea)
    if i == 188: return cast[uint8](0x65)
    if i == 189: return cast[uint8](0x7a)
    if i == 190: return cast[uint8](0xae)
    if i == 191: return cast[uint8](0x08)
    if i == 192: return cast[uint8](0xba)
    if i == 193: return cast[uint8](0x78)
    if i == 194: return cast[uint8](0x25)
    if i == 195: return cast[uint8](0x2e)
    if i == 196: return cast[uint8](0x1c)
    if i == 197: return cast[uint8](0xa6)
    if i == 198: return cast[uint8](0xb4)
    if i == 199: return cast[uint8](0xc6)
    if i == 200: return cast[uint8](0xe8)
    if i == 201: return cast[uint8](0xdd)
    if i == 202: return cast[uint8](0x74)
    if i == 203: return cast[uint8](0x1f)
    if i == 204: return cast[uint8](0x4b)
    if i == 205: return cast[uint8](0xbd)
    if i == 206: return cast[uint8](0x8b)
    if i == 207: return cast[uint8](0x8a)
    if i == 208: return cast[uint8](0x70)
    if i == 209: return cast[uint8](0x3e)
    if i == 210: return cast[uint8](0xb5)
    if i == 211: return cast[uint8](0x66)
    if i == 212: return cast[uint8](0x48)
    if i == 213: return cast[uint8](0x03)
    if i == 214: return cast[uint8](0xf6)
    if i == 215: return cast[uint8](0x0e)
    if i == 216: return cast[uint8](0x61)
    if i == 217: return cast[uint8](0x35)
    if i == 218: return cast[uint8](0x57)
    if i == 219: return cast[uint8](0xb9)
    if i == 220: return cast[uint8](0x86)
    if i == 221: return cast[uint8](0xc1)
    if i == 222: return cast[uint8](0x1d)
    if i == 223: return cast[uint8](0x9e)
    if i == 224: return cast[uint8](0xe1)
    if i == 225: return cast[uint8](0xf8)
    if i == 226: return cast[uint8](0x98)
    if i == 227: return cast[uint8](0x11)
    if i == 228: return cast[uint8](0x69)
    if i == 229: return cast[uint8](0xd9)
    if i == 230: return cast[uint8](0x8e)
    if i == 231: return cast[uint8](0x94)
    if i == 232: return cast[uint8](0x9b)
    if i == 233: return cast[uint8](0x1e)
    if i == 234: return cast[uint8](0x87)
    if i == 235: return cast[uint8](0xe9)
    if i == 236: return cast[uint8](0xce)
    if i == 237: return cast[uint8](0x55)
    if i == 238: return cast[uint8](0x28)
    if i == 239: return cast[uint8](0xdf)
    if i == 240: return cast[uint8](0x8c)
    if i == 241: return cast[uint8](0xa1)
    if i == 242: return cast[uint8](0x89)
    if i == 243: return cast[uint8](0x0d)
    if i == 244: return cast[uint8](0xbf)
    if i == 245: return cast[uint8](0xe6)
    if i == 246: return cast[uint8](0x42)
    if i == 247: return cast[uint8](0x68)
    if i == 248: return cast[uint8](0x41)
    if i == 249: return cast[uint8](0x99)
    if i == 250: return cast[uint8](0x2d)
    if i == 251: return cast[uint8](0x0f)
    if i == 252: return cast[uint8](0xb0)
    if i == 253: return cast[uint8](0x54)
    if i == 254: return cast[uint8](0xbb)
    if i == 255: return cast[uint8](0x16)
    return cast[uint8](0)

# Inverse S-box lookup
def aes_inv_sbox(i: int32) -> uint8:
    if i == 0: return cast[uint8](0x52)
    if i == 1: return cast[uint8](0x09)
    if i == 2: return cast[uint8](0x6a)
    if i == 3: return cast[uint8](0xd5)
    if i == 4: return cast[uint8](0x30)
    if i == 5: return cast[uint8](0x36)
    if i == 6: return cast[uint8](0xa5)
    if i == 7: return cast[uint8](0x38)
    if i == 8: return cast[uint8](0xbf)
    if i == 9: return cast[uint8](0x40)
    if i == 10: return cast[uint8](0xa3)
    if i == 11: return cast[uint8](0x9e)
    if i == 12: return cast[uint8](0x81)
    if i == 13: return cast[uint8](0xf3)
    if i == 14: return cast[uint8](0xd7)
    if i == 15: return cast[uint8](0xfb)
    if i == 16: return cast[uint8](0x7c)
    if i == 17: return cast[uint8](0xe3)
    if i == 18: return cast[uint8](0x39)
    if i == 19: return cast[uint8](0x82)
    if i == 20: return cast[uint8](0x9b)
    if i == 21: return cast[uint8](0x2f)
    if i == 22: return cast[uint8](0xff)
    if i == 23: return cast[uint8](0x87)
    if i == 24: return cast[uint8](0x34)
    if i == 25: return cast[uint8](0x8e)
    if i == 26: return cast[uint8](0x43)
    if i == 27: return cast[uint8](0x44)
    if i == 28: return cast[uint8](0xc4)
    if i == 29: return cast[uint8](0xde)
    if i == 30: return cast[uint8](0xe9)
    if i == 31: return cast[uint8](0xcb)
    if i == 32: return cast[uint8](0x54)
    if i == 33: return cast[uint8](0x7b)
    if i == 34: return cast[uint8](0x94)
    if i == 35: return cast[uint8](0x32)
    if i == 36: return cast[uint8](0xa6)
    if i == 37: return cast[uint8](0xc2)
    if i == 38: return cast[uint8](0x23)
    if i == 39: return cast[uint8](0x3d)
    if i == 40: return cast[uint8](0xee)
    if i == 41: return cast[uint8](0x4c)
    if i == 42: return cast[uint8](0x95)
    if i == 43: return cast[uint8](0x0b)
    if i == 44: return cast[uint8](0x42)
    if i == 45: return cast[uint8](0xfa)
    if i == 46: return cast[uint8](0xc3)
    if i == 47: return cast[uint8](0x4e)
    if i == 48: return cast[uint8](0x08)
    if i == 49: return cast[uint8](0x2e)
    if i == 50: return cast[uint8](0xa1)
    if i == 51: return cast[uint8](0x66)
    if i == 52: return cast[uint8](0x28)
    if i == 53: return cast[uint8](0xd9)
    if i == 54: return cast[uint8](0x24)
    if i == 55: return cast[uint8](0xb2)
    if i == 56: return cast[uint8](0x76)
    if i == 57: return cast[uint8](0x5b)
    if i == 58: return cast[uint8](0xa2)
    if i == 59: return cast[uint8](0x49)
    if i == 60: return cast[uint8](0x6d)
    if i == 61: return cast[uint8](0x8b)
    if i == 62: return cast[uint8](0xd1)
    if i == 63: return cast[uint8](0x25)
    if i == 64: return cast[uint8](0x72)
    if i == 65: return cast[uint8](0xf8)
    if i == 66: return cast[uint8](0xf6)
    if i == 67: return cast[uint8](0x64)
    if i == 68: return cast[uint8](0x86)
    if i == 69: return cast[uint8](0x68)
    if i == 70: return cast[uint8](0x98)
    if i == 71: return cast[uint8](0x16)
    if i == 72: return cast[uint8](0xd4)
    if i == 73: return cast[uint8](0xa4)
    if i == 74: return cast[uint8](0x5c)
    if i == 75: return cast[uint8](0xcc)
    if i == 76: return cast[uint8](0x5d)
    if i == 77: return cast[uint8](0x65)
    if i == 78: return cast[uint8](0xb6)
    if i == 79: return cast[uint8](0x92)
    if i == 80: return cast[uint8](0x6c)
    if i == 81: return cast[uint8](0x70)
    if i == 82: return cast[uint8](0x48)
    if i == 83: return cast[uint8](0x50)
    if i == 84: return cast[uint8](0xfd)
    if i == 85: return cast[uint8](0xed)
    if i == 86: return cast[uint8](0xb9)
    if i == 87: return cast[uint8](0xda)
    if i == 88: return cast[uint8](0x5e)
    if i == 89: return cast[uint8](0x15)
    if i == 90: return cast[uint8](0x46)
    if i == 91: return cast[uint8](0x57)
    if i == 92: return cast[uint8](0xa7)
    if i == 93: return cast[uint8](0x8d)
    if i == 94: return cast[uint8](0x9d)
    if i == 95: return cast[uint8](0x84)
    if i == 96: return cast[uint8](0x90)
    if i == 97: return cast[uint8](0xd8)
    if i == 98: return cast[uint8](0xab)
    if i == 99: return cast[uint8](0x00)
    if i == 100: return cast[uint8](0x8c)
    if i == 101: return cast[uint8](0xbc)
    if i == 102: return cast[uint8](0xd3)
    if i == 103: return cast[uint8](0x0a)
    if i == 104: return cast[uint8](0xf7)
    if i == 105: return cast[uint8](0xe4)
    if i == 106: return cast[uint8](0x58)
    if i == 107: return cast[uint8](0x05)
    if i == 108: return cast[uint8](0xb8)
    if i == 109: return cast[uint8](0xb3)
    if i == 110: return cast[uint8](0x45)
    if i == 111: return cast[uint8](0x06)
    if i == 112: return cast[uint8](0xd0)
    if i == 113: return cast[uint8](0x2c)
    if i == 114: return cast[uint8](0x1e)
    if i == 115: return cast[uint8](0x8f)
    if i == 116: return cast[uint8](0xca)
    if i == 117: return cast[uint8](0x3f)
    if i == 118: return cast[uint8](0x0f)
    if i == 119: return cast[uint8](0x02)
    if i == 120: return cast[uint8](0xc1)
    if i == 121: return cast[uint8](0xaf)
    if i == 122: return cast[uint8](0xbd)
    if i == 123: return cast[uint8](0x03)
    if i == 124: return cast[uint8](0x01)
    if i == 125: return cast[uint8](0x13)
    if i == 126: return cast[uint8](0x8a)
    if i == 127: return cast[uint8](0x6b)
    if i == 128: return cast[uint8](0x3a)
    if i == 129: return cast[uint8](0x91)
    if i == 130: return cast[uint8](0x11)
    if i == 131: return cast[uint8](0x41)
    if i == 132: return cast[uint8](0x4f)
    if i == 133: return cast[uint8](0x67)
    if i == 134: return cast[uint8](0xdc)
    if i == 135: return cast[uint8](0xea)
    if i == 136: return cast[uint8](0x97)
    if i == 137: return cast[uint8](0xf2)
    if i == 138: return cast[uint8](0xcf)
    if i == 139: return cast[uint8](0xce)
    if i == 140: return cast[uint8](0xf0)
    if i == 141: return cast[uint8](0xb4)
    if i == 142: return cast[uint8](0xe6)
    if i == 143: return cast[uint8](0x73)
    if i == 144: return cast[uint8](0x96)
    if i == 145: return cast[uint8](0xac)
    if i == 146: return cast[uint8](0x74)
    if i == 147: return cast[uint8](0x22)
    if i == 148: return cast[uint8](0xe7)
    if i == 149: return cast[uint8](0xad)
    if i == 150: return cast[uint8](0x35)
    if i == 151: return cast[uint8](0x85)
    if i == 152: return cast[uint8](0xe2)
    if i == 153: return cast[uint8](0xf9)
    if i == 154: return cast[uint8](0x37)
    if i == 155: return cast[uint8](0xe8)
    if i == 156: return cast[uint8](0x1c)
    if i == 157: return cast[uint8](0x75)
    if i == 158: return cast[uint8](0xdf)
    if i == 159: return cast[uint8](0x6e)
    if i == 160: return cast[uint8](0x47)
    if i == 161: return cast[uint8](0xf1)
    if i == 162: return cast[uint8](0x1a)
    if i == 163: return cast[uint8](0x71)
    if i == 164: return cast[uint8](0x1d)
    if i == 165: return cast[uint8](0x29)
    if i == 166: return cast[uint8](0xc5)
    if i == 167: return cast[uint8](0x89)
    if i == 168: return cast[uint8](0x6f)
    if i == 169: return cast[uint8](0xb7)
    if i == 170: return cast[uint8](0x62)
    if i == 171: return cast[uint8](0x0e)
    if i == 172: return cast[uint8](0xaa)
    if i == 173: return cast[uint8](0x18)
    if i == 174: return cast[uint8](0xbe)
    if i == 175: return cast[uint8](0x1b)
    if i == 176: return cast[uint8](0xfc)
    if i == 177: return cast[uint8](0x56)
    if i == 178: return cast[uint8](0x3e)
    if i == 179: return cast[uint8](0x4b)
    if i == 180: return cast[uint8](0xc6)
    if i == 181: return cast[uint8](0xd2)
    if i == 182: return cast[uint8](0x79)
    if i == 183: return cast[uint8](0x20)
    if i == 184: return cast[uint8](0x9a)
    if i == 185: return cast[uint8](0xdb)
    if i == 186: return cast[uint8](0xc0)
    if i == 187: return cast[uint8](0xfe)
    if i == 188: return cast[uint8](0x78)
    if i == 189: return cast[uint8](0xcd)
    if i == 190: return cast[uint8](0x5a)
    if i == 191: return cast[uint8](0xf4)
    if i == 192: return cast[uint8](0x1f)
    if i == 193: return cast[uint8](0xdd)
    if i == 194: return cast[uint8](0xa8)
    if i == 195: return cast[uint8](0x33)
    if i == 196: return cast[uint8](0x88)
    if i == 197: return cast[uint8](0x07)
    if i == 198: return cast[uint8](0xc7)
    if i == 199: return cast[uint8](0x31)
    if i == 200: return cast[uint8](0xb1)
    if i == 201: return cast[uint8](0x12)
    if i == 202: return cast[uint8](0x10)
    if i == 203: return cast[uint8](0x59)
    if i == 204: return cast[uint8](0x27)
    if i == 205: return cast[uint8](0x80)
    if i == 206: return cast[uint8](0xec)
    if i == 207: return cast[uint8](0x5f)
    if i == 208: return cast[uint8](0x60)
    if i == 209: return cast[uint8](0x51)
    if i == 210: return cast[uint8](0x7f)
    if i == 211: return cast[uint8](0xa9)
    if i == 212: return cast[uint8](0x19)
    if i == 213: return cast[uint8](0xb5)
    if i == 214: return cast[uint8](0x4a)
    if i == 215: return cast[uint8](0x0d)
    if i == 216: return cast[uint8](0x2d)
    if i == 217: return cast[uint8](0xe5)
    if i == 218: return cast[uint8](0x7a)
    if i == 219: return cast[uint8](0x9f)
    if i == 220: return cast[uint8](0x93)
    if i == 221: return cast[uint8](0xc9)
    if i == 222: return cast[uint8](0x9c)
    if i == 223: return cast[uint8](0xef)
    if i == 224: return cast[uint8](0xa0)
    if i == 225: return cast[uint8](0xe0)
    if i == 226: return cast[uint8](0x3b)
    if i == 227: return cast[uint8](0x4d)
    if i == 228: return cast[uint8](0xae)
    if i == 229: return cast[uint8](0x2a)
    if i == 230: return cast[uint8](0xf5)
    if i == 231: return cast[uint8](0xb0)
    if i == 232: return cast[uint8](0xc8)
    if i == 233: return cast[uint8](0xeb)
    if i == 234: return cast[uint8](0xbb)
    if i == 235: return cast[uint8](0x3c)
    if i == 236: return cast[uint8](0x83)
    if i == 237: return cast[uint8](0x53)
    if i == 238: return cast[uint8](0x99)
    if i == 239: return cast[uint8](0x61)
    if i == 240: return cast[uint8](0x17)
    if i == 241: return cast[uint8](0x2b)
    if i == 242: return cast[uint8](0x04)
    if i == 243: return cast[uint8](0x7e)
    if i == 244: return cast[uint8](0xba)
    if i == 245: return cast[uint8](0x77)
    if i == 246: return cast[uint8](0xd6)
    if i == 247: return cast[uint8](0x26)
    if i == 248: return cast[uint8](0xe1)
    if i == 249: return cast[uint8](0x69)
    if i == 250: return cast[uint8](0x14)
    if i == 251: return cast[uint8](0x63)
    if i == 252: return cast[uint8](0x55)
    if i == 253: return cast[uint8](0x21)
    if i == 254: return cast[uint8](0x0c)
    if i == 255: return cast[uint8](0x7d)
    return cast[uint8](0)

# Rcon (round constants)
def aes_rcon(i: int32) -> uint8:
    if i == 0: return cast[uint8](0x01)
    if i == 1: return cast[uint8](0x02)
    if i == 2: return cast[uint8](0x04)
    if i == 3: return cast[uint8](0x08)
    if i == 4: return cast[uint8](0x10)
    if i == 5: return cast[uint8](0x20)
    if i == 6: return cast[uint8](0x40)
    if i == 7: return cast[uint8](0x80)
    if i == 8: return cast[uint8](0x1b)
    if i == 9: return cast[uint8](0x36)
    return cast[uint8](0)

# GF(2^8) multiplication by 2
def xtime(x: uint8) -> uint8:
    return cast[uint8](((cast[int32](x) << 1) ^ (((cast[int32](x) >> 7) & 1) * 0x1b)) & 0xff)

# GF(2^8) multiplication
def gf_mul(a: uint8, b: uint8) -> uint8:
    p: uint8 = cast[uint8](0)
    i: int32 = 0
    while i < 8:
        if (cast[int32](b) & 1) != 0:
            p = cast[uint8](cast[int32](p) ^ cast[int32](a))
        hi: int32 = cast[int32](a) & 0x80
        a = cast[uint8]((cast[int32](a) << 1) & 0xff)
        if hi != 0:
            a = cast[uint8](cast[int32](a) ^ 0x1b)
        b = cast[uint8](cast[int32](b) >> 1)
        i = i + 1
    return p

# Key expansion
def aes_key_expansion(key: Ptr[uint8], key_len: int32):
    nk: int32 = key_len / 4  # Number of 32-bit words in key
    if key_len == 16:
        g_aes_ctx.num_rounds = 10
    elif key_len == 24:
        g_aes_ctx.num_rounds = 12
    else:
        g_aes_ctx.num_rounds = 14
    g_aes_ctx.key_len = key_len

    nr: int32 = g_aes_ctx.num_rounds
    nb: int32 = 4  # AES always uses 4 columns

    # Copy original key
    i: int32 = 0
    while i < key_len:
        g_aes_ctx.round_keys[i] = key[i]
        i = i + 1

    # Generate remaining round keys
    i = nk
    while i < (nb * (nr + 1)):
        temp: Array[4, uint8]
        k: int32 = (i - 1) * 4
        temp[0] = g_aes_ctx.round_keys[k]
        temp[1] = g_aes_ctx.round_keys[k + 1]
        temp[2] = g_aes_ctx.round_keys[k + 2]
        temp[3] = g_aes_ctx.round_keys[k + 3]

        if (i % nk) == 0:
            # RotWord
            t: uint8 = temp[0]
            temp[0] = temp[1]
            temp[1] = temp[2]
            temp[2] = temp[3]
            temp[3] = t
            # SubWord
            temp[0] = aes_sbox(cast[int32](temp[0]))
            temp[1] = aes_sbox(cast[int32](temp[1]))
            temp[2] = aes_sbox(cast[int32](temp[2]))
            temp[3] = aes_sbox(cast[int32](temp[3]))
            # XOR with Rcon
            temp[0] = cast[uint8](cast[int32](temp[0]) ^ cast[int32](aes_rcon((i / nk) - 1)))
        elif (nk > 6) and ((i % nk) == 4):
            # SubWord only for AES-256
            temp[0] = aes_sbox(cast[int32](temp[0]))
            temp[1] = aes_sbox(cast[int32](temp[1]))
            temp[2] = aes_sbox(cast[int32](temp[2]))
            temp[3] = aes_sbox(cast[int32](temp[3]))

        k = (i - nk) * 4
        j: int32 = i * 4
        g_aes_ctx.round_keys[j] = cast[uint8](cast[int32](g_aes_ctx.round_keys[k]) ^ cast[int32](temp[0]))
        g_aes_ctx.round_keys[j + 1] = cast[uint8](cast[int32](g_aes_ctx.round_keys[k + 1]) ^ cast[int32](temp[1]))
        g_aes_ctx.round_keys[j + 2] = cast[uint8](cast[int32](g_aes_ctx.round_keys[k + 2]) ^ cast[int32](temp[2]))
        g_aes_ctx.round_keys[j + 3] = cast[uint8](cast[int32](g_aes_ctx.round_keys[k + 3]) ^ cast[int32](temp[3]))
        i = i + 1

# AddRoundKey
def aes_add_round_key(state: Ptr[uint8], round: int32):
    offset: int32 = round * 16
    i: int32 = 0
    while i < 16:
        state[i] = cast[uint8](cast[int32](state[i]) ^ cast[int32](g_aes_ctx.round_keys[offset + i]))
        i = i + 1

# SubBytes
def aes_sub_bytes(state: Ptr[uint8]):
    i: int32 = 0
    while i < 16:
        state[i] = aes_sbox(cast[int32](state[i]))
        i = i + 1

# InvSubBytes
def aes_inv_sub_bytes(state: Ptr[uint8]):
    i: int32 = 0
    while i < 16:
        state[i] = aes_inv_sbox(cast[int32](state[i]))
        i = i + 1

# ShiftRows
def aes_shift_rows(state: Ptr[uint8]):
    t: uint8
    # Row 1: shift left by 1
    t = state[1]
    state[1] = state[5]
    state[5] = state[9]
    state[9] = state[13]
    state[13] = t
    # Row 2: shift left by 2
    t = state[2]
    state[2] = state[10]
    state[10] = t
    t = state[6]
    state[6] = state[14]
    state[14] = t
    # Row 3: shift left by 3
    t = state[15]
    state[15] = state[11]
    state[11] = state[7]
    state[7] = state[3]
    state[3] = t

# InvShiftRows
def aes_inv_shift_rows(state: Ptr[uint8]):
    t: uint8
    # Row 1: shift right by 1
    t = state[13]
    state[13] = state[9]
    state[9] = state[5]
    state[5] = state[1]
    state[1] = t
    # Row 2: shift right by 2
    t = state[2]
    state[2] = state[10]
    state[10] = t
    t = state[6]
    state[6] = state[14]
    state[14] = t
    # Row 3: shift right by 3
    t = state[3]
    state[3] = state[7]
    state[7] = state[11]
    state[11] = state[15]
    state[15] = t

# MixColumns
def aes_mix_columns(state: Ptr[uint8]):
    col: int32 = 0
    while col < 4:
        i: int32 = col * 4
        a: Array[4, uint8]
        a[0] = state[i]
        a[1] = state[i + 1]
        a[2] = state[i + 2]
        a[3] = state[i + 3]
        state[i] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](2))) ^ cast[int32](gf_mul(a[1], cast[uint8](3))) ^ cast[int32](a[2]) ^ cast[int32](a[3]))
        state[i + 1] = cast[uint8](cast[int32](a[0]) ^ cast[int32](gf_mul(a[1], cast[uint8](2))) ^ cast[int32](gf_mul(a[2], cast[uint8](3))) ^ cast[int32](a[3]))
        state[i + 2] = cast[uint8](cast[int32](a[0]) ^ cast[int32](a[1]) ^ cast[int32](gf_mul(a[2], cast[uint8](2))) ^ cast[int32](gf_mul(a[3], cast[uint8](3))))
        state[i + 3] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](3))) ^ cast[int32](a[1]) ^ cast[int32](a[2]) ^ cast[int32](gf_mul(a[3], cast[uint8](2))))
        col = col + 1

# InvMixColumns
def aes_inv_mix_columns(state: Ptr[uint8]):
    col: int32 = 0
    while col < 4:
        i: int32 = col * 4
        a: Array[4, uint8]
        a[0] = state[i]
        a[1] = state[i + 1]
        a[2] = state[i + 2]
        a[3] = state[i + 3]
        state[i] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](0x0e))) ^ cast[int32](gf_mul(a[1], cast[uint8](0x0b))) ^ cast[int32](gf_mul(a[2], cast[uint8](0x0d))) ^ cast[int32](gf_mul(a[3], cast[uint8](0x09))))
        state[i + 1] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](0x09))) ^ cast[int32](gf_mul(a[1], cast[uint8](0x0e))) ^ cast[int32](gf_mul(a[2], cast[uint8](0x0b))) ^ cast[int32](gf_mul(a[3], cast[uint8](0x0d))))
        state[i + 2] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](0x0d))) ^ cast[int32](gf_mul(a[1], cast[uint8](0x09))) ^ cast[int32](gf_mul(a[2], cast[uint8](0x0e))) ^ cast[int32](gf_mul(a[3], cast[uint8](0x0b))))
        state[i + 3] = cast[uint8](cast[int32](gf_mul(a[0], cast[uint8](0x0b))) ^ cast[int32](gf_mul(a[1], cast[uint8](0x0d))) ^ cast[int32](gf_mul(a[2], cast[uint8](0x09))) ^ cast[int32](gf_mul(a[3], cast[uint8](0x0e))))
        col = col + 1

# Initialize AES
def aes_init() -> int32:
    g_aes_initialized = 1
    return 0

def aes_initialize() -> int32:
    return aes_init()

def aes_has_hardware_support() -> int32:
    return 0  # Software implementation

def aes_check_aesni() -> int32:
    return 0

# Set key
def aes_set_key(key: Ptr[uint8], key_len: int32) -> int32:
    if key == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER
    if (key_len != 16) and (key_len != 24) and (key_len != 32):
        return AES_ERROR_INVALID_KEY
    aes_key_expansion(key, key_len)
    return 0

def aes_key_init(key: Ptr[uint8], key_len: int32) -> int32:
    return aes_set_key(key, key_len)

# Encrypt single block
def aes_encrypt_block(input: Ptr[uint8], output: Ptr[uint8]) -> int32:
    state: Array[16, uint8]
    i: int32 = 0
    while i < 16:
        state[i] = input[i]
        i = i + 1

    aes_add_round_key(addr(state[0]), 0)

    round: int32 = 1
    while round < g_aes_ctx.num_rounds:
        aes_sub_bytes(addr(state[0]))
        aes_shift_rows(addr(state[0]))
        aes_mix_columns(addr(state[0]))
        aes_add_round_key(addr(state[0]), round)
        round = round + 1

    aes_sub_bytes(addr(state[0]))
    aes_shift_rows(addr(state[0]))
    aes_add_round_key(addr(state[0]), g_aes_ctx.num_rounds)

    i = 0
    while i < 16:
        output[i] = state[i]
        i = i + 1

    return 0

# Decrypt single block
def aes_decrypt_block(input: Ptr[uint8], output: Ptr[uint8]) -> int32:
    state: Array[16, uint8]
    i: int32 = 0
    while i < 16:
        state[i] = input[i]
        i = i + 1

    aes_add_round_key(addr(state[0]), g_aes_ctx.num_rounds)

    round: int32 = g_aes_ctx.num_rounds - 1
    while round > 0:
        aes_inv_shift_rows(addr(state[0]))
        aes_inv_sub_bytes(addr(state[0]))
        aes_add_round_key(addr(state[0]), round)
        aes_inv_mix_columns(addr(state[0]))
        round = round - 1

    aes_inv_shift_rows(addr(state[0]))
    aes_inv_sub_bytes(addr(state[0]))
    aes_add_round_key(addr(state[0]), 0)

    i = 0
    while i < 16:
        output[i] = state[i]
        i = i + 1

    return 0

# CBC encrypt
def aes_cbc_encrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    if (input == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)) or (iv == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    if (length % 16) != 0:
        return AES_ERROR_INVALID_LENGTH

    prev: Array[16, uint8]
    i: int32 = 0
    while i < 16:
        prev[i] = iv[i]
        i = i + 1

    blocks: int32 = length / 16
    b: int32 = 0
    while b < blocks:
        offset: int32 = b * 16
        block: Array[16, uint8]
        i = 0
        while i < 16:
            block[i] = cast[uint8](cast[int32](input[offset + i]) ^ cast[int32](prev[i]))
            i = i + 1
        aes_encrypt_block(addr(block[0]), cast[Ptr[uint8]](cast[int32](output) + offset))
        i = 0
        while i < 16:
            prev[i] = output[offset + i]
            i = i + 1
        b = b + 1

    return 0

# CBC decrypt
def aes_cbc_decrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    if (input == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)) or (iv == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    if (length % 16) != 0:
        return AES_ERROR_INVALID_LENGTH

    prev: Array[16, uint8]
    i: int32 = 0
    while i < 16:
        prev[i] = iv[i]
        i = i + 1

    blocks: int32 = length / 16
    b: int32 = 0
    while b < blocks:
        offset: int32 = b * 16
        curr: Array[16, uint8]
        i = 0
        while i < 16:
            curr[i] = input[offset + i]
            i = i + 1
        aes_decrypt_block(addr(curr[0]), cast[Ptr[uint8]](cast[int32](output) + offset))
        i = 0
        while i < 16:
            output[offset + i] = cast[uint8](cast[int32](output[offset + i]) ^ cast[int32](prev[i]))
            prev[i] = curr[i]
            i = i + 1
        b = b + 1

    return 0

# High-level wrappers
def aes_encrypt_cbc_mode(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    return aes_cbc_encrypt(input, output, length, iv)

def aes_decrypt_cbc_mode(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    return aes_cbc_decrypt(input, output, length, iv)

def aes_encrypt_ecb(input: Ptr[uint8], output: Ptr[uint8], length: int32) -> int32:
    if (input == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    if (length % 16) != 0:
        return AES_ERROR_INVALID_LENGTH
    blocks: int32 = length / 16
    b: int32 = 0
    while b < blocks:
        offset: int32 = b * 16
        aes_encrypt_block(cast[Ptr[uint8]](cast[int32](input) + offset), cast[Ptr[uint8]](cast[int32](output) + offset))
        b = b + 1
    return 0

def aes_decrypt_ecb(input: Ptr[uint8], output: Ptr[uint8], length: int32) -> int32:
    if (input == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    if (length % 16) != 0:
        return AES_ERROR_INVALID_LENGTH
    blocks: int32 = length / 16
    b: int32 = 0
    while b < blocks:
        offset: int32 = b * 16
        aes_decrypt_block(cast[Ptr[uint8]](cast[int32](input) + offset), cast[Ptr[uint8]](cast[int32](output) + offset))
        b = b + 1
    return 0

def aes_get_key_size_name(key_len: int32) -> Ptr[uint8]:
    if key_len == 16:
        return cast[Ptr[uint8]]("AES-128")
    elif key_len == 24:
        return cast[Ptr[uint8]]("AES-192")
    elif key_len == 32:
        return cast[Ptr[uint8]]("AES-256")
    return cast[Ptr[uint8]]("Invalid")

def aes_get_error_message(error_code: int32) -> Ptr[uint8]:
    if error_code == 0:
        return cast[Ptr[uint8]]("Success")
    elif error_code == -1:
        return cast[Ptr[uint8]]("General error")
    elif error_code == -2:
        return cast[Ptr[uint8]]("Invalid key")
    elif error_code == -3:
        return cast[Ptr[uint8]]("Invalid length")
    elif error_code == -4:
        return cast[Ptr[uint8]]("Null pointer")
    return cast[Ptr[uint8]]("Unknown error")

def aes_encrypt_string(plaintext: Ptr[uint8], plaintext_len: int32, output: Ptr[uint8], output_size: int32, key: Ptr[uint8], key_len: int32, iv: Ptr[uint8]) -> int32:
    if (plaintext == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)) or (key == cast[Ptr[uint8]](0)) or (iv == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    aes_key_init(key, key_len)
    padding: int32 = 16 - (plaintext_len % 16)
    padded_len: int32 = plaintext_len + padding
    if padded_len > output_size:
        return AES_ERROR_INVALID_LENGTH
    i: int32 = 0
    while i < plaintext_len:
        output[i] = plaintext[i]
        i = i + 1
    while i < padded_len:
        output[i] = cast[uint8](padding)
        i = i + 1
    return aes_cbc_encrypt(output, output, padded_len, iv)

def aes_decrypt_string(ciphertext: Ptr[uint8], ciphertext_len: int32, output: Ptr[uint8], output_size: int32, key: Ptr[uint8], key_len: int32, iv: Ptr[uint8]) -> int32:
    if (ciphertext == cast[Ptr[uint8]](0)) or (output == cast[Ptr[uint8]](0)) or (key == cast[Ptr[uint8]](0)) or (iv == cast[Ptr[uint8]](0)):
        return AES_ERROR_NULL_POINTER
    if ciphertext_len > output_size:
        return AES_ERROR_INVALID_LENGTH
    aes_key_init(key, key_len)
    result: int32 = aes_cbc_decrypt(ciphertext, output, ciphertext_len, iv)
    if result != 0:
        return result
    padding: int32 = cast[int32](output[ciphertext_len - 1])
    if (padding < 1) or (padding > 16):
        return AES_ERROR_INVALID_LENGTH
    return ciphertext_len - padding
