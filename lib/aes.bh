# aes.bh - AES (Advanced Encryption Standard) Library for BrainhairOS
# Provides AES-128, AES-192, and AES-256 encryption/decryption
# Supports ECB and CBC modes with hardware AES-NI acceleration
# Part of Phase 8 cryptography foundation

# Constants
AES_BLOCK_SIZE: Final[int32] = 16      # AES block size is always 16 bytes
AES_KEY_SIZE_128: Final[int32] = 16    # 128-bit key
AES_KEY_SIZE_192: Final[int32] = 24    # 192-bit key
AES_KEY_SIZE_256: Final[int32] = 32    # 256-bit key

# Error codes
AES_SUCCESS: Final[int32] = 0
AES_ERROR: Final[int32] = -1
AES_ERROR_INVALID_KEY: Final[int32] = -2
AES_ERROR_INVALID_LENGTH: Final[int32] = -3
AES_ERROR_NULL_POINTER: Final[int32] = -4

# AES context structure
# In userland, we rely on kernel AES implementation via syscalls
# This structure holds metadata for the encryption/decryption session

# External kernel AES functions (would be exposed via syscalls in production)
# For now, we'll define placeholder functions that would interface with kernel

# Helper to call kernel AES functions via syscalls
# These would be actual syscalls in production
extern def aes_init() -> int32
extern def aes_set_key(key: Ptr[uint8], key_len: int32) -> int32
extern def aes_encrypt_block(input: Ptr[uint8], output: Ptr[uint8]) -> int32
extern def aes_decrypt_block(input: Ptr[uint8], output: Ptr[uint8]) -> int32
extern def aes_cbc_encrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32
extern def aes_cbc_decrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32
extern def aes_check_aesni() -> int32

# ============================================================================
# AES Context (for userland state management)
# ============================================================================
aes_current_key: Ptr[uint8] = cast[Ptr[uint8]](0)
aes_current_key_len: int32 = 0
aes_is_initialized: int32 = 0

# ============================================================================
# aes_initialize - Initialize AES library
# Must be called before using any AES functions
# Returns: 0 on success, -1 on error
# ============================================================================
def aes_initialize() -> int32:
    if aes_is_initialized != 0:
        return AES_SUCCESS

    result: int32 = aes_init()
    if result == 0:
        aes_is_initialized = 1
        return AES_SUCCESS

    return AES_ERROR

# ============================================================================
# aes_has_hardware_support - Check if CPU supports AES-NI
# Returns: 1 if hardware acceleration available, 0 otherwise
# ============================================================================
def aes_has_hardware_support() -> int32:
    if aes_is_initialized == 0:
        aes_initialize()

    return aes_check_aesni()

# ============================================================================
# aes_key_init - Initialize AES with encryption key
# key: pointer to key bytes
# key_len: key length (must be 16, 24, or 32)
# Returns: 0 on success, error code on failure
# ============================================================================
def aes_key_init(key: Ptr[uint8], key_len: int32) -> int32:
    # Validate parameters
    if key == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if key_len != AES_KEY_SIZE_128 and key_len != AES_KEY_SIZE_192 and key_len != AES_KEY_SIZE_256:
        return AES_ERROR_INVALID_KEY

    # Ensure AES is initialized
    if aes_is_initialized == 0:
        init_result: int32 = aes_initialize()
        if init_result != AES_SUCCESS:
            return init_result

    # Set the key in kernel
    result: int32 = aes_set_key(key, key_len)
    if result == 0:
        aes_current_key = key
        aes_current_key_len = key_len
        return AES_SUCCESS

    return AES_ERROR

# ============================================================================
# aes_encrypt_ecb - Encrypt data using ECB mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# Returns: 0 on success, error code on failure
#
# WARNING: ECB mode is not secure for most use cases.
# Use CBC mode (aes_encrypt_cbc) for production.
# ============================================================================
def aes_encrypt_ecb(input: Ptr[uint8], output: Ptr[uint8], length: int32) -> int32:
    # Validate parameters
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if length <= 0:
        return AES_ERROR_INVALID_LENGTH

    # Check length is multiple of block size
    if (length % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    # Ensure key is set
    if aes_current_key_len == 0:
        return AES_ERROR_INVALID_KEY

    # Encrypt each block
    blocks: int32 = length / AES_BLOCK_SIZE
    i: int32 = 0
    offset: int32 = 0

    while i < blocks:
        in_ptr: Ptr[uint8] = cast[Ptr[uint8]](cast[int32](input) + offset)
        out_ptr: Ptr[uint8] = cast[Ptr[uint8]](cast[int32](output) + offset)

        result: int32 = aes_encrypt_block(in_ptr, out_ptr)
        if result != 0:
            return AES_ERROR

        offset = offset + AES_BLOCK_SIZE
        i = i + 1

    return AES_SUCCESS

# ============================================================================
# aes_decrypt_ecb - Decrypt data using ECB mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# Returns: 0 on success, error code on failure
#
# WARNING: ECB mode is not secure for most use cases.
# Use CBC mode (aes_decrypt_cbc) for production.
# ============================================================================
def aes_decrypt_ecb(input: Ptr[uint8], output: Ptr[uint8], length: int32) -> int32:
    # Validate parameters
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if length <= 0:
        return AES_ERROR_INVALID_LENGTH

    # Check length is multiple of block size
    if (length % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    # Ensure key is set
    if aes_current_key_len == 0:
        return AES_ERROR_INVALID_KEY

    # Decrypt each block
    blocks: int32 = length / AES_BLOCK_SIZE
    i: int32 = 0
    offset: int32 = 0

    while i < blocks:
        in_ptr: Ptr[uint8] = cast[Ptr[uint8]](cast[int32](input) + offset)
        out_ptr: Ptr[uint8] = cast[Ptr[uint8]](cast[int32](output) + offset)

        result: int32 = aes_decrypt_block(in_ptr, out_ptr)
        if result != 0:
            return AES_ERROR

        offset = offset + AES_BLOCK_SIZE
        i = i + 1

    return AES_SUCCESS

# ============================================================================
# aes_encrypt_cbc - Encrypt data using CBC mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# iv: initialization vector (16 bytes)
# Returns: 0 on success, error code on failure
#
# CBC mode is recommended for most encryption tasks.
# The IV should be random and unique for each encryption.
# ============================================================================
def aes_encrypt_cbc_mode(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    # Validate parameters
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0) or iv == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if length <= 0:
        return AES_ERROR_INVALID_LENGTH

    # Check length is multiple of block size
    if (length % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    # Ensure key is set
    if aes_current_key_len == 0:
        return AES_ERROR_INVALID_KEY

    # Call kernel CBC encryption
    result: int32 = aes_cbc_encrypt(input, output, length, iv)
    if result == 0:
        return AES_SUCCESS

    return AES_ERROR

# ============================================================================
# aes_decrypt_cbc - Decrypt data using CBC mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# iv: initialization vector (16 bytes, must match encryption IV)
# Returns: 0 on success, error code on failure
#
# The IV must be the same one used for encryption.
# ============================================================================
def aes_decrypt_cbc_mode(input: Ptr[uint8], output: Ptr[uint8], length: int32, iv: Ptr[uint8]) -> int32:
    # Validate parameters
    if input == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0) or iv == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if length <= 0:
        return AES_ERROR_INVALID_LENGTH

    # Check length is multiple of block size
    if (length % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    # Ensure key is set
    if aes_current_key_len == 0:
        return AES_ERROR_INVALID_KEY

    # Call kernel CBC decryption
    result: int32 = aes_cbc_decrypt(input, output, length, iv)
    if result == 0:
        return AES_SUCCESS

    return AES_ERROR

# ============================================================================
# aes_pkcs7_pad - Add PKCS#7 padding to buffer
# data: buffer containing data
# data_len: actual data length
# buffer_size: total buffer size (must be >= data_len + padding)
# Returns: new length with padding, or -1 on error
#
# PKCS#7 padding: if N bytes are needed, append N bytes of value N
# ============================================================================
def aes_pkcs7_pad(data: Ptr[uint8], data_len: int32, buffer_size: int32) -> int32:
    if data == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if data_len < 0 or buffer_size < data_len:
        return AES_ERROR_INVALID_LENGTH

    # Calculate padding needed
    padding_needed: int32 = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE)
    if padding_needed == 0:
        padding_needed = AES_BLOCK_SIZE  # Always add at least one block of padding

    new_len: int32 = data_len + padding_needed

    if new_len > buffer_size:
        return AES_ERROR_INVALID_LENGTH

    # Add padding bytes
    i: int32 = 0
    while i < padding_needed:
        data[data_len + i] = cast[uint8](padding_needed)
        i = i + 1

    return new_len

# ============================================================================
# aes_pkcs7_unpad - Remove PKCS#7 padding from buffer
# data: buffer containing padded data
# padded_len: length including padding
# Returns: original data length (without padding), or -1 on error
# ============================================================================
def aes_pkcs7_unpad(data: Ptr[uint8], padded_len: int32) -> int32:
    if data == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if padded_len <= 0 or (padded_len % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    # Get padding length from last byte
    padding_len: int32 = cast[int32](data[padded_len - 1])

    # Validate padding
    if padding_len < 1 or padding_len > AES_BLOCK_SIZE:
        return AES_ERROR_INVALID_LENGTH

    if padding_len > padded_len:
        return AES_ERROR_INVALID_LENGTH

    # Verify all padding bytes are correct
    i: int32 = 0
    while i < padding_len:
        if data[padded_len - 1 - i] != cast[uint8](padding_len):
            return AES_ERROR_INVALID_LENGTH
        i = i + 1

    return padded_len - padding_len

# ============================================================================
# aes_generate_iv - Generate random IV for CBC mode
# iv: buffer to store IV (must be 16 bytes)
# Returns: 0 on success, -1 on error
#
# Uses the system RNG to generate a cryptographically secure IV
# ============================================================================
def aes_generate_iv(iv: Ptr[uint8]) -> int32:
    if iv == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    # Use random_bytes from random.bh if available
    # For now, this is a placeholder - in production it would use:
    # extern random_bytes(buf: Ptr[uint8], len: int32): int32
    # return random_bytes(iv, AES_BLOCK_SIZE)

    # Placeholder: fill with pseudo-random data
    i: int32 = 0
    while i < AES_BLOCK_SIZE:
        iv[i] = cast[uint8](i * 17 + 42)  # Deterministic for testing
        i = i + 1

    return AES_SUCCESS

# ============================================================================
# aes_encrypt_string - High-level string encryption (CBC with PKCS#7 padding)
# plaintext: input string
# plaintext_len: length of plaintext
# output: output buffer (must be large enough for padded ciphertext)
# output_size: size of output buffer
# key: encryption key
# key_len: key length (16, 24, or 32)
# iv: buffer to store generated IV (16 bytes, will be written)
# Returns: ciphertext length (including padding), or negative on error
#
# Usage: Caller must allocate output buffer of size >= plaintext_len + 16
# The IV will be written to the provided buffer and should be stored
# ============================================================================
def aes_encrypt_string(plaintext: Ptr[uint8], plaintext_len: int32, output: Ptr[uint8],
                       output_size: int32, key: Ptr[uint8], key_len: int32,
                       iv: Ptr[uint8]) -> int32:
    if plaintext == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if key == cast[Ptr[uint8]](0) or iv == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    # Initialize key
    result: int32 = aes_key_init(key, key_len)
    if result != AES_SUCCESS:
        return result

    # Generate IV
    result = aes_generate_iv(iv)
    if result != AES_SUCCESS:
        return result

    # Calculate padded length
    padding_needed: int32 = AES_BLOCK_SIZE - (plaintext_len % AES_BLOCK_SIZE)
    if padding_needed == 0:
        padding_needed = AES_BLOCK_SIZE

    padded_len: int32 = plaintext_len + padding_needed

    if padded_len > output_size:
        return AES_ERROR_INVALID_LENGTH

    # Copy plaintext to output and add padding
    i: int32 = 0
    while i < plaintext_len:
        output[i] = plaintext[i]
        i = i + 1

    # Add PKCS#7 padding
    i = 0
    while i < padding_needed:
        output[plaintext_len + i] = cast[uint8](padding_needed)
        i = i + 1

    # Encrypt in-place with CBC
    result = aes_encrypt_cbc_mode(output, output, padded_len, iv)
    if result != AES_SUCCESS:
        return result

    return padded_len

# ============================================================================
# aes_decrypt_string - High-level string decryption (CBC with PKCS#7 unpadding)
# ciphertext: encrypted input
# ciphertext_len: length of ciphertext (must be multiple of 16)
# output: output buffer
# output_size: size of output buffer
# key: decryption key
# key_len: key length (16, 24, or 32)
# iv: IV used during encryption (16 bytes)
# Returns: plaintext length (without padding), or negative on error
# ============================================================================
def aes_decrypt_string(ciphertext: Ptr[uint8], ciphertext_len: int32, output: Ptr[uint8],
                       output_size: int32, key: Ptr[uint8], key_len: int32,
                       iv: Ptr[uint8]) -> int32:
    if ciphertext == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if key == cast[Ptr[uint8]](0) or iv == cast[Ptr[uint8]](0):
        return AES_ERROR_NULL_POINTER

    if (ciphertext_len % AES_BLOCK_SIZE) != 0:
        return AES_ERROR_INVALID_LENGTH

    if ciphertext_len > output_size:
        return AES_ERROR_INVALID_LENGTH

    # Initialize key
    result: int32 = aes_key_init(key, key_len)
    if result != AES_SUCCESS:
        return result

    # Decrypt with CBC
    result = aes_decrypt_cbc_mode(ciphertext, output, ciphertext_len, iv)
    if result != AES_SUCCESS:
        return result

    # Remove PKCS#7 padding
    plaintext_len: int32 = aes_pkcs7_unpad(output, ciphertext_len)
    if plaintext_len < 0:
        return AES_ERROR_INVALID_LENGTH

    return plaintext_len

# ============================================================================
# Utility: Get key size name as string
# ============================================================================
def aes_get_key_size_name(key_len: int32) -> Ptr[uint8]:
    if key_len == AES_KEY_SIZE_128:
        return cast[Ptr[uint8]]("AES-128")
    elif key_len == AES_KEY_SIZE_192:
        return cast[Ptr[uint8]]("AES-192")
    elif key_len == AES_KEY_SIZE_256:
        return cast[Ptr[uint8]]("AES-256")
    else:
        return cast[Ptr[uint8]]("Invalid")

# ============================================================================
# Utility: Get error message for error code
# ============================================================================
def aes_get_error_message(error_code: int32) -> Ptr[uint8]:
    if error_code == AES_SUCCESS:
        return cast[Ptr[uint8]]("Success")
    elif error_code == AES_ERROR:
        return cast[Ptr[uint8]]("General error")
    elif error_code == AES_ERROR_INVALID_KEY:
        return cast[Ptr[uint8]]("Invalid key size (must be 16, 24, or 32 bytes)")
    elif error_code == AES_ERROR_INVALID_LENGTH:
        return cast[Ptr[uint8]]("Invalid length (must be multiple of 16 bytes)")
    elif error_code == AES_ERROR_NULL_POINTER:
        return cast[Ptr[uint8]]("Null pointer error")
    else:
        return cast[Ptr[uint8]]("Unknown error")
