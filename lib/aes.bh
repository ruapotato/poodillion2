# aes.bh - AES (Advanced Encryption Standard) Library for BrainhairOS
# Provides AES-128, AES-192, and AES-256 encryption/decryption
# Supports ECB and CBC modes with hardware AES-NI acceleration
# Part of Phase 8 cryptography foundation

# Constants
const AES_BLOCK_SIZE: int32 = 16      # AES block size is always 16 bytes
const AES_KEY_SIZE_128: int32 = 16    # 128-bit key
const AES_KEY_SIZE_192: int32 = 24    # 192-bit key
const AES_KEY_SIZE_256: int32 = 32    # 256-bit key

# Error codes
const AES_SUCCESS: int32 = 0
const AES_ERROR: int32 = -1
const AES_ERROR_INVALID_KEY: int32 = -2
const AES_ERROR_INVALID_LENGTH: int32 = -3
const AES_ERROR_NULL_POINTER: int32 = -4

# AES context structure
# In userland, we rely on kernel AES implementation via syscalls
# This structure holds metadata for the encryption/decryption session

# External kernel AES functions (would be exposed via syscalls in production)
# For now, we'll define placeholder functions that would interface with kernel

# Helper to call kernel AES functions via syscalls
# These would be actual syscalls in production
extern aes_init(): int32
extern aes_set_key(key: ptr uint8, key_len: int32): int32
extern aes_encrypt_block(input: ptr uint8, output: ptr uint8): int32
extern aes_decrypt_block(input: ptr uint8, output: ptr uint8): int32
extern aes_cbc_encrypt(input: ptr uint8, output: ptr uint8, len: int32, iv: ptr uint8): int32
extern aes_cbc_decrypt(input: ptr uint8, output: ptr uint8, len: int32, iv: ptr uint8): int32
extern aes_check_aesni(): int32

# ============================================================================
# AES Context (for userland state management)
# ============================================================================
var aes_current_key: ptr uint8 = cast[ptr uint8](0)
var aes_current_key_len: int32 = 0
var aes_is_initialized: int32 = 0

# ============================================================================
# aes_initialize - Initialize AES library
# Must be called before using any AES functions
# Returns: 0 on success, -1 on error
# ============================================================================
proc aes_initialize(): int32 =
  if aes_is_initialized != 0:
    return AES_SUCCESS

  var result: int32 = aes_init()
  if result == 0:
    aes_is_initialized = 1
    return AES_SUCCESS

  return AES_ERROR

# ============================================================================
# aes_has_hardware_support - Check if CPU supports AES-NI
# Returns: 1 if hardware acceleration available, 0 otherwise
# ============================================================================
proc aes_has_hardware_support(): int32 =
  if aes_is_initialized == 0:
    aes_initialize()

  return aes_check_aesni()

# ============================================================================
# aes_key_init - Initialize AES with encryption key
# key: pointer to key bytes
# key_len: key length (must be 16, 24, or 32)
# Returns: 0 on success, error code on failure
# ============================================================================
proc aes_key_init(key: ptr uint8, key_len: int32): int32 =
  # Validate parameters
  if key == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if key_len != AES_KEY_SIZE_128 and key_len != AES_KEY_SIZE_192 and key_len != AES_KEY_SIZE_256:
    return AES_ERROR_INVALID_KEY

  # Ensure AES is initialized
  if aes_is_initialized == 0:
    var init_result: int32 = aes_initialize()
    if init_result != AES_SUCCESS:
      return init_result

  # Set the key in kernel
  var result: int32 = aes_set_key(key, key_len)
  if result == 0:
    aes_current_key = key
    aes_current_key_len = key_len
    return AES_SUCCESS

  return AES_ERROR

# ============================================================================
# aes_encrypt_ecb - Encrypt data using ECB mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# Returns: 0 on success, error code on failure
#
# WARNING: ECB mode is not secure for most use cases.
# Use CBC mode (aes_encrypt_cbc) for production.
# ============================================================================
proc aes_encrypt_ecb(input: ptr uint8, output: ptr uint8, length: int32): int32 =
  # Validate parameters
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if length <= 0:
    return AES_ERROR_INVALID_LENGTH

  # Check length is multiple of block size
  if (length % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  # Ensure key is set
  if aes_current_key_len == 0:
    return AES_ERROR_INVALID_KEY

  # Encrypt each block
  var blocks: int32 = length / AES_BLOCK_SIZE
  var i: int32 = 0
  var offset: int32 = 0

  while i < blocks:
    var in_ptr: ptr uint8 = cast[ptr uint8](cast[int32](input) + offset)
    var out_ptr: ptr uint8 = cast[ptr uint8](cast[int32](output) + offset)

    var result: int32 = aes_encrypt_block(in_ptr, out_ptr)
    if result != 0:
      return AES_ERROR

    offset = offset + AES_BLOCK_SIZE
    i = i + 1

  return AES_SUCCESS

# ============================================================================
# aes_decrypt_ecb - Decrypt data using ECB mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# Returns: 0 on success, error code on failure
#
# WARNING: ECB mode is not secure for most use cases.
# Use CBC mode (aes_decrypt_cbc) for production.
# ============================================================================
proc aes_decrypt_ecb(input: ptr uint8, output: ptr uint8, length: int32): int32 =
  # Validate parameters
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if length <= 0:
    return AES_ERROR_INVALID_LENGTH

  # Check length is multiple of block size
  if (length % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  # Ensure key is set
  if aes_current_key_len == 0:
    return AES_ERROR_INVALID_KEY

  # Decrypt each block
  var blocks: int32 = length / AES_BLOCK_SIZE
  var i: int32 = 0
  var offset: int32 = 0

  while i < blocks:
    var in_ptr: ptr uint8 = cast[ptr uint8](cast[int32](input) + offset)
    var out_ptr: ptr uint8 = cast[ptr uint8](cast[int32](output) + offset)

    var result: int32 = aes_decrypt_block(in_ptr, out_ptr)
    if result != 0:
      return AES_ERROR

    offset = offset + AES_BLOCK_SIZE
    i = i + 1

  return AES_SUCCESS

# ============================================================================
# aes_encrypt_cbc - Encrypt data using CBC mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# iv: initialization vector (16 bytes)
# Returns: 0 on success, error code on failure
#
# CBC mode is recommended for most encryption tasks.
# The IV should be random and unique for each encryption.
# ============================================================================
proc aes_encrypt_cbc_mode(input: ptr uint8, output: ptr uint8, length: int32, iv: ptr uint8): int32 =
  # Validate parameters
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0) or iv == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if length <= 0:
    return AES_ERROR_INVALID_LENGTH

  # Check length is multiple of block size
  if (length % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  # Ensure key is set
  if aes_current_key_len == 0:
    return AES_ERROR_INVALID_KEY

  # Call kernel CBC encryption
  var result: int32 = aes_cbc_encrypt(input, output, length, iv)
  if result == 0:
    return AES_SUCCESS

  return AES_ERROR

# ============================================================================
# aes_decrypt_cbc - Decrypt data using CBC mode
# input: input buffer (must be multiple of 16 bytes)
# output: output buffer (same size as input)
# length: length in bytes (must be multiple of 16)
# iv: initialization vector (16 bytes, must match encryption IV)
# Returns: 0 on success, error code on failure
#
# The IV must be the same one used for encryption.
# ============================================================================
proc aes_decrypt_cbc_mode(input: ptr uint8, output: ptr uint8, length: int32, iv: ptr uint8): int32 =
  # Validate parameters
  if input == cast[ptr uint8](0) or output == cast[ptr uint8](0) or iv == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if length <= 0:
    return AES_ERROR_INVALID_LENGTH

  # Check length is multiple of block size
  if (length % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  # Ensure key is set
  if aes_current_key_len == 0:
    return AES_ERROR_INVALID_KEY

  # Call kernel CBC decryption
  var result: int32 = aes_cbc_decrypt(input, output, length, iv)
  if result == 0:
    return AES_SUCCESS

  return AES_ERROR

# ============================================================================
# aes_pkcs7_pad - Add PKCS#7 padding to buffer
# data: buffer containing data
# data_len: actual data length
# buffer_size: total buffer size (must be >= data_len + padding)
# Returns: new length with padding, or -1 on error
#
# PKCS#7 padding: if N bytes are needed, append N bytes of value N
# ============================================================================
proc aes_pkcs7_pad(data: ptr uint8, data_len: int32, buffer_size: int32): int32 =
  if data == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if data_len < 0 or buffer_size < data_len:
    return AES_ERROR_INVALID_LENGTH

  # Calculate padding needed
  var padding_needed: int32 = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE)
  if padding_needed == 0:
    padding_needed = AES_BLOCK_SIZE  # Always add at least one block of padding

  var new_len: int32 = data_len + padding_needed

  if new_len > buffer_size:
    return AES_ERROR_INVALID_LENGTH

  # Add padding bytes
  var i: int32 = 0
  while i < padding_needed:
    data[data_len + i] = cast[uint8](padding_needed)
    i = i + 1

  return new_len

# ============================================================================
# aes_pkcs7_unpad - Remove PKCS#7 padding from buffer
# data: buffer containing padded data
# padded_len: length including padding
# Returns: original data length (without padding), or -1 on error
# ============================================================================
proc aes_pkcs7_unpad(data: ptr uint8, padded_len: int32): int32 =
  if data == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if padded_len <= 0 or (padded_len % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  # Get padding length from last byte
  var padding_len: int32 = cast[int32](data[padded_len - 1])

  # Validate padding
  if padding_len < 1 or padding_len > AES_BLOCK_SIZE:
    return AES_ERROR_INVALID_LENGTH

  if padding_len > padded_len:
    return AES_ERROR_INVALID_LENGTH

  # Verify all padding bytes are correct
  var i: int32 = 0
  while i < padding_len:
    if data[padded_len - 1 - i] != cast[uint8](padding_len):
      return AES_ERROR_INVALID_LENGTH
    i = i + 1

  return padded_len - padding_len

# ============================================================================
# aes_generate_iv - Generate random IV for CBC mode
# iv: buffer to store IV (must be 16 bytes)
# Returns: 0 on success, -1 on error
#
# Uses the system RNG to generate a cryptographically secure IV
# ============================================================================
proc aes_generate_iv(iv: ptr uint8): int32 =
  if iv == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  # Use random_bytes from random.bh if available
  # For now, this is a placeholder - in production it would use:
  # extern random_bytes(buf: ptr uint8, len: int32): int32
  # return random_bytes(iv, AES_BLOCK_SIZE)

  # Placeholder: fill with pseudo-random data
  var i: int32 = 0
  while i < AES_BLOCK_SIZE:
    iv[i] = cast[uint8](i * 17 + 42)  # Deterministic for testing
    i = i + 1

  return AES_SUCCESS

# ============================================================================
# aes_encrypt_string - High-level string encryption (CBC with PKCS#7 padding)
# plaintext: input string
# plaintext_len: length of plaintext
# output: output buffer (must be large enough for padded ciphertext)
# output_size: size of output buffer
# key: encryption key
# key_len: key length (16, 24, or 32)
# iv: buffer to store generated IV (16 bytes, will be written)
# Returns: ciphertext length (including padding), or negative on error
#
# Usage: Caller must allocate output buffer of size >= plaintext_len + 16
# The IV will be written to the provided buffer and should be stored
# ============================================================================
proc aes_encrypt_string(plaintext: ptr uint8, plaintext_len: int32, output: ptr uint8,
                        output_size: int32, key: ptr uint8, key_len: int32,
                        iv: ptr uint8): int32 =
  if plaintext == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if key == cast[ptr uint8](0) or iv == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  # Initialize key
  var result: int32 = aes_key_init(key, key_len)
  if result != AES_SUCCESS:
    return result

  # Generate IV
  result = aes_generate_iv(iv)
  if result != AES_SUCCESS:
    return result

  # Calculate padded length
  var padding_needed: int32 = AES_BLOCK_SIZE - (plaintext_len % AES_BLOCK_SIZE)
  if padding_needed == 0:
    padding_needed = AES_BLOCK_SIZE

  var padded_len: int32 = plaintext_len + padding_needed

  if padded_len > output_size:
    return AES_ERROR_INVALID_LENGTH

  # Copy plaintext to output and add padding
  var i: int32 = 0
  while i < plaintext_len:
    output[i] = plaintext[i]
    i = i + 1

  # Add PKCS#7 padding
  i = 0
  while i < padding_needed:
    output[plaintext_len + i] = cast[uint8](padding_needed)
    i = i + 1

  # Encrypt in-place with CBC
  result = aes_encrypt_cbc_mode(output, output, padded_len, iv)
  if result != AES_SUCCESS:
    return result

  return padded_len

# ============================================================================
# aes_decrypt_string - High-level string decryption (CBC with PKCS#7 unpadding)
# ciphertext: encrypted input
# ciphertext_len: length of ciphertext (must be multiple of 16)
# output: output buffer
# output_size: size of output buffer
# key: decryption key
# key_len: key length (16, 24, or 32)
# iv: IV used during encryption (16 bytes)
# Returns: plaintext length (without padding), or negative on error
# ============================================================================
proc aes_decrypt_string(ciphertext: ptr uint8, ciphertext_len: int32, output: ptr uint8,
                        output_size: int32, key: ptr uint8, key_len: int32,
                        iv: ptr uint8): int32 =
  if ciphertext == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if key == cast[ptr uint8](0) or iv == cast[ptr uint8](0):
    return AES_ERROR_NULL_POINTER

  if (ciphertext_len % AES_BLOCK_SIZE) != 0:
    return AES_ERROR_INVALID_LENGTH

  if ciphertext_len > output_size:
    return AES_ERROR_INVALID_LENGTH

  # Initialize key
  var result: int32 = aes_key_init(key, key_len)
  if result != AES_SUCCESS:
    return result

  # Decrypt with CBC
  result = aes_decrypt_cbc_mode(ciphertext, output, ciphertext_len, iv)
  if result != AES_SUCCESS:
    return result

  # Remove PKCS#7 padding
  var plaintext_len: int32 = aes_pkcs7_unpad(output, ciphertext_len)
  if plaintext_len < 0:
    return AES_ERROR_INVALID_LENGTH

  return plaintext_len

# ============================================================================
# Utility: Get key size name as string
# ============================================================================
proc aes_get_key_size_name(key_len: int32): ptr uint8 =
  if key_len == AES_KEY_SIZE_128:
    return cast[ptr uint8]("AES-128")
  elif key_len == AES_KEY_SIZE_192:
    return cast[ptr uint8]("AES-192")
  elif key_len == AES_KEY_SIZE_256:
    return cast[ptr uint8]("AES-256")
  else:
    return cast[ptr uint8]("Invalid")

# ============================================================================
# Utility: Get error message for error code
# ============================================================================
proc aes_get_error_message(error_code: int32): ptr uint8 =
  if error_code == AES_SUCCESS:
    return cast[ptr uint8]("Success")
  elif error_code == AES_ERROR:
    return cast[ptr uint8]("General error")
  elif error_code == AES_ERROR_INVALID_KEY:
    return cast[ptr uint8]("Invalid key size (must be 16, 24, or 32 bytes)")
  elif error_code == AES_ERROR_INVALID_LENGTH:
    return cast[ptr uint8]("Invalid length (must be multiple of 16 bytes)")
  elif error_code == AES_ERROR_NULL_POINTER:
    return cast[ptr uint8]("Null pointer error")
  else:
    return cast[ptr uint8]("Unknown error")
