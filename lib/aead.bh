# aead.bh - ChaCha20-Poly1305 AEAD Cipher Suite for BrainhairOS
# Implements Authenticated Encryption with Associated Data (AEAD)
# As specified in RFC 8439
#
# ChaCha20-Poly1305 combines:
#   - ChaCha20 stream cipher for confidentiality
#   - Poly1305 MAC for authenticity and integrity

# Constants
CHACHA20_POLY1305_KEY_SIZE: Final[int32] = 32    # 256-bit key
CHACHA20_POLY1305_NONCE_SIZE: Final[int32] = 12  # 96-bit nonce
CHACHA20_POLY1305_TAG_SIZE: Final[int32] = 16    # 128-bit authentication tag

# External functions from ChaCha20
extern def chacha20_init(key: Ptr[uint8], nonce: Ptr[uint8], counter: int32)
extern def chacha20_block()
extern def chacha20_get_block() -> Ptr[uint8]
extern def chacha20_encrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, key: Ptr[uint8], nonce: Ptr[uint8], counter: int32)

# External functions from Poly1305
extern def poly1305_init(key: Ptr[uint8]) -> int32
extern def poly1305_update(msg: Ptr[uint8], length: int32)
extern def poly1305_final(tag: Ptr[uint8]) -> int32

# ============================================================================
# Helper: poly1305_key_gen_internal
# Generate Poly1305 key from ChaCha20 (first block with counter=0)
# ============================================================================
def poly1305_key_gen_internal(chacha_key: Ptr[uint8], nonce: Ptr[uint8], poly_key: Ptr[uint8]) -> int32:
    if chacha_key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or poly_key == cast[Ptr[uint8]](0):
        return -1

    # Initialize ChaCha20 with counter=0
    chacha20_init(chacha_key, nonce, 0)

    # Generate first block
    chacha20_block()
    keystream: Ptr[uint8] = chacha20_get_block()

    # Copy first 32 bytes as Poly1305 key
    i: int32 = 0
    while i < 32:
        poly_key[i] = keystream[i]
        i = i + 1

    return 0

# ============================================================================
# Helper: pad_to_16
# Pad data to 16-byte boundary for Poly1305 (returns padding needed)
# ============================================================================
def pad_to_16(length: int32) -> int32:
    remainder: int32 = length & 15  # len % 16
    if remainder == 0:
        return 0
    else:
        return 16 - remainder

# ============================================================================
# Helper: write_le64
# Write 64-bit little-endian integer to buffer
# ============================================================================
def write_le64(buffer: Ptr[uint8], value: int32):
    # Note: BrainhairOS is 32-bit, so we only write the low 32 bits
    # and zero the high 32 bits
    buffer[0] = cast[uint8](value & 0xff)
    buffer[1] = cast[uint8]((value >> 8) & 0xff)
    buffer[2] = cast[uint8]((value >> 16) & 0xff)
    buffer[3] = cast[uint8]((value >> 24) & 0xff)
    buffer[4] = cast[uint8](0)
    buffer[5] = cast[uint8](0)
    buffer[6] = cast[uint8](0)
    buffer[7] = cast[uint8](0)

# ============================================================================
# aead_chacha20_poly1305_encrypt - Encrypt with authentication
# ============================================================================
def aead_chacha20_poly1305_encrypt(
    plaintext: Ptr[uint8],
    plaintext_len: int32,
    aad: Ptr[uint8],
    aad_len: int32,
    key: Ptr[uint8],
    nonce: Ptr[uint8],
    ciphertext: Ptr[uint8],
    tag: Ptr[uint8]
) -> int32:

    if key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or tag == cast[Ptr[uint8]](0):
        return -1

    if plaintext_len > 0 and (plaintext == cast[Ptr[uint8]](0) or ciphertext == cast[Ptr[uint8]](0)):
        return -1

    if aad_len > 0 and aad == cast[Ptr[uint8]](0):
        return -1

    # Step 1: Generate Poly1305 key using ChaCha20 with counter=0
    poly_key: Array[32, uint8]
    result: int32 = poly1305_key_gen_internal(key, nonce, addr(poly_key[0]))
    if result != 0:
        return -1

    # Step 2: Encrypt plaintext using ChaCha20 with counter=1
    if plaintext_len > 0:
        chacha20_encrypt(plaintext, ciphertext, plaintext_len, key, nonce, 1)

    # Step 3: Compute Poly1305 MAC
    result = poly1305_init(addr(poly_key[0]))
    if result != 0:
        return -1

    # Authenticate AAD
    if aad_len > 0:
        poly1305_update(aad, aad_len)

    # Pad AAD to 16-byte boundary
    padding_needed: int32 = pad_to_16(aad_len)
    if padding_needed > 0:
        padding: Array[16, uint8]
        i: int32 = 0
        while i < 16:
            padding[i] = cast[uint8](0)
            i = i + 1
        poly1305_update(addr(padding[0]), padding_needed)

    # Authenticate ciphertext
    if plaintext_len > 0:
        poly1305_update(ciphertext, plaintext_len)

    # Pad ciphertext to 16-byte boundary
    padding_needed = pad_to_16(plaintext_len)
    if padding_needed > 0:
        padding: Array[16, uint8]
        i: int32 = 0
        while i < 16:
            padding[i] = cast[uint8](0)
            i = i + 1
        poly1305_update(addr(padding[0]), padding_needed)

    # Authenticate lengths (as 64-bit little-endian)
    lengths: Array[16, uint8]
    write_le64(addr(lengths[0]), aad_len)
    write_le64(addr(lengths[8]), plaintext_len)
    poly1305_update(addr(lengths[0]), 16)

    # Finalize and get tag
    result = poly1305_final(tag)
    if result != 0:
        return -1

    return 0

# ============================================================================
# aead_chacha20_poly1305_decrypt - Decrypt and verify authentication
# ============================================================================
def aead_chacha20_poly1305_decrypt(
    ciphertext: Ptr[uint8],
    ciphertext_len: int32,
    aad: Ptr[uint8],
    aad_len: int32,
    tag: Ptr[uint8],
    key: Ptr[uint8],
    nonce: Ptr[uint8],
    plaintext: Ptr[uint8]
) -> int32:

    if key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0) or tag == cast[Ptr[uint8]](0):
        return -1

    if ciphertext_len > 0 and (ciphertext == cast[Ptr[uint8]](0) or plaintext == cast[Ptr[uint8]](0)):
        return -1

    if aad_len > 0 and aad == cast[Ptr[uint8]](0):
        return -1

    # Step 1: Generate Poly1305 key using ChaCha20 with counter=0
    poly_key: Array[32, uint8]
    result: int32 = poly1305_key_gen_internal(key, nonce, addr(poly_key[0]))
    if result != 0:
        return -1

    # Step 2: Compute expected MAC (same as encryption)
    result = poly1305_init(addr(poly_key[0]))
    if result != 0:
        return -1

    # Authenticate AAD
    if aad_len > 0:
        poly1305_update(aad, aad_len)

    # Pad AAD to 16-byte boundary
    padding_needed: int32 = pad_to_16(aad_len)
    if padding_needed > 0:
        padding: Array[16, uint8]
        i: int32 = 0
        while i < 16:
            padding[i] = cast[uint8](0)
            i = i + 1
        poly1305_update(addr(padding[0]), padding_needed)

    # Authenticate ciphertext
    if ciphertext_len > 0:
        poly1305_update(ciphertext, ciphertext_len)

    # Pad ciphertext to 16-byte boundary
    padding_needed = pad_to_16(ciphertext_len)
    if padding_needed > 0:
        padding: Array[16, uint8]
        i: int32 = 0
        while i < 16:
            padding[i] = cast[uint8](0)
            i = i + 1
        poly1305_update(addr(padding[0]), padding_needed)

    # Authenticate lengths
    lengths: Array[16, uint8]
    write_le64(addr(lengths[0]), aad_len)
    write_le64(addr(lengths[8]), ciphertext_len)
    poly1305_update(addr(lengths[0]), 16)

    # Compute expected tag
    expected_tag: Array[16, uint8]
    result = poly1305_final(addr(expected_tag[0]))
    if result != 0:
        return -1

    # Step 3: Verify tag (constant-time comparison)
    diff: int32 = 0
    i: int32 = 0
    while i < 16:
        diff = diff | (cast[int32](expected_tag[i]) ^ cast[int32](tag[i]))
        i = i + 1

    if diff != 0:
        # Authentication failed - DO NOT decrypt
        return -2

    # Step 4: Tag verified - decrypt ciphertext
    if ciphertext_len > 0:
        chacha20_encrypt(ciphertext, plaintext, ciphertext_len, key, nonce, 1)

    return 0

# ============================================================================
# AEAD Context for incremental operations
# ============================================================================
class AEADContext:
    key: Array[32, uint8]
    nonce: Array[12, uint8]
    poly_key: Array[32, uint8]
    aad_len: int32
    data_len: int32
    initialized: int32

# ============================================================================
# aead_init - Initialize AEAD context for incremental operations
# ============================================================================
def aead_init(ctx: Ptr[AEADContext], key: Ptr[uint8], nonce: Ptr[uint8]) -> int32:
    if ctx == cast[Ptr[AEADContext]](0) or key == cast[Ptr[uint8]](0) or nonce == cast[Ptr[uint8]](0):
        return -1

    # Copy key and nonce
    i: int32 = 0
    while i < 32:
        ctx.key[i] = key[i]
        i = i + 1

    i = 0
    while i < 12:
        ctx.nonce[i] = nonce[i]
        i = i + 1

    # Generate Poly1305 key
    result: int32 = poly1305_key_gen_internal(key, nonce, addr(ctx.poly_key[0]))
    if result != 0:
        return -1

    ctx.aad_len = 0
    ctx.data_len = 0
    ctx.initialized = 1

    return 0

# ============================================================================
# aead_reset - Reset context for reuse with same key/nonce
# ============================================================================
def aead_reset(ctx: Ptr[AEADContext]) -> int32:
    if ctx == cast[Ptr[AEADContext]](0):
        return -1

    ctx.aad_len = 0
    ctx.data_len = 0

    return 0
