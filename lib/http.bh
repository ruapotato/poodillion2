# PoodillionOS HTTP Library
# Provides simple HTTP client and server functionality

import "lib/net"
import "lib/syscalls"

# HTTP status codes
const HTTP_OK: int32 = 200
const HTTP_NOT_FOUND: int32 = 404
const HTTP_SERVER_ERROR: int32 = 500

# Buffer sizes
const HTTP_BUF_SIZE: int32 = 4096

# =============================================================================
# HTTP Client Functions
# =============================================================================

# Perform a simple HTTP GET request
# host_ip: pointer to 4-byte IPv4 address
# port: server port (usually 80)
# path: URL path (e.g., "/index.html")
# response_buf: buffer to store response body
# max_len: maximum response length
# Returns: number of bytes in response body, or -1 on error
proc http_get(host_ip: ptr uint8, port: int32, path: ptr uint8,
              response_buf: ptr uint8, max_len: int32): int32 =
  # Connect to server
  var sock: int32 = net_connect(host_ip, port)
  if sock < 0:
    return -1

  # Wait for connection
  if net_wait_connected(sock, 5000) == 0:
    net_close(sock)
    return -1

  # Build and send HTTP request
  discard net_send_str(sock, cast[ptr uint8]("GET "))
  discard net_send_str(sock, path)
  discard net_send_str(sock, cast[ptr uint8](" HTTP/1.0\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("Host: "))
  var ip_buf: array[16, uint8]
  discard format_ipv4(host_ip, addr(ip_buf[0]))
  discard net_send_str(sock, addr(ip_buf[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("Connection: close\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Read response
  var total: int32 = 0
  var headers_done: int32 = 0

  while total < max_len:
    var n: int32 = net_recv_blocking(sock, addr(response_buf[total]), max_len - total, 5000)
    if n <= 0:
      break
    total = total + n

  net_close(sock)

  # Find end of headers (\r\n\r\n) and return just body
  var i: int32 = 0
  while i < total - 3:
    if response_buf[i] == 13 and response_buf[i + 1] == 10 and
       response_buf[i + 2] == 13 and response_buf[i + 3] == 10:
      # Found header end - copy body to start of buffer
      var body_start: int32 = i + 4
      var body_len: int32 = total - body_start
      var j: int32 = 0
      while j < body_len:
        response_buf[j] = response_buf[body_start + j]
        j = j + 1
      response_buf[body_len] = 0  # Null terminate
      return body_len
    i = i + 1

  # No headers found, return as-is
  response_buf[total] = 0
  return total

# =============================================================================
# HTTP Server Functions
# =============================================================================

# Send an HTTP response
# sock: connected socket
# status: HTTP status code (e.g., 200, 404)
# content_type: MIME type (e.g., "text/html")
# body: response body
# body_len: length of body (or -1 to use strlen)
proc http_send_response(sock: int32, status: int32, content_type: ptr uint8,
                        body: ptr uint8, body_len: int32) =
  # Status line
  discard net_send_str(sock, cast[ptr uint8]("HTTP/1.0 "))
  var status_str: array[16, uint8]
  discard itoa(status, addr(status_str[0]))
  discard net_send_str(sock, addr(status_str[0]))

  if status == 200:
    discard net_send_str(sock, cast[ptr uint8](" OK\r\n"))
  elif status == 404:
    discard net_send_str(sock, cast[ptr uint8](" Not Found\r\n"))
  else:
    discard net_send_str(sock, cast[ptr uint8](" Error\r\n"))

  # Content-Type header
  discard net_send_str(sock, cast[ptr uint8]("Content-Type: "))
  discard net_send_str(sock, content_type)
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Content-Length header
  var len: int32 = body_len
  if len < 0:
    len = strlen(body)
  discard net_send_str(sock, cast[ptr uint8]("Content-Length: "))
  var len_str: array[16, uint8]
  discard itoa(len, addr(len_str[0]))
  discard net_send_str(sock, addr(len_str[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # End of headers
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Body
  if len > 0:
    discard net_send(sock, body, len)

# Send a simple HTML response
proc http_send_html(sock: int32, status: int32, html: ptr uint8) =
  http_send_response(sock, status, cast[ptr uint8]("text/html"), html, -1)

# Send a plain text response
proc http_send_text(sock: int32, status: int32, text: ptr uint8) =
  http_send_response(sock, status, cast[ptr uint8]("text/plain"), text, -1)

# Send a 404 Not Found response
proc http_send_404(sock: int32) =
  http_send_html(sock, 404, cast[ptr uint8]("<html><body><h1>404 Not Found</h1></body></html>"))

# =============================================================================
# HTTP Request Parsing
# =============================================================================

# Extract the request path from an HTTP request
# request: the raw HTTP request buffer
# path_buf: buffer to store the extracted path
# max_len: maximum path length
# Returns: length of path, or -1 on error
proc http_get_path(request: ptr uint8, path_buf: ptr uint8, max_len: int32): int32 =
  # Find start of path (after "GET " or "POST " etc.)
  var i: int32 = 0

  # Skip method
  while request[i] != 0 and request[i] != 32:  # space
    i = i + 1

  if request[i] == 0:
    return -1

  # Skip space
  i = i + 1

  # Copy path until space or end
  var path_len: int32 = 0
  while request[i] != 0 and request[i] != 32 and path_len < max_len - 1:
    path_buf[path_len] = request[i]
    path_len = path_len + 1
    i = i + 1

  path_buf[path_len] = 0
  return path_len

# Check if request is a GET request
proc http_is_get(request: ptr uint8): int32 =
  if request[0] == 71 and request[1] == 69 and request[2] == 84 and request[3] == 32:
    return 1  # "GET "
  return 0

# Check if request is a POST request
proc http_is_post(request: ptr uint8): int32 =
  if request[0] == 80 and request[1] == 79 and request[2] == 83 and request[3] == 84 and request[4] == 32:
    return 1  # "POST "
  return 0

# =============================================================================
# Simple HTTP Server
# =============================================================================

# Run a simple HTTP server that serves a single static page
# port: port to listen on
# html: HTML content to serve
# Note: This function runs forever until the process is killed
proc http_serve_static(port: int32, html: ptr uint8) =
  var sock: int32 = net_listen(port)
  if sock < 0:
    return

  while 1:
    net_poll()

    if net_accept_ready(sock) == 1:
      # Connection established - read request
      var buf: array[1024, uint8]
      var n: int32 = net_recv_blocking(sock, addr(buf[0]), 1023, 2000)

      if n > 0:
        buf[n] = 0  # Null terminate

        # Send response
        http_send_html(sock, 200, html)

      # Close and re-listen
      net_close(sock)
      sock = net_listen(port)

# =============================================================================
# HTTP Response Structure
# =============================================================================

type HttpResponse = object
  status_code: int32
  content_length: int32
  body: ptr uint8
  body_len: int32
  headers_raw: ptr uint8
  headers_len: int32

# =============================================================================
# HTTP Header Parsing
# =============================================================================

# Parse HTTP status code from response
# response: raw HTTP response
# Returns: status code (e.g., 200, 404) or -1 on error
proc http_parse_status(response: ptr uint8): int32 =
  # Find first space after "HTTP/x.x"
  var i: int32 = 0
  while response[i] != 0 and response[i] != 32:
    i = i + 1

  if response[i] == 0:
    return -1

  # Skip space
  i = i + 1

  # Parse status code (3 digits)
  var status: int32 = 0
  var digits: int32 = 0
  while digits < 3 and response[i] >= 48 and response[i] <= 57:
    status = status * 10 + (cast[int32](response[i]) - 48)
    i = i + 1
    digits = digits + 1

  if digits != 3:
    return -1

  return status

# Get header value by name
# response: raw HTTP response
# header_name: name of header to find (case-insensitive comparison simplified)
# value_buf: buffer to store header value
# max_len: maximum value length
# Returns: length of value or -1 if not found
proc http_get_header(response: ptr uint8, header_name: ptr uint8, value_buf: ptr uint8, max_len: int32): int32 =
  var i: int32 = 0
  var name_len: int32 = strlen(header_name)

  # Skip status line
  while response[i] != 0 and response[i] != 10:
    i = i + 1
  if response[i] == 10:
    i = i + 1

  # Search through headers
  while response[i] != 0:
    # Check for end of headers (empty line)
    if response[i] == 13 and response[i + 1] == 10:
      break
    if response[i] == 10:
      break

    # Compare header name (case-insensitive for ASCII)
    var matched: int32 = 1
    var j: int32 = 0
    while j < name_len:
      var c1: int32 = cast[int32](response[i + j])
      var c2: int32 = cast[int32](header_name[j])
      # Convert to lowercase
      if c1 >= 65 and c1 <= 90:
        c1 = c1 + 32
      if c2 >= 65 and c2 <= 90:
        c2 = c2 + 32
      if c1 != c2:
        matched = 0
        break
      j = j + 1

    if matched == 1 and response[i + name_len] == 58:  # ':'
      # Found header, extract value
      i = i + name_len + 1

      # Skip whitespace
      while response[i] == 32 or response[i] == 9:
        i = i + 1

      # Copy value until CR or LF
      var val_len: int32 = 0
      while response[i] != 0 and response[i] != 13 and response[i] != 10 and val_len < max_len - 1:
        value_buf[val_len] = response[i]
        val_len = val_len + 1
        i = i + 1

      value_buf[val_len] = 0
      return val_len

    # Skip to next line
    while response[i] != 0 and response[i] != 10:
      i = i + 1
    if response[i] == 10:
      i = i + 1

  return -1

# Parse Content-Length header
# response: raw HTTP response
# Returns: content length or -1 if not found
proc http_get_content_length(response: ptr uint8): int32 =
  var value: array[32, uint8]
  var len: int32 = http_get_header(response, cast[ptr uint8]("Content-Length"), addr(value[0]), 32)
  if len < 0:
    return -1

  # Parse integer
  var result: int32 = 0
  var i: int32 = 0
  while value[i] >= 48 and value[i] <= 57:
    result = result * 10 + (cast[int32](value[i]) - 48)
    i = i + 1

  return result

# Get Location header (for redirects)
# response: raw HTTP response
# location_buf: buffer to store location
# max_len: maximum buffer size
# Returns: length of location or -1 if not found
proc http_get_location(response: ptr uint8, location_buf: ptr uint8, max_len: int32): int32 =
  return http_get_header(response, cast[ptr uint8]("Location"), location_buf, max_len)

# =============================================================================
# HTTP POST Support
# =============================================================================

# Perform a simple HTTP POST request
# host_ip: pointer to 4-byte IPv4 address
# port: server port
# path: URL path
# content_type: content type of body
# body: POST body data
# body_len: length of body
# response_buf: buffer to store response body
# max_len: maximum response length
# Returns: number of bytes in response body, or -1 on error
proc http_post(host_ip: ptr uint8, port: int32, path: ptr uint8,
               content_type: ptr uint8, body: ptr uint8, body_len: int32,
               response_buf: ptr uint8, max_len: int32): int32 =
  var sock: int32 = net_connect(host_ip, port)
  if sock < 0:
    return -1

  if net_wait_connected(sock, 5000) == 0:
    net_close(sock)
    return -1

  # Build and send HTTP request
  discard net_send_str(sock, cast[ptr uint8]("POST "))
  discard net_send_str(sock, path)
  discard net_send_str(sock, cast[ptr uint8](" HTTP/1.0\r\n"))

  # Host header
  discard net_send_str(sock, cast[ptr uint8]("Host: "))
  var ip_buf: array[16, uint8]
  discard format_ipv4(host_ip, addr(ip_buf[0]))
  discard net_send_str(sock, addr(ip_buf[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Content-Type header
  discard net_send_str(sock, cast[ptr uint8]("Content-Type: "))
  discard net_send_str(sock, content_type)
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Content-Length header
  discard net_send_str(sock, cast[ptr uint8]("Content-Length: "))
  var len_buf: array[16, uint8]
  discard itoa(body_len, addr(len_buf[0]))
  discard net_send_str(sock, addr(len_buf[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  discard net_send_str(sock, cast[ptr uint8]("Connection: close\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Send body
  if body_len > 0:
    discard net_send(sock, body, body_len)

  # Read response
  var total: int32 = 0
  while total < max_len:
    var n: int32 = net_recv_blocking(sock, addr(response_buf[total]), max_len - total, 5000)
    if n <= 0:
      break
    total = total + n

  net_close(sock)

  # Find end of headers and return body
  var i: int32 = 0
  while i < total - 3:
    if response_buf[i] == 13 and response_buf[i + 1] == 10 and
       response_buf[i + 2] == 13 and response_buf[i + 3] == 10:
      var body_start: int32 = i + 4
      var resp_body_len: int32 = total - body_start
      var j: int32 = 0
      while j < resp_body_len:
        response_buf[j] = response_buf[body_start + j]
        j = j + 1
      response_buf[resp_body_len] = 0
      return resp_body_len
    i = i + 1

  response_buf[total] = 0
  return total

# =============================================================================
# HTTP GET with full response (headers + body)
# =============================================================================

# HTTP GET returning full response including headers
# host_ip: pointer to 4-byte IPv4 address
# port: server port
# path: URL path
# response_buf: buffer to store full response
# max_len: maximum response length
# Returns: total bytes received, or -1 on error
proc http_get_full(host_ip: ptr uint8, port: int32, path: ptr uint8,
                   response_buf: ptr uint8, max_len: int32): int32 =
  var sock: int32 = net_connect(host_ip, port)
  if sock < 0:
    return -1

  if net_wait_connected(sock, 5000) == 0:
    net_close(sock)
    return -1

  # Build and send HTTP request
  discard net_send_str(sock, cast[ptr uint8]("GET "))
  discard net_send_str(sock, path)
  discard net_send_str(sock, cast[ptr uint8](" HTTP/1.0\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("Host: "))
  var ip_buf: array[16, uint8]
  discard format_ipv4(host_ip, addr(ip_buf[0]))
  discard net_send_str(sock, addr(ip_buf[0]))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("Connection: close\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("User-Agent: BrainhairOS/1.0\r\n"))
  discard net_send_str(sock, cast[ptr uint8]("\r\n"))

  # Read response
  var total: int32 = 0
  while total < max_len - 1:
    var n: int32 = net_recv_blocking(sock, addr(response_buf[total]), max_len - total - 1, 5000)
    if n <= 0:
      break
    total = total + n

  net_close(sock)
  response_buf[total] = 0
  return total

# =============================================================================
# URL Parsing
# =============================================================================

# Parse URL into components
# url: URL string (e.g., "http://example.com:8080/path")
# host_buf: buffer to store hostname
# host_max: max hostname length
# path_buf: buffer to store path
# path_max: max path length
# port: pointer to store port number
# Returns: 0 on success, -1 on error
proc http_parse_url(url: ptr uint8, host_buf: ptr uint8, host_max: int32,
                    path_buf: ptr uint8, path_max: int32, port: ptr int32): int32 =
  var i: int32 = 0

  # Skip "http://" or "https://"
  if url[0] == 104 and url[1] == 116 and url[2] == 116 and url[3] == 112:  # "http"
    i = 4
    if url[4] == 115:  # "https"
      i = 5
      if port != cast[ptr int32](0):
        port[0] = 443
    else:
      if port != cast[ptr int32](0):
        port[0] = 80

    if url[i] == 58 and url[i + 1] == 47 and url[i + 2] == 47:  # "://"
      i = i + 3

  # Extract hostname
  var host_len: int32 = 0
  while url[i] != 0 and url[i] != 47 and url[i] != 58 and host_len < host_max - 1:  # '/' or ':'
    host_buf[host_len] = url[i]
    host_len = host_len + 1
    i = i + 1
  host_buf[host_len] = 0

  if host_len == 0:
    return -1

  # Check for port
  if url[i] == 58:  # ':'
    i = i + 1
    var parsed_port: int32 = 0
    while url[i] >= 48 and url[i] <= 57:  # '0'-'9'
      parsed_port = parsed_port * 10 + (cast[int32](url[i]) - 48)
      i = i + 1
    if parsed_port > 0 and port != cast[ptr int32](0):
      port[0] = parsed_port

  # Extract path
  var path_len: int32 = 0
  if url[i] == 47:  # '/'
    while url[i] != 0 and path_len < path_max - 1:
      path_buf[path_len] = url[i]
      path_len = path_len + 1
      i = i + 1
  else:
    # Default path
    path_buf[0] = 47  # '/'
    path_len = 1
  path_buf[path_len] = 0

  return 0

# =============================================================================
# Query String Helpers
# =============================================================================

# Extract query parameter from URL or query string
# query: query string (e.g., "?foo=bar&baz=qux" or just "foo=bar&baz=qux")
# param_name: parameter name to find
# value_buf: buffer to store parameter value
# max_len: maximum value length
# Returns: length of value or -1 if not found
proc http_get_query_param(query: ptr uint8, param_name: ptr uint8,
                          value_buf: ptr uint8, max_len: int32): int32 =
  var i: int32 = 0
  var name_len: int32 = strlen(param_name)

  # Skip leading '?' if present
  if query[0] == 63:
    i = 1

  while query[i] != 0:
    # Check if this is the parameter we're looking for
    var matched: int32 = 1
    var j: int32 = 0
    while j < name_len:
      if query[i + j] != param_name[j]:
        matched = 0
        break
      j = j + 1

    if matched == 1 and query[i + name_len] == 61:  # '='
      # Found it, extract value
      i = i + name_len + 1
      var val_len: int32 = 0
      while query[i] != 0 and query[i] != 38 and val_len < max_len - 1:  # '&'
        value_buf[val_len] = query[i]
        val_len = val_len + 1
        i = i + 1
      value_buf[val_len] = 0
      return val_len

    # Skip to next parameter
    while query[i] != 0 and query[i] != 38:
      i = i + 1
    if query[i] == 38:
      i = i + 1

  return -1

# URL-encode a string
# input: string to encode
# output: buffer for encoded string (must be 3x input length + 1)
# Returns: length of encoded string
proc http_url_encode(input: ptr uint8, output: ptr uint8): int32 =
  var hex: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var i: int32 = 0
  var o: int32 = 0

  while input[i] != 0:
    var c: int32 = cast[int32](input[i])

    # Unreserved characters: A-Z, a-z, 0-9, -, _, ., ~
    if (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
       (c >= 48 and c <= 57) or c == 45 or c == 95 or c == 46 or c == 126:
      output[o] = cast[uint8](c)
      o = o + 1
    else:
      # Encode as %XX
      output[o] = 37  # '%'
      output[o + 1] = hex[(c / 16) and 15]
      output[o + 2] = hex[c and 15]
      o = o + 3

    i = i + 1

  output[o] = 0
  return o

# URL-decode a string
# input: encoded string
# output: buffer for decoded string
# Returns: length of decoded string
proc http_url_decode(input: ptr uint8, output: ptr uint8): int32 =
  var i: int32 = 0
  var o: int32 = 0

  while input[i] != 0:
    if input[i] == 37 and input[i + 1] != 0 and input[i + 2] != 0:  # '%'
      # Decode hex
      var high: int32 = 0
      var low: int32 = 0
      var c: int32 = cast[int32](input[i + 1])

      if c >= 48 and c <= 57:
        high = c - 48
      elif c >= 65 and c <= 70:
        high = c - 55
      elif c >= 97 and c <= 102:
        high = c - 87

      c = cast[int32](input[i + 2])
      if c >= 48 and c <= 57:
        low = c - 48
      elif c >= 65 and c <= 70:
        low = c - 55
      elif c >= 97 and c <= 102:
        low = c - 87

      output[o] = cast[uint8](high * 16 + low)
      o = o + 1
      i = i + 3
    elif input[i] == 43:  # '+' -> space
      output[o] = 32
      o = o + 1
      i = i + 1
    else:
      output[o] = input[i]
      o = o + 1
      i = i + 1

  output[o] = 0
  return o
