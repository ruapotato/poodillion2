# hmac.bh - HMAC (Hash-based Message Authentication Code) Library for BrainhairOS
# RFC 2104 / RFC 4231 compliant HMAC implementation
# Supports SHA-256 and SHA-512 hash functions
#
# HMAC provides message authentication using a shared secret key.
# Use cases: API authentication, message integrity, key derivation

from lib.syscalls import *

# ===========================================================================
# Constants
# ===========================================================================

# SHA-256 parameters
HMAC_SHA256_BLOCK_SIZE: Final[int32] = 64
HMAC_SHA256_DIGEST_SIZE: Final[int32] = 32

# SHA-512 parameters
HMAC_SHA512_BLOCK_SIZE: Final[int32] = 128
HMAC_SHA512_DIGEST_SIZE: Final[int32] = 64

# HMAC padding constants
HMAC_IPAD: Final[int32] = 0x36
HMAC_OPAD: Final[int32] = 0x5c

# ===========================================================================
# External SHA Functions
# ===========================================================================

# SHA-256 (from kernel/sha256.asm)
extern def sha256_init(ctx: Ptr[uint8]) -> int32
extern def sha256_update(ctx: Ptr[uint8], data: Ptr[uint8], length: int32) -> int32
extern def sha256_final(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32
extern def sha256_hash(data: Ptr[uint8], length: int32, output: Ptr[uint8]) -> int32

# SHA-512 syscalls
def sha512_init(ctx: Ptr[uint8]) -> int32:
    return syscall3(260, cast[int32](ctx), 0, 0)

def sha512_update(ctx: Ptr[uint8], data: Ptr[uint8], length: int32) -> int32:
    return syscall3(261, cast[int32](ctx), cast[int32](data), length)

def sha512_final(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32:
    return syscall3(262, cast[int32](ctx), cast[int32](output), 0)

def sha512_hash(data: Ptr[uint8], length: int32, output: Ptr[uint8]) -> int32:
    ctx: Array[256, uint8]
    sha512_init(addr(ctx[0]))
    sha512_update(addr(ctx[0]), data, length)
    return sha512_final(addr(ctx[0]), output)

# ===========================================================================
# HMAC-SHA256 Context
# ===========================================================================

class HmacSha256Context:
    key_block: Array[64, uint8]    # Padded key
    inner_ctx: Array[128, uint8]   # SHA-256 context for inner hash
    outer_key: Array[64, uint8]    # Key XOR opad for outer hash
    initialized: int32

# ===========================================================================
# HMAC-SHA256 Functions
# ===========================================================================

# Initialize HMAC-SHA256 context with key
def hmac_sha256_init(ctx: Ptr[HmacSha256Context], key: Ptr[uint8], key_len: int32) -> int32:
    if ctx == cast[Ptr[HmacSha256Context]](0) or key == cast[Ptr[uint8]](0):
        return -1

    i: int32 = 0

    # Prepare key block - hash if too long, pad with zeros if short
    if key_len > 64:
        # Key is too long, hash it first
        sha256_hash(key, key_len, addr(ctx.key_block[0]))
        i = 32
        while i < 64:
            ctx.key_block[i] = 0
            i = i + 1
    else:
        # Copy key and pad with zeros
        i = 0
        while i < key_len:
            ctx.key_block[i] = key[i]
            i = i + 1
        while i < 64:
            ctx.key_block[i] = 0
            i = i + 1

    # Create inner padded key (key XOR ipad)
    ipad: Array[64, uint8]
    i = 0
    while i < 64:
        ipad[i] = cast[uint8](cast[int32](ctx.key_block[i]) ^ HMAC_IPAD)
        ctx.outer_key[i] = cast[uint8](cast[int32](ctx.key_block[i]) ^ HMAC_OPAD)
        i = i + 1

    # Initialize inner hash with (key XOR ipad)
    sha256_init(addr(ctx.inner_ctx[0]))
    sha256_update(addr(ctx.inner_ctx[0]), addr(ipad[0]), 64)

    ctx.initialized = 1
    return 0

# Update HMAC-SHA256 with more data
def hmac_sha256_update(ctx: Ptr[HmacSha256Context], data: Ptr[uint8], length: int32) -> int32:
    if ctx == cast[Ptr[HmacSha256Context]](0) or ctx.initialized != 1:
        return -1

    return sha256_update(addr(ctx.inner_ctx[0]), data, length)

# Finalize HMAC-SHA256 and get MAC
def hmac_sha256_final(ctx: Ptr[HmacSha256Context], output: Ptr[uint8]) -> int32:
    if ctx == cast[Ptr[HmacSha256Context]](0) or ctx.initialized != 1:
        return -1

    # Complete inner hash
    inner_hash: Array[32, uint8]
    sha256_final(addr(ctx.inner_ctx[0]), addr(inner_hash[0]))

    # Compute outer hash: H((key XOR opad) || inner_hash)
    outer_ctx: Array[128, uint8]
    sha256_init(addr(outer_ctx[0]))
    sha256_update(addr(outer_ctx[0]), addr(ctx.outer_key[0]), 64)
    sha256_update(addr(outer_ctx[0]), addr(inner_hash[0]), 32)
    sha256_final(addr(outer_ctx[0]), output)

    ctx.initialized = 0
    return 0

# One-shot HMAC-SHA256
def hmac_sha256(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    ctx: HmacSha256Context

    if hmac_sha256_init(addr(ctx), key, key_len) < 0:
        return -1

    if hmac_sha256_update(addr(ctx), data, data_len) < 0:
        return -1

    return hmac_sha256_final(addr(ctx), output)

# ===========================================================================
# HMAC-SHA512 Context
# ===========================================================================

class HmacSha512Context:
    key_block: Array[128, uint8]   # Padded key (128 bytes for SHA-512)
    inner_ctx: Array[256, uint8]   # SHA-512 context for inner hash
    outer_key: Array[128, uint8]   # Key XOR opad for outer hash
    initialized: int32

# ===========================================================================
# HMAC-SHA512 Functions
# ===========================================================================

# Initialize HMAC-SHA512 context with key
def hmac_sha512_init(ctx: Ptr[HmacSha512Context], key: Ptr[uint8], key_len: int32) -> int32:
    if ctx == cast[Ptr[HmacSha512Context]](0) or key == cast[Ptr[uint8]](0):
        return -1

    i: int32 = 0

    # Prepare key block - hash if too long, pad with zeros if short
    if key_len > 128:
        # Key is too long, hash it first
        sha512_hash(key, key_len, addr(ctx.key_block[0]))
        i = 64
        while i < 128:
            ctx.key_block[i] = 0
            i = i + 1
    else:
        # Copy key and pad with zeros
        i = 0
        while i < key_len:
            ctx.key_block[i] = key[i]
            i = i + 1
        while i < 128:
            ctx.key_block[i] = 0
            i = i + 1

    # Create inner padded key (key XOR ipad) and outer key (key XOR opad)
    ipad: Array[128, uint8]
    i = 0
    while i < 128:
        ipad[i] = cast[uint8](cast[int32](ctx.key_block[i]) ^ HMAC_IPAD)
        ctx.outer_key[i] = cast[uint8](cast[int32](ctx.key_block[i]) ^ HMAC_OPAD)
        i = i + 1

    # Initialize inner hash with (key XOR ipad)
    sha512_init(addr(ctx.inner_ctx[0]))
    sha512_update(addr(ctx.inner_ctx[0]), addr(ipad[0]), 128)

    ctx.initialized = 1
    return 0

# Update HMAC-SHA512 with more data
def hmac_sha512_update(ctx: Ptr[HmacSha512Context], data: Ptr[uint8], length: int32) -> int32:
    if ctx == cast[Ptr[HmacSha512Context]](0) or ctx.initialized != 1:
        return -1

    return sha512_update(addr(ctx.inner_ctx[0]), data, length)

# Finalize HMAC-SHA512 and get MAC
def hmac_sha512_final(ctx: Ptr[HmacSha512Context], output: Ptr[uint8]) -> int32:
    if ctx == cast[Ptr[HmacSha512Context]](0) or ctx.initialized != 1:
        return -1

    # Complete inner hash
    inner_hash: Array[64, uint8]
    sha512_final(addr(ctx.inner_ctx[0]), addr(inner_hash[0]))

    # Compute outer hash: H((key XOR opad) || inner_hash)
    outer_ctx: Array[256, uint8]
    sha512_init(addr(outer_ctx[0]))
    sha512_update(addr(outer_ctx[0]), addr(ctx.outer_key[0]), 128)
    sha512_update(addr(outer_ctx[0]), addr(inner_hash[0]), 64)
    sha512_final(addr(outer_ctx[0]), output)

    ctx.initialized = 0
    return 0

# One-shot HMAC-SHA512
def hmac_sha512(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    ctx: HmacSha512Context

    if hmac_sha512_init(addr(ctx), key, key_len) < 0:
        return -1

    if hmac_sha512_update(addr(ctx), data, data_len) < 0:
        return -1

    return hmac_sha512_final(addr(ctx), output)

# ===========================================================================
# HKDF (HMAC-based Key Derivation Function) - RFC 5869
# ===========================================================================

# HKDF-Extract using SHA-256
def hkdf_sha256_extract(salt: Ptr[uint8], salt_len: int32, ikm: Ptr[uint8], ikm_len: int32, prk: Ptr[uint8]) -> int32:
    if ikm == cast[Ptr[uint8]](0) or prk == cast[Ptr[uint8]](0):
        return -1

    # If no salt provided, use string of zeros
    zero_salt: Array[32, uint8]
    actual_salt: Ptr[uint8] = salt
    actual_salt_len: int32 = salt_len

    if salt == cast[Ptr[uint8]](0) or salt_len == 0:
        i: int32 = 0
        while i < 32:
            zero_salt[i] = 0
            i = i + 1
        actual_salt = addr(zero_salt[0])
        actual_salt_len = 32

    # PRK = HMAC-Hash(salt, IKM)
    return hmac_sha256(actual_salt, actual_salt_len, ikm, ikm_len, prk)

# HKDF-Expand using SHA-256
def hkdf_sha256_expand(prk: Ptr[uint8], info: Ptr[uint8], info_len: int32, okm: Ptr[uint8], okm_len: int32) -> int32:
    if prk == cast[Ptr[uint8]](0) or okm == cast[Ptr[uint8]](0):
        return -1

    if okm_len <= 0 or okm_len > 8160:
        return -1

    hash_len: int32 = 32
    n: int32 = (okm_len + hash_len - 1) / hash_len  # Ceiling division

    t: Array[32, uint8]  # T(i)
    t_len: int32 = 0       # Length of T(i-1)
    pos: int32 = 0         # Position in output
    i: int32 = 1

    while i <= n:
        # T(i) = HMAC-Hash(PRK, T(i-1) || info || i)
        ctx: HmacSha256Context
        hmac_sha256_init(addr(ctx), prk, 32)

        # Add T(i-1) if not first iteration
        if t_len > 0:
            hmac_sha256_update(addr(ctx), addr(t[0]), t_len)

        # Add info
        if info != cast[Ptr[uint8]](0) and info_len > 0:
            hmac_sha256_update(addr(ctx), info, info_len)

        # Add counter byte
        counter: uint8 = cast[uint8](i)
        hmac_sha256_update(addr(ctx), addr(counter), 1)

        hmac_sha256_final(addr(ctx), addr(t[0]))
        t_len = 32

        # Copy to output
        copy_len: int32 = hash_len
        if pos + copy_len > okm_len:
            copy_len = okm_len - pos

        j: int32 = 0
        while j < copy_len:
            okm[pos] = t[j]
            pos = pos + 1
            j = j + 1

        i = i + 1

    return 0

# HKDF one-shot using SHA-256
def hkdf_sha256(salt: Ptr[uint8], salt_len: int32, ikm: Ptr[uint8], ikm_len: int32, info: Ptr[uint8], info_len: int32, okm: Ptr[uint8], okm_len: int32) -> int32:
    prk: Array[32, uint8]

    if hkdf_sha256_extract(salt, salt_len, ikm, ikm_len, addr(prk[0])) < 0:
        return -1

    return hkdf_sha256_expand(addr(prk[0]), info, info_len, okm, okm_len)

# ===========================================================================
# HKDF using SHA-512
# ===========================================================================

# HKDF-Extract using SHA-512
def hkdf_sha512_extract(salt: Ptr[uint8], salt_len: int32, ikm: Ptr[uint8], ikm_len: int32, prk: Ptr[uint8]) -> int32:
    if ikm == cast[Ptr[uint8]](0) or prk == cast[Ptr[uint8]](0):
        return -1

    zero_salt: Array[64, uint8]
    actual_salt: Ptr[uint8] = salt
    actual_salt_len: int32 = salt_len

    if salt == cast[Ptr[uint8]](0) or salt_len == 0:
        i: int32 = 0
        while i < 64:
            zero_salt[i] = 0
            i = i + 1
        actual_salt = addr(zero_salt[0])
        actual_salt_len = 64

    return hmac_sha512(actual_salt, actual_salt_len, ikm, ikm_len, prk)

# HKDF-Expand using SHA-512
def hkdf_sha512_expand(prk: Ptr[uint8], info: Ptr[uint8], info_len: int32, okm: Ptr[uint8], okm_len: int32) -> int32:
    if prk == cast[Ptr[uint8]](0) or okm == cast[Ptr[uint8]](0):
        return -1

    if okm_len <= 0 or okm_len > 16320:  # 255 * 64
        return -1

    hash_len: int32 = 64
    n: int32 = (okm_len + hash_len - 1) / hash_len

    t: Array[64, uint8]
    t_len: int32 = 0
    pos: int32 = 0
    i: int32 = 1

    while i <= n:
        ctx: HmacSha512Context
        hmac_sha512_init(addr(ctx), prk, 64)

        if t_len > 0:
            hmac_sha512_update(addr(ctx), addr(t[0]), t_len)

        if info != cast[Ptr[uint8]](0) and info_len > 0:
            hmac_sha512_update(addr(ctx), info, info_len)

        counter: uint8 = cast[uint8](i)
        hmac_sha512_update(addr(ctx), addr(counter), 1)

        hmac_sha512_final(addr(ctx), addr(t[0]))
        t_len = 64

        copy_len: int32 = hash_len
        if pos + copy_len > okm_len:
            copy_len = okm_len - pos

        j: int32 = 0
        while j < copy_len:
            okm[pos] = t[j]
            pos = pos + 1
            j = j + 1

        i = i + 1

    return 0

# HKDF one-shot using SHA-512
def hkdf_sha512(salt: Ptr[uint8], salt_len: int32, ikm: Ptr[uint8], ikm_len: int32, info: Ptr[uint8], info_len: int32, okm: Ptr[uint8], okm_len: int32) -> int32:
    prk: Array[64, uint8]

    if hkdf_sha512_extract(salt, salt_len, ikm, ikm_len, addr(prk[0])) < 0:
        return -1

    return hkdf_sha512_expand(addr(prk[0]), info, info_len, okm, okm_len)

# ===========================================================================
# PBKDF2 (Password-Based Key Derivation Function 2) - RFC 8018
# ===========================================================================

# PBKDF2-HMAC-SHA256
def pbkdf2_sha256(password: Ptr[uint8], pass_len: int32, salt: Ptr[uint8], salt_len: int32, iterations: int32, output: Ptr[uint8], output_len: int32) -> int32:
    if password == cast[Ptr[uint8]](0) or salt == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return -1

    if iterations < 1 or output_len < 1:
        return -1

    hash_len: int32 = 32
    blocks_needed: int32 = (output_len + hash_len - 1) / hash_len
    pos: int32 = 0
    block_num: int32 = 1

    # Salt buffer with space for 4-byte block counter
    salt_block: Array[1024, uint8]
    i: int32 = 0
    while i < salt_len and i < 1020:
        salt_block[i] = salt[i]
        i = i + 1

    while block_num <= blocks_needed:
        # Append block number as big-endian 32-bit integer
        salt_block[salt_len] = cast[uint8]((block_num / 16777216) & 0xFF)
        salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) & 0xFF)
        salt_block[salt_len + 2] = cast[uint8]((block_num / 256) & 0xFF)
        salt_block[salt_len + 3] = cast[uint8](block_num & 0xFF)

        # U_1 = PRF(Password, Salt || INT(i))
        u: Array[32, uint8]
        result: Array[32, uint8]
        hmac_sha256(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

        # Copy U_1 to result
        i = 0
        while i < 32:
            result[i] = u[i]
            i = i + 1

        # U_2 through U_c
        iter: int32 = 1
        while iter < iterations:
            hmac_sha256(password, pass_len, addr(u[0]), 32, addr(u[0]))
            # XOR into result
            i = 0
            while i < 32:
                result[i] = cast[uint8](cast[int32](result[i]) ^ cast[int32](u[i]))
                i = i + 1
            iter = iter + 1

        # Copy to output
        copy_len: int32 = hash_len
        if pos + copy_len > output_len:
            copy_len = output_len - pos

        i = 0
        while i < copy_len:
            output[pos] = result[i]
            pos = pos + 1
            i = i + 1

        block_num = block_num + 1

    return 0

# PBKDF2-HMAC-SHA512
def pbkdf2_sha512(password: Ptr[uint8], pass_len: int32, salt: Ptr[uint8], salt_len: int32, iterations: int32, output: Ptr[uint8], output_len: int32) -> int32:
    if password == cast[Ptr[uint8]](0) or salt == cast[Ptr[uint8]](0) or output == cast[Ptr[uint8]](0):
        return -1

    if iterations < 1 or output_len < 1:
        return -1

    hash_len: int32 = 64
    blocks_needed: int32 = (output_len + hash_len - 1) / hash_len
    pos: int32 = 0
    block_num: int32 = 1

    salt_block: Array[1024, uint8]
    i: int32 = 0
    while i < salt_len and i < 1020:
        salt_block[i] = salt[i]
        i = i + 1

    while block_num <= blocks_needed:
        salt_block[salt_len] = cast[uint8]((block_num / 16777216) & 0xFF)
        salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) & 0xFF)
        salt_block[salt_len + 2] = cast[uint8]((block_num / 256) & 0xFF)
        salt_block[salt_len + 3] = cast[uint8](block_num & 0xFF)

        u: Array[64, uint8]
        result: Array[64, uint8]
        hmac_sha512(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

        i = 0
        while i < 64:
            result[i] = u[i]
            i = i + 1

        iter: int32 = 1
        while iter < iterations:
            hmac_sha512(password, pass_len, addr(u[0]), 64, addr(u[0]))
            i = 0
            while i < 64:
                result[i] = cast[uint8](cast[int32](result[i]) ^ cast[int32](u[i]))
                i = i + 1
            iter = iter + 1

        copy_len: int32 = hash_len
        if pos + copy_len > output_len:
            copy_len = output_len - pos

        i = 0
        while i < copy_len:
            output[pos] = result[i]
            pos = pos + 1
            i = i + 1

        block_num = block_num + 1

    return 0

# ===========================================================================
# Utility Functions
# ===========================================================================

# Constant-time comparison to prevent timing attacks
def hmac_compare(mac1: Ptr[uint8], mac2: Ptr[uint8], length: int32) -> int32:
    if mac1 == cast[Ptr[uint8]](0) or mac2 == cast[Ptr[uint8]](0):
        return 0

    diff: int32 = 0
    i: int32 = 0
    while i < length:
        diff = diff | (cast[int32](mac1[i]) ^ cast[int32](mac2[i]))
        i = i + 1

    if diff == 0:
        return 1
    return 0

# Verify HMAC-SHA256 in constant time
def hmac_sha256_verify(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, expected: Ptr[uint8]) -> int32:
    computed: Array[32, uint8]
    if hmac_sha256(key, key_len, data, data_len, addr(computed[0])) < 0:
        return 0
    return hmac_compare(addr(computed[0]), expected, 32)

# Verify HMAC-SHA512 in constant time
def hmac_sha512_verify(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, expected: Ptr[uint8]) -> int32:
    computed: Array[64, uint8]
    if hmac_sha512(key, key_len, data, data_len, addr(computed[0])) < 0:
        return 0
    return hmac_compare(addr(computed[0]), expected, 64)
