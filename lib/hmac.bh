# hmac.bh - HMAC (Hash-based Message Authentication Code) Library for BrainhairOS
# RFC 2104 / RFC 4231 compliant HMAC implementation
# Supports SHA-256 and SHA-512 hash functions
#
# HMAC provides message authentication using a shared secret key.
# Use cases: API authentication, message integrity, key derivation

import "lib/syscalls"

# ===========================================================================
# Constants
# ===========================================================================

# SHA-256 parameters
const HMAC_SHA256_BLOCK_SIZE: int32 = 64
const HMAC_SHA256_DIGEST_SIZE: int32 = 32

# SHA-512 parameters
const HMAC_SHA512_BLOCK_SIZE: int32 = 128
const HMAC_SHA512_DIGEST_SIZE: int32 = 64

# HMAC padding constants
const HMAC_IPAD: int32 = 0x36
const HMAC_OPAD: int32 = 0x5c

# ===========================================================================
# External SHA Functions
# ===========================================================================

# SHA-256 (from kernel/sha256.asm)
extern sha256_init(ctx: ptr uint8): int32
extern sha256_update(ctx: ptr uint8, data: ptr uint8, len: int32): int32
extern sha256_final(ctx: ptr uint8, output: ptr uint8): int32
extern sha256_hash(data: ptr uint8, len: int32, output: ptr uint8): int32

# SHA-512 syscalls
proc sha512_init(ctx: ptr uint8): int32 =
  return syscall3(260, cast[int32](ctx), 0, 0)

proc sha512_update(ctx: ptr uint8, data: ptr uint8, len: int32): int32 =
  return syscall3(261, cast[int32](ctx), cast[int32](data), len)

proc sha512_final(ctx: ptr uint8, output: ptr uint8): int32 =
  return syscall3(262, cast[int32](ctx), cast[int32](output), 0)

proc sha512_hash(data: ptr uint8, len: int32, output: ptr uint8): int32 =
  var ctx: array[256, uint8]
  sha512_init(addr(ctx[0]))
  sha512_update(addr(ctx[0]), data, len)
  return sha512_final(addr(ctx[0]), output)

# ===========================================================================
# HMAC-SHA256 Context
# ===========================================================================

type HmacSha256Context = object
  key_block: array[64, uint8]    # Padded key
  inner_ctx: array[128, uint8]   # SHA-256 context for inner hash
  outer_key: array[64, uint8]    # Key XOR opad for outer hash
  initialized: int32

# ===========================================================================
# HMAC-SHA256 Functions
# ===========================================================================

# Initialize HMAC-SHA256 context with key
# ctx: pointer to HmacSha256Context
# key: pointer to key bytes
# key_len: length of key in bytes
# Returns: 0 on success, -1 on error
proc hmac_sha256_init(ctx: ptr HmacSha256Context, key: ptr uint8, key_len: int32): int32 =
  if ctx == cast[ptr HmacSha256Context](0) or key == cast[ptr uint8](0):
    return -1

  var i: int32 = 0

  # Prepare key block - hash if too long, pad with zeros if short
  if key_len > 64:
    # Key is too long, hash it first
    sha256_hash(key, key_len, addr(ctx.key_block[0]))
    i = 32
    while i < 64:
      ctx.key_block[i] = 0
      i = i + 1
  else:
    # Copy key and pad with zeros
    i = 0
    while i < key_len:
      ctx.key_block[i] = key[i]
      i = i + 1
    while i < 64:
      ctx.key_block[i] = 0
      i = i + 1

  # Create inner padded key (key XOR ipad)
  var ipad: array[64, uint8]
  i = 0
  while i < 64:
    ipad[i] = cast[uint8](cast[int32](ctx.key_block[i]) xor HMAC_IPAD)
    ctx.outer_key[i] = cast[uint8](cast[int32](ctx.key_block[i]) xor HMAC_OPAD)
    i = i + 1

  # Initialize inner hash with (key XOR ipad)
  sha256_init(addr(ctx.inner_ctx[0]))
  sha256_update(addr(ctx.inner_ctx[0]), addr(ipad[0]), 64)

  ctx.initialized = 1
  return 0

# Update HMAC-SHA256 with more data
# ctx: pointer to initialized HmacSha256Context
# data: pointer to data bytes
# len: length of data
# Returns: 0 on success, -1 on error
proc hmac_sha256_update(ctx: ptr HmacSha256Context, data: ptr uint8, len: int32): int32 =
  if ctx == cast[ptr HmacSha256Context](0) or ctx.initialized != 1:
    return -1

  return sha256_update(addr(ctx.inner_ctx[0]), data, len)

# Finalize HMAC-SHA256 and get MAC
# ctx: pointer to HmacSha256Context
# output: pointer to 32-byte output buffer
# Returns: 0 on success, -1 on error
proc hmac_sha256_final(ctx: ptr HmacSha256Context, output: ptr uint8): int32 =
  if ctx == cast[ptr HmacSha256Context](0) or ctx.initialized != 1:
    return -1

  # Complete inner hash
  var inner_hash: array[32, uint8]
  sha256_final(addr(ctx.inner_ctx[0]), addr(inner_hash[0]))

  # Compute outer hash: H((key XOR opad) || inner_hash)
  var outer_ctx: array[128, uint8]
  sha256_init(addr(outer_ctx[0]))
  sha256_update(addr(outer_ctx[0]), addr(ctx.outer_key[0]), 64)
  sha256_update(addr(outer_ctx[0]), addr(inner_hash[0]), 32)
  sha256_final(addr(outer_ctx[0]), output)

  ctx.initialized = 0
  return 0

# One-shot HMAC-SHA256
# key: pointer to key bytes
# key_len: length of key
# data: pointer to data bytes
# data_len: length of data
# output: pointer to 32-byte output buffer
# Returns: 0 on success, -1 on error
proc hmac_sha256(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, output: ptr uint8): int32 =
  var ctx: HmacSha256Context

  if hmac_sha256_init(addr(ctx), key, key_len) < 0:
    return -1

  if hmac_sha256_update(addr(ctx), data, data_len) < 0:
    return -1

  return hmac_sha256_final(addr(ctx), output)

# ===========================================================================
# HMAC-SHA512 Context
# ===========================================================================

type HmacSha512Context = object
  key_block: array[128, uint8]   # Padded key (128 bytes for SHA-512)
  inner_ctx: array[256, uint8]   # SHA-512 context for inner hash
  outer_key: array[128, uint8]   # Key XOR opad for outer hash
  initialized: int32

# ===========================================================================
# HMAC-SHA512 Functions
# ===========================================================================

# Initialize HMAC-SHA512 context with key
# ctx: pointer to HmacSha512Context
# key: pointer to key bytes
# key_len: length of key in bytes
# Returns: 0 on success, -1 on error
proc hmac_sha512_init(ctx: ptr HmacSha512Context, key: ptr uint8, key_len: int32): int32 =
  if ctx == cast[ptr HmacSha512Context](0) or key == cast[ptr uint8](0):
    return -1

  var i: int32 = 0

  # Prepare key block - hash if too long, pad with zeros if short
  if key_len > 128:
    # Key is too long, hash it first
    sha512_hash(key, key_len, addr(ctx.key_block[0]))
    i = 64
    while i < 128:
      ctx.key_block[i] = 0
      i = i + 1
  else:
    # Copy key and pad with zeros
    i = 0
    while i < key_len:
      ctx.key_block[i] = key[i]
      i = i + 1
    while i < 128:
      ctx.key_block[i] = 0
      i = i + 1

  # Create inner padded key (key XOR ipad) and outer key (key XOR opad)
  var ipad: array[128, uint8]
  i = 0
  while i < 128:
    ipad[i] = cast[uint8](cast[int32](ctx.key_block[i]) xor HMAC_IPAD)
    ctx.outer_key[i] = cast[uint8](cast[int32](ctx.key_block[i]) xor HMAC_OPAD)
    i = i + 1

  # Initialize inner hash with (key XOR ipad)
  sha512_init(addr(ctx.inner_ctx[0]))
  sha512_update(addr(ctx.inner_ctx[0]), addr(ipad[0]), 128)

  ctx.initialized = 1
  return 0

# Update HMAC-SHA512 with more data
# ctx: pointer to initialized HmacSha512Context
# data: pointer to data bytes
# len: length of data
# Returns: 0 on success, -1 on error
proc hmac_sha512_update(ctx: ptr HmacSha512Context, data: ptr uint8, len: int32): int32 =
  if ctx == cast[ptr HmacSha512Context](0) or ctx.initialized != 1:
    return -1

  return sha512_update(addr(ctx.inner_ctx[0]), data, len)

# Finalize HMAC-SHA512 and get MAC
# ctx: pointer to HmacSha512Context
# output: pointer to 64-byte output buffer
# Returns: 0 on success, -1 on error
proc hmac_sha512_final(ctx: ptr HmacSha512Context, output: ptr uint8): int32 =
  if ctx == cast[ptr HmacSha512Context](0) or ctx.initialized != 1:
    return -1

  # Complete inner hash
  var inner_hash: array[64, uint8]
  sha512_final(addr(ctx.inner_ctx[0]), addr(inner_hash[0]))

  # Compute outer hash: H((key XOR opad) || inner_hash)
  var outer_ctx: array[256, uint8]
  sha512_init(addr(outer_ctx[0]))
  sha512_update(addr(outer_ctx[0]), addr(ctx.outer_key[0]), 128)
  sha512_update(addr(outer_ctx[0]), addr(inner_hash[0]), 64)
  sha512_final(addr(outer_ctx[0]), output)

  ctx.initialized = 0
  return 0

# One-shot HMAC-SHA512
# key: pointer to key bytes
# key_len: length of key
# data: pointer to data bytes
# data_len: length of data
# output: pointer to 64-byte output buffer
# Returns: 0 on success, -1 on error
proc hmac_sha512(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, output: ptr uint8): int32 =
  var ctx: HmacSha512Context

  if hmac_sha512_init(addr(ctx), key, key_len) < 0:
    return -1

  if hmac_sha512_update(addr(ctx), data, data_len) < 0:
    return -1

  return hmac_sha512_final(addr(ctx), output)

# ===========================================================================
# HKDF (HMAC-based Key Derivation Function) - RFC 5869
# ===========================================================================

# HKDF-Extract using SHA-256
# Extracts a pseudo-random key from input keying material
# salt: optional salt value (can be null, will use zeros)
# salt_len: length of salt
# ikm: input keying material
# ikm_len: length of input keying material
# prk: output pseudo-random key (32 bytes)
# Returns: 0 on success, -1 on error
proc hkdf_sha256_extract(salt: ptr uint8, salt_len: int32, ikm: ptr uint8, ikm_len: int32, prk: ptr uint8): int32 =
  if ikm == cast[ptr uint8](0) or prk == cast[ptr uint8](0):
    return -1

  # If no salt provided, use string of zeros
  var zero_salt: array[32, uint8]
  var actual_salt: ptr uint8 = salt
  var actual_salt_len: int32 = salt_len

  if salt == cast[ptr uint8](0) or salt_len == 0:
    var i: int32 = 0
    while i < 32:
      zero_salt[i] = 0
      i = i + 1
    actual_salt = addr(zero_salt[0])
    actual_salt_len = 32

  # PRK = HMAC-Hash(salt, IKM)
  return hmac_sha256(actual_salt, actual_salt_len, ikm, ikm_len, prk)

# HKDF-Expand using SHA-256
# Expands a pseudo-random key into output keying material
# prk: pseudo-random key from HKDF-Extract (32 bytes)
# info: optional context/application-specific info
# info_len: length of info
# okm: output keying material
# okm_len: length of output keying material (max 8160 bytes = 255*32)
# Returns: 0 on success, -1 on error
proc hkdf_sha256_expand(prk: ptr uint8, info: ptr uint8, info_len: int32, okm: ptr uint8, okm_len: int32): int32 =
  if prk == cast[ptr uint8](0) or okm == cast[ptr uint8](0):
    return -1

  if okm_len <= 0 or okm_len > 8160:
    return -1

  var hash_len: int32 = 32
  var n: int32 = (okm_len + hash_len - 1) / hash_len  # Ceiling division

  var t: array[32, uint8]  # T(i)
  var t_len: int32 = 0       # Length of T(i-1)
  var pos: int32 = 0         # Position in output
  var i: int32 = 1

  while i <= n:
    # T(i) = HMAC-Hash(PRK, T(i-1) || info || i)
    var ctx: HmacSha256Context
    hmac_sha256_init(addr(ctx), prk, 32)

    # Add T(i-1) if not first iteration
    if t_len > 0:
      hmac_sha256_update(addr(ctx), addr(t[0]), t_len)

    # Add info
    if info != cast[ptr uint8](0) and info_len > 0:
      hmac_sha256_update(addr(ctx), info, info_len)

    # Add counter byte
    var counter: uint8 = cast[uint8](i)
    hmac_sha256_update(addr(ctx), addr(counter), 1)

    hmac_sha256_final(addr(ctx), addr(t[0]))
    t_len = 32

    # Copy to output
    var copy_len: int32 = hash_len
    if pos + copy_len > okm_len:
      copy_len = okm_len - pos

    var j: int32 = 0
    while j < copy_len:
      okm[pos] = t[j]
      pos = pos + 1
      j = j + 1

    i = i + 1

  return 0

# HKDF one-shot using SHA-256
# Combines extract and expand in a single call
# salt: optional salt (can be null)
# salt_len: length of salt
# ikm: input keying material
# ikm_len: length of input keying material
# info: optional context info
# info_len: length of info
# okm: output keying material
# okm_len: desired length of output
# Returns: 0 on success, -1 on error
proc hkdf_sha256(salt: ptr uint8, salt_len: int32, ikm: ptr uint8, ikm_len: int32, info: ptr uint8, info_len: int32, okm: ptr uint8, okm_len: int32): int32 =
  var prk: array[32, uint8]

  if hkdf_sha256_extract(salt, salt_len, ikm, ikm_len, addr(prk[0])) < 0:
    return -1

  return hkdf_sha256_expand(addr(prk[0]), info, info_len, okm, okm_len)

# ===========================================================================
# HKDF using SHA-512
# ===========================================================================

# HKDF-Extract using SHA-512
proc hkdf_sha512_extract(salt: ptr uint8, salt_len: int32, ikm: ptr uint8, ikm_len: int32, prk: ptr uint8): int32 =
  if ikm == cast[ptr uint8](0) or prk == cast[ptr uint8](0):
    return -1

  var zero_salt: array[64, uint8]
  var actual_salt: ptr uint8 = salt
  var actual_salt_len: int32 = salt_len

  if salt == cast[ptr uint8](0) or salt_len == 0:
    var i: int32 = 0
    while i < 64:
      zero_salt[i] = 0
      i = i + 1
    actual_salt = addr(zero_salt[0])
    actual_salt_len = 64

  return hmac_sha512(actual_salt, actual_salt_len, ikm, ikm_len, prk)

# HKDF-Expand using SHA-512
proc hkdf_sha512_expand(prk: ptr uint8, info: ptr uint8, info_len: int32, okm: ptr uint8, okm_len: int32): int32 =
  if prk == cast[ptr uint8](0) or okm == cast[ptr uint8](0):
    return -1

  if okm_len <= 0 or okm_len > 16320:  # 255 * 64
    return -1

  var hash_len: int32 = 64
  var n: int32 = (okm_len + hash_len - 1) / hash_len

  var t: array[64, uint8]
  var t_len: int32 = 0
  var pos: int32 = 0
  var i: int32 = 1

  while i <= n:
    var ctx: HmacSha512Context
    hmac_sha512_init(addr(ctx), prk, 64)

    if t_len > 0:
      hmac_sha512_update(addr(ctx), addr(t[0]), t_len)

    if info != cast[ptr uint8](0) and info_len > 0:
      hmac_sha512_update(addr(ctx), info, info_len)

    var counter: uint8 = cast[uint8](i)
    hmac_sha512_update(addr(ctx), addr(counter), 1)

    hmac_sha512_final(addr(ctx), addr(t[0]))
    t_len = 64

    var copy_len: int32 = hash_len
    if pos + copy_len > okm_len:
      copy_len = okm_len - pos

    var j: int32 = 0
    while j < copy_len:
      okm[pos] = t[j]
      pos = pos + 1
      j = j + 1

    i = i + 1

  return 0

# HKDF one-shot using SHA-512
proc hkdf_sha512(salt: ptr uint8, salt_len: int32, ikm: ptr uint8, ikm_len: int32, info: ptr uint8, info_len: int32, okm: ptr uint8, okm_len: int32): int32 =
  var prk: array[64, uint8]

  if hkdf_sha512_extract(salt, salt_len, ikm, ikm_len, addr(prk[0])) < 0:
    return -1

  return hkdf_sha512_expand(addr(prk[0]), info, info_len, okm, okm_len)

# ===========================================================================
# PBKDF2 (Password-Based Key Derivation Function 2) - RFC 8018
# ===========================================================================

# PBKDF2-HMAC-SHA256
# Derives a key from a password using HMAC-SHA256
# password: password bytes
# pass_len: length of password
# salt: salt value (should be random, at least 16 bytes recommended)
# salt_len: length of salt
# iterations: iteration count (recommended: 100,000+ for security)
# output: output key buffer
# output_len: desired output length
# Returns: 0 on success, -1 on error
proc pbkdf2_sha256(password: ptr uint8, pass_len: int32, salt: ptr uint8, salt_len: int32, iterations: int32, output: ptr uint8, output_len: int32): int32 =
  if password == cast[ptr uint8](0) or salt == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return -1

  if iterations < 1 or output_len < 1:
    return -1

  var hash_len: int32 = 32
  var blocks_needed: int32 = (output_len + hash_len - 1) / hash_len
  var pos: int32 = 0
  var block_num: int32 = 1

  # Salt buffer with space for 4-byte block counter
  var salt_block: array[1024, uint8]
  var i: int32 = 0
  while i < salt_len and i < 1020:
    salt_block[i] = salt[i]
    i = i + 1

  while block_num <= blocks_needed:
    # Append block number as big-endian 32-bit integer
    salt_block[salt_len] = cast[uint8]((block_num / 16777216) and 0xFF)
    salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) and 0xFF)
    salt_block[salt_len + 2] = cast[uint8]((block_num / 256) and 0xFF)
    salt_block[salt_len + 3] = cast[uint8](block_num and 0xFF)

    # U_1 = PRF(Password, Salt || INT(i))
    var u: array[32, uint8]
    var result: array[32, uint8]
    hmac_sha256(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

    # Copy U_1 to result
    i = 0
    while i < 32:
      result[i] = u[i]
      i = i + 1

    # U_2 through U_c
    var iter: int32 = 1
    while iter < iterations:
      hmac_sha256(password, pass_len, addr(u[0]), 32, addr(u[0]))
      # XOR into result
      i = 0
      while i < 32:
        result[i] = cast[uint8](cast[int32](result[i]) xor cast[int32](u[i]))
        i = i + 1
      iter = iter + 1

    # Copy to output
    var copy_len: int32 = hash_len
    if pos + copy_len > output_len:
      copy_len = output_len - pos

    i = 0
    while i < copy_len:
      output[pos] = result[i]
      pos = pos + 1
      i = i + 1

    block_num = block_num + 1

  return 0

# PBKDF2-HMAC-SHA512
# Same as PBKDF2-SHA256 but using SHA-512 (64-byte output per block)
proc pbkdf2_sha512(password: ptr uint8, pass_len: int32, salt: ptr uint8, salt_len: int32, iterations: int32, output: ptr uint8, output_len: int32): int32 =
  if password == cast[ptr uint8](0) or salt == cast[ptr uint8](0) or output == cast[ptr uint8](0):
    return -1

  if iterations < 1 or output_len < 1:
    return -1

  var hash_len: int32 = 64
  var blocks_needed: int32 = (output_len + hash_len - 1) / hash_len
  var pos: int32 = 0
  var block_num: int32 = 1

  var salt_block: array[1024, uint8]
  var i: int32 = 0
  while i < salt_len and i < 1020:
    salt_block[i] = salt[i]
    i = i + 1

  while block_num <= blocks_needed:
    salt_block[salt_len] = cast[uint8]((block_num / 16777216) and 0xFF)
    salt_block[salt_len + 1] = cast[uint8]((block_num / 65536) and 0xFF)
    salt_block[salt_len + 2] = cast[uint8]((block_num / 256) and 0xFF)
    salt_block[salt_len + 3] = cast[uint8](block_num and 0xFF)

    var u: array[64, uint8]
    var result: array[64, uint8]
    hmac_sha512(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))

    i = 0
    while i < 64:
      result[i] = u[i]
      i = i + 1

    var iter: int32 = 1
    while iter < iterations:
      hmac_sha512(password, pass_len, addr(u[0]), 64, addr(u[0]))
      i = 0
      while i < 64:
        result[i] = cast[uint8](cast[int32](result[i]) xor cast[int32](u[i]))
        i = i + 1
      iter = iter + 1

    var copy_len: int32 = hash_len
    if pos + copy_len > output_len:
      copy_len = output_len - pos

    i = 0
    while i < copy_len:
      output[pos] = result[i]
      pos = pos + 1
      i = i + 1

    block_num = block_num + 1

  return 0

# ===========================================================================
# Utility Functions
# ===========================================================================

# Constant-time comparison to prevent timing attacks
# Returns: 1 if equal, 0 if not equal
proc hmac_compare(mac1: ptr uint8, mac2: ptr uint8, len: int32): int32 =
  if mac1 == cast[ptr uint8](0) or mac2 == cast[ptr uint8](0):
    return 0

  var diff: int32 = 0
  var i: int32 = 0
  while i < len:
    diff = diff or (cast[int32](mac1[i]) xor cast[int32](mac2[i]))
    i = i + 1

  if diff == 0:
    return 1
  return 0

# Verify HMAC-SHA256 in constant time
# Returns: 1 if valid, 0 if invalid
proc hmac_sha256_verify(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, expected: ptr uint8): int32 =
  var computed: array[32, uint8]
  if hmac_sha256(key, key_len, data, data_len, addr(computed[0])) < 0:
    return 0
  return hmac_compare(addr(computed[0]), expected, 32)

# Verify HMAC-SHA512 in constant time
# Returns: 1 if valid, 0 if invalid
proc hmac_sha512_verify(key: ptr uint8, key_len: int32, data: ptr uint8, data_len: int32, expected: ptr uint8): int32 =
  var computed: array[64, uint8]
  if hmac_sha512(key, key_len, data, data_len, addr(computed[0])) < 0:
    return 0
  return hmac_compare(addr(computed[0]), expected, 64)

# ===========================================================================
# Test Vectors (RFC 4231)
# ===========================================================================

# HMAC-SHA256 Test Vector 1:
#   Key  = 0x0b repeated 20 times
#   Data = "Hi There"
#   HMAC = b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7

# HMAC-SHA512 Test Vector 1:
#   Key  = 0x0b repeated 20 times
#   Data = "Hi There"
#   HMAC = 87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cde
#          daa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854
