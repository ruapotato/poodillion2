# Ed25519 Digital Signature Library for BrainhairOS
# Provides high-level interface for Ed25519 signatures
#
# Ed25519 is an EdDSA signature scheme providing:
# - 32-byte public keys
# - 64-byte signatures
# - ~128-bit security level
# - Deterministic signatures (no random nonce needed)
# - Fast verification

import syscalls

# ============================================================================
# Constants
# ============================================================================

const ED25519_SEED_SIZE: int32 = 32      # Size of secret seed
const ED25519_PUBLIC_KEY_SIZE: int32 = 32 # Size of public key
const ED25519_PRIVATE_KEY_SIZE: int32 = 64 # Size of private key (seed + pubkey)
const ED25519_SIGNATURE_SIZE: int32 = 64   # Size of signature

# Syscall numbers
const SYS_ED25519_KEYGEN: int32 = 270
const SYS_ED25519_SIGN: int32 = 271
const SYS_ED25519_VERIFY: int32 = 272

# SHA-512 syscalls (needed for manual operations)
const SYS_SHA512_INIT: int32 = 260
const SYS_SHA512_UPDATE: int32 = 261
const SYS_SHA512_FINAL: int32 = 262

# ============================================================================
# Key Types
# ============================================================================

# Ed25519 public key (32 bytes)
type Ed25519PublicKey = record
  bytes: array[32, int8]
end

# Ed25519 private key (64 bytes: seed || public key)
type Ed25519PrivateKey = record
  bytes: array[64, int8]
end

# Ed25519 signature (64 bytes: R || S)
type Ed25519Signature = record
  bytes: array[64, int8]
end

# Ed25519 keypair
type Ed25519Keypair = record
  public_key: Ed25519PublicKey
  private_key: Ed25519PrivateKey
end

# ============================================================================
# Low-Level Syscall Wrappers
# ============================================================================

# Generate an Ed25519 keypair from a 32-byte seed
proc ed25519_keygen_raw(seed: ptr int8, pubkey: ptr int8, privkey: ptr int8): int32 =
  return syscall3(SYS_ED25519_KEYGEN, cast[int32](seed),
                  cast[int32](pubkey), cast[int32](privkey))

# Sign a message
proc ed25519_sign_raw(msg: ptr int8, msg_len: int32,
                       privkey: ptr int8, sig: ptr int8): int32 =
  return syscall4(SYS_ED25519_SIGN, cast[int32](msg), msg_len,
                  cast[int32](privkey), cast[int32](sig))

# Verify a signature
proc ed25519_verify_raw(msg: ptr int8, msg_len: int32,
                         pubkey: ptr int8, sig: ptr int8): int32 =
  return syscall4(SYS_ED25519_VERIFY, cast[int32](msg), msg_len,
                  cast[int32](pubkey), cast[int32](sig))

# SHA-512 functions
proc sha512_init(): int32 =
  return syscall0(SYS_SHA512_INIT)

proc sha512_update(data: ptr int8, length: int32): int32 =
  return syscall2(SYS_SHA512_UPDATE, cast[int32](data), length)

proc sha512_final(output: ptr int8): int32 =
  return syscall1(SYS_SHA512_FINAL, cast[int32](output))

# ============================================================================
# High-Level API
# ============================================================================

# Generate a keypair from a 32-byte seed
# Returns 0 on success, -1 on error
proc ed25519_generate_keypair(seed: ptr int8, keypair: ptr Ed25519Keypair): int32 =
  return ed25519_keygen_raw(seed,
                             addr(keypair.public_key.bytes[0]),
                             addr(keypair.private_key.bytes[0]))

# Generate a keypair using system random
# Returns 0 on success, -1 on error
proc ed25519_generate_keypair_random(keypair: ptr Ed25519Keypair): int32 =
  var seed: array[32, int8]

  # Get random seed from system
  let SYS_GETRANDOM: int32 = 180
  let result = syscall3(SYS_GETRANDOM, cast[int32](addr(seed[0])), 32, 0)
  if result < 0:
    return -1
  end

  return ed25519_generate_keypair(addr(seed[0]), keypair)

# Extract public key from private key
proc ed25519_public_key(privkey: ptr Ed25519PrivateKey,
                        pubkey: ptr Ed25519PublicKey) =
  var i: int32 = 0
  while i < 32:
    pubkey.bytes[i] = privkey.bytes[i + 32]
    i = i + 1
  end

# Sign a message
# Returns 0 on success, -1 on error
proc ed25519_sign(msg: ptr int8, msg_len: int32,
                  privkey: ptr Ed25519PrivateKey,
                  sig: ptr Ed25519Signature): int32 =
  return ed25519_sign_raw(msg, msg_len,
                          addr(privkey.bytes[0]),
                          addr(sig.bytes[0]))

# Verify a signature
# Returns 0 if valid, -1 if invalid
proc ed25519_verify(msg: ptr int8, msg_len: int32,
                    pubkey: ptr Ed25519PublicKey,
                    sig: ptr Ed25519Signature): int32 =
  return ed25519_verify_raw(msg, msg_len,
                            addr(pubkey.bytes[0]),
                            addr(sig.bytes[0]))

# ============================================================================
# Utility Functions
# ============================================================================

# Compare two public keys
proc ed25519_pubkey_equal(a: ptr Ed25519PublicKey,
                          b: ptr Ed25519PublicKey): int32 =
  var i: int32 = 0
  while i < 32:
    if a.bytes[i] != b.bytes[i]:
      return 0
    end
    i = i + 1
  end
  return 1

# Compare two signatures
proc ed25519_sig_equal(a: ptr Ed25519Signature,
                       b: ptr Ed25519Signature): int32 =
  var i: int32 = 0
  while i < 64:
    if a.bytes[i] != b.bytes[i]:
      return 0
    end
    i = i + 1
  end
  return 1

# Zero out a private key (for security)
proc ed25519_privkey_clear(privkey: ptr Ed25519PrivateKey) =
  var i: int32 = 0
  while i < 64:
    privkey.bytes[i] = 0
    i = i + 1
  end

# Copy public key
proc ed25519_pubkey_copy(dest: ptr Ed25519PublicKey,
                         src: ptr Ed25519PublicKey) =
  var i: int32 = 0
  while i < 32:
    dest.bytes[i] = src.bytes[i]
    i = i + 1
  end

# Copy signature
proc ed25519_sig_copy(dest: ptr Ed25519Signature,
                      src: ptr Ed25519Signature) =
  var i: int32 = 0
  while i < 64:
    dest.bytes[i] = src.bytes[i]
    i = i + 1
  end

# ============================================================================
# SHA-512 High-Level Functions
# ============================================================================

const SHA512_DIGEST_SIZE: int32 = 64

type SHA512Digest = record
  bytes: array[64, int8]
end

# Compute SHA-512 hash of data
proc sha512_hash(data: ptr int8, length: int32,
                 digest: ptr SHA512Digest): int32 =
  discard sha512_init()
  discard sha512_update(data, length)
  return sha512_final(addr(digest.bytes[0]))

# Incremental SHA-512 context (for streaming)
type SHA512Context = record
  initialized: int32
end

proc sha512_ctx_init(ctx: ptr SHA512Context) =
  discard sha512_init()
  ctx.initialized = 1

proc sha512_ctx_update(ctx: ptr SHA512Context,
                       data: ptr int8, length: int32) =
  if ctx.initialized == 1:
    discard sha512_update(data, length)
  end

proc sha512_ctx_final(ctx: ptr SHA512Context,
                      digest: ptr SHA512Digest) =
  if ctx.initialized == 1:
    discard sha512_final(addr(digest.bytes[0]))
    ctx.initialized = 0
  end

# ============================================================================
# Message Authentication with Ed25519
# ============================================================================

# Sign a message and return signature
# Convenience wrapper that allocates on stack
proc ed25519_sign_message(msg: cstring,
                          privkey: ptr Ed25519PrivateKey): Ed25519Signature =
  var sig: Ed25519Signature
  var len: int32 = 0

  # Calculate string length
  var p: ptr int8 = cast[ptr int8](msg)
  while (deref(p)) != 0:
    len = len + 1
    p = cast[ptr int8](cast[int32](p) + 1)
  end

  discard ed25519_sign(cast[ptr int8](msg), len, privkey, addr(sig))
  return sig

# Verify a message signature
# Returns 1 if valid, 0 if invalid
proc ed25519_verify_message(msg: cstring,
                            pubkey: ptr Ed25519PublicKey,
                            sig: ptr Ed25519Signature): int32 =
  var len: int32 = 0

  # Calculate string length
  var p: ptr int8 = cast[ptr int8](msg)
  while (deref(p)) != 0:
    len = len + 1
    p = cast[ptr int8](cast[int32](p) + 1)
  end

  if ed25519_verify(cast[ptr int8](msg), len, pubkey, sig) == 0:
    return 1
  end
  return 0
