# Ed25519 Digital Signature Library for BrainhairOS
# Provides high-level interface for Ed25519 signatures
#
# Ed25519 is an EdDSA signature scheme providing:
# - 32-byte public keys
# - 64-byte signatures
# - ~128-bit security level
# - Deterministic signatures (no random nonce needed)
# - Fast verification

from lib.syscalls import *

# ============================================================================
# Constants
# ============================================================================

ED25519_SEED_SIZE: Final[int32] = 32      # Size of secret seed
ED25519_PUBLIC_KEY_SIZE: Final[int32] = 32 # Size of public key
ED25519_PRIVATE_KEY_SIZE: Final[int32] = 64 # Size of private key (seed + pubkey)
ED25519_SIGNATURE_SIZE: Final[int32] = 64   # Size of signature

# Syscall numbers
SYS_ED25519_KEYGEN: Final[int32] = 270
SYS_ED25519_SIGN: Final[int32] = 271
SYS_ED25519_VERIFY: Final[int32] = 272

# SHA-512 syscalls (needed for manual operations)
SYS_SHA512_INIT: Final[int32] = 260
SYS_SHA512_UPDATE: Final[int32] = 261
SYS_SHA512_FINAL: Final[int32] = 262

# ============================================================================
# Key Types
# ============================================================================

# Ed25519 public key (32 bytes)
class Ed25519PublicKey:
    data: Array[32, int8]

# Ed25519 private key (64 bytes: seed || public key)
class Ed25519PrivateKey:
    data: Array[64, int8]

# Ed25519 signature (64 bytes: R || S)
class Ed25519Signature:
    data: Array[64, int8]

# Ed25519 keypair
class Ed25519Keypair:
    public_key: Ed25519PublicKey
    private_key: Ed25519PrivateKey

# ============================================================================
# Low-Level Syscall Wrappers
# ============================================================================

# Generate an Ed25519 keypair from a 32-byte seed
def ed25519_keygen_raw(seed: Ptr[int8], pubkey: Ptr[int8], privkey: Ptr[int8]) -> int32:
    return syscall3(SYS_ED25519_KEYGEN, cast[int32](seed),
                    cast[int32](pubkey), cast[int32](privkey))

# Sign a message
def ed25519_sign_raw(msg: Ptr[int8], msg_len: int32,
                     privkey: Ptr[int8], sig: Ptr[int8]) -> int32:
    return syscall4(SYS_ED25519_SIGN, cast[int32](msg), msg_len,
                    cast[int32](privkey), cast[int32](sig))

# Verify a signature
def ed25519_verify_raw(msg: Ptr[int8], msg_len: int32,
                       pubkey: Ptr[int8], sig: Ptr[int8]) -> int32:
    return syscall4(SYS_ED25519_VERIFY, cast[int32](msg), msg_len,
                    cast[int32](pubkey), cast[int32](sig))

# SHA-512 functions
def sha512_init() -> int32:
    return syscall0(SYS_SHA512_INIT)

def sha512_update(data: Ptr[int8], length: int32) -> int32:
    return syscall2(SYS_SHA512_UPDATE, cast[int32](data), length)

def sha512_final(output: Ptr[int8]) -> int32:
    return syscall1(SYS_SHA512_FINAL, cast[int32](output))

# ============================================================================
# High-Level API
# ============================================================================

# Generate a keypair from a 32-byte seed
# Returns 0 on success, -1 on error
def ed25519_generate_keypair(seed: Ptr[int8], keypair: Ptr[Ed25519Keypair]) -> int32:
    return ed25519_keygen_raw(seed,
                              addr(keypair.public_key.data[0]),
                              addr(keypair.private_key.data[0]))

# Generate a keypair using system random
# Returns 0 on success, -1 on error
def ed25519_generate_keypair_random(keypair: Ptr[Ed25519Keypair]) -> int32:
    seed: Array[32, int8]

    # Get random seed from system
    SYS_GETRANDOM: Final[int32] = 180
    result: int32 = syscall3(SYS_GETRANDOM, cast[int32](addr(seed[0])), 32, 0)
    if result < 0:
        return -1

    return ed25519_generate_keypair(addr(seed[0]), keypair)

# Extract public key from private key
def ed25519_public_key(privkey: Ptr[Ed25519PrivateKey],
                       pubkey: Ptr[Ed25519PublicKey]):
    i: int32 = 0
    while i < 32:
        pubkey.data[i] = privkey.data[i + 32]
        i = i + 1

# Sign a message
# Returns 0 on success, -1 on error
def ed25519_sign(msg: Ptr[int8], msg_len: int32,
                 privkey: Ptr[Ed25519PrivateKey],
                 sig: Ptr[Ed25519Signature]) -> int32:
    return ed25519_sign_raw(msg, msg_len,
                            addr(privkey.data[0]),
                            addr(sig.data[0]))

# Verify a signature
# Returns 0 if valid, -1 if invalid
def ed25519_verify(msg: Ptr[int8], msg_len: int32,
                   pubkey: Ptr[Ed25519PublicKey],
                   sig: Ptr[Ed25519Signature]) -> int32:
    return ed25519_verify_raw(msg, msg_len,
                              addr(pubkey.data[0]),
                              addr(sig.data[0]))

# ============================================================================
# Utility Functions
# ============================================================================

# Compare two public keys
def ed25519_pubkey_equal(a: Ptr[Ed25519PublicKey],
                         b: Ptr[Ed25519PublicKey]) -> int32:
    i: int32 = 0
    while i < 32:
        if a.data[i] != b.data[i]:
            return 0
        i = i + 1
    return 1

# Compare two signatures
def ed25519_sig_equal(a: Ptr[Ed25519Signature],
                      b: Ptr[Ed25519Signature]) -> int32:
    i: int32 = 0
    while i < 64:
        if a.data[i] != b.data[i]:
            return 0
        i = i + 1
    return 1

# Zero out a private key (for security)
def ed25519_privkey_clear(privkey: Ptr[Ed25519PrivateKey]):
    i: int32 = 0
    while i < 64:
        privkey.data[i] = 0
        i = i + 1

# Copy public key
def ed25519_pubkey_copy(dest: Ptr[Ed25519PublicKey],
                        src: Ptr[Ed25519PublicKey]):
    i: int32 = 0
    while i < 32:
        dest.data[i] = src.data[i]
        i = i + 1

# Copy signature
def ed25519_sig_copy(dest: Ptr[Ed25519Signature],
                     src: Ptr[Ed25519Signature]):
    i: int32 = 0
    while i < 64:
        dest.data[i] = src.data[i]
        i = i + 1

# ============================================================================
# SHA-512 High-Level Functions
# ============================================================================

SHA512_DIGEST_SIZE: Final[int32] = 64

class SHA512Digest:
    data: Array[64, int8]

# Compute SHA-512 hash of data
def sha512_hash(data: Ptr[int8], length: int32,
                digest: Ptr[SHA512Digest]) -> int32:
    sha512_init()
    sha512_update(data, length)
    return sha512_final(addr(digest.data[0]))

# Incremental SHA-512 context (for streaming)
class SHA512Context:
    initialized: int32

def sha512_ctx_init(ctx: Ptr[SHA512Context]):
    sha512_init()
    ctx.initialized = 1

def sha512_ctx_update(ctx: Ptr[SHA512Context],
                      data: Ptr[int8], length: int32):
    if ctx.initialized == 1:
        sha512_update(data, length)

def sha512_ctx_final(ctx: Ptr[SHA512Context],
                     digest: Ptr[SHA512Digest]):
    if ctx.initialized == 1:
        sha512_final(addr(digest.data[0]))
        ctx.initialized = 0

# ============================================================================
# Message Authentication with Ed25519
# ============================================================================

# Sign a message and return signature
# Convenience wrapper that allocates on stack
def ed25519_sign_message(msg: Ptr[uint8],
                         privkey: Ptr[Ed25519PrivateKey]) -> Ed25519Signature:
    sig: Ed25519Signature
    len: int32 = 0

    # Calculate string length
    p: Ptr[int8] = cast[Ptr[int8]](msg)
    while p[0] != 0:
        len = len + 1
        p = cast[Ptr[int8]](cast[int32](p) + 1)

    ed25519_sign(cast[Ptr[int8]](msg), len, privkey, addr(sig))
    return sig

# Verify a message signature
# Returns 1 if valid, 0 if invalid
def ed25519_verify_message(msg: Ptr[uint8],
                           pubkey: Ptr[Ed25519PublicKey],
                           sig: Ptr[Ed25519Signature]) -> int32:
    len: int32 = 0

    # Calculate string length
    p: Ptr[int8] = cast[Ptr[int8]](msg)
    while p[0] != 0:
        len = len + 1
        p = cast[Ptr[int8]](cast[int32](p) + 1)

    if ed25519_verify(cast[Ptr[int8]](msg), len, pubkey, sig) == 0:
        return 1
    return 0
