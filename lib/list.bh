# list.bh - Dynamic List (Vector) Implementation for Brainhair
# Provides a growable array similar to Python's list or Rust's Vec
#
# Usage:
#   items: List[int32]
#   list_init(addr(items), 4)  # Initial capacity of 4 elements
#   list_append(addr(items), 42)
#   val: int32 = list_get(addr(items), 0)
#   list_free(addr(items))

from lib.memory import *

# List structure layout (3 words = 12 bytes):
#   [0] data: Ptr[uint8]  - pointer to element array
#   [1] len: int32        - number of elements
#   [2] cap: int32        - capacity (allocated elements)
#   [3] elem_size: int32  - size of each element in bytes

LIST_DATA_OFFSET: Final[int32] = 0
LIST_LEN_OFFSET: Final[int32] = 4
LIST_CAP_OFFSET: Final[int32] = 8
LIST_ELEM_SIZE_OFFSET: Final[int32] = 12
LIST_STRUCT_SIZE: Final[int32] = 16

# Initialize a list with given element size and initial capacity
def list_init(list: Ptr[int32], elem_size: int32, initial_cap: int32):
    cap: int32 = initial_cap
    if cap < 4:
        cap = 4
    data: Ptr[uint8] = alloc(cap * elem_size)
    list[0] = cast[int32](data)  # data pointer
    list[1] = 0                   # len = 0
    list[2] = cap                 # capacity
    list[3] = elem_size           # element size

# Initialize a list for int32 elements
def list_init_i32(list: Ptr[int32], initial_cap: int32):
    list_init(list, 4, initial_cap)

# Initialize a list for Ptr elements (pointers)
def list_init_ptr(list: Ptr[int32], initial_cap: int32):
    list_init(list, 4, initial_cap)

# Free a list's memory
def list_free(list: Ptr[int32]):
    data: Ptr[uint8] = Ptr[uint8](list[0])
    if cast[int32](data) != 0:
        free(data)
    list[0] = 0
    list[1] = 0
    list[2] = 0

# Get list length
def list_len(list: Ptr[int32]) -> int32:
    return list[1]

# Get list capacity
def list_cap(list: Ptr[int32]) -> int32:
    return list[2]

# Check if list is empty
def list_empty(list: Ptr[int32]) -> int32:
    if list[1] == 0:
        return 1
    return 0

# Grow list capacity (internal)
def list_grow(list: Ptr[int32]):
    old_cap: int32 = list[2]
    new_cap: int32 = old_cap * 2
    elem_size: int32 = list[3]
    old_data: Ptr[uint8] = Ptr[uint8](list[0])
    new_data: Ptr[uint8] = realloc(old_data, old_cap * elem_size, new_cap * elem_size)
    list[0] = cast[int32](new_data)
    list[2] = new_cap

# Ensure list has space for at least n more elements
def list_reserve(list: Ptr[int32], additional: int32):
    len: int32 = list[1]
    cap: int32 = list[2]
    needed: int32 = len + additional
    while cap < needed:
        list_grow(list)
        cap = list[2]

# Append an int32 value to list
def list_append_i32(list: Ptr[int32], value: int32):
    len: int32 = list[1]
    cap: int32 = list[2]
    if len >= cap:
        list_grow(list)
    data: Ptr[int32] = Ptr[int32](list[0])
    data[len] = value
    list[1] = len + 1

# Append a pointer value to list
def list_append_ptr(list: Ptr[int32], value: Ptr[uint8]):
    list_append_i32(list, cast[int32](value))

# Get int32 value at index
def list_get_i32(list: Ptr[int32], index: int32) -> int32:
    data: Ptr[int32] = Ptr[int32](list[0])
    return data[index]

# Get pointer value at index
def list_get_ptr(list: Ptr[int32], index: int32) -> Ptr[uint8]:
    data: Ptr[int32] = Ptr[int32](list[0])
    return Ptr[uint8](data[index])

# Set int32 value at index
def list_set_i32(list: Ptr[int32], index: int32, value: int32):
    data: Ptr[int32] = Ptr[int32](list[0])
    data[index] = value

# Set pointer value at index
def list_set_ptr(list: Ptr[int32], index: int32, value: Ptr[uint8]):
    data: Ptr[int32] = Ptr[int32](list[0])
    data[index] = cast[int32](value)

# Pop last element and return it
def list_pop_i32(list: Ptr[int32]) -> int32:
    len: int32 = list[1]
    if len == 0:
        return 0
    len = len - 1
    list[1] = len
    data: Ptr[int32] = Ptr[int32](list[0])
    return data[len]

# Pop last element (pointer version)
def list_pop_ptr(list: Ptr[int32]) -> Ptr[uint8]:
    return Ptr[uint8](list_pop_i32(list))

# Clear list (keep capacity)
def list_clear(list: Ptr[int32]):
    list[1] = 0

# Get pointer to element at index (for any element type)
def list_get_elem_ptr(list: Ptr[int32], index: int32) -> Ptr[uint8]:
    data: Ptr[uint8] = Ptr[uint8](list[0])
    elem_size: int32 = list[3]
    return Ptr[uint8](cast[int32](data) + (index * elem_size))

# Copy list contents to another list
def list_copy(dest: Ptr[int32], src: Ptr[int32]):
    src_len: int32 = src[1]
    elem_size: int32 = src[3]
    list_init(dest, elem_size, src_len)
    src_data: Ptr[uint8] = Ptr[uint8](src[0])
    dest_data: Ptr[uint8] = Ptr[uint8](dest[0])
    mem_copy(dest_data, src_data, src_len * elem_size)
    dest[1] = src_len

# Insert element at index (shifts elements right)
def list_insert_i32(list: Ptr[int32], index: int32, value: int32):
    len: int32 = list[1]
    if len >= list[2]:
        list_grow(list)
    data: Ptr[int32] = Ptr[int32](list[0])
    # Shift elements right
    i: int32 = len
    while i > index:
        data[i] = data[i - 1]
        i = i - 1
    data[index] = value
    list[1] = len + 1

# Remove element at index (shifts elements left)
def list_remove(list: Ptr[int32], index: int32):
    len: int32 = list[1]
    if index >= len:
        return
    data: Ptr[int32] = Ptr[int32](list[0])
    # Shift elements left
    i: int32 = index
    while i < len - 1:
        data[i] = data[i + 1]
        i = i + 1
    list[1] = len - 1

# Find first occurrence of value, return index or -1
def list_find_i32(list: Ptr[int32], value: int32) -> int32:
    len: int32 = list[1]
    data: Ptr[int32] = Ptr[int32](list[0])
    i: int32 = 0
    while i < len:
        if data[i] == value:
            return i
        i = i + 1
    return -1

# Check if list contains value
def list_contains_i32(list: Ptr[int32], value: int32) -> int32:
    if list_find_i32(list, value) >= 0:
        return 1
    return 0

# Reverse list in place
def list_reverse(list: Ptr[int32]):
    len: int32 = list[1]
    if len < 2:
        return
    data: Ptr[int32] = Ptr[int32](list[0])
    i: int32 = 0
    j: int32 = len - 1
    while i < j:
        tmp: int32 = data[i]
        data[i] = data[j]
        data[j] = tmp
        i = i + 1
        j = j - 1
