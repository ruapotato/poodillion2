# SHA-256 Implementation in pure Brainhair
# No external dependencies

SHA256_DIGEST_SIZE: Final[int32] = 32
SHA256_BLOCK_SIZE: Final[int32] = 64

# SHA256 context structure
class SHA256Ctx:
    state: Array[8, uint32]      # Hash state (H0-H7)
    count: Array[2, uint32]      # Number of bits processed
    buffer: Array[64, uint8]     # Input buffer

# SHA256 K constants
def sha256_k(i: int32) -> uint32:
    if i == 0: return cast[uint32](0x428a2f98)
    if i == 1: return cast[uint32](0x71374491)
    if i == 2: return cast[uint32](0xb5c0fbcf)
    if i == 3: return cast[uint32](0xe9b5dba5)
    if i == 4: return cast[uint32](0x3956c25b)
    if i == 5: return cast[uint32](0x59f111f1)
    if i == 6: return cast[uint32](0x923f82a4)
    if i == 7: return cast[uint32](0xab1c5ed5)
    if i == 8: return cast[uint32](0xd807aa98)
    if i == 9: return cast[uint32](0x12835b01)
    if i == 10: return cast[uint32](0x243185be)
    if i == 11: return cast[uint32](0x550c7dc3)
    if i == 12: return cast[uint32](0x72be5d74)
    if i == 13: return cast[uint32](0x80deb1fe)
    if i == 14: return cast[uint32](0x9bdc06a7)
    if i == 15: return cast[uint32](0xc19bf174)
    if i == 16: return cast[uint32](0xe49b69c1)
    if i == 17: return cast[uint32](0xefbe4786)
    if i == 18: return cast[uint32](0x0fc19dc6)
    if i == 19: return cast[uint32](0x240ca1cc)
    if i == 20: return cast[uint32](0x2de92c6f)
    if i == 21: return cast[uint32](0x4a7484aa)
    if i == 22: return cast[uint32](0x5cb0a9dc)
    if i == 23: return cast[uint32](0x76f988da)
    if i == 24: return cast[uint32](0x983e5152)
    if i == 25: return cast[uint32](0xa831c66d)
    if i == 26: return cast[uint32](0xb00327c8)
    if i == 27: return cast[uint32](0xbf597fc7)
    if i == 28: return cast[uint32](0xc6e00bf3)
    if i == 29: return cast[uint32](0xd5a79147)
    if i == 30: return cast[uint32](0x06ca6351)
    if i == 31: return cast[uint32](0x14292967)
    if i == 32: return cast[uint32](0x27b70a85)
    if i == 33: return cast[uint32](0x2e1b2138)
    if i == 34: return cast[uint32](0x4d2c6dfc)
    if i == 35: return cast[uint32](0x53380d13)
    if i == 36: return cast[uint32](0x650a7354)
    if i == 37: return cast[uint32](0x766a0abb)
    if i == 38: return cast[uint32](0x81c2c92e)
    if i == 39: return cast[uint32](0x92722c85)
    if i == 40: return cast[uint32](0xa2bfe8a1)
    if i == 41: return cast[uint32](0xa81a664b)
    if i == 42: return cast[uint32](0xc24b8b70)
    if i == 43: return cast[uint32](0xc76c51a3)
    if i == 44: return cast[uint32](0xd192e819)
    if i == 45: return cast[uint32](0xd6990624)
    if i == 46: return cast[uint32](0xf40e3585)
    if i == 47: return cast[uint32](0x106aa070)
    if i == 48: return cast[uint32](0x19a4c116)
    if i == 49: return cast[uint32](0x1e376c08)
    if i == 50: return cast[uint32](0x2748774c)
    if i == 51: return cast[uint32](0x34b0bcb5)
    if i == 52: return cast[uint32](0x391c0cb3)
    if i == 53: return cast[uint32](0x4ed8aa4a)
    if i == 54: return cast[uint32](0x5b9cca4f)
    if i == 55: return cast[uint32](0x682e6ff3)
    if i == 56: return cast[uint32](0x748f82ee)
    if i == 57: return cast[uint32](0x78a5636f)
    if i == 58: return cast[uint32](0x84c87814)
    if i == 59: return cast[uint32](0x8cc70208)
    if i == 60: return cast[uint32](0x90befffa)
    if i == 61: return cast[uint32](0xa4506ceb)
    if i == 62: return cast[uint32](0xbef9a3f7)
    if i == 63: return cast[uint32](0xc67178f2)
    return cast[uint32](0)

# Right rotate
def rotr32(x: uint32, n: int32) -> uint32:
    return ((x >> n) | (x << (32 - n)))

# SHA256 functions
def sha256_ch(x: uint32, y: uint32, z: uint32) -> uint32:
    return ((x & y) ^ ((~x) & z))

def sha256_maj(x: uint32, y: uint32, z: uint32) -> uint32:
    return ((x & y) ^ (x & z) ^ (y & z))

def sha256_sigma0(x: uint32) -> uint32:
    return (rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22))

def sha256_sigma1(x: uint32) -> uint32:
    return (rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25))

def sha256_gamma0(x: uint32) -> uint32:
    return (rotr32(x, 7) ^ rotr32(x, 18) ^ (x >> 3))

def sha256_gamma1(x: uint32) -> uint32:
    return (rotr32(x, 17) ^ rotr32(x, 19) ^ (x >> 10))

# Process a single 64-byte block
def sha256_transform(ctx: Ptr[SHA256Ctx], block: Ptr[uint8]):
    w: Array[64, uint32]
    a: uint32
    b: uint32
    c: uint32
    d: uint32
    e: uint32
    f: uint32
    g: uint32
    h: uint32
    t1: uint32
    t2: uint32
    i: int32

    # Prepare message schedule
    i = 0
    while i < 16:
        j: int32 = i * 4
        w[i] = ((cast[uint32](block[j]) << 24) | (cast[uint32](block[j + 1]) << 16) | (cast[uint32](block[j + 2]) << 8) | cast[uint32](block[j + 3]))
        i = i + 1

    while i < 64:
        w[i] = (sha256_gamma1(w[i - 2]) + w[i - 7] + sha256_gamma0(w[i - 15]) + w[i - 16])
        i = i + 1

    # Initialize working variables
    a = ctx.state[0]
    b = ctx.state[1]
    c = ctx.state[2]
    d = ctx.state[3]
    e = ctx.state[4]
    f = ctx.state[5]
    g = ctx.state[6]
    h = ctx.state[7]

    # Main loop
    i = 0
    while i < 64:
        t1 = (h + sha256_sigma1(e) + sha256_ch(e, f, g) + sha256_k(i) + w[i])
        t2 = (sha256_sigma0(a) + sha256_maj(a, b, c))
        h = g
        g = f
        f = e
        e = (d + t1)
        d = c
        c = b
        b = a
        a = (t1 + t2)
        i = i + 1

    # Add to state
    ctx.state[0] = (ctx.state[0] + a)
    ctx.state[1] = (ctx.state[1] + b)
    ctx.state[2] = (ctx.state[2] + c)
    ctx.state[3] = (ctx.state[3] + d)
    ctx.state[4] = (ctx.state[4] + e)
    ctx.state[5] = (ctx.state[5] + f)
    ctx.state[6] = (ctx.state[6] + g)
    ctx.state[7] = (ctx.state[7] + h)

# Initialize SHA256 context
def sha256_init(ctx: Ptr[uint8]) -> int32:
    c: Ptr[SHA256Ctx] = cast[Ptr[SHA256Ctx]](ctx)
    c.state[0] = cast[uint32](0x6a09e667)
    c.state[1] = cast[uint32](0xbb67ae85)
    c.state[2] = cast[uint32](0x3c6ef372)
    c.state[3] = cast[uint32](0xa54ff53a)
    c.state[4] = cast[uint32](0x510e527f)
    c.state[5] = cast[uint32](0x9b05688c)
    c.state[6] = cast[uint32](0x1f83d9ab)
    c.state[7] = cast[uint32](0x5be0cd19)
    c.count[0] = cast[uint32](0)
    c.count[1] = cast[uint32](0)
    return 0

# Update SHA256 with data
def sha256_update(ctx: Ptr[uint8], data: Ptr[uint8], len: int32) -> int32:
    c: Ptr[SHA256Ctx] = cast[Ptr[SHA256Ctx]](ctx)
    i: int32 = 0
    idx: int32 = cast[int32]((c.count[0] >> 3) & cast[uint32](63))

    # Update bit count
    c.count[0] = (c.count[0] + cast[uint32](len << 3))
    if c.count[0] < cast[uint32](len << 3):
        c.count[1] = (c.count[1] + cast[uint32](1))
    c.count[1] = (c.count[1] + cast[uint32](len >> 29))

    # Process data
    while i < len:
        c.buffer[idx] = data[i]
        idx = idx + 1
        if idx == 64:
            sha256_transform(c, addr(c.buffer[0]))
            idx = 0
        i = i + 1

    return 0

# Finalize SHA256 and output hash
def sha256_final(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32:
    c: Ptr[SHA256Ctx] = cast[Ptr[SHA256Ctx]](ctx)
    idx: int32 = cast[int32]((c.count[0] >> 3) & cast[uint32](63))

    # Pad
    c.buffer[idx] = cast[uint8](0x80)
    idx = idx + 1

    if idx > 56:
        while idx < 64:
            c.buffer[idx] = cast[uint8](0)
            idx = idx + 1
        sha256_transform(c, addr(c.buffer[0]))
        idx = 0

    while idx < 56:
        c.buffer[idx] = cast[uint8](0)
        idx = idx + 1

    # Append length (big endian)
    c.buffer[56] = cast[uint8](c.count[1] >> 24)
    c.buffer[57] = cast[uint8](c.count[1] >> 16)
    c.buffer[58] = cast[uint8](c.count[1] >> 8)
    c.buffer[59] = cast[uint8](c.count[1])
    c.buffer[60] = cast[uint8](c.count[0] >> 24)
    c.buffer[61] = cast[uint8](c.count[0] >> 16)
    c.buffer[62] = cast[uint8](c.count[0] >> 8)
    c.buffer[63] = cast[uint8](c.count[0])

    sha256_transform(c, addr(c.buffer[0]))

    # Output hash (big endian)
    i: int32 = 0
    while i < 8:
        j: int32 = i * 4
        output[j] = cast[uint8](c.state[i] >> 24)
        output[j + 1] = cast[uint8](c.state[i] >> 16)
        output[j + 2] = cast[uint8](c.state[i] >> 8)
        output[j + 3] = cast[uint8](c.state[i])
        i = i + 1

    return 0

# Hash data in one call
def sha256_hash(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    ctx: SHA256Ctx
    sha256_init(cast[Ptr[uint8]](addr(ctx)))
    sha256_update(cast[Ptr[uint8]](addr(ctx)), data, len)
    sha256_final(cast[Ptr[uint8]](addr(ctx)), output)
    return 0

# Legacy compatibility wrapper class
class SHA256:
    ctx: SHA256Ctx

def sha256_new() -> Ptr[SHA256]:
    return Ptr[SHA256](0)

def sha256_init_ctx(ctx: Ptr[SHA256]) -> int32:
    if ctx == Ptr[SHA256](0):
        return -1
    return sha256_init(cast[Ptr[uint8]](addr(ctx.ctx)))

def sha256_update_ctx(ctx: Ptr[SHA256], data: Ptr[uint8], len: int32) -> int32:
    if ctx == Ptr[SHA256](0):
        return -1
    return sha256_update(cast[Ptr[uint8]](addr(ctx.ctx)), data, len)

def sha256_final_ctx(ctx: Ptr[SHA256], output: Ptr[uint8]) -> int32:
    if ctx == Ptr[SHA256](0):
        return -1
    return sha256_final(cast[Ptr[uint8]](addr(ctx.ctx)), output)

def sha256_hash_bytes(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    return sha256_hash(data, len, output)

def sha256_hash_string(s: Ptr[uint8], output: Ptr[uint8]) -> int32:
    if s == Ptr[uint8](0):
        return -1
    len: int32 = 0
    while s[len] != cast[uint8](0):
        len = len + 1
    return sha256_hash(s, len, output)

def sha256_to_hex(hash: Ptr[uint8], output: Ptr[uint8]):
    if (hash == Ptr[uint8](0)) or (output == Ptr[uint8](0)):
        return
    hexchars: Ptr[uint8] = Ptr[uint8]("0123456789abcdef")
    i: int32 = 0
    pos: int32 = 0
    while i < 32:
        byte: int32 = cast[int32](hash[i])
        output[pos] = hexchars[(byte >> 4) & 15]
        pos = pos + 1
        output[pos] = hexchars[byte & 15]
        pos = pos + 1
        i = i + 1
    output[64] = cast[uint8](0)

def sha256_compare(hash1: Ptr[uint8], hash2: Ptr[uint8]) -> int32:
    if (hash1 == Ptr[uint8](0)) or (hash2 == Ptr[uint8](0)):
        return 0
    i: int32 = 0
    while i < 32:
        if hash1[i] != hash2[i]:
            return 0
        i = i + 1
    return 1

def sha256_hmac(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    if ((key == Ptr[uint8](0)) or (data == Ptr[uint8](0))) or (output == Ptr[uint8](0)):
        return -1
    ipad: Array[64, uint8]
    opad: Array[64, uint8]
    key_block: Array[64, uint8]
    i: int32 = 0
    if key_len > 64:
        sha256_hash(key, key_len, addr(key_block[0]))
        i = 32
        while i < 64:
            key_block[i] = cast[uint8](0)
            i = i + 1
    else:
        i = 0
        while i < key_len:
            key_block[i] = key[i]
            i = i + 1
        while i < 64:
            key_block[i] = cast[uint8](0)
            i = i + 1
    i = 0
    while i < 64:
        ipad[i] = cast[uint8](cast[int32](key_block[i]) ^ 54)
        opad[i] = cast[uint8](cast[int32](key_block[i]) ^ 92)
        i = i + 1
    ctx: SHA256
    sha256_init_ctx(addr(ctx))
    sha256_update_ctx(addr(ctx), addr(ipad[0]), 64)
    sha256_update_ctx(addr(ctx), data, data_len)
    inner_hash: Array[32, uint8]
    sha256_final_ctx(addr(ctx), addr(inner_hash[0]))
    sha256_init_ctx(addr(ctx))
    sha256_update_ctx(addr(ctx), addr(opad[0]), 64)
    sha256_update_ctx(addr(ctx), addr(inner_hash[0]), 32)
    sha256_final_ctx(addr(ctx), output)
    return 0

def sha256_pbkdf2(password: Ptr[uint8], pass_len: int32, salt: Ptr[uint8], salt_len: int32, iterations: int32, output: Ptr[uint8], output_len: int32) -> int32:
    if ((password == Ptr[uint8](0)) or (salt == Ptr[uint8](0))) or (output == Ptr[uint8](0)):
        return -1
    if ((iterations <= 0) or (output_len <= 0)) or (output_len > 32):
        return -1
    salt_block: Array[128, uint8]
    i: int32 = 0
    while (i < salt_len) and (i < 124):
        salt_block[i] = salt[i]
        i = i + 1
    salt_block[i] = cast[uint8](0)
    salt_block[i + 1] = cast[uint8](0)
    salt_block[i + 2] = cast[uint8](0)
    salt_block[i + 3] = cast[uint8](1)
    u: Array[32, uint8]
    result: Array[32, uint8]
    sha256_hmac(password, pass_len, addr(salt_block[0]), salt_len + 4, addr(u[0]))
    i = 0
    while i < 32:
        result[i] = u[i]
        i = i + 1
    iter: int32 = 1
    while iter < iterations:
        sha256_hmac(password, pass_len, addr(u[0]), 32, addr(u[0]))
        i = 0
        while i < 32:
            result[i] = cast[uint8](cast[int32](result[i]) ^ cast[int32](u[i]))
            i = i + 1
        iter = iter + 1
    i = 0
    while i < output_len:
        output[i] = result[i]
        i = i + 1
    return 0
