SHA256_DIGEST_SIZE: Final[int32] = 32
SHA256_BLOCK_SIZE: Final[int32] = 64
SHA256_CTX_SIZE: Final[int32] = 108

extern def sha256_init(ctx: Ptr[uint8]) -> int32

extern def sha256_update(ctx: Ptr[uint8], data: Ptr[uint8], len: int32) -> int32

extern def sha256_final(ctx: Ptr[uint8], output: Ptr[uint8]) -> int32

extern def sha256_hash(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32

class SHA256:
    ctx: Array[108, uint8]

def sha256_new() -> Ptr[SHA256]:
    return Ptr[SHA256](0)

def sha256_init_ctx(ctx: Ptr[SHA256]) -> int32:
    if (ctx == Ptr[SHA256](0)):
        return -1
    return sha256_init(addr(ctx.ctx[0]))

def sha256_update_ctx(ctx: Ptr[SHA256], data: Ptr[uint8], len: int32) -> int32:
    if (ctx == Ptr[SHA256](0)):
        return -1
    return sha256_update(addr(ctx.ctx[0]), data, len)

def sha256_final_ctx(ctx: Ptr[SHA256], output: Ptr[uint8]) -> int32:
    if (ctx == Ptr[SHA256](0)):
        return -1
    return sha256_final(addr(ctx.ctx[0]), output)

def sha256_hash_bytes(data: Ptr[uint8], len: int32, output: Ptr[uint8]) -> int32:
    return sha256_hash(data, len, output)

def sha256_hash_string(s: Ptr[uint8], output: Ptr[uint8]) -> int32:
    if (s == Ptr[uint8](0)):
        return -1
    len: int32 = 0
    while (s[len] != cast[uint8](0)):
        len = (len + 1)
    return sha256_hash(s, len, output)

def sha256_to_hex(hash: Ptr[uint8], output: Ptr[uint8]):
    if ((hash == Ptr[uint8](0)) or (output == Ptr[uint8](0))):
        return
    hexchars: Ptr[uint8] = Ptr[uint8]("0123456789abcdef")
    i: int32 = 0
    pos: int32 = 0
    while (i < 32):
        byte: int32 = cast[int32](hash[i])
        output[pos] = hexchars[((byte >> 4) & 15)]
        pos = (pos + 1)
        output[pos] = hexchars[(byte & 15)]
        pos = (pos + 1)
        i = (i + 1)
    output[64] = cast[uint8](0)

def sha256_compare(hash1: Ptr[uint8], hash2: Ptr[uint8]) -> int32:
    if ((hash1 == Ptr[uint8](0)) or (hash2 == Ptr[uint8](0))):
        return 0
    i: int32 = 0
    while (i < 32):
        if (hash1[i] != hash2[i]):
            return 0
        i = (i + 1)
    return 1

def sha256_hmac(key: Ptr[uint8], key_len: int32, data: Ptr[uint8], data_len: int32, output: Ptr[uint8]) -> int32:
    if (((key == Ptr[uint8](0)) or (data == Ptr[uint8](0))) or (output == Ptr[uint8](0))):
        return -1
    ipad: Array[64, uint8]
    opad: Array[64, uint8]
    key_block: Array[64, uint8]
    i: int32 = 0
    if (key_len > 64):
        sha256_hash(key, key_len, addr(key_block[0]))
        i = 32
        while (i < 64):
            key_block[i] = cast[uint8](0)
            i = (i + 1)
    else:
        i = 0
        while (i < key_len):
            key_block[i] = key[i]
            i = (i + 1)
        while (i < 64):
            key_block[i] = cast[uint8](0)
            i = (i + 1)
    i = 0
    while (i < 64):
        ipad[i] = cast[uint8]((cast[int32](key_block[i]) ^ 54))
        opad[i] = cast[uint8]((cast[int32](key_block[i]) ^ 92))
        i = (i + 1)
    ctx: SHA256
    sha256_init_ctx(addr(ctx))
    sha256_update_ctx(addr(ctx), addr(ipad[0]), 64)
    sha256_update_ctx(addr(ctx), data, data_len)
    inner_hash: Array[32, uint8]
    sha256_final_ctx(addr(ctx), addr(inner_hash[0]))
    sha256_init_ctx(addr(ctx))
    sha256_update_ctx(addr(ctx), addr(opad[0]), 64)
    sha256_update_ctx(addr(ctx), addr(inner_hash[0]), 32)
    sha256_final_ctx(addr(ctx), output)
    return 0

def sha256_pbkdf2(password: Ptr[uint8], pass_len: int32, salt: Ptr[uint8], salt_len: int32, iterations: int32, output: Ptr[uint8], output_len: int32) -> int32:
    if (((password == Ptr[uint8](0)) or (salt == Ptr[uint8](0))) or (output == Ptr[uint8](0))):
        return -1
    if (((iterations <= 0) or (output_len <= 0)) or (output_len > 32)):
        return -1
    salt_block: Array[128, uint8]
    i: int32 = 0
    while ((i < salt_len) and (i < 124)):
        salt_block[i] = salt[i]
        i = (i + 1)
    salt_block[i] = cast[uint8](0)
    salt_block[(i + 1)] = cast[uint8](0)
    salt_block[(i + 2)] = cast[uint8](0)
    salt_block[(i + 3)] = cast[uint8](1)
    u: Array[32, uint8]
    result: Array[32, uint8]
    sha256_hmac(password, pass_len, addr(salt_block[0]), (salt_len + 4), addr(u[0]))
    i = 0
    while (i < 32):
        result[i] = u[i]
        i = (i + 1)
    iter: int32 = 1
    while (iter < iterations):
        sha256_hmac(password, pass_len, addr(u[0]), 32, addr(u[0]))
        i = 0
        while (i < 32):
            result[i] = cast[uint8]((cast[int32](result[i]) ^ cast[int32](u[i])))
            i = (i + 1)
        iter = (iter + 1)
    i = 0
    while (i < output_len):
        output[i] = result[i]
        i = (i + 1)
    return 0