from lib.syscalls import *

SYS_NET_LISTEN: Final[int32] = 50
SYS_NET_ACCEPT: Final[int32] = 51
SYS_NET_CONNECT: Final[int32] = 52
SYS_NET_SEND: Final[int32] = 53
SYS_NET_RECV: Final[int32] = 54
SYS_NET_CLOSE: Final[int32] = 55
SYS_NET_STATE: Final[int32] = 56
SYS_NET_POLL: Final[int32] = 57
SOCKET_INVALID: Final[int32] = -1
SOCKET_MAX: Final[int32] = 16
TCP_CLOSED: Final[int32] = 0
TCP_LISTEN: Final[int32] = 1
TCP_SYN_SENT: Final[int32] = 2
TCP_SYN_RECEIVED: Final[int32] = 3
TCP_ESTABLISHED: Final[int32] = 4
TCP_FIN_WAIT_1: Final[int32] = 5
TCP_FIN_WAIT_2: Final[int32] = 6
TCP_CLOSE_WAIT: Final[int32] = 7
TCP_CLOSING: Final[int32] = 8
TCP_LAST_ACK: Final[int32] = 9
TCP_TIME_WAIT: Final[int32] = 10

extern def net_syscall0(num: int32) -> int32

extern def net_syscall1(num: int32, arg1: int32) -> int32

extern def net_syscall2(num: int32, arg1: int32, arg2: int32) -> int32

extern def net_syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32) -> int32

def net_listen(port: int32) -> int32:
    return net_syscall1(SYS_NET_LISTEN, port)

def net_accept_ready(sock: int32) -> int32:
    return net_syscall1(SYS_NET_ACCEPT, sock)

def net_connect(ip: Ptr[uint8], port: int32) -> int32:
    return net_syscall2(SYS_NET_CONNECT, cast[int32](ip), port)

def net_send(sock: int32, data: Ptr[uint8], len: int32) -> int32:
    return net_syscall3(SYS_NET_SEND, sock, cast[int32](data), len)

def net_recv(sock: int32, buf: Ptr[uint8], max_len: int32) -> int32:
    return net_syscall3(SYS_NET_RECV, sock, cast[int32](buf), max_len)

def net_close(sock: int32):
    net_syscall1(SYS_NET_CLOSE, sock)

def net_state(sock: int32) -> int32:
    return net_syscall1(SYS_NET_STATE, sock)

def net_poll():
    net_syscall0(SYS_NET_POLL)

def net_is_connected(sock: int32) -> int32:
    if (net_state(sock) == TCP_ESTABLISHED):
        return 1
    return 0

def net_has_data(sock: int32) -> int32:
    return net_is_connected(sock)

def parse_ipv4(s: Ptr[uint8], out_ip: Ptr[uint8]) -> int32:
    i: int32 = 0
    octet: int32 = 0
    octet_idx: int32 = 0
    digits: int32 = 0
    while (s[i] != 0):
        ch: int32 = cast[int32](s[i])
        if ((ch >= 48) and (ch <= 57)):
            octet = ((octet * 10) + (ch - 48))
            digits = (digits + 1)
            if (octet > 255):
                return 0
        elif (ch == 46):
            if ((digits == 0) or (octet_idx >= 3)):
                return 0
            out_ip[octet_idx] = cast[uint8](octet)
            octet_idx = (octet_idx + 1)
            octet = 0
            digits = 0
        else:
            return 0
        i = (i + 1)
    if ((digits == 0) or (octet_idx != 3)):
        return 0
    out_ip[octet_idx] = cast[uint8](octet)
    return 1

def format_ipv4(ip: Ptr[uint8], buf: Ptr[uint8]) -> int32:
    pos: int32 = 0
    i: int32 = 0
    while (i < 4):
        octet: int32 = cast[int32](ip[i])
        if (octet >= 100):
            buf[pos] = cast[uint8]((48 + (octet / 100)))
            pos = (pos + 1)
            octet = (octet % 100)
            buf[pos] = cast[uint8]((48 + (octet / 10)))
            pos = (pos + 1)
            buf[pos] = cast[uint8]((48 + (octet % 10)))
            pos = (pos + 1)
        elif (octet >= 10):
            buf[pos] = cast[uint8]((48 + (octet / 10)))
            pos = (pos + 1)
            buf[pos] = cast[uint8]((48 + (octet % 10)))
            pos = (pos + 1)
        else:
            buf[pos] = cast[uint8]((48 + octet))
            pos = (pos + 1)
        if (i < 3):
            buf[pos] = cast[uint8](46)
            pos = (pos + 1)
        i = (i + 1)
    buf[pos] = 0
    return pos

def net_wait_connected(sock: int32, timeout_ms: int32) -> int32:
    elapsed: int32 = 0
    while ((elapsed < timeout_ms) or (timeout_ms == 0)):
        net_poll()
        if (net_is_connected(sock) == 1):
            return 1
        delay: int32 = 0
        while (delay < 100000):
            delay = (delay + 1)
        elapsed = (elapsed + 10)
    return 0

def net_recv_blocking(sock: int32, buf: Ptr[uint8], max_len: int32, timeout_ms: int32) -> int32:
    elapsed: int32 = 0
    while ((elapsed < timeout_ms) or (timeout_ms == 0)):
        net_poll()
        state: int32 = net_state(sock)
        if ((state == TCP_CLOSED) or (state == TCP_CLOSE_WAIT)):
            return -1
        n: int32 = net_recv(sock, buf, max_len)
        if (n > 0):
            return n
        delay: int32 = 0
        while (delay < 100000):
            delay = (delay + 1)
        elapsed = (elapsed + 10)
    return 0

def net_send_all(sock: int32, data: Ptr[uint8], len: int32) -> int32:
    sent: int32 = 0
    while (sent < len):
        net_poll()
        state: int32 = net_state(sock)
        if (state != TCP_ESTABLISHED):
            if (sent > 0):
                return sent
            return -1
        n: int32 = net_send(sock, addr(data[sent]), (len - sent))
        if (n < 0):
            if (sent > 0):
                return sent
            return -1
        sent = (sent + n)
    return sent

def net_send_str(sock: int32, s: Ptr[uint8]) -> int32:
    return net_send(sock, s, strlen(s))

def net_send_line(sock: int32, s: Ptr[uint8]) -> int32:
    n: int32 = net_send_str(sock, s)
    if (n >= 0):

        net_send(sock, Ptr[uint8]("\n"), 2)
    return n