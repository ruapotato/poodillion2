# PoodillionOS Networking Library
# Provides TCP client/server functionality for userland programs

import "lib/syscalls"

# Syscall numbers for networking (must match kernel)
const SYS_NET_LISTEN: int32 = 50
const SYS_NET_ACCEPT: int32 = 51
const SYS_NET_CONNECT: int32 = 52
const SYS_NET_SEND: int32 = 53
const SYS_NET_RECV: int32 = 54
const SYS_NET_CLOSE: int32 = 55
const SYS_NET_STATE: int32 = 56
const SYS_NET_POLL: int32 = 57

# Socket constants
const SOCKET_INVALID: int32 = -1
const SOCKET_MAX: int32 = 16

# TCP connection states (must match kernel)
const TCP_CLOSED: int32 = 0
const TCP_LISTEN: int32 = 1
const TCP_SYN_SENT: int32 = 2
const TCP_SYN_RECEIVED: int32 = 3
const TCP_ESTABLISHED: int32 = 4
const TCP_FIN_WAIT_1: int32 = 5
const TCP_FIN_WAIT_2: int32 = 6
const TCP_CLOSE_WAIT: int32 = 7
const TCP_CLOSING: int32 = 8
const TCP_LAST_ACK: int32 = 9
const TCP_TIME_WAIT: int32 = 10

# Assembly syscall wrappers (in syscalls.asm)
extern net_syscall0(num: int32): int32
extern net_syscall1(num: int32, arg1: int32): int32
extern net_syscall2(num: int32, arg1: int32, arg2: int32): int32
extern net_syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32

# =============================================================================
# Core Networking Functions
# =============================================================================

# Create a listening TCP socket on the specified port
# Returns: socket handle (0-15) on success, -1 on failure
proc net_listen(port: int32): int32 =
  return net_syscall1(SYS_NET_LISTEN, port)

# Check if a listening socket has an established connection
# Returns: 1 if connection ready, 0 if still waiting
proc net_accept_ready(sock: int32): int32 =
  return net_syscall1(SYS_NET_ACCEPT, sock)

# Connect to a remote host
# ip: pointer to 4-byte IPv4 address
# port: destination port number
# Returns: socket handle on success, -1 on failure
proc net_connect(ip: ptr uint8, port: int32): int32 =
  return net_syscall2(SYS_NET_CONNECT, cast[int32](ip), port)

# Send data on an established connection
# Returns: number of bytes sent, or -1 on error
proc net_send(sock: int32, data: ptr uint8, len: int32): int32 =
  return net_syscall3(SYS_NET_SEND, sock, cast[int32](data), len)

# Receive data from a connection (non-blocking)
# Returns: number of bytes received, or 0 if no data available
proc net_recv(sock: int32, buf: ptr uint8, max_len: int32): int32 =
  return net_syscall3(SYS_NET_RECV, sock, cast[int32](buf), max_len)

# Close a socket
proc net_close(sock: int32) =
  discard net_syscall1(SYS_NET_CLOSE, sock)

# Get the current state of a socket
# Returns: TCP_* state constant
proc net_state(sock: int32): int32 =
  return net_syscall1(SYS_NET_STATE, sock)

# Poll for network events (must be called regularly)
proc net_poll() =
  discard net_syscall0(SYS_NET_POLL)

# =============================================================================
# Helper Functions
# =============================================================================

# Check if a socket is connected (in ESTABLISHED state)
proc net_is_connected(sock: int32): int32 =
  if net_state(sock) == TCP_ESTABLISHED:
    return 1
  return 0

# Check if a socket has data available to read
# Note: This requires polling first
proc net_has_data(sock: int32): int32 =
  # Try to peek - if recv returns > 0, there's data
  # Actually we need to check the kernel's recv_ready flag
  # For now, just check if we're connected
  return net_is_connected(sock)

# Parse an IPv4 address string (e.g., "10.0.2.2") into 4 bytes
# Returns: 1 on success, 0 on failure
proc parse_ipv4(str: ptr uint8, out_ip: ptr uint8): int32 =
  var i: int32 = 0
  var octet: int32 = 0
  var octet_idx: int32 = 0
  var digits: int32 = 0

  while str[i] != 0:
    var ch: int32 = cast[int32](str[i])

    if ch >= 48 and ch <= 57:
      # Digit (0-9)
      octet = octet * 10 + (ch - 48)
      digits = digits + 1
      if octet > 255:
        return 0  # Invalid octet
    elif ch == 46:
      # Dot separator
      if digits == 0 or octet_idx >= 3:
        return 0  # Invalid format
      out_ip[octet_idx] = cast[uint8](octet)
      octet_idx = octet_idx + 1
      octet = 0
      digits = 0
    else:
      return 0  # Invalid character

    i = i + 1

  # Store the last octet
  if digits == 0 or octet_idx != 3:
    return 0
  out_ip[octet_idx] = cast[uint8](octet)

  return 1

# Format an IPv4 address as a string
# buf must be at least 16 bytes
proc format_ipv4(ip: ptr uint8, buf: ptr uint8): int32 =
  var pos: int32 = 0
  var i: int32 = 0

  while i < 4:
    var octet: int32 = cast[int32](ip[i])

    # Convert octet to string
    if octet >= 100:
      buf[pos] = cast[uint8](48 + octet / 100)
      pos = pos + 1
      octet = octet % 100
      buf[pos] = cast[uint8](48 + octet / 10)
      pos = pos + 1
      buf[pos] = cast[uint8](48 + octet % 10)
      pos = pos + 1
    elif octet >= 10:
      buf[pos] = cast[uint8](48 + octet / 10)
      pos = pos + 1
      buf[pos] = cast[uint8](48 + octet % 10)
      pos = pos + 1
    else:
      buf[pos] = cast[uint8](48 + octet)
      pos = pos + 1

    # Add dot separator (except after last octet)
    if i < 3:
      buf[pos] = cast[uint8](46)  # '.'
      pos = pos + 1

    i = i + 1

  buf[pos] = 0  # Null terminator
  return pos

# =============================================================================
# Blocking I/O Helpers
# =============================================================================

# Wait for a connection to be established (blocking)
# timeout_ms: maximum time to wait in milliseconds (0 = no timeout)
# Returns: 1 if connected, 0 if timeout
proc net_wait_connected(sock: int32, timeout_ms: int32): int32 =
  var elapsed: int32 = 0
  while elapsed < timeout_ms or timeout_ms == 0:
    net_poll()
    if net_is_connected(sock) == 1:
      return 1
    # Simple delay (roughly 10ms per iteration)
    var delay: int32 = 0
    while delay < 100000:
      delay = delay + 1
    elapsed = elapsed + 10
  return 0

# Receive data with blocking wait
# timeout_ms: maximum time to wait (0 = no timeout)
# Returns: bytes received, or 0 on timeout, or -1 on error
proc net_recv_blocking(sock: int32, buf: ptr uint8, max_len: int32, timeout_ms: int32): int32 =
  var elapsed: int32 = 0
  while elapsed < timeout_ms or timeout_ms == 0:
    net_poll()

    # Check if socket is still valid
    var state: int32 = net_state(sock)
    if state == TCP_CLOSED or state == TCP_CLOSE_WAIT:
      return -1

    # Try to receive
    var n: int32 = net_recv(sock, buf, max_len)
    if n > 0:
      return n

    # Simple delay
    var delay: int32 = 0
    while delay < 100000:
      delay = delay + 1
    elapsed = elapsed + 10

  return 0  # Timeout

# Send all data (blocking until all sent or error)
# Returns: total bytes sent, or -1 on error
proc net_send_all(sock: int32, data: ptr uint8, len: int32): int32 =
  var sent: int32 = 0
  while sent < len:
    net_poll()

    # Check if socket is still valid
    var state: int32 = net_state(sock)
    if state != TCP_ESTABLISHED:
      if sent > 0:
        return sent
      return -1

    var n: int32 = net_send(sock, addr(data[sent]), len - sent)
    if n < 0:
      if sent > 0:
        return sent
      return -1
    sent = sent + n

  return sent

# =============================================================================
# Convenience Functions
# =============================================================================

# Send a null-terminated string
proc net_send_str(sock: int32, str: ptr uint8): int32 =
  return net_send(sock, str, strlen(str))

# Send a string followed by CRLF
proc net_send_line(sock: int32, str: ptr uint8): int32 =
  var n: int32 = net_send_str(sock, str)
  if n >= 0:
    discard net_send(sock, cast[ptr uint8]("\r\n"), 2)
  return n
