# chacha20.bh - ChaCha20 Stream Cipher in pure Brainhair
# Implements RFC 8439 ChaCha20

from lib.syscalls import syscall3

# Constants
CHACHA20_KEY_SIZE: Final[int32] = 32
CHACHA20_NONCE_SIZE: Final[int32] = 12
CHACHA20_BLOCK_SIZE: Final[int32] = 64

# Syscall for random
SYS_GETRANDOM: Final[int32] = 355

# Global state (16 x 32-bit words = 64 bytes)
g_chacha_state: Array[16, uint32]
g_chacha_block: Array[64, uint8]

# Rotate left for uint32
def chacha_rotl(x: uint32, n: int32) -> uint32:
    return ((x << n) | (x >> (32 - n)))

# Quarter round on 4 words
def chacha_quarter_round(state: Ptr[uint32], a: int32, b: int32, c: int32, d: int32):
    state[a] = state[a] + state[b]
    state[d] = chacha_rotl((state[d] ^ state[a]), 16)

    state[c] = state[c] + state[d]
    state[b] = chacha_rotl((state[b] ^ state[c]), 12)

    state[a] = state[a] + state[b]
    state[d] = chacha_rotl((state[d] ^ state[a]), 8)

    state[c] = state[c] + state[d]
    state[b] = chacha_rotl((state[b] ^ state[c]), 7)

# Load 32-bit little-endian word from bytes
def chacha_load32_le(src: Ptr[uint8]) -> uint32:
    v: uint32 = cast[uint32](src[0])
    v = v | (cast[uint32](src[1]) << 8)
    v = v | (cast[uint32](src[2]) << 16)
    v = v | (cast[uint32](src[3]) << 24)
    return v

# Store 32-bit little-endian word to bytes
def chacha_store32_le(dst: Ptr[uint8], val: uint32):
    dst[0] = cast[uint8](val & cast[uint32](255))
    dst[1] = cast[uint8]((val >> 8) & cast[uint32](255))
    dst[2] = cast[uint8]((val >> 16) & cast[uint32](255))
    dst[3] = cast[uint8]((val >> 24) & cast[uint32](255))

# Initialize ChaCha20 state
# State layout:
#   0-3:   "expand 32-byte k" constants
#   4-11:  256-bit key (8 words)
#   12:    block counter
#   13-15: 96-bit nonce (3 words)
def chacha20_init(key: Ptr[uint8], nonce: Ptr[uint8], counter: int32):
    # Constants "expand 32-byte k"
    g_chacha_state[0] = cast[uint32](0x61707865)  # "expa"
    g_chacha_state[1] = cast[uint32](0x3320646e)  # "nd 3"
    g_chacha_state[2] = cast[uint32](0x79622d32)  # "2-by"
    g_chacha_state[3] = cast[uint32](0x6b206574)  # "te k"

    # Key (8 x 32-bit words)
    i: int32 = 0
    while i < 8:
        g_chacha_state[4 + i] = chacha_load32_le(cast[Ptr[uint8]](cast[int32](key) + (i * 4)))
        i = i + 1

    # Counter
    g_chacha_state[12] = cast[uint32](counter)

    # Nonce (3 x 32-bit words)
    g_chacha_state[13] = chacha_load32_le(nonce)
    g_chacha_state[14] = chacha_load32_le(cast[Ptr[uint8]](cast[int32](nonce) + 4))
    g_chacha_state[15] = chacha_load32_le(cast[Ptr[uint8]](cast[int32](nonce) + 8))

# Generate one 64-byte block of keystream
def chacha20_block():
    # Working state
    working: Array[16, uint32]

    # Copy initial state to working state
    i: int32 = 0
    while i < 16:
        working[i] = g_chacha_state[i]
        i = i + 1

    # 20 rounds (10 double-rounds)
    round: int32 = 0
    while round < 10:
        # Column rounds
        chacha_quarter_round(Ptr[uint32](addr(working)), 0, 4, 8, 12)
        chacha_quarter_round(Ptr[uint32](addr(working)), 1, 5, 9, 13)
        chacha_quarter_round(Ptr[uint32](addr(working)), 2, 6, 10, 14)
        chacha_quarter_round(Ptr[uint32](addr(working)), 3, 7, 11, 15)

        # Diagonal rounds
        chacha_quarter_round(Ptr[uint32](addr(working)), 0, 5, 10, 15)
        chacha_quarter_round(Ptr[uint32](addr(working)), 1, 6, 11, 12)
        chacha_quarter_round(Ptr[uint32](addr(working)), 2, 7, 8, 13)
        chacha_quarter_round(Ptr[uint32](addr(working)), 3, 4, 9, 14)

        round = round + 1

    # Add original state
    i = 0
    while i < 16:
        working[i] = working[i] + g_chacha_state[i]
        i = i + 1

    # Serialize to bytes (little-endian)
    i = 0
    while i < 16:
        chacha_store32_le(cast[Ptr[uint8]](cast[int32](addr(g_chacha_block)) + (i * 4)), working[i])
        i = i + 1

    # Increment counter
    g_chacha_state[12] = g_chacha_state[12] + cast[uint32](1)

# Get pointer to current block
def chacha20_get_block() -> Ptr[uint8]:
    return Ptr[uint8](addr(g_chacha_block))

# Encrypt/decrypt data with ChaCha20
def chacha20_encrypt(input: Ptr[uint8], output: Ptr[uint8], length: int32, key: Ptr[uint8], nonce: Ptr[uint8], counter: int32):
    # Initialize state
    chacha20_init(key, nonce, counter)

    offset: int32 = 0
    while offset < length:
        # Generate keystream block
        chacha20_block()

        # XOR with input (up to 64 bytes or remaining)
        block_len: int32 = length - offset
        if block_len > 64:
            block_len = 64

        i: int32 = 0
        while i < block_len:
            output[offset + i] = input[offset + i] ^ g_chacha_block[i]
            i = i + 1

        offset = offset + 64

# ChaCha20 context structure
class ChaCha20Context:
    key: Array[32, uint8]
    nonce: Array[12, uint8]
    counter: int32

# Initialize context
def chacha20_ctx_init(ctx: Ptr[ChaCha20Context], key: Ptr[uint8], nonce: Ptr[uint8]):
    i: int32 = 0
    while i < CHACHA20_KEY_SIZE:
        ctx.key[i] = key[i]
        i = i + 1
    i = 0
    while i < CHACHA20_NONCE_SIZE:
        ctx.nonce[i] = nonce[i]
        i = i + 1
    ctx.counter = 0

# Encrypt with context
def chacha20_ctx_encrypt(ctx: Ptr[ChaCha20Context], input: Ptr[uint8], output: Ptr[uint8], length: int32):
    chacha20_encrypt(input, output, length, Ptr[uint8](addr(ctx.key)), Ptr[uint8](addr(ctx.nonce)), ctx.counter)
    blocks: int32 = (length + CHACHA20_BLOCK_SIZE - 1) / CHACHA20_BLOCK_SIZE
    ctx.counter = ctx.counter + blocks

# Decrypt with context (same as encrypt for stream cipher)
def chacha20_ctx_decrypt(ctx: Ptr[ChaCha20Context], input: Ptr[uint8], output: Ptr[uint8], length: int32):
    chacha20_ctx_encrypt(ctx, input, output, length)

# Reset context counter
def chacha20_ctx_reset(ctx: Ptr[ChaCha20Context]):
    ctx.counter = 0

# Set context counter
def chacha20_ctx_set_counter(ctx: Ptr[ChaCha20Context], counter: int32):
    ctx.counter = counter

# One-shot encrypt
def chacha20_encrypt_simple(input: Ptr[uint8], output: Ptr[uint8], length: int32, key: Ptr[uint8], nonce: Ptr[uint8]):
    chacha20_encrypt(input, output, length, key, nonce, 0)

# One-shot decrypt
def chacha20_decrypt_simple(input: Ptr[uint8], output: Ptr[uint8], length: int32, key: Ptr[uint8], nonce: Ptr[uint8]):
    chacha20_encrypt(input, output, length, key, nonce, 0)

# Generate random key
def chacha20_generate_key(key: Ptr[uint8]) -> int32:
    return syscall3(SYS_GETRANDOM, cast[int32](key), CHACHA20_KEY_SIZE, 0)

# Generate random nonce
def chacha20_generate_nonce(nonce: Ptr[uint8]) -> int32:
    return syscall3(SYS_GETRANDOM, cast[int32](nonce), CHACHA20_NONCE_SIZE, 0)
