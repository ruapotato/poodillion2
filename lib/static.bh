# BrainhairOS Static File Server Library
# Provides static file serving with MIME type detection

from lib.syscalls import *
from lib.net import *

# MIME type constants
MIME_HTML: Final[int32] = 0
MIME_CSS: Final[int32] = 1
MIME_JS: Final[int32] = 2
MIME_JSON: Final[int32] = 3
MIME_PNG: Final[int32] = 4
MIME_JPG: Final[int32] = 5
MIME_GIF: Final[int32] = 6
MIME_SVG: Final[int32] = 7
MIME_ICO: Final[int32] = 8
MIME_TXT: Final[int32] = 9
MIME_XML: Final[int32] = 10
MIME_BINARY: Final[int32] = 11

# Static route storage
MAX_STATIC_ROUTES: Final[int32] = 8
MAX_STATIC_PREFIX: Final[int32] = 64
MAX_STATIC_DIR: Final[int32] = 128
MAX_FILE_PATH: Final[int32] = 256
STATIC_BUF_SIZE: Final[int32] = 4096

static_prefixes: Array[512, uint8]
static_dirs: Array[1024, uint8]
static_count: int32 = 0

# File read buffer
static_file_buf: Array[4096, uint8]

# =============================================================================
# MIME Type Detection
# =============================================================================

def get_mime_type_str(mime_type: int32) -> Ptr[uint8]:
    """Get MIME type string from constant"""
    if mime_type == MIME_HTML:
        return Ptr[uint8]("text/html")
    elif mime_type == MIME_CSS:
        return Ptr[uint8]("text/css")
    elif mime_type == MIME_JS:
        return Ptr[uint8]("application/javascript")
    elif mime_type == MIME_JSON:
        return Ptr[uint8]("application/json")
    elif mime_type == MIME_PNG:
        return Ptr[uint8]("image/png")
    elif mime_type == MIME_JPG:
        return Ptr[uint8]("image/jpeg")
    elif mime_type == MIME_GIF:
        return Ptr[uint8]("image/gif")
    elif mime_type == MIME_SVG:
        return Ptr[uint8]("image/svg+xml")
    elif mime_type == MIME_ICO:
        return Ptr[uint8]("image/x-icon")
    elif mime_type == MIME_TXT:
        return Ptr[uint8]("text/plain")
    elif mime_type == MIME_XML:
        return Ptr[uint8]("application/xml")
    else:
        return Ptr[uint8]("application/octet-stream")

def ext_matches(filename: Ptr[uint8], ext: Ptr[uint8]) -> int32:
    """Check if filename ends with extension"""
    name_len: int32 = strlen(filename)
    ext_len: int32 = strlen(ext)
    
    if name_len < ext_len:
        return 0
    
    i: int32 = 0
    offset: int32 = name_len - ext_len
    while i < ext_len:
        c1: int32 = cast[int32](filename[offset + i])
        c2: int32 = cast[int32](ext[i])
        # Case-insensitive comparison
        if c1 >= 65 and c1 <= 90:
            c1 = c1 + 32
        if c2 >= 65 and c2 <= 90:
            c2 = c2 + 32
        if c1 != c2:
            return 0
        i = i + 1
    
    return 1

def get_mime_type(filename: Ptr[uint8]) -> int32:
    """Determine MIME type from filename extension"""
    if ext_matches(filename, Ptr[uint8](".html")) == 1:
        return MIME_HTML
    if ext_matches(filename, Ptr[uint8](".htm")) == 1:
        return MIME_HTML
    if ext_matches(filename, Ptr[uint8](".css")) == 1:
        return MIME_CSS
    if ext_matches(filename, Ptr[uint8](".js")) == 1:
        return MIME_JS
    if ext_matches(filename, Ptr[uint8](".json")) == 1:
        return MIME_JSON
    if ext_matches(filename, Ptr[uint8](".png")) == 1:
        return MIME_PNG
    if ext_matches(filename, Ptr[uint8](".jpg")) == 1:
        return MIME_JPG
    if ext_matches(filename, Ptr[uint8](".jpeg")) == 1:
        return MIME_JPG
    if ext_matches(filename, Ptr[uint8](".gif")) == 1:
        return MIME_GIF
    if ext_matches(filename, Ptr[uint8](".svg")) == 1:
        return MIME_SVG
    if ext_matches(filename, Ptr[uint8](".ico")) == 1:
        return MIME_ICO
    if ext_matches(filename, Ptr[uint8](".txt")) == 1:
        return MIME_TXT
    if ext_matches(filename, Ptr[uint8](".xml")) == 1:
        return MIME_XML
    return MIME_BINARY

# =============================================================================
# Static Route Registration
# =============================================================================

def static_route(url_prefix: Ptr[uint8], dir_path: Ptr[uint8]) -> int32:
    """Register a static file directory
    
    url_prefix: URL path prefix (e.g., "/static")
    dir_path: filesystem directory path (e.g., "./public")
    
    Returns 0 on success, -1 on error
    """
    if static_count >= MAX_STATIC_ROUTES:
        return -1
    
    prefix_offset: int32 = static_count * MAX_STATIC_PREFIX
    dir_offset: int32 = static_count * MAX_STATIC_DIR
    
    # Copy URL prefix
    i: int32 = 0
    while url_prefix[i] != 0 and i < MAX_STATIC_PREFIX - 1:
        static_prefixes[prefix_offset + i] = url_prefix[i]
        i = i + 1
    static_prefixes[prefix_offset + i] = 0
    
    # Copy directory path
    i = 0
    while dir_path[i] != 0 and i < MAX_STATIC_DIR - 1:
        static_dirs[dir_offset + i] = dir_path[i]
        i = i + 1
    static_dirs[dir_offset + i] = 0
    
    static_count = static_count + 1
    return 0

# =============================================================================
# Path Security
# =============================================================================

def is_path_safe(path: Ptr[uint8]) -> int32:
    """Check if path is safe (no directory traversal)"""
    i: int32 = 0
    
    while path[i] != 0:
        # Check for ".."
        if path[i] == 46 and path[i + 1] == 46:
            # Could be ../ or ..\
            if path[i + 2] == 0 or path[i + 2] == 47 or path[i + 2] == 92:
                return 0
        i = i + 1
    
    return 1

# =============================================================================
# Static File Resolution
# =============================================================================

def resolve_static_path(url: Ptr[uint8], out_path: Ptr[uint8], max_len: int32) -> int32:
    """Resolve URL to filesystem path
    
    Returns: MIME type constant, or -1 if not found
    """
    i: int32 = 0
    
    while i < static_count:
        prefix_offset: int32 = i * MAX_STATIC_PREFIX
        prefix: Ptr[uint8] = addr(static_prefixes[prefix_offset])
        prefix_len: int32 = strlen(prefix)
        
        # Check if URL starts with this prefix
        j: int32 = 0
        matched: int32 = 1
        while j < prefix_len:
            if url[j] != prefix[j]:
                matched = 0
                break
            j = j + 1
        
        if matched == 1:
            # Get remaining path after prefix
            remaining: Ptr[uint8] = addr(url[prefix_len])
            
            # Security check
            if is_path_safe(remaining) == 0:
                return -1
            
            # Build full path: dir_path + remaining
            dir_offset: int32 = i * MAX_STATIC_DIR
            dir_path: Ptr[uint8] = addr(static_dirs[dir_offset])
            dir_len: int32 = strlen(dir_path)
            
            # Copy directory path
            k: int32 = 0
            while k < dir_len and k < max_len - 1:
                out_path[k] = dir_path[k]
                k = k + 1
            
            # Copy remaining path
            j = 0
            while remaining[j] != 0 and k < max_len - 1:
                out_path[k] = remaining[j]
                k = k + 1
                j = j + 1
            out_path[k] = 0
            
            return get_mime_type(out_path)
        
        i = i + 1
    
    return -1

# =============================================================================
# Static File Serving
# =============================================================================

def serve_file(sock: int32, filepath: Ptr[uint8], mime_type: int32) -> int32:
    """Serve a file with appropriate HTTP headers
    
    sock: socket to send to
    filepath: path to file
    mime_type: MIME type constant
    
    Returns: 0 on success, -1 on error
    """
    # Open file
    fd: int32 = open(filepath, 0, 0)  # O_RDONLY = 0
    if fd < 0:
        return -1
    
    # Get file size using lseek
    file_size: int32 = lseek(fd, 0, 2)  # SEEK_END = 2
    dummy: int32 = lseek(fd, 0, 0)  # SEEK_SET = 0, back to start
    
    # Get MIME type string
    mime_str: Ptr[uint8] = get_mime_type_str(mime_type)
    
    # Send HTTP response headers
    net_send_str(sock, Ptr[uint8]("HTTP/1.0 200 OK\r\n"))
    net_send_str(sock, Ptr[uint8]("Content-Type: "))
    net_send_str(sock, mime_str)
    net_send_str(sock, Ptr[uint8]("\r\n"))
    
    # Content-Length
    net_send_str(sock, Ptr[uint8]("Content-Length: "))
    len_buf: Array[16, uint8]
    itoa(file_size, addr(len_buf[0]))
    net_send_str(sock, addr(len_buf[0]))
    net_send_str(sock, Ptr[uint8]("\r\n"))
    
    net_send_str(sock, Ptr[uint8]("Connection: close\r\n"))
    net_send_str(sock, Ptr[uint8]("\r\n"))
    
    # Send file contents
    bytes_sent: int32 = 0
    while bytes_sent < file_size:
        n: int32 = read(fd, addr(static_file_buf[0]), STATIC_BUF_SIZE)
        if n <= 0:
            break
        net_send(sock, addr(static_file_buf[0]), n)
        bytes_sent = bytes_sent + n
    
    close(fd)
    return 0

def serve_static(sock: int32, url: Ptr[uint8]) -> int32:
    """Try to serve a static file for the given URL
    
    sock: socket to send response to
    url: URL path from request
    
    Returns: 1 if file was served, 0 if not a static route
    """
    filepath: Array[256, uint8]
    
    mime_type: int32 = resolve_static_path(url, addr(filepath[0]), 256)
    if mime_type < 0:
        return 0
    
    # Try to serve the file
    if serve_file(sock, addr(filepath[0]), mime_type) == 0:
        return 1
    
    # If path is a directory, try index.html
    path_len: int32 = strlen(addr(filepath[0]))
    if path_len > 0 and filepath[path_len - 1] == 47:  # ends with '/'
        # Append index.html
        idx_name: Ptr[uint8] = Ptr[uint8]("index.html")
        i: int32 = 0
        while idx_name[i] != 0 and path_len + i < 255:
            filepath[path_len + i] = idx_name[i]
            i = i + 1
        filepath[path_len + i] = 0
        
        if serve_file(sock, addr(filepath[0]), MIME_HTML) == 0:
            return 1
    
    return 0

def send_404(sock: int32):
    """Send 404 Not Found response"""
    body: Ptr[uint8] = Ptr[uint8]("<html><body><h1>404 Not Found</h1></body></html>")
    body_len: int32 = strlen(body)
    
    net_send_str(sock, Ptr[uint8]("HTTP/1.0 404 Not Found\r\n"))
    net_send_str(sock, Ptr[uint8]("Content-Type: text/html\r\n"))
    net_send_str(sock, Ptr[uint8]("Content-Length: "))
    len_buf: Array[16, uint8]
    itoa(body_len, addr(len_buf[0]))
    net_send_str(sock, addr(len_buf[0]))
    net_send_str(sock, Ptr[uint8]("\r\n"))
    net_send_str(sock, Ptr[uint8]("Connection: close\r\n"))
    net_send_str(sock, Ptr[uint8]("\r\n"))
    net_send_str(sock, body)
