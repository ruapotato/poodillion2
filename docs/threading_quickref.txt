BrainhairOS Kernel Threading - Quick Reference
==============================================

KERNEL API (kernel/process.asm)
--------------------------------

thread_create(entry, stack_ptr)
  Create a new thread
  Args: entry = function pointer, stack_ptr = stack (0=auto)
  Returns: Thread PID or -1

thread_exit(code)
  Exit current thread
  Args: code = exit code
  Returns: Never

thread_yield()
  Yield CPU to other threads
  Args: None
  Returns: None

get_thread_id()
  Get current thread ID
  Returns: TID (0=main, 1+=thread)

is_thread()
  Check if running as thread
  Returns: 1=thread, 0=process


SYSCALL API (userland)
----------------------

Syscall Numbers:
  SYS_thread_create  = 200
  SYS_thread_exit    = 201
  SYS_thread_yield   = 202
  SYS_get_thread_id  = 203
  SYS_is_thread      = 204

Usage:
  syscall2(SYS_thread_create, entry, stack)
  syscall1(SYS_thread_exit, code)
  syscall1(SYS_thread_yield, 0)
  syscall1(SYS_get_thread_id, 0)
  syscall1(SYS_is_thread, 0)


PCB STRUCTURE (kernel/process.asm)
----------------------------------

Offset  Field           Type    Description
------  -----           ----    -----------
100     PCB_IS_THREAD   int32   1=thread, 0=process
104     PCB_MAIN_PROC   int32   Main process PID
108     PCB_THREAD_ID   int32   Thread ID (0=main)
112     PCB_NEXT_TID    int32   Next TID to assign


EXAMPLE CODE
------------

Kernel (Brainhair):
  proc worker() =
    var tid: int32 = get_thread_id()
    print("Thread ")
    print_int(tid)
    thread_exit(0)

  proc main(): int32 =
    var t1: int32 = thread_create(addr(worker), 0)
    thread_yield()
    return 0

Userland (Brainhair with syscalls):
  import "lib/syscalls"

  const SYS_thread_create: int32 = 200

  proc worker() =
    print_msg("Hello from thread\n")
    discard syscall1(SYS_thread_exit, 0)

  proc main(): int32 =
    var t: int32 = syscall2(SYS_thread_create,
                            cast[int32](addr(worker)), 0)
    discard syscall1(SYS_thread_yield, 0)
    return 0


KEY CONCEPTS
------------

1. Shared Memory: Threads share page directory = same address space
2. Independent Stacks: Each thread has 4KB kernel stack
3. Cooperative: Must call thread_yield() to switch
4. Scheduled Equally: Round-robin with processes
5. Simple Lifecycle: Create -> Run -> Yield -> Exit


FILES MODIFIED
--------------

kernel/process.asm      Thread management functions (~270 lines)
kernel/kernel_main.bh   Thread function declarations
kernel/isr.asm          Syscall handlers (~50 lines)
userland/thread_test.bh Test program (~230 lines)


BUILD & TEST
------------

Build:
  make microkernel

Test:
  bin/thread_test

Output:
  Shows 3 worker threads + main thread running concurrently
  Shared counter incremented by all threads
  Demonstrates proper context switching


LIMITATIONS
-----------

- No mutexes/semaphores (race conditions possible)
- No thread join (can't wait for completion)
- No TLS (thread-local storage)
- Max 16 threads (shares process table)
- Cooperative (must yield explicitly)


TROUBLESHOOTING
---------------

Q: Thread not starting?
A: Check return value - negative means creation failed

Q: Threads not switching?
A: Must call thread_yield() - no preemption

Q: Race conditions on shared data?
A: No synchronization primitives yet - design around it

Q: Thread stuck/hung?
A: Cooperative scheduling - must yield periodically
