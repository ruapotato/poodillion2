# Demonstration of struct and array syntax in Brainhair
# This file shows all the new parser features

# Define a simple Point struct
type Point = object
    x: int32
    y: int32

# Define a more complex Process struct
type Process = object
    pid: int32
    name: ptr char
    status: int32
    priority: int32

# Array declarations with various types
var buffer: array[256, char]
var numbers: array[10, int32]
var matrix: array[5, array[5, int32]]
var processes: array[16, Process]

# Procedure using struct literals
proc create_point(x: int32, y: int32): Point =
    return Point(x: x, y: y)

# Procedure using array literals
proc init_array(): array[5, int32] =
    return [1, 2, 3, 4, 5]

# Procedure demonstrating field access
proc get_pid(p: Process): int32 =
    return p.pid

# Procedure demonstrating field assignment
proc set_status(p: Process, status: int32) =
    p.status = status

# Main procedure showing complex usage
proc main() =
    # Create a point using struct literal
    var origin: Point = Point(x: 0, y: 0)
    var p1: Point = create_point(10, 20)

    # Access struct fields
    var x_coord: int32 = p1.x
    var y_coord: int32 = p1.y

    # Modify struct fields
    p1.x = 100
    p1.y = 200

    # Array literals
    var small_array: array[3, int32] = [1, 2, 3]

    # Array of struct literals (formatted for readability)
    var points: array[3, Point] = [
        Point(x: 0, y: 0),
        Point(x: 10, y: 10),
        Point(x: 20, y: 20)
    ]

    # Nested field access and array indexing
    var first_x: int32 = points[0].x
    var second_y: int32 = points[1].y

    # Combine with existing features
    var proc_ptr: ptr Process = addr(processes[0])

    # Create and initialize a process
    var init_proc: Process = Process(
        pid: 1,
        status: 0,
        priority: 10
    )
