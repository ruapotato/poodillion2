# Test peek_char for multi-char operators
try:
    from typing import List
except:
    pass

TT_PLUS: int = 67
TT_PLUS_EQUALS: int = 81
TT_EQUALS: int = 74
TT_EQUALS_EQUALS: int = 75
TT_ARROW: int = 126
TT_MINUS: int = 68

class Token:
    def __init__(self, ttype: int, value, line: int, column: int):
        self.ttype: int = ttype
        self.value = value
        self.line: int = line
        self.column: int = column

class Lexer:
    def __init__(self, source: str):
        self.source: str = source
        self.pos: int = 0
        self.line: int = 1
        self.column: int = 1
        self.tokens: List[Token] = []

    def at_end(self) -> bool:
        return self.pos >= len(self.source)

    def current_char(self) -> char:
        return self.source[self.pos]

    def peek_char(self, offset: int = 1) -> char:
        pos: int = self.pos + offset
        if pos >= len(self.source):
            return ' '
        return self.source[pos]

    def advance(self):
        self.pos = self.pos + 1
        self.column = self.column + 1

    def tokenize(self) -> List[Token]:
        while not self.at_end():
            ch: char = self.current_char()
            start_line: int = self.line
            start_col: int = self.column

            if ch == ' ':
                self.advance()
                continue

            if ch == '+':
                if self.peek_char() == '=':
                    self.advance()
                    self.advance()
                    self.tokens.append(Token(TT_PLUS_EQUALS, None, start_line, start_col))
                else:
                    self.advance()
                    self.tokens.append(Token(TT_PLUS, None, start_line, start_col))
            elif ch == '=':
                if self.peek_char() == '=':
                    self.advance()
                    self.advance()
                    self.tokens.append(Token(TT_EQUALS_EQUALS, None, start_line, start_col))
                else:
                    self.advance()
                    self.tokens.append(Token(TT_EQUALS, None, start_line, start_col))
            elif ch == '-':
                if self.peek_char() == '>':
                    self.advance()
                    self.advance()
                    self.tokens.append(Token(TT_ARROW, None, start_line, start_col))
                else:
                    self.advance()
                    self.tokens.append(Token(TT_MINUS, None, start_line, start_col))
            else:
                self.advance()

        return self.tokens

def main() -> int:
    code: str = "+= == ->"
    lexer: Lexer = Lexer(code)
    tokens: List[Token] = lexer.tokenize()
    n: int = len(tokens)
    if n == 3:
        t0: Token = tokens[0]
        t1: Token = tokens[1]
        t2: Token = tokens[2]
        if t0.ttype == TT_PLUS_EQUALS and t1.ttype == TT_EQUALS_EQUALS and t2.ttype == TT_ARROW:
            print("OK\n")
        else:
            print("FAIL: wrong types\n")
    else:
        print("FAIL: count\n")
    return 0
