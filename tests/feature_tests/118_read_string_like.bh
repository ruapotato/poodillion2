# Test: read_string-like method with while loop and string concat
try:
    from typing import List
except:
    pass

class Token:
    def __init__(self, ttype: int, value, line: int, column: int):
        self.ttype: int = ttype
        self.value = value
        self.line: int = line
        self.column: int = column

class Lexer:
    def __init__(self, source: str):
        self.source: str = source
        self.pos: int = 0
        self.line: int = 1
        self.column: int = 1
        self.tokens: List[Token] = []

    def at_end(self) -> bool:
        return self.pos >= len(self.source)

    def current_char(self) -> char:
        return self.source[self.pos]

    def advance(self):
        self.pos = self.pos + 1
        self.column = self.column + 1

    def read_string(self, is_fstring: bool = False) -> Token:
        start_line: int = self.line
        start_col: int = self.column
        quote: char = self.current_char()
        self.advance()

        string: str = ""
        while not self.at_end():
            ch: char = self.current_char()
            if ch == quote:
                self.advance()
                break
            string = string + ch
            self.advance()

        ttype: int = 5
        return Token(ttype, string, start_line, start_col)

    def run(self):
        while not self.at_end():
            ch: char = self.current_char()

            if ch == '"':
                t: Token = self.read_string()
                self.tokens.append(t)
                continue

            self.advance()

def main() -> int:
    lexer: Lexer = Lexer("\"abc\"")
    lexer.run()
    n: int = len(lexer.tokens)
    if n == 1:
        print("OK\n")
    else:
        print("FAIL: ")
        c: char = chr(48 + n)
        print(c)
        print("\n")
    return 0
