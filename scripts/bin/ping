#!/usr/bin/pooscript
# ping - send ICMP ECHO_REQUEST to network hosts via /dev/net/packet

if len(args) == 0:
    error("ping: usage: ping [-c count] destination")
    exit(1)

# Parse options
count = 4  # default count
target = None
i = 0
while i < len(args):
    arg = args[i]
    if arg == '-c' and i + 1 < len(args):
        count = int(args[i + 1])
        i += 2
    else:
        target = arg
        i += 1

if not target:
    error("ping: usage: ping [-c count] destination")
    exit(1)

# Get system info
system_iface = process.get_system()
if not system_iface:
    error(f"ping: cannot get system info")
    exit(1)

# Get our IP (use primary interface)
local_ip = system_iface.local_ip
pid = process.getpid()

print(f"PING {target} 56(84) bytes of data.")


# Helper functions for packet building
def ip_to_bytes(ip_str):
    """Convert IP string to 4 bytes"""
    parts = ip_str.split('.')
    return bytes([int(p) for p in parts])


def build_icmp_packet(icmp_type, code, icmp_id, sequence, data):
    """Build ICMP packet with checksum"""
    # Build packet without checksum first
    packet = bytearray(8 + len(data))
    packet[0] = icmp_type
    packet[1] = code
    packet[2:4] = b'\x00\x00'  # Checksum placeholder
    packet[4:6] = bytes([(icmp_id >> 8) & 0xFF, icmp_id & 0xFF])  # ID big-endian
    packet[6:8] = bytes([(sequence >> 8) & 0xFF, sequence & 0xFF])  # Seq big-endian
    packet[8:] = data

    # Calculate checksum
    checksum = 0
    for i in range(0, len(packet), 2):
        if i + 1 < len(packet):
            word = (packet[i] << 8) + packet[i + 1]
        else:
            word = packet[i] << 8
        checksum += word

    # Add carry bits
    checksum = (checksum >> 16) + (checksum & 0xFFFF)
    checksum = ~checksum & 0xFFFF

    # Set checksum
    packet[2:4] = bytes([(checksum >> 8) & 0xFF, checksum & 0xFF])

    return bytes(packet)


def build_ip_packet(src_ip, dst_ip, protocol, data):
    """Build IP packet"""
    header = bytearray(20)

    # Version (4) + IHL (5 = 20 bytes)
    header[0] = (4 << 4) | 5

    # Total length
    total_len = 20 + len(data)
    header[2:4] = bytes([(total_len >> 8) & 0xFF, total_len & 0xFF])

    # TTL (64)
    header[8] = 64

    # Protocol
    header[9] = protocol

    # Source IP
    header[12:16] = ip_to_bytes(src_ip)

    # Destination IP
    header[16:20] = ip_to_bytes(dst_ip)

    # Checksum (simplified - just set to 0)
    header[10:12] = b'\x00\x00'

    return bytes(header) + data


def parse_ip_packet(packet_bytes):
    """Parse IP packet and return dict"""
    if len(packet_bytes) < 20:
        return None

    version_ihl = packet_bytes[0]
    version = version_ihl >> 4
    ihl = (version_ihl & 0x0F) * 4

    protocol = packet_bytes[9]

    src_ip = '.'.join([str(b) for b in packet_bytes[12:16]])
    dst_ip = '.'.join([str(b) for b in packet_bytes[16:20]])

    data = packet_bytes[ihl:]

    return {
        'version': version,
        'protocol': protocol,
        'src': src_ip,
        'dst': dst_ip,
        'data': data
    }


def parse_icmp_packet(icmp_bytes):
    """Parse ICMP packet"""
    if len(icmp_bytes) < 8:
        return None

    icmp_type = icmp_bytes[0]
    code = icmp_bytes[1]
    icmp_id = (icmp_bytes[4] << 8) | icmp_bytes[5]
    sequence = (icmp_bytes[6] << 8) | icmp_bytes[7]
    data = icmp_bytes[8:]

    return {
        'type': icmp_type,
        'code': code,
        'id': icmp_id,
        'sequence': sequence,
        'data': data
    }


# Main ping loop
success_count = 0
packet_dev = '/dev/net/packet'

for i in range(count):
    sequence = i + 1

    # Build ICMP Echo Request
    icmp_data = b'poodillion'
    icmp_packet = build_icmp_packet(8, 0, pid, sequence, icmp_data)  # Type 8 = Echo Request

    # Build IP packet
    ip_packet = build_ip_packet(local_ip, target, 1, icmp_packet)  # Protocol 1 = ICMP

    try:
        # Send packet
        vfs.write_bytes(packet_dev, ip_packet)

        # Wait a bit for response
        time_sleep(0.1)

        # Try to read response (non-blocking)
        response = vfs.read_bytes(packet_dev)

        if response and len(response) > 0:
            # Parse IP packet
            ip_reply = parse_ip_packet(response)

            if ip_reply and ip_reply['protocol'] == 1:  # ICMP
                # Parse ICMP
                icmp_reply = parse_icmp_packet(ip_reply['data'])

                if icmp_reply and icmp_reply['type'] == 0:  # Echo Reply
                    # Check if it's our reply
                    if icmp_reply['id'] == pid and icmp_reply['sequence'] == sequence:
                        # Success!
                        ping_time = 0.5 + ((i * 137) % 100) / 100.0
                        print(f"64 bytes from {target}: icmp_seq={sequence} ttl=64 time={ping_time:.1f} ms")
                        success_count += 1
                    else:
                        print(f"From {local_ip} icmp_seq={sequence} Destination Host Unreachable")
                else:
                    print(f"From {local_ip} icmp_seq={sequence} Destination Host Unreachable")
            else:
                print(f"From {local_ip} icmp_seq={sequence} Destination Host Unreachable")
        else:
            print(f"From {local_ip} icmp_seq={sequence} Destination Host Unreachable")

    except Exception as e:
        print(f"From {local_ip} icmp_seq={sequence} Destination Host Unreachable")

    # Wait before next ping
    if i < count - 1:
        time_sleep(0.9)

# Print statistics
print(f"\n--- {target} ping statistics ---")
packet_loss = 0 if count == 0 else int(100 * (count - success_count) / count)
print(f"{count} packets transmitted, {success_count} received, {packet_loss}% packet loss")

exit(0 if success_count > 0 else 1)
