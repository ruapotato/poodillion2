#!/usr/bin/pooscript
# named - DNS server daemon (like BIND)
# Listens for DNS queries and responds with A records from zone files

# Get system interface
system = process.get_system()
if not system:
    error("named: cannot get system info")
    exit(1)

# Check permissions (root only)
if process.uid != 0:
    error("named: must be run as root")
    exit(1)

print("Starting named (DNS server)...")

# Load DNS zones from /etc/named/zones/
zones = {}

# Try to load zone files
zone_files = [
    '/etc/named/zones/root.zone',
    '/etc/named/zones/com.zone',
    '/etc/named/zones/net.zone',
    '/etc/named/zones/org.zone',
]

for zone_file in zone_files:
    try:
        content = vfs.read(zone_file)
        if content:
            # Parse zone file
            for line in content.split('\n'):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Simple format: hostname A ip_address
                parts = line.split()
                if len(parts) >= 3 and parts[1] == 'A':
                    hostname = parts[0]
                    ip = parts[2]
                    zones[hostname] = ip
                    print(f"  Loaded: {hostname} -> {ip}")
    except:
        pass

print(f"Loaded {len(zones)} DNS records")

# Store zones in a global location that other processes can access
# We'll use a special file in /var/run/
dns_db = ""
for hostname, ip in zones.items():
    dns_db += f"{hostname} {ip}\n"

# Make sure /var/run exists
try:
    vfs.mkdir('/var/run', 0o755)
except:
    pass  # Already exists

# Write DNS database
vfs.write('/var/run/named.db', dns_db)

print(f"DNS server ready on {system.local_ip}")
print(f"Zone database: /var/run/named.db")

# In a real implementation, this would listen on UDP port 53
# For this simulation, commands will read directly from /var/run/named.db

# Keep daemon running
while True:
    time_sleep(1.0)

exit(0)
