#!/usr/bin/pooscript
# netd - Network routing daemon
# This daemon runs on boot and handles all network layer operations:
# - Reads packets from network interfaces
# - Makes routing decisions
# - Forwards packets hop-by-hop
# - Handles ICMP responses
# - Respects ip_forward setting

# ============================================================================
# PACKET PARSING HELPERS
# ============================================================================

def parse_ip_header(packet):
    """Parse IP packet header and return dict"""
    if len(packet) < 20:
        return None

    version_ihl = packet[0]
    version = version_ihl >> 4
    ihl = (version_ihl & 0x0F) * 4  # Header length in bytes

    ttl = packet[8]
    protocol = packet[9]

    # Extract IPs (bytes 12-15 = source, 16-19 = dest)
    src_ip = f"{packet[12]}.{packet[13]}.{packet[14]}.{packet[15]}"
    dst_ip = f"{packet[16]}.{packet[17]}.{packet[18]}.{packet[19]}"

    # Data starts after header
    data = packet[ihl:]

    return {
        'version': version,
        'ihl': ihl,
        'ttl': ttl,
        'protocol': protocol,
        'src': src_ip,
        'dst': dst_ip,
        'data': data,
        'full_packet': packet
    }


def decrement_ttl(packet):
    """Decrement TTL in IP packet and return new packet"""
    new_packet = bytearray(packet)
    if len(new_packet) >= 9:
        new_packet[8] = max(0, new_packet[8] - 1)  # Decrement TTL
        # Recalculate checksum (simplified - set to 0)
        new_packet[10:12] = b'\x00\x00'
    return bytes(new_packet)


def build_icmp_echo_reply(dst_ip, src_ip, icmp_id, sequence, data):
    """Build ICMP Echo Reply packet"""
    # Build ICMP packet (type 0 = Echo Reply)
    icmp = bytearray(8 + len(data))
    icmp[0] = 0  # Type: Echo Reply
    icmp[1] = 0  # Code
    icmp[2:4] = b'\x00\x00'  # Checksum placeholder
    icmp[4:6] = bytes([(icmp_id >> 8) & 0xFF, icmp_id & 0xFF])
    icmp[6:8] = bytes([(sequence >> 8) & 0xFF, sequence & 0xFF])
    icmp[8:] = data

    # Calculate checksum
    checksum = 0
    for i in range(0, len(icmp), 2):
        if i + 1 < len(icmp):
            word = (icmp[i] << 8) + icmp[i + 1]
        else:
            word = icmp[i] << 8
        checksum += word

    checksum = (checksum >> 16) + (checksum & 0xFFFF)
    checksum = ~checksum & 0xFFFF
    icmp[2:4] = bytes([(checksum >> 8) & 0xFF, checksum & 0xFF])

    # Build IP packet
    return build_ip_packet(dst_ip, src_ip, 1, bytes(icmp))


def build_ip_packet(src_ip, dst_ip, protocol, data):
    """Build IP packet"""
    header = bytearray(20)

    # Version (4) + IHL (5 = 20 bytes)
    header[0] = (4 << 4) | 5

    # Total length
    total_len = 20 + len(data)
    header[2:4] = bytes([(total_len >> 8) & 0xFF, total_len & 0xFF])

    # TTL (64)
    header[8] = 64

    # Protocol
    header[9] = protocol

    # Source IP
    src_parts = [int(x) for x in src_ip.split('.')]
    header[12:16] = bytes(src_parts)

    # Destination IP
    dst_parts = [int(x) for x in dst_ip.split('.')]
    header[16:20] = bytes(dst_parts)

    # Checksum (simplified - set to 0)
    header[10:12] = b'\x00\x00'

    return bytes(header) + data


# ============================================================================
# ROUTING TABLE MANAGEMENT
# ============================================================================

def load_routing_table():
    """Load routing table from /etc/network/routes"""
    routes = []

    try:
        content = vfs.read('/etc/network/routes')
        for line in content.split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            parts = line.split()
            if len(parts) >= 4:
                routes.append({
                    'destination': parts[0],
                    'gateway': parts[1],
                    'netmask': parts[2],
                    'interface': parts[3]
                })
    except:
        # No routing table file, use defaults
        pass

    return routes


def lookup_route(dst_ip, routes):
    """
    Find route for destination IP
    Returns route dict or None
    """
    # Check each route
    for route in routes:
        if matches_route(dst_ip, route):
            return route

    # Default route (0.0.0.0)
    for route in routes:
        if route['destination'] == '0.0.0.0':
            return route

    return None


def matches_route(ip, route):
    """Check if IP matches route destination/netmask"""
    if route['destination'] == '0.0.0.0':
        return True  # Default route matches everything

    # Simple /24 matching for now
    ip_prefix = '.'.join(ip.split('.')[:3])
    route_prefix = '.'.join(route['destination'].split('.')[:3])

    return ip_prefix == route_prefix


# ============================================================================
# MAIN ROUTING LOGIC
# ============================================================================

def route_packet(packet_bytes, recv_iface):
    """
    Route a packet to its destination
    This is the core of the network layer!
    """
    # Parse IP header
    ip = parse_ip_header(packet_bytes)
    if not ip:
        # Malformed packet, drop it
        return

    # Get system configuration
    sys = process.get_system()
    if not sys:
        return

    interfaces = sys.interfaces  # {'eth0': '192.168.1.1', 'eth1': '10.0.0.1'}

    # Is this packet for us (localhost)?
    if ip['dst'] in interfaces.values() or ip['dst'] == '127.0.0.1':
        # Deliver to local stack
        try:
            vfs.write_bytes('/dev/net/local', packet_bytes)
        except:
            pass

        # Handle ICMP Echo Request (ping)
        if ip['protocol'] == 1:  # ICMP
            icmp_data = ip['data']
            if len(icmp_data) >= 8:
                icmp_type = icmp_data[0]
                if icmp_type == 8:  # Echo Request
                    # Extract ICMP fields
                    icmp_id = (icmp_data[4] << 8) | icmp_data[5]
                    sequence = (icmp_data[6] << 8) | icmp_data[7]
                    payload = icmp_data[8:]

                    # Send Echo Reply
                    reply = build_icmp_echo_reply(ip['dst'], ip['src'], icmp_id, sequence, payload)

                    # Find output interface for reply
                    for iface_name, iface_ip in interfaces.items():
                        if iface_ip == ip['dst']:
                            try:
                                vfs.write_bytes(f'/dev/net/{iface_name}_raw', reply)
                            except:
                                pass
                            break

        return  # Done - packet was for us

    # Packet is for someone else - should we forward it?
    if not sys.ip_forward:
        # Not a router, drop packet
        return

    # Check TTL
    if ip['ttl'] <= 1:
        # TTL expired - should send ICMP Time Exceeded
        # For now, just drop
        return

    # Decrement TTL
    new_packet = decrement_ttl(packet_bytes)

    # Load routing table
    routes = load_routing_table()

    # Find route for destination
    route = lookup_route(ip['dst'], routes)
    if not route:
        # No route to host - should send ICMP Unreachable
        # For now, just drop
        return

    # Forward to output interface
    out_iface = route['interface']

    try:
        vfs.write_bytes(f'/dev/net/{out_iface}_raw', new_packet)
        print(f"[netd] Forwarded packet {ip['src']} -> {ip['dst']} via {out_iface}")
    except:
        # Could not send packet
        pass


# ============================================================================
# MAIN DAEMON LOOP
# ============================================================================

print("[netd] Network daemon starting...")

# Get system configuration
system = process.get_system()
if not system:
    error("netd: cannot get system interface")
    exit(1)

interfaces = system.interfaces
print(f"[netd] Configured interfaces: {list(interfaces.keys())}")
print(f"[netd] IP forwarding: {'enabled' if system.ip_forward else 'disabled'}")

# Load routing table
routes = load_routing_table()
print(f"[netd] Loaded {len(routes)} routes")

# Main packet processing loop
print("[netd] Entering packet processing loop...")
print("[netd] Press Ctrl+C to stop (not recommended - routing will stop!)")
packet_count = 0

while True:
    # Check each interface for incoming packets
    for iface_name in interfaces.keys():
        if iface_name == 'lo':
            continue  # Skip loopback for now

        try:
            # Read packet from interface
            packet = vfs.read_bytes(f'/dev/net/{iface_name}_raw')

            if packet and len(packet) > 0:
                packet_count += 1
                route_packet(packet, iface_name)

                # Log every 100 packets
                if packet_count % 100 == 0:
                    print(f"[netd] Processed {packet_count} packets")

        except Exception as e:
            # Error reading from interface - log but continue
            if packet_count % 1000 == 0:  # Don't spam errors
                print(f"[netd] Error on {iface_name}: {e}")

    # Small delay to avoid burning CPU
    # In a real system, this would use select() or epoll()
    time_sleep(0.01)

# This daemon runs forever - should never reach here
