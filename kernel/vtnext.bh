# vtnext.bh - VTNext Protocol Renderer for BrainhairOS
# Implements VTNext drawing primitives and command handlers
# Called from vtnext.asm parser when commands are recognized

import "../lib/graphics"

# ============ External ASM functions ============

extern vtn_get_fb_addr(): int32
extern vtn_get_fb_width(): int32
extern vtn_get_fb_height(): int32
extern vtn_get_modifiers(): int32
extern vtn_get_timestamp(): int32
extern vtn_scancode_to_keycode(scancode: int32): int32

# Getter functions for framebuffer variables
extern vtn_get_input_mode(): int32
extern vtn_get_cursor_visible(): int32
extern vtn_get_viewport_w(): int32
extern vtn_get_viewport_h(): int32

# Setter functions for state variables
extern vtn_set_input_mode(mode: int32)
extern vtn_set_cursor_visible(visible: int32)
extern vtn_set_viewport(w: int32, h: int32)

# ============ Helper Functions ============

# Parse integer from string, updates position pointer
proc vtn_parse_int(buf: ptr uint8, pos: ptr int32): int32 =
  var result: int32 = 0
  var negative: int32 = 0
  var i: int32 = pos[0]

  # Skip whitespace and semicolons
  while buf[i] == cast[uint8](32) or buf[i] == cast[uint8](59):
    i = i + 1

  # Check for negative
  if buf[i] == cast[uint8](45):
    negative = 1
    i = i + 1

  # Parse digits
  while buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    result = result * 10 + (cast[int32](buf[i]) - 48)
    i = i + 1

  # Skip trailing semicolon or space
  if buf[i] == cast[uint8](59) or buf[i] == cast[uint8](32):
    i = i + 1

  pos[0] = i

  if negative != 0:
    return 0 - result
  return result

# Parse float as fixed point (integer * 1000)
proc vtn_parse_float(buf: ptr uint8, pos: ptr int32): int32 =
  var whole: int32 = 0
  var frac: int32 = 0
  var frac_div: int32 = 1
  var negative: int32 = 0
  var i: int32 = pos[0]
  var in_frac: int32 = 0

  # Skip whitespace and semicolons
  while buf[i] == cast[uint8](32) or buf[i] == cast[uint8](59):
    i = i + 1

  # Check for negative
  if buf[i] == cast[uint8](45):
    negative = 1
    i = i + 1

  # Parse whole part
  while buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
    whole = whole * 10 + (cast[int32](buf[i]) - 48)
    i = i + 1

  # Check for decimal point
  if buf[i] == cast[uint8](46):
    i = i + 1
    # Parse fractional part (up to 3 digits)
    var frac_count: int32 = 0
    while buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57) and frac_count < 3:
      frac = frac * 10 + (cast[int32](buf[i]) - 48)
      frac_div = frac_div * 10
      i = i + 1
      frac_count = frac_count + 1
    # Skip remaining fraction digits
    while buf[i] >= cast[uint8](48) and buf[i] <= cast[uint8](57):
      i = i + 1

  # Skip trailing semicolon or space
  if buf[i] == cast[uint8](59) or buf[i] == cast[uint8](32):
    i = i + 1

  pos[0] = i

  # Convert to integer (we use integer coords for now)
  var result: int32 = whole
  if frac_div == 10:
    result = result  # frac is tenths, we ignore for now
  elif frac_div == 100:
    result = result  # frac is hundredths

  if negative != 0:
    return 0 - result
  return result

# Parse quoted string, returns length
proc vtn_parse_string(buf: ptr uint8, pos: ptr int32, out_buf: ptr uint8, max_len: int32): int32 =
  var i: int32 = pos[0]
  var out_pos: int32 = 0

  # Skip to opening quote
  while buf[i] != cast[uint8](34) and buf[i] != cast[uint8](0):
    i = i + 1

  if buf[i] == cast[uint8](34):
    i = i + 1  # Skip opening quote

  # Copy until closing quote
  while buf[i] != cast[uint8](34) and buf[i] != cast[uint8](0) and out_pos < max_len - 1:
    out_buf[out_pos] = buf[i]
    out_pos = out_pos + 1
    i = i + 1

  out_buf[out_pos] = cast[uint8](0)

  if buf[i] == cast[uint8](34):
    i = i + 1  # Skip closing quote

  pos[0] = i
  return out_pos

# Compare string prefix
proc vtn_str_prefix(s: ptr uint8, prefix: ptr uint8): int32 =
  var i: int32 = 0
  while prefix[i] != cast[uint8](0):
    if s[i] != prefix[i]:
      return 0
    i = i + 1
  return 1

# ============ Drawing Primitives ============

# Get framebuffer as uint32 array
proc vtn_get_fb(): ptr uint32 =
  return cast[ptr uint32](vtn_get_fb_addr())

# Draw pixel with bounds check
proc vtn_pixel(x: int32, y: int32, color: int32) =
  var fb: ptr uint32 = vtn_get_fb()
  var w: int32 = vtn_get_fb_width()
  var h: int32 = vtn_get_fb_height()

  if x >= 0 and x < w and y >= 0 and y < h:
    fb[y * w + x] = cast[uint32](color)

# Draw horizontal line (fast)
proc vtn_hline(x1: int32, x2: int32, y: int32, color: int32) =
  var fb: ptr uint32 = vtn_get_fb()
  var w: int32 = vtn_get_fb_width()
  var h: int32 = vtn_get_fb_height()

  if y < 0 or y >= h:
    return

  var sx: int32 = x1
  var ex: int32 = x2
  if sx > ex:
    sx = x2
    ex = x1
  if sx < 0: sx = 0
  if ex >= w: ex = w - 1

  var offset: int32 = y * w + sx
  var x: int32 = sx
  while x <= ex:
    fb[offset] = cast[uint32](color)
    offset = offset + 1
    x = x + 1

# Draw vertical line
proc vtn_vline(x: int32, y1: int32, y2: int32, color: int32) =
  var fb: ptr uint32 = vtn_get_fb()
  var w: int32 = vtn_get_fb_width()
  var h: int32 = vtn_get_fb_height()

  if x < 0 or x >= w:
    return

  var sy: int32 = y1
  var ey: int32 = y2
  if sy > ey:
    sy = y2
    ey = y1
  if sy < 0: sy = 0
  if ey >= h: ey = h - 1

  var y: int32 = sy
  while y <= ey:
    fb[y * w + x] = cast[uint32](color)
    y = y + 1

# Draw line using Bresenham's algorithm
proc vtn_line(x1: int32, y1: int32, x2: int32, y2: int32, color: int32) =
  var dx: int32 = x2 - x1
  var dy: int32 = y2 - y1

  if dx < 0: dx = 0 - dx
  if dy < 0: dy = 0 - dy

  var sx: int32 = 1
  var sy: int32 = 1
  if x1 > x2: sx = -1
  if y1 > y2: sy = -1

  var err: int32 = dx - dy
  var x: int32 = x1
  var y: int32 = y1

  while true:
    vtn_pixel(x, y, color)

    if x == x2 and y == y2:
      return

    var e2: int32 = 2 * err
    if e2 > 0 - dy:
      err = err - dy
      x = x + sx
    if e2 < dx:
      err = err + dx
      y = y + sy

# Fill rectangle
proc vtn_fill_rect(x: int32, y: int32, w: int32, h: int32, color: int32) =
  var fb: ptr uint32 = vtn_get_fb()
  var fb_w: int32 = vtn_get_fb_width()
  var fb_h: int32 = vtn_get_fb_height()

  # Clip to screen
  var sx: int32 = x
  var sy: int32 = y
  var ex: int32 = x + w
  var ey: int32 = y + h

  if sx < 0: sx = 0
  if sy < 0: sy = 0
  if ex > fb_w: ex = fb_w
  if ey > fb_h: ey = fb_h

  var py: int32 = sy
  while py < ey:
    var offset: int32 = py * fb_w + sx
    var px: int32 = sx
    while px < ex:
      fb[offset] = cast[uint32](color)
      offset = offset + 1
      px = px + 1
    py = py + 1

# Draw rectangle outline
proc vtn_rect_outline(x: int32, y: int32, w: int32, h: int32, color: int32) =
  vtn_hline(x, x + w - 1, y, color)
  vtn_hline(x, x + w - 1, y + h - 1, color)
  vtn_vline(x, y, y + h - 1, color)
  vtn_vline(x + w - 1, y, y + h - 1, color)

# Draw filled circle using midpoint algorithm
proc vtn_fill_circle(cx: int32, cy: int32, r: int32, color: int32) =
  var x: int32 = r
  var y: int32 = 0
  var err: int32 = 1 - r

  while x >= y:
    vtn_hline(cx - x, cx + x, cy + y, color)
    vtn_hline(cx - x, cx + x, cy - y, color)
    vtn_hline(cx - y, cx + y, cy + x, color)
    vtn_hline(cx - y, cx + y, cy - x, color)

    y = y + 1
    if err < 0:
      err = err + 2 * y + 1
    else:
      x = x - 1
      err = err + 2 * (y - x) + 1

# Draw circle outline
proc vtn_circle_outline(cx: int32, cy: int32, r: int32, color: int32) =
  var x: int32 = r
  var y: int32 = 0
  var err: int32 = 1 - r

  while x >= y:
    vtn_pixel(cx + x, cy + y, color)
    vtn_pixel(cx - x, cy + y, color)
    vtn_pixel(cx + x, cy - y, color)
    vtn_pixel(cx - x, cy - y, color)
    vtn_pixel(cx + y, cy + x, color)
    vtn_pixel(cx - y, cy + x, color)
    vtn_pixel(cx + y, cy - x, color)
    vtn_pixel(cx - y, cy - x, color)

    y = y + 1
    if err < 0:
      err = err + 2 * y + 1
    else:
      x = x - 1
      err = err + 2 * (y - x) + 1

# Draw filled ellipse
proc vtn_fill_ellipse(cx: int32, cy: int32, rx: int32, ry: int32, color: int32) =
  # Simple scanline approach
  var y: int32 = 0 - ry
  while y <= ry:
    # Calculate x extent at this y
    # x^2/rx^2 + y^2/ry^2 = 1
    # x = rx * sqrt(1 - y^2/ry^2)
    var y2: int32 = y * y
    var ry2: int32 = ry * ry
    var rx2: int32 = rx * rx

    # Approximate: x = rx * (ry2 - y2) / ry2  (not quite right but workable)
    var inner: int32 = ry2 - y2
    if inner < 0: inner = 0

    # Integer square root approximation
    var x_extent: int32 = 0
    var test: int32 = rx
    while test > 0:
      if test * test * ry2 <= inner * rx2:
        x_extent = test
        test = 0  # Exit loop
      else:
        test = test - 1

    vtn_hline(cx - x_extent, cx + x_extent, cy + y, color)
    y = y + 1

# Draw text using graphics.bh font
proc vtn_draw_text_at(x: int32, y: int32, text: ptr uint8, color: int32, scale: int32) =
  var fb: ptr uint32 = vtn_get_fb()
  var fb_w: int32 = vtn_get_fb_width()
  var fb_h: int32 = vtn_get_fb_height()

  var i: int32 = 0
  var px: int32 = x

  while text[i] != cast[uint8](0):
    var c: int32 = cast[int32](text[i])

    # Draw character
    var row: int32 = 0
    while row < 8:
      var bitmap: int32 = get_font_row(c, row)
      var col: int32 = 0
      while col < 8:
        var bit: int32 = (bitmap >> (7 - col)) & 1
        if bit != 0:
          # Draw scaled pixel
          if scale <= 1:
            vtn_pixel(px + col, y + row, color)
          else:
            var sy: int32 = 0
            while sy < scale:
              var sx: int32 = 0
              while sx < scale:
                vtn_pixel(px + col * scale + sx, y + row * scale + sy, color)
                sx = sx + 1
              sy = sy + 1
        col = col + 1
      row = row + 1

    if scale <= 1:
      px = px + 8
    else:
      px = px + 8 * scale

    i = i + 1

# Draw rounded rectangle
proc vtn_fill_rrect(x: int32, y: int32, w: int32, h: int32, radius: int32, color: int32) =
  var r: int32 = radius
  if r > w / 2: r = w / 2
  if r > h / 2: r = h / 2

  # Fill center
  vtn_fill_rect(x + r, y, w - 2 * r, h, color)

  # Fill left and right sides
  vtn_fill_rect(x, y + r, r, h - 2 * r, color)
  vtn_fill_rect(x + w - r, y + r, r, h - 2 * r, color)

  # Draw corner circles
  vtn_fill_circle(x + r, y + r, r, color)
  vtn_fill_circle(x + w - r - 1, y + r, r, color)
  vtn_fill_circle(x + r, y + h - r - 1, r, color)
  vtn_fill_circle(x + w - r - 1, y + h - r - 1, r, color)

# ============ Command Handlers ============

# Make RGBA from components
proc vtn_make_color(r: int32, g: int32, b: int32, a: int32): int32 =
  return (a << 24) | (r << 16) | (g << 8) | b

# Parse and execute clear command
# Format: r;g;b;a  OR  x;y;w;h;r;g;b;a
proc vtn_clear_cmd(params: ptr uint8) =
  var pos: int32 = 0

  # Count semicolons to determine format
  var semicolons: int32 = 0
  var i: int32 = 0
  while params[i] != cast[uint8](0):
    if params[i] == cast[uint8](59):
      semicolons = semicolons + 1
    i = i + 1

  if semicolons >= 7:
    # Region clear: x;y;w;h;r;g;b;a
    var x: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    var y: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    var w: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    var h: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var color: int32 = vtn_make_color(r, g, b, a)
    vtn_fill_rect(x, y, w, h, color)
  else:
    # Full clear: r;g;b;a
    var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
    var color: int32 = vtn_make_color(r, g, b, a)
    vtn_fill_rect(0, 0, vtn_get_fb_width(), vtn_get_fb_height(), color)

# Parse and execute text command
# Format: x;y;z;rot;scale;r;g;b;a;"content"
proc vtn_draw_text_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var x: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var y: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var rot: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var scale: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var text_buf: array[256, uint8]
  discard vtn_parse_string(params, cast[ptr int32](addr(pos)), cast[ptr uint8](addr(text_buf)), 256)

  var color: int32 = vtn_make_color(r, g, b, a)

  # Scale is float, convert to int (1.0 = 1, 2.0 = 2, etc.)
  var scale_int: int32 = scale
  if scale_int < 1: scale_int = 1

  vtn_draw_text_at(x, y, cast[ptr uint8](addr(text_buf)), color, scale_int)

# Parse and execute rect command
# Format: x;y;z;w;h;rot;r;g;b;a;filled
proc vtn_draw_rect_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var x: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var y: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var w: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var h: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var rot: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var filled: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  if filled != 0:
    vtn_fill_rect(x, y, w, h, color)
  else:
    vtn_rect_outline(x, y, w, h, color)

# Parse and execute line command
# Format: x1;y1;x2;y2;z;thickness;r;g;b;a
proc vtn_draw_line_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var x1: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var y1: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var x2: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var y2: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var thickness: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  # TODO: handle thickness > 1
  vtn_line(x1, y1, x2, y2, color)

# Parse and execute circle command
# Format: cx;cy;z;radius;r;g;b;a;filled
proc vtn_draw_circle_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var cx: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var cy: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var radius: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var filled: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  if filled != 0:
    vtn_fill_circle(cx, cy, radius, color)
  else:
    vtn_circle_outline(cx, cy, radius, color)

# Parse and execute ellipse command
# Format: cx;cy;z;rx;ry;rot;r;g;b;a;filled
proc vtn_draw_ellipse_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var cx: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var cy: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var rx: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var ry: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var rot: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var filled: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  # TODO: rotation not implemented
  if filled != 0:
    vtn_fill_ellipse(cx, cy, rx, ry, color)

# Parse and execute rounded rect command
# Format: x;y;z;w;h;radius;r;g;b;a;filled
proc vtn_draw_rrect_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var x: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var y: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var w: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var h: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var radius: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var filled: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  if filled != 0:
    vtn_fill_rrect(x, y, w, h, radius, color)

# Parse and execute polygon command
# Format: z;r;g;b;a;filled;n;x1;y1;x2;y2;...
proc vtn_draw_poly_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var z: int32 = vtn_parse_float(params, cast[ptr int32](addr(pos)))
  var r: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var g: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var b: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var a: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var filled: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var n: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  var color: int32 = vtn_make_color(r, g, b, a)

  # Read points into temporary arrays
  var points_x: array[64, int32]
  var points_y: array[64, int32]

  var i: int32 = 0
  while i < n and i < 64:
    points_x[i] = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    points_y[i] = vtn_parse_float(params, cast[ptr int32](addr(pos)))
    i = i + 1

  # Draw outline (connect consecutive points)
  if n >= 2:
    i = 0
    while i < n - 1:
      vtn_line(points_x[i], points_y[i], points_x[i + 1], points_y[i + 1], color)
      i = i + 1
    # Close polygon
    vtn_line(points_x[n - 1], points_y[n - 1], points_x[0], points_y[0], color)

# Parse and execute input mode command
# Format: raw OR normal
proc vtn_input_cmd(params: ptr uint8) =
  if vtn_str_prefix(params, cast[ptr uint8]("raw")) != 0:
    vtn_set_input_mode(1)
  elif vtn_str_prefix(params, cast[ptr uint8]("normal")) != 0:
    vtn_set_input_mode(0)

# Parse and execute cursor command
# Format: hide OR show
proc vtn_cursor_cmd(params: ptr uint8) =
  if vtn_str_prefix(params, cast[ptr uint8]("hide")) != 0:
    vtn_set_cursor_visible(0)
  elif vtn_str_prefix(params, cast[ptr uint8]("show")) != 0:
    vtn_set_cursor_visible(1)

# Parse and execute viewport command
# Format: width;height
proc vtn_viewport_cmd(params: ptr uint8) =
  var pos: int32 = 0
  var w: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))
  var h: int32 = vtn_parse_int(params, cast[ptr int32](addr(pos)))

  vtn_set_viewport(w, h)

# Helper to send string over serial (for responses)
proc vtn_send_response(s: ptr uint8) =
  var i: int32 = 0
  while s[i] != cast[uint8](0):
    serial_putchar(cast[int32](s[i]))
    i = i + 1

# Parse and execute query command
# Format: version OR size OR features
proc vtn_query_cmd(params: ptr uint8) =
  if vtn_str_prefix(params, cast[ptr uint8]("version")) != 0:
    # Send: ESC ] vtnr ; version ; 0 ; 1 ; 0 BEL
    vtn_send_response(cast[ptr uint8]("\x1B]vtnr;version;0;1;0\x07"))
  elif vtn_str_prefix(params, cast[ptr uint8]("size")) != 0:
    # Send: ESC ] vtnr ; size ; width ; height BEL
    # For simplicity, send fixed response
    vtn_send_response(cast[ptr uint8]("\x1B]vtnr;size;1024;768\x07"))
  elif vtn_str_prefix(params, cast[ptr uint8]("features")) != 0:
    # Send: ESC ] vtnr ; features ; text ; rect ; circle ; line BEL
    vtn_send_response(cast[ptr uint8]("\x1B]vtnr;features;text;rect;circle;line;rrect;ellipse;poly;clear\x07"))

# ============ Input Event Generation ============

# Format and send key down event
# ESC ] vtni ; kd ; keycode ; scancode ; modifiers ; timestamp BEL
proc vtn_send_key_down(keycode: int32, scancode: int32) =
  var mods: int32 = vtn_get_modifiers()
  var ts: int32 = vtn_get_timestamp()

  # Build response
  vtn_send_response(cast[ptr uint8]("\x1B]vtni;kd;"))

  # Send keycode as decimal
  var buf: array[16, uint8]
  vtn_int_to_str(keycode, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)  # ;

  vtn_int_to_str(scancode, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)

  vtn_int_to_str(mods, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)

  vtn_int_to_str(ts, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))

  serial_putchar(7)  # BEL

# Format and send key up event
proc vtn_send_key_up(keycode: int32, scancode: int32) =
  var mods: int32 = vtn_get_modifiers()
  var ts: int32 = vtn_get_timestamp()

  vtn_send_response(cast[ptr uint8]("\x1B]vtni;ku;"))

  var buf: array[16, uint8]
  vtn_int_to_str(keycode, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)

  vtn_int_to_str(scancode, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)

  vtn_int_to_str(mods, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))
  serial_putchar(59)

  vtn_int_to_str(ts, cast[ptr uint8](addr(buf)))
  vtn_send_response(cast[ptr uint8](addr(buf)))

  serial_putchar(7)

# Integer to string conversion
proc vtn_int_to_str(n: int32, buf: ptr uint8): int32 =
  var num: int32 = n
  var i: int32 = 0
  var negative: int32 = 0

  if num < 0:
    negative = 1
    num = 0 - num

  if num == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    return 1

  # Build number in reverse
  var temp: int32 = 0
  var count: int32 = 0
  while num > 0:
    temp = temp * 10 + (num % 10)
    num = num / 10
    count = count + 1

  # Write digits
  var pos: int32 = 0
  if negative == 1:
    buf[0] = cast[uint8](45)
    pos = 1

  while temp > 0 or count > 0:
    buf[pos] = cast[uint8](48 + (temp % 10))
    temp = temp / 10
    pos = pos + 1
    count = count - 1

  buf[pos] = cast[uint8](0)
  return pos
