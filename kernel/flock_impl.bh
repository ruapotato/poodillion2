# =============================================================================
# File Locking (flock/fcntl) Implementation
# =============================================================================

# Note: get_current_pid is declared in kernel_main.bh

# flock() constants
const LOCK_SH: int32 = 1      # Shared lock (read)
const LOCK_EX: int32 = 2      # Exclusive lock (write)
const LOCK_UN: int32 = 8      # Unlock
const LOCK_NB: int32 = 4      # Non-blocking

# Lock types
const FLOCK_NONE: int32 = 0
const FLOCK_SHARED: int32 = 1
const FLOCK_EXCLUSIVE: int32 = 2

# Maximum concurrent locks
const MAX_LOCKS: int32 = 64

# File lock table entry (16 bytes)
# Each entry tracks: inode, pid, lock_type, fd
var flock_inode: array[64, int32]      # Inode being locked
var flock_pid: array[64, int32]        # Process holding lock
var flock_type: array[64, int32]       # Lock type (FLOCK_SHARED/FLOCK_EXCLUSIVE)
var flock_fd: array[64, int32]         # File descriptor

# Initialize file locking system
proc flock_init() =
  var i: int32 = 0
  while i < MAX_LOCKS:
    flock_inode[i] = 0
    flock_pid[i] = 0
    flock_type[i] = FLOCK_NONE
    flock_fd[i] = -1
    i = i + 1

# Find a lock entry for a given inode and pid
proc flock_find(inode: int32, pid: int32, fd: int32): int32 =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_inode[i] == inode and flock_pid[i] == pid and flock_fd[i] == fd:
      return i
    i = i + 1
  return -1

# Check if an inode has any exclusive locks (returns 1 if locked, 0 if free)
proc flock_has_exclusive(inode: int32, exclude_pid: int32): int32 =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_inode[i] == inode and flock_type[i] == FLOCK_EXCLUSIVE:
      if flock_pid[i] != exclude_pid:
        return 1
    i = i + 1
  return 0

# Check if an inode has any locks at all (shared or exclusive)
proc flock_has_any(inode: int32, exclude_pid: int32): int32 =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_inode[i] == inode and flock_type[i] != FLOCK_NONE:
      if flock_pid[i] != exclude_pid:
        return 1
    i = i + 1
  return 0

# Allocate a new lock entry
proc flock_alloc(): int32 =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_type[i] == FLOCK_NONE:
      return i
    i = i + 1
  return -1

# Get inode from file descriptor (stub - needs proper FD -> inode mapping)
# For now, we'll use the FD as a pseudo-inode for pipes/devices
# Real implementation would look up the inode from the FD table
proc flock_get_inode_from_fd(fd: int32): int32 =
  # This is a simplified implementation
  # In a full implementation, we'd lookup the FD table to get the actual inode
  # For now, we treat each FD as unique (FD+1000 to avoid conflicts with real inodes)
  return fd + 1000

# flock() syscall implementation
# fd: file descriptor to lock
# operation: LOCK_SH, LOCK_EX, LOCK_UN, optionally ORed with LOCK_NB
# Returns: 0 on success, -1 on error
proc sys_flock(fd: int32, operation: int32): int32 =
  # Get current PID
  var pid: int32 = get_current_pid()

  # Validate file descriptor (basic check)
  if fd < 0 or fd >= 16:
    return -1

  # Get inode for this file descriptor
  var inode: int32 = flock_get_inode_from_fd(fd)

  # Extract non-blocking flag
  var nonblocking: int32 = operation & LOCK_NB
  var lock_op: int32 = operation & (0 - LOCK_NB)  # Clear LOCK_NB bit

  # Handle unlock
  if lock_op == LOCK_UN:
    var idx: int32 = flock_find(inode, pid, fd)
    if idx >= 0:
      flock_type[idx] = FLOCK_NONE
      flock_inode[idx] = 0
      flock_pid[idx] = 0
      flock_fd[idx] = -1
    return 0

  # Handle shared lock (LOCK_SH)
  if lock_op == LOCK_SH:
    # Shared lock can be acquired if no exclusive lock exists
    if flock_has_exclusive(inode, pid) != 0:
      if nonblocking != 0:
        return -1  # EWOULDBLOCK
      # In blocking mode, we would sleep here
      # For now, just fail
      return -1

    # Check if we already have a lock
    var idx: int32 = flock_find(inode, pid, fd)
    if idx >= 0:
      # Upgrade/downgrade to shared
      flock_type[idx] = FLOCK_SHARED
      return 0

    # Allocate new lock entry
    idx = flock_alloc()
    if idx < 0:
      return -1  # Lock table full

    flock_inode[idx] = inode
    flock_pid[idx] = pid
    flock_type[idx] = FLOCK_SHARED
    flock_fd[idx] = fd
    return 0

  # Handle exclusive lock (LOCK_EX)
  if lock_op == LOCK_EX:
    # Exclusive lock requires no other locks
    if flock_has_any(inode, pid) != 0:
      if nonblocking != 0:
        return -1  # EWOULDBLOCK
      # In blocking mode, we would sleep here
      # For now, just fail
      return -1

    # Check if we already have a lock
    var idx: int32 = flock_find(inode, pid, fd)
    if idx >= 0:
      # Upgrade to exclusive
      flock_type[idx] = FLOCK_EXCLUSIVE
      return 0

    # Allocate new lock entry
    idx = flock_alloc()
    if idx < 0:
      return -1  # Lock table full

    flock_inode[idx] = inode
    flock_pid[idx] = pid
    flock_type[idx] = FLOCK_EXCLUSIVE
    flock_fd[idx] = fd
    return 0

  # Invalid operation
  return -1

# Release all locks held by a process (called when process exits or closes FD)
proc flock_release_pid(pid: int32) =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_pid[i] == pid:
      flock_type[i] = FLOCK_NONE
      flock_inode[i] = 0
      flock_pid[i] = 0
      flock_fd[i] = -1
    i = i + 1

# Release locks held by a process on a specific FD
proc flock_release_fd(pid: int32, fd: int32) =
  var i: int32 = 0
  while i < MAX_LOCKS:
    if flock_pid[i] == pid and flock_fd[i] == fd:
      flock_type[i] = FLOCK_NONE
      flock_inode[i] = 0
      flock_pid[i] = 0
      flock_fd[i] = -1
    i = i + 1

# =============================================================================
# Filesystem Syscall Stubs (link/symlink/readlink)
# NOTE: The actual implementations are in kernel_main.bh after the BrainFS functions
# =============================================================================
