# ata.bh - ATA/IDE Disk Driver for BrainhairOS
# High-level driver interface for ATA PIO mode disk access
#
# Supports up to 4 drives:
#   Drive 0: Primary Master
#   Drive 1: Primary Slave
#   Drive 2: Secondary Master
#   Drive 3: Secondary Slave

# =============================================================================
# External Assembly Functions (from kernel/ata.asm)
# =============================================================================

extern proc ata_read_sectors_pio(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32
extern proc ata_write_sectors_pio(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32
extern proc ata_identify(drive: int32): int32
extern proc ata_soft_reset(controller: int32): int32
extern proc ata_irq14_handler(): int32
extern proc ata_irq15_handler(): int32
extern var ata_identify_buffer: ptr uint8
extern var ata_primary_irq_fired: int32
extern var ata_secondary_irq_fired: int32

# Serial output from syscalls
extern proc print(s: ptr uint8)
extern proc println(s: ptr uint8)
extern proc print_int(n: int32)
extern proc print_hex(n: int32)

# =============================================================================
# Constants
# =============================================================================

const ATA_MAX_DRIVES: int32 = 4
const ATA_SECTOR_SIZE: int32 = 512

# Drive types
const ATA_TYPE_NONE: int32 = 0
const ATA_TYPE_ATA: int32 = 1
const ATA_TYPE_ATAPI: int32 = 2

# =============================================================================
# Drive Info Structure
# =============================================================================

# For each detected drive, store info from IDENTIFY command
# Array of 4 drive info structures (one per possible drive)

# Drive present flag (0 = not present, 1 = present)
var ata_drives_present: array[4, int32]

# Drive type (ATA_TYPE_NONE, ATA_TYPE_ATA, ATA_TYPE_ATAPI)
var ata_drives_type: array[4, int32]

# Total sectors (28-bit LBA limit = 128 GB max)
var ata_drives_sectors: array[4, int32]

# Model string (40 chars + null)
var ata_drives_model: array[164, uint8]  # 4 drives * 41 bytes each

# Initialized flag
var ata_initialized: int32 = 0

# =============================================================================
# Helper Functions
# =============================================================================

# Copy string from identify buffer (byte-swapped pairs)
proc ata_copy_model(drive: int32, offset: int32, length: int32) =
  var i: int32 = 0
  var src: ptr uint8 = ata_identify_buffer
  var dst_offset: int32 = drive * 41

  while i < length:
    # ATA strings are byte-swapped in pairs
    var byte_offset: int32 = offset + i
    # Swap pairs: even bytes come from odd positions
    ata_drives_model[dst_offset + i] = src[byte_offset + 1]
    ata_drives_model[dst_offset + i + 1] = src[byte_offset]
    i = i + 2

  # Null terminate and trim trailing spaces
  i = length - 1
  while i >= 0:
    var c: uint8 = ata_drives_model[dst_offset + i]
    if c != cast[uint8](32) and c != cast[uint8](0):
      break
    ata_drives_model[dst_offset + i] = cast[uint8](0)
    i = i - 1

  ata_drives_model[dst_offset + 40] = cast[uint8](0)

# Get model string pointer for a drive
proc ata_get_model(drive: int32): ptr uint8 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return cast[ptr uint8](0)
  return addr(ata_drives_model[drive * 41])

# =============================================================================
# Initialization
# =============================================================================

# Probe a single drive and populate drive info
proc ata_probe_drive(drive: int32): int32 =
  print(cast[ptr uint8]("[ATA] Probing drive "))
  print_int(drive)
  print(cast[ptr uint8]("... "))

  # Initialize as not present
  ata_drives_present[drive] = 0
  ata_drives_type[drive] = ATA_TYPE_NONE
  ata_drives_sectors[drive] = 0

  # Send IDENTIFY command
  var result: int32 = ata_identify(drive)

  if result != 0:
    println(cast[ptr uint8]("not found"))
    return 0

  # Drive found - parse IDENTIFY response
  ata_drives_present[drive] = 1
  ata_drives_type[drive] = ATA_TYPE_ATA

  # Get total sectors from words 60-61 (28-bit LBA)
  var buf: ptr uint8 = ata_identify_buffer
  var sectors_lo: int32 = cast[int32](buf[120]) | (cast[int32](buf[121]) << 8)
  var sectors_hi: int32 = cast[int32](buf[122]) | (cast[int32](buf[123]) << 8)
  ata_drives_sectors[drive] = sectors_lo | (sectors_hi << 16)

  # Copy model string (words 27-46 = bytes 54-93, 40 bytes)
  ata_copy_model(drive, 54, 40)

  print(cast[ptr uint8]("found: "))
  println(ata_get_model(drive))

  var size_mb: int32 = ata_drives_sectors[drive] / 2048
  print(cast[ptr uint8]("       Size: "))
  print_int(size_mb)
  println(cast[ptr uint8](" MB"))

  return 1

# Initialize ATA subsystem and detect all drives
proc ata_init(): int32 =
  if ata_initialized != 0:
    return 0

  println(cast[ptr uint8]("[ATA] Initializing ATA subsystem..."))

  # Reset both controllers
  discard ata_soft_reset(0)  # Primary
  discard ata_soft_reset(1)  # Secondary

  # Probe all 4 possible drives
  var drives_found: int32 = 0
  var i: int32 = 0

  while i < ATA_MAX_DRIVES:
    drives_found = drives_found + ata_probe_drive(i)
    i = i + 1

  if drives_found == 0:
    println(cast[ptr uint8]("[ATA] No drives detected"))
  else:
    print(cast[ptr uint8]("[ATA] Found "))
    print_int(drives_found)
    println(cast[ptr uint8](" drive(s)"))

  ata_initialized = 1
  return drives_found

# =============================================================================
# Public API
# =============================================================================

# Check if a drive is present
proc ata_drive_present(drive: int32): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return 0
  return ata_drives_present[drive]

# Get drive size in sectors
proc ata_drive_sectors(drive: int32): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return 0
  return ata_drives_sectors[drive]

# Get drive size in bytes (limited to 2GB for int32)
proc ata_drive_size(drive: int32): int32 =
  var sectors: int32 = ata_drive_sectors(drive)
  # Avoid overflow: if > 4M sectors, return max
  if sectors > 4194304:
    return 2147483647  # Max positive int32
  return sectors * ATA_SECTOR_SIZE

# Read sectors from a drive
# Returns: number of sectors read, or -1 on error
proc ata_read(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  # Validate parameters
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return -1

  if ata_drives_present[drive] == 0:
    return -1

  if count <= 0 or count > 256:
    return -1

  if lba < 0:
    return -1

  # Check if read would exceed drive size
  var max_sectors: int32 = ata_drives_sectors[drive]
  if lba + count > max_sectors:
    return -1

  # Perform the read
  return ata_read_sectors_pio(drive, lba, count, buf)

# Write sectors to a drive
# Returns: number of sectors written, or -1 on error
proc ata_write(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  # Validate parameters
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return -1

  if ata_drives_present[drive] == 0:
    return -1

  if count <= 0 or count > 256:
    return -1

  if lba < 0:
    return -1

  # Check if write would exceed drive size
  var max_sectors: int32 = ata_drives_sectors[drive]
  if lba + count > max_sectors:
    return -1

  # Perform the write
  return ata_write_sectors_pio(drive, lba, count, buf)

# =============================================================================
# Debug / Shell Commands
# =============================================================================

# List all detected drives
proc ata_list_drives() =
  println(cast[ptr uint8]("ATA Drives:"))
  println(cast[ptr uint8]("==========="))

  var i: int32 = 0
  var found: int32 = 0

  while i < ATA_MAX_DRIVES:
    if ata_drives_present[i] != 0:
      found = 1

      # Print drive number
      print(cast[ptr uint8]("  Drive "))
      print_int(i)
      print(cast[ptr uint8](": "))

      # Print controller info
      if i < 2:
        print(cast[ptr uint8]("Primary "))
      else:
        print(cast[ptr uint8]("Secondary "))

      if (i & 1) == 0:
        print(cast[ptr uint8]("Master"))
      else:
        print(cast[ptr uint8]("Slave"))

      println(cast[ptr uint8](""))

      # Print model
      print(cast[ptr uint8]("         Model: "))
      println(ata_get_model(i))

      # Print size
      var size_mb: int32 = ata_drives_sectors[i] / 2048
      print(cast[ptr uint8]("         Size:  "))
      print_int(size_mb)
      println(cast[ptr uint8](" MB"))

    i = i + 1

  if found == 0:
    println(cast[ptr uint8]("  No drives detected"))

# Hex dump a sector
proc ata_dump_sector(drive: int32, lba: int32) =
  var buf: array[512, uint8]

  print(cast[ptr uint8]("Reading sector "))
  print_int(lba)
  print(cast[ptr uint8](" from drive "))
  print_int(drive)
  println(cast[ptr uint8]("..."))

  var result: int32 = ata_read(drive, lba, 1, addr(buf[0]))

  if result < 0:
    println(cast[ptr uint8]("Error reading sector!"))
    return

  # Print hex dump (first 256 bytes to keep output manageable)
  var i: int32 = 0
  while i < 256:
    # Print offset
    if (i & 15) == 0:
      print_hex(i)
      print(cast[ptr uint8](": "))

    # Print hex byte
    print_hex(cast[int32](buf[i]))
    print(cast[ptr uint8](" "))

    # Newline every 16 bytes
    if (i & 15) == 15:
      println(cast[ptr uint8](""))

    i = i + 1
