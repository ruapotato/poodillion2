# BrainhairOS Microkernel
# Main kernel entry point - called by boot.asm _start

# Import VTNext graphics renderer
import "vtnext"

# Import file locking implementation
import "flock_impl"

# External assembly functions - Serial
extern serial_init()
extern serial_putchar(c: int32)
extern serial_print(s: int32)
extern serial_available(): int32
extern serial_getchar(): int32

# External assembly functions - IDT
extern init_idt()
extern remap_pic()
extern enable_interrupts()
extern disable_interrupts()

# External assembly functions - Paging
extern init_paging()
extern alloc_frame(): int32
extern free_frame(frame_addr: int32)
extern map_page(virtual_addr: int32, physical_addr: int32, flags: int32): int32
extern get_physical_address(virtual_addr: int32): int32
extern flush_tlb()
extern set_cr3(pdir: int32)
extern get_cr3(): int32

# External assembly functions - Process/Scheduler
extern init_scheduler()
extern create_process(entry: int32, parent: int32): int32
extern schedule(): int32
extern context_switch(new_pid: int32)
extern yield()
extern exit_process(code: int32)
extern fork(): int32
extern thread_create(entry: int32, arg: int32): int32
extern thread_exit(code: int32)
extern thread_yield()
extern get_thread_id(): int32
extern is_thread(): int32
extern thread_join(tid: int32, status_ptr: ptr int32): int32
extern thread_detach(tid: int32): int32
extern sys_exec(elf_ptr: int32, argv: int32): int32
extern sys_execve(path: ptr uint8, argv: int32, envp: int32): int32
extern waitpid(pid: int32, status_ptr: ptr int32): int32
extern getppid(): int32

# User/group functions
extern sys_getuid(): int32
extern sys_getgid(): int32
extern sys_geteuid(): int32
extern sys_getegid(): int32
extern sys_setuid(uid: int32): int32
extern sys_setgid(gid: int32): int32
extern get_current_pid(): int32
extern set_process_state(pid: int32, state: int32)
extern timer_tick()

# Pipe/FD functions
extern init_pipes()
extern setup_std_fds(pid: int32)
extern sys_pipe(fds: ptr int32): int32
extern sys_read(fd: int32, buf: ptr uint8, count: int32): int32
extern sys_write(fd: int32, buf: ptr uint8, count: int32): int32
extern sys_close(fd: int32): int32
extern sys_dup(fd: int32): int32
extern sys_dup2(old_fd: int32, new_fd: int32): int32

# VFS mount table functions
extern vfs_init()
extern vfs_mount(path: ptr uint8, fs_type: int32, device: int32, root_inode: int32): int32
extern vfs_mount_count(): int32
extern vfs_get_mount_path(idx: int32): ptr uint8
extern vfs_get_mount_type(idx: int32): int32

# VFS filesystem types
const FS_TYPE_NONE: int32 = 0
const FS_TYPE_RAMFS: int32 = 1
const FS_TYPE_BRAINFS: int32 = 2
const FS_TYPE_DEVFS: int32 = 3
const FS_TYPE_PROCFS: int32 = 4
const FS_TYPE_SYSFS: int32 = 5
const FS_TYPE_TMPFS: int32 = 6

# Signal functions
extern init_signals()
extern sys_kill(pid: int32, sig: int32): int32
extern sys_signal(sig: int32, handler: int32): int32
extern sys_raise(sig: int32): int32
extern check_signals(): int32

# Signal numbers (POSIX)
const SIGHUP: int32 = 1
const SIGINT: int32 = 2
const SIGQUIT: int32 = 3
const SIGKILL: int32 = 9
const SIGUSR1: int32 = 10
const SIGUSR2: int32 = 12
const SIGTERM: int32 = 15
const SIGCHLD: int32 = 17
const SIGCONT: int32 = 18
const SIGSTOP: int32 = 19

# Device filesystem functions
extern devfs_init()
extern devfs_lookup(name: ptr uint8): int32
extern devfs_read(dev: int32, buf: ptr uint8, count: int32): int32
extern devfs_write(dev: int32, buf: ptr uint8, count: int32): int32
extern devfs_get_name(dev: int32): ptr uint8
extern devfs_get_type(dev: int32): int32
extern devfs_get_device_count(): int32

# Device types
const DEV_TYPE_CHAR: int32 = 1
const DEV_TYPE_BLOCK: int32 = 2

# TTY subsystem functions
extern tty_init()
extern tty_read(tty_idx: int32, buf: ptr uint8, count: int32): int32
extern tty_write(tty_idx: int32, buf: ptr uint8, count: int32): int32
extern tty_input(c: int32)
extern tty_set_fg(tty_idx: int32, pid: int32)
extern tty_get_fg(tty_idx: int32): int32
extern tty_set_flags(tty_idx: int32, flags: int32)
extern tty_get_flags(tty_idx: int32): int32
extern tty_get_winsize(tty_idx: int32, rows: ptr int32, cols: ptr int32): int32

# TTY flags
const TTY_ECHO: int32 = 1
const TTY_ICANON: int32 = 2
const TTY_ISIG: int32 = 4

# Get current tick count
extern get_tick_count(): int32

# Get process state (0=unused, 1=ready, 2=running, 3=blocked, 4=zombie)
extern get_process_state(pid: int32): int32

# External assembly functions - Keyboard
extern keyboard_init()
extern keyboard_read_char(): int32
extern keyboard_available(): int32

# External assembly functions - VTNext graphics
extern vtn_init()
extern vtn_set_fb_info(fb_base: int32, width: int32, height: int32, bpp: int32)

# External assembly functions - ChaCha20 encryption
extern chacha20_init(key: ptr uint8, nonce: ptr uint8, counter: int32)
extern chacha20_block()
extern chacha20_encrypt(input: ptr uint8, output: ptr uint8, length: int32, key: ptr uint8, nonce: ptr uint8, counter: int32)
extern chacha20_get_block(): ptr uint8

# Multiboot framebuffer info (from boot/multiboot.asm)
extern multiboot_fb_addr(): int32
extern multiboot_fb_width(): int32
extern multiboot_fb_height(): int32
extern multiboot_fb_bpp(): int32

# External assembly functions - Port I/O
extern port_outb(port: int32, value: int32)
extern port_outw(port: int32, value: int32)
extern port_outl(port: int32, value: int32)
extern port_inb(port: int32): int32
extern port_inw(port: int32): int32
extern port_inl(port: int32): int32

# External assembly functions - PCI
extern pci_config_read32(bus: int32, slot: int32, func: int32, offset: int32): int32
extern pci_config_write32(bus: int32, slot: int32, func: int32, offset: int32, value: int32)
extern pci_config_read16(bus: int32, slot: int32, func: int32, offset: int32): int32
extern pci_config_read8(bus: int32, slot: int32, func: int32, offset: int32): int32

# External assembly functions - MMIO
extern mmio_read32(address: int32): int32
extern mmio_write32(address: int32, value: int32)
extern net_memcpy(dest: int32, src: int32, len: int32)

# External assembly functions - ELF loader
extern elf_validate(elf_ptr: int32): int32
extern elf_get_entry(elf_ptr: int32): int32
extern elf_load(elf_ptr: int32, dest_base: int32): int32

# External assembly functions - ATA/IDE disk driver
extern ata_read_sectors_pio(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32
extern ata_write_sectors_pio(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32
extern ata_identify(drive: int32): int32
extern ata_soft_reset(controller: int32): int32
extern ata_irq14_handler(): int32
extern ata_irq15_handler(): int32
extern ata_get_identify_buffer(): ptr uint8

# Embedded userland binaries (accessor functions)
extern get_webapp_bin(): int32
extern get_webapp_bin_size(): int32
extern get_vtn_demo_bin(): int32
extern get_vtn_demo_bin_size(): int32
extern get_vtn_pong_bin(): int32
extern get_vtn_pong_bin_size(): int32
extern get_vtn_edit_bin(): int32
extern get_vtn_edit_bin_size(): int32
extern get_vtn_shell_bin(): int32
extern get_vtn_shell_bin_size(): int32
extern get_2048_bin(): int32
extern get_2048_bin_size(): int32
extern call_entry(entry: int32)
extern call_entry_with_stack(entry: int32, stack_ptr: int32)
extern net_memset(dest: int32, val: int32, len: int32)
extern wait_tick()  # Wait for next interrupt (allows timer to fire)

# Test thread function for kernel thread testing
proc test_thread_func(arg: int32) =
  ser_print(cast[ptr uint8]("[THREAD] Hello from thread! arg = "))
  ser_print_int(arg)
  ser_print(cast[ptr uint8](", TID = "))
  ser_print_int(get_thread_id())
  ser_print(cast[ptr uint8](", is_thread = "))
  ser_print_int(is_thread())
  kprintln(cast[ptr uint8](""))

  var i: int32 = 0
  while i < 3:
    ser_print(cast[ptr uint8]("[THREAD] Counting: "))
    ser_print_int(i)
    kprintln(cast[ptr uint8](""))
    thread_yield()
    i = i + 1

  kprintln(cast[ptr uint8]("[THREAD] Thread exiting..."))
  thread_exit(0)

# Socket test server thread
var socket_test_server_done: int32 = 0
proc socket_test_server(arg: int32) =
  ser_println(cast[ptr uint8]("[SOCK SERVER] Starting server..."))

  # Debug: check unix_find_free
  ser_print(cast[ptr uint8]("[SOCK SERVER] unix_state[0] = "))
  ser_print_int(unix_state[0])
  ser_print(cast[ptr uint8](", CLOSED = "))
  ser_print_int(UNIX_STATE_CLOSED)
  ser_println(cast[ptr uint8](""))
  var free_id: int32 = unix_find_free()
  ser_print(cast[ptr uint8]("[SOCK SERVER] unix_find_free = "))
  ser_print_int(free_id)
  ser_println(cast[ptr uint8](""))

  # Listen on socket
  var listen_id: int32 = unix_listen(cast[ptr uint8]("/tmp/test.sock"))
  if listen_id < 0:
    ser_println(cast[ptr uint8]("[SOCK SERVER] ERROR: Failed to listen"))
    socket_test_server_done = 1
    thread_exit(1)

  ser_print(cast[ptr uint8]("[SOCK SERVER] Listening on socket "))
  ser_print_int(listen_id)
  ser_println(cast[ptr uint8](""))

  # Poll for connection
  var wait_count: int32 = 0
  while unix_accept_ready(listen_id) == 0 and wait_count < 100:
    thread_yield()
    wait_count = wait_count + 1

  if wait_count >= 100:
    ser_println(cast[ptr uint8]("[SOCK SERVER] ERROR: Timeout waiting for client"))
    discard unix_close(listen_id)
    socket_test_server_done = 1
    thread_exit(1)

  # Accept connection
  var conn_id: int32 = unix_accept(listen_id)
  if conn_id < 0:
    ser_println(cast[ptr uint8]("[SOCK SERVER] ERROR: Failed to accept"))
    discard unix_close(listen_id)
    socket_test_server_done = 1
    thread_exit(1)

  ser_print(cast[ptr uint8]("[SOCK SERVER] Accepted connection "))
  ser_print_int(conn_id)
  ser_println(cast[ptr uint8](""))

  # Wait for data
  wait_count = 0
  while unix_has_data(conn_id) == 0 and wait_count < 50:
    thread_yield()
    wait_count = wait_count + 1

  # Receive data
  var recv_buf: array[64, uint8]
  var recv_len: int32 = unix_recv(conn_id, addr(recv_buf[0]), 63)
  if recv_len > 0:
    recv_buf[recv_len] = cast[uint8](0)  # Null-terminate
    ser_print(cast[ptr uint8]("[SOCK SERVER] Received: "))
    ser_println(addr(recv_buf[0]))
  else:
    ser_println(cast[ptr uint8]("[SOCK SERVER] No data received"))

  discard unix_close(conn_id)
  discard unix_close(listen_id)
  ser_println(cast[ptr uint8]("[SOCK SERVER] Server done"))
  socket_test_server_done = 1
  thread_exit(0)

# Socket test client thread
proc socket_test_client(arg: int32) =
  # Wait a bit for server to start
  var i: int32 = 0
  while i < 5:
    thread_yield()
    i = i + 1

  ser_println(cast[ptr uint8]("[SOCK CLIENT] Connecting..."))

  var sock_id: int32 = unix_connect(cast[ptr uint8]("/tmp/test.sock"))
  if sock_id < 0:
    ser_println(cast[ptr uint8]("[SOCK CLIENT] ERROR: Failed to connect"))
    thread_exit(1)

  ser_print(cast[ptr uint8]("[SOCK CLIENT] Connected on socket "))
  ser_print_int(sock_id)
  ser_println(cast[ptr uint8](""))

  # Wait for connection to complete
  i = 0
  while i < 5:
    thread_yield()
    i = i + 1

  # Send data
  var msg: ptr uint8 = cast[ptr uint8]("Hello Unix Socket!")
  var sent: int32 = unix_send(sock_id, msg, 18)
  ser_print(cast[ptr uint8]("[SOCK CLIENT] Sent "))
  ser_print_int(sent)
  ser_println(cast[ptr uint8](" bytes"))

  discard unix_close(sock_id)
  ser_println(cast[ptr uint8]("[SOCK CLIENT] Client done"))
  thread_exit(0)

# Process states
const PROC_UNUSED: int32 = 0
const PROC_READY: int32 = 1
const PROC_RUNNING: int32 = 2
const PROC_BLOCKED: int32 = 3
const PROC_ZOMBIE: int32 = 4
const PROC_STOPPED: int32 = 5

# Paging flags
const PTE_PRESENT: int32 = 1
const PTE_WRITABLE: int32 = 2
const PTE_USER: int32 = 4
const PTE_KERNEL: int32 = 3      # PRESENT | WRITABLE
const PTE_USER_RW: int32 = 7     # PRESENT | WRITABLE | USER

# VGA text mode constants
const VGA_MEMORY: int32 = 0xB8000
const VGA_WIDTH: int32 = 80
const VGA_HEIGHT: int32 = 25

# VGA colors
const VGA_BLACK: int32 = 0
const VGA_BLUE: int32 = 1
const VGA_GREEN: int32 = 2
const VGA_CYAN: int32 = 3
const VGA_RED: int32 = 4
const VGA_MAGENTA: int32 = 5
const VGA_BROWN: int32 = 6
const VGA_LIGHT_GREY: int32 = 7
const VGA_DARK_GREY: int32 = 8
const VGA_LIGHT_BLUE: int32 = 9
const VGA_LIGHT_GREEN: int32 = 10
const VGA_LIGHT_CYAN: int32 = 11
const VGA_LIGHT_RED: int32 = 12
const VGA_LIGHT_MAGENTA: int32 = 13
const VGA_YELLOW: int32 = 14
const VGA_WHITE: int32 = 15

# Current cursor position
var vga_row: int32 = 0
var vga_col: int32 = 0
var vga_color: int32 = 0x0F  # White on black

# Make VGA attribute byte from fg/bg colors
proc vga_make_color(fg: int32, bg: int32): int32 =
  return (bg << 4) | fg

# Make VGA entry (char + attribute)
proc vga_make_entry(c: int32, color: int32): int32 =
  return (color << 8) | c

# Put a character at specific position
proc vga_putchar_at(c: int32, x: int32, y: int32, color: int32) =
  var index: int32 = y * VGA_WIDTH + x
  var entry: int32 = vga_make_entry(c, color)
  cast[ptr uint16](VGA_MEMORY)[index] = cast[uint16](entry)

# Clear the screen
proc vga_clear() =
  var y: int32 = 0
  while y < VGA_HEIGHT:
    var x: int32 = 0
    while x < VGA_WIDTH:
      vga_putchar_at(32, x, y, vga_color)  # Space character
      x = x + 1
    y = y + 1
  vga_row = 0
  vga_col = 0

# Scroll the screen up one line
proc vga_scroll() =
  var vga: ptr uint16 = cast[ptr uint16](VGA_MEMORY)

  # Move all lines up
  var y: int32 = 0
  while y < VGA_HEIGHT - 1:
    var x: int32 = 0
    while x < VGA_WIDTH:
      var src_idx: int32 = (y + 1) * VGA_WIDTH + x
      var dst_idx: int32 = y * VGA_WIDTH + x
      vga[dst_idx] = vga[src_idx]
      x = x + 1
    y = y + 1

  # Clear the last line
  var x: int32 = 0
  while x < VGA_WIDTH:
    vga_putchar_at(32, x, VGA_HEIGHT - 1, vga_color)
    x = x + 1

# Print a character with cursor advancement
proc vga_putchar(c: int32) =
  if c == 10:  # Newline
    vga_col = 0
    vga_row = vga_row + 1
  elif c == 13:  # Carriage return
    vga_col = 0
  elif c == 9:  # Tab
    vga_col = (vga_col + 8) & (0 - 8)  # Align to 8
  else:
    vga_putchar_at(c, vga_col, vga_row, vga_color)
    vga_col = vga_col + 1
    if vga_col >= VGA_WIDTH:
      vga_col = 0
      vga_row = vga_row + 1

  if vga_row >= VGA_HEIGHT:
    vga_scroll()
    vga_row = VGA_HEIGHT - 1

# Print a null-terminated string (VGA only)
proc vga_print(s: ptr uint8) =
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    vga_putchar(cast[int32](s[i]))
    i = i + 1

# Print a string with newline (VGA only)
proc vga_println(s: ptr uint8) =
  vga_print(s)
  vga_putchar(10)

# ============================================================================
# Serial Output (for debugging)
# ============================================================================

# Print string to serial (character by character)
proc ser_print(s: ptr uint8) =
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    serial_putchar(cast[int32](s[i]))
    i = i + 1

# Print string with newline to serial
proc ser_println(s: ptr uint8) =
  ser_print(s)
  serial_putchar(13)
  serial_putchar(10)

# Print integer to serial
proc ser_print_int(num: int32) =
  if num < 0:
    serial_putchar(45)  # '-'
    num = 0 - num
  if num == 0:
    serial_putchar(48)  # '0'
    return

  var buf: array[12, uint8]
  var i: int32 = 0
  while num > 0:
    var digit: int32 = num - (num / 10) * 10  # num % 10
    buf[i] = cast[uint8](48 + digit)
    num = num / 10
    i = i + 1

  # Print in reverse order
  while i > 0:
    i = i - 1
    serial_putchar(cast[int32](buf[i]))

# Print single character to serial
proc ser_putchar(c: int32) =
  serial_putchar(c)

# Print to both VGA and serial
proc kprint(s: ptr uint8) =
  vga_print(s)
  ser_print(s)

proc kprintln(s: ptr uint8) =
  vga_println(s)
  ser_println(s)

# Set text color
proc vga_set_color(fg: int32, bg: int32) =
  vga_color = vga_make_color(fg, bg)

# Print a decimal number to both VGA and serial
proc kprint_dec(num: int32) =
  if num == 0:
    vga_putchar(48)
    serial_putchar(48)
    return

  var buf: array[12, uint8]
  var i: int32 = 0
  var n: int32 = num

  if n < 0:
    vga_putchar(45)
    serial_putchar(45)
    n = 0 - n

  while n > 0:
    buf[i] = cast[uint8](48 + (n - ((n / 10) * 10)))
    n = n / 10
    i = i + 1

  while i > 0:
    i = i - 1
    var c: int32 = cast[int32](buf[i])
    vga_putchar(c)
    serial_putchar(c)

# Print a decimal number to serial only (for VTNext protocol)
proc serial_print_dec(num: int32) =
  if num == 0:
    serial_putchar(48)
    return

  var buf: array[12, uint8]
  var i: int32 = 0
  var n: int32 = num

  if n < 0:
    serial_putchar(45)
    n = 0 - n

  while n > 0:
    buf[i] = cast[uint8](48 + (n - ((n / 10) * 10)))
    n = n / 10
    i = i + 1

  while i > 0:
    i = i - 1
    serial_putchar(cast[int32](buf[i]))

# Print a hex byte (2 digits)
proc kprint_hex_byte(num: int32) =
  var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var hi: int32 = (num >> 4) & 0x0F
  var lo: int32 = num & 0x0F
  vga_putchar(cast[int32](hex_chars[hi]))
  serial_putchar(cast[int32](hex_chars[hi]))
  vga_putchar(cast[int32](hex_chars[lo]))
  serial_putchar(cast[int32](hex_chars[lo]))

# Print a hexadecimal number to VGA
proc vga_print_hex(num: int32) =
  var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var buf: array[11, uint8]
  buf[0] = cast[uint8](48)  # '0'
  buf[1] = cast[uint8](120) # 'x'

  var i: int32 = 9
  var n: int32 = num
  while i >= 2:
    buf[i] = hex_chars[n & 0xF]
    n = n >> 4
    i = i - 1
  buf[10] = cast[uint8](0)

  kprint(addr(buf[0]))

# Print a hexadecimal number to serial
proc ser_print_hex(num: int32) =
  var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var buf: array[11, uint8]
  buf[0] = cast[uint8](48)  # '0'
  buf[1] = cast[uint8](120) # 'x'

  var i: int32 = 9
  var n: int32 = num
  while i >= 2:
    buf[i] = hex_chars[n & 0xF]
    n = n >> 4
    i = i - 1
  buf[10] = cast[uint8](0)

  ser_print(addr(buf[0]))

# Halt the CPU
proc halt() =
  while true:
    # In a real kernel, this would be 'hlt' instruction
    # For now, just spin
    discard

# ============================================================================
# Kernel Entry Point
# ============================================================================

# Print status OK line
proc print_ok(msg: ptr uint8) =
  # VGA with colors
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("  ["))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  vga_print(cast[ptr uint8]("OK"))
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("] "))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  vga_println(msg)
  # Serial (plain)
  ser_print(cast[ptr uint8]("[OK] "))
  ser_println(msg)

# Print status pending line
proc print_pending(msg: ptr uint8) =
  # VGA with colors
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("  ["))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_print(cast[ptr uint8](".."))
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("] "))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_println(msg)
  # Serial (plain)
  ser_print(cast[ptr uint8]("[..] "))
  ser_println(msg)

# Print status skip line (for optional features not available)
proc print_skip(msg: ptr uint8) =
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("  ["))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_print(cast[ptr uint8]("--"))
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("] "))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_println(msg)
  ser_print(cast[ptr uint8]("[--] "))
  ser_println(msg)

# =============================================================================
# ATA/IDE Disk Driver
# =============================================================================

const ATA_MAX_DRIVES: int32 = 4
const ATA_SECTOR_SIZE: int32 = 512
const ATA_TYPE_NONE: int32 = 0
const ATA_TYPE_ATA: int32 = 1

# Drive info arrays
var ata_drives_present: array[4, int32]
var ata_drives_type: array[4, int32]
var ata_drives_sectors: array[4, int32]
var ata_drives_model: array[164, uint8]
var ata_initialized: int32 = 0

# Copy model string from identify buffer (byte-swapped)
proc ata_copy_model(drive: int32, offset: int32, length: int32) =
  var i: int32 = 0
  var src: ptr uint8 = ata_get_identify_buffer()
  var dst_offset: int32 = drive * 41

  while i < length:
    var byte_offset: int32 = offset + i
    ata_drives_model[dst_offset + i] = src[byte_offset + 1]
    ata_drives_model[dst_offset + i + 1] = src[byte_offset]
    i = i + 2

  # Null terminate and trim
  i = length - 1
  while i >= 0:
    var c: uint8 = ata_drives_model[dst_offset + i]
    if c != cast[uint8](32) and c != cast[uint8](0):
      break
    ata_drives_model[dst_offset + i] = cast[uint8](0)
    i = i - 1
  ata_drives_model[dst_offset + 40] = cast[uint8](0)

# Get model string pointer
proc ata_get_model(drive: int32): ptr uint8 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return cast[ptr uint8](0)
  return addr(ata_drives_model[drive * 41])

# Probe a single drive
proc ata_probe_drive(drive: int32): int32 =
  ser_print(cast[ptr uint8]("[ATA] Probing drive "))
  ser_print_int(drive)
  ser_print(cast[ptr uint8]("... "))

  ata_drives_present[drive] = 0
  ata_drives_type[drive] = ATA_TYPE_NONE
  ata_drives_sectors[drive] = 0

  var result: int32 = ata_identify(drive)
  if result != 0:
    ser_println(cast[ptr uint8]("not found"))
    return 0

  ata_drives_present[drive] = 1
  ata_drives_type[drive] = ATA_TYPE_ATA

  # Get total sectors from words 60-61
  var buf: ptr uint8 = ata_get_identify_buffer()
  var sectors_lo: int32 = cast[int32](buf[120]) | (cast[int32](buf[121]) << 8)
  var sectors_hi: int32 = cast[int32](buf[122]) | (cast[int32](buf[123]) << 8)
  ata_drives_sectors[drive] = sectors_lo | (sectors_hi << 16)

  ata_copy_model(drive, 54, 40)

  ser_print(cast[ptr uint8]("found: "))
  ser_println(ata_get_model(drive))

  var size_mb: int32 = ata_drives_sectors[drive] / 2048
  ser_print(cast[ptr uint8]("       Size: "))
  ser_print_int(size_mb)
  ser_println(cast[ptr uint8](" MB"))

  return 1

# Initialize ATA subsystem
proc ata_init(): int32 =
  if ata_initialized != 0:
    return 0

  ser_println(cast[ptr uint8]("[ATA] Initializing ATA subsystem..."))

  discard ata_soft_reset(0)
  discard ata_soft_reset(1)

  var drives_found: int32 = 0
  var i: int32 = 0
  while i < ATA_MAX_DRIVES:
    drives_found = drives_found + ata_probe_drive(i)
    i = i + 1

  if drives_found == 0:
    ser_println(cast[ptr uint8]("[ATA] No drives detected"))
  else:
    ser_print(cast[ptr uint8]("[ATA] Found "))
    ser_print_int(drives_found)
    ser_println(cast[ptr uint8](" drive(s)"))

  ata_initialized = 1
  return drives_found

# Check if drive is present
proc ata_drive_present(drive: int32): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return 0
  return ata_drives_present[drive]

# Get drive size in sectors
proc ata_drive_sectors(drive: int32): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return 0
  return ata_drives_sectors[drive]

# Read sectors from drive
proc ata_read(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return -1
  if ata_drives_present[drive] == 0:
    return -1
  if count <= 0 or count > 256:
    return -1
  if lba < 0:
    return -1
  var max_sectors: int32 = ata_drives_sectors[drive]
  if lba + count > max_sectors:
    return -1
  return ata_read_sectors_pio(drive, lba, count, buf)

# Write sectors to drive
proc ata_write(drive: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if drive < 0 or drive >= ATA_MAX_DRIVES:
    return -1
  if ata_drives_present[drive] == 0:
    return -1
  if count <= 0 or count > 256:
    return -1
  if lba < 0:
    return -1
  var max_sectors: int32 = ata_drives_sectors[drive]
  if lba + count > max_sectors:
    return -1
  return ata_write_sectors_pio(drive, lba, count, buf)

# =============================================================================
# Block Device Layer
# =============================================================================
# Unified interface for all block storage devices (ATA, AHCI, ramdisk, etc.)

const BLKDEV_MAX: int32 = 16
const BLKDEV_SECTOR_SIZE: int32 = 512

# Device types
const BLKDEV_TYPE_NONE: int32 = 0
const BLKDEV_TYPE_ATA: int32 = 1
const BLKDEV_TYPE_AHCI: int32 = 2
const BLKDEV_TYPE_RAMDISK: int32 = 3
const BLKDEV_TYPE_NVME: int32 = 4
const BLKDEV_TYPE_PARTITION: int32 = 5

# Block device structure (per device)
# For each device: type, driver_index, sector_count, name offset
var blkdev_types: array[16, int32]
var blkdev_drv_idx: array[16, int32]
var blkdev_sectors: array[16, int32]
var blkdev_names: array[256, uint8]  # 16 devices * 16 chars each
var blkdev_count: int32 = 0

# Partition info (forward declared for partition read/write)
# PART_MAX defined later in Partition Table section
var part_parent_dev: array[16, int32]   # Parent block device
var part_start_lba: array[16, int32]    # Start sector
var part_sectors: array[16, int32]      # Number of sectors
var part_type: array[16, int32]         # Partition type
var part_count: int32 = 0

# Register a block device
# Returns: device index, or -1 on error
proc blkdev_register(dev_type: int32, drv_idx: int32, sectors: int32, name: ptr uint8): int32 =
  if blkdev_count >= BLKDEV_MAX:
    return -1

  var idx: int32 = blkdev_count
  blkdev_types[idx] = dev_type
  blkdev_drv_idx[idx] = drv_idx
  blkdev_sectors[idx] = sectors

  # Copy name (max 15 chars + null)
  var name_offset: int32 = idx * 16
  var i: int32 = 0
  while i < 15:
    var c: uint8 = name[i]
    if c == cast[uint8](0):
      break
    blkdev_names[name_offset + i] = c
    i = i + 1
  blkdev_names[name_offset + i] = cast[uint8](0)

  blkdev_count = blkdev_count + 1

  ser_print(cast[ptr uint8]("[BLKDEV] Registered "))
  ser_print(name)
  ser_print(cast[ptr uint8](" ("))
  ser_print_int(sectors)
  ser_println(cast[ptr uint8](" sectors)"))

  return idx

# Get device name
proc blkdev_get_name(dev: int32): ptr uint8 =
  if dev < 0 or dev >= blkdev_count:
    return cast[ptr uint8](0)
  return addr(blkdev_names[dev * 16])

# Get device type
proc blkdev_get_type(dev: int32): int32 =
  if dev < 0 or dev >= blkdev_count:
    return BLKDEV_TYPE_NONE
  return blkdev_types[dev]

# Get device sector count
proc blkdev_get_sectors(dev: int32): int32 =
  if dev < 0 or dev >= blkdev_count:
    return 0
  return blkdev_sectors[dev]

# Get device size in MB
proc blkdev_get_size_mb(dev: int32): int32 =
  return blkdev_get_sectors(dev) / 2048

# Forward declaration needed for partition I/O (defined later in file)
# partition_read and partition_write are called via device type dispatch

# Read sectors from block device
proc blkdev_read(dev: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if dev < 0 or dev >= blkdev_count:
    return -1
  if count <= 0:
    return -1

  var dev_type: int32 = blkdev_types[dev]
  var drv_idx: int32 = blkdev_drv_idx[dev]

  if dev_type == 1:  # BLKDEV_TYPE_ATA
    return ata_read(drv_idx, lba, count, buf)
  if dev_type == 5:  # BLKDEV_TYPE_PARTITION
    # For partitions, drv_idx is the partition index
    # Translate LBA to parent device LBA
    var part_idx: int32 = drv_idx
    if part_idx < 0 or part_idx >= part_count:
      return -1
    var parent_dev: int32 = part_parent_dev[part_idx]
    var start_lba: int32 = part_start_lba[part_idx]
    var part_sectors_val: int32 = part_sectors[part_idx]
    # Bounds check
    if lba < 0 or lba + count > part_sectors_val:
      return -1
    # Read from parent device at adjusted LBA
    return blkdev_read(parent_dev, start_lba + lba, count, buf)
  # Future: AHCI, NVMe, ramdisk handlers here

  return -1

# Write sectors to block device
proc blkdev_write(dev: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if dev < 0 or dev >= blkdev_count:
    return -1
  if count <= 0:
    return -1

  var dev_type: int32 = blkdev_types[dev]
  var drv_idx: int32 = blkdev_drv_idx[dev]

  if dev_type == 1:  # BLKDEV_TYPE_ATA
    return ata_write(drv_idx, lba, count, buf)
  if dev_type == 5:  # BLKDEV_TYPE_PARTITION
    # For partitions, drv_idx is the partition index
    var part_idx: int32 = drv_idx
    if part_idx < 0 or part_idx >= part_count:
      return -1
    var parent_dev: int32 = part_parent_dev[part_idx]
    var start_lba: int32 = part_start_lba[part_idx]
    var part_sectors_val: int32 = part_sectors[part_idx]
    # Bounds check
    if lba < 0 or lba + count > part_sectors_val:
      return -1
    # Write to parent device at adjusted LBA
    return blkdev_write(parent_dev, start_lba + lba, count, buf)
  # Future: AHCI, NVMe, ramdisk handlers here

  return -1

# Initialize block device layer and register all known devices
proc blkdev_init() =
  # Reset state
  blkdev_count = 0
  var i: int32 = 0
  while i < BLKDEV_MAX:
    blkdev_types[i] = BLKDEV_TYPE_NONE
    blkdev_drv_idx[i] = 0
    blkdev_sectors[i] = 0
    i = i + 1

  # Register all detected ATA drives
  i = 0
  while i < ATA_MAX_DRIVES:
    if ata_drives_present[i] != 0:
      # Build device name: hda, hdb, hdc, hdd
      var name: array[4, uint8]
      name[0] = cast[uint8](104)  # 'h'
      name[1] = cast[uint8](100)  # 'd'
      name[2] = cast[uint8](97 + i)  # 'a' + i
      name[3] = cast[uint8](0)
      discard blkdev_register(BLKDEV_TYPE_ATA, i, ata_drives_sectors[i], addr(name[0]))
    i = i + 1

  ser_print(cast[ptr uint8]("[BLKDEV] Total devices: "))
  ser_print_int(blkdev_count)
  ser_println(cast[ptr uint8](""))

# List all block devices
proc blkdev_list() =
  ser_println(cast[ptr uint8]("Block Devices:"))
  ser_println(cast[ptr uint8]("=============="))

  if blkdev_count == 0:
    ser_println(cast[ptr uint8]("  No block devices registered"))
    return

  var i: int32 = 0
  while i < blkdev_count:
    ser_print(cast[ptr uint8]("  "))
    ser_print(blkdev_get_name(i))
    ser_print(cast[ptr uint8](": "))

    var dev_type: int32 = blkdev_types[i]
    if dev_type == BLKDEV_TYPE_ATA:
      ser_print(cast[ptr uint8]("ATA"))
    elif dev_type == BLKDEV_TYPE_AHCI:
      ser_print(cast[ptr uint8]("AHCI"))
    elif dev_type == BLKDEV_TYPE_RAMDISK:
      ser_print(cast[ptr uint8]("RAM"))
    elif dev_type == BLKDEV_TYPE_NVME:
      ser_print(cast[ptr uint8]("NVMe"))
    else:
      ser_print(cast[ptr uint8]("???"))

    ser_print(cast[ptr uint8](" "))
    ser_print_int(blkdev_get_size_mb(i))
    ser_println(cast[ptr uint8](" MB"))

    i = i + 1

# Find block device by name
proc blkdev_find(name: ptr uint8): int32 =
  var i: int32 = 0
  while i < blkdev_count:
    # Compare names (16 bytes per entry)
    var dev_name: ptr uint8 = addr(blkdev_names[i * 16])
    if str_equals(dev_name, name) == 1:
      return i
    i = i + 1
  return -1

# =============================================================================
# Partition Table Support
# =============================================================================
# Parses MBR partition tables and registers partitions as block devices

const PART_MAX: int32 = 16
const PART_TYPE_EMPTY: int32 = 0x00
const PART_TYPE_FAT12: int32 = 0x01
const PART_TYPE_FAT16_SMALL: int32 = 0x04
const PART_TYPE_EXTENDED: int32 = 0x05
const PART_TYPE_FAT16: int32 = 0x06
const PART_TYPE_NTFS: int32 = 0x07
const PART_TYPE_FAT32: int32 = 0x0B
const PART_TYPE_FAT32_LBA: int32 = 0x0C
const PART_TYPE_FAT16_LBA: int32 = 0x0E
const PART_TYPE_EXTENDED_LBA: int32 = 0x0F
const PART_TYPE_LINUX: int32 = 0x83
const PART_TYPE_LINUX_SWAP: int32 = 0x82
const PART_TYPE_LINUX_LVM: int32 = 0x8E

# (Note: Partition arrays are declared earlier with blkdev layer)

# Sector buffer for reading MBR
var part_sector_buf: array[512, uint8]

# Read 16-bit little-endian value from buffer
proc read_le16(buf: ptr uint8, offset: int32): int32 =
  var lo: int32 = cast[int32](buf[offset])
  var hi: int32 = cast[int32](buf[offset + 1])
  return lo | (hi << 8)

# Read 32-bit little-endian value from buffer
proc read_le32(buf: ptr uint8, offset: int32): int32 =
  var b0: int32 = cast[int32](buf[offset])
  var b1: int32 = cast[int32](buf[offset + 1])
  var b2: int32 = cast[int32](buf[offset + 2])
  var b3: int32 = cast[int32](buf[offset + 3])
  return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

# Get partition type name
proc part_type_name(ptype: int32): ptr uint8 =
  if ptype == 0:
    return cast[ptr uint8]("Empty")
  if ptype == 1:
    return cast[ptr uint8]("FAT12")
  if ptype == 4:
    return cast[ptr uint8]("FAT16<32M")
  if ptype == 5:
    return cast[ptr uint8]("Extended")
  if ptype == 6:
    return cast[ptr uint8]("FAT16")
  if ptype == 7:
    return cast[ptr uint8]("NTFS")
  if ptype == 11:
    return cast[ptr uint8]("FAT32")
  if ptype == 12:
    return cast[ptr uint8]("FAT32 LBA")
  if ptype == 14:
    return cast[ptr uint8]("FAT16 LBA")
  if ptype == 15:
    return cast[ptr uint8]("Ext LBA")
  if ptype == 130:
    return cast[ptr uint8]("Swap")
  if ptype == 131:
    return cast[ptr uint8]("Linux")
  if ptype == 142:
    return cast[ptr uint8]("LVM")
  return cast[ptr uint8]("Unknown")

# Parse MBR partition table entry
# Entry is 16 bytes at offset 446 + (entry_num * 16)
# Returns: 1 if valid partition, 0 if empty
proc parse_mbr_entry(buf: ptr uint8, entry_num: int32, dev: int32): int32 =
  var entry_offset: int32 = 446 + (entry_num * 16)

  # Byte 0: Boot flag (0x80 = bootable, 0x00 = not)
  # Bytes 1-3: CHS start (ignored, use LBA)
  # Byte 4: Partition type
  var ptype: int32 = cast[int32](buf[entry_offset + 4])

  if ptype == PART_TYPE_EMPTY:
    return 0

  # Bytes 8-11: LBA start (little-endian)
  var lba_start: int32 = read_le32(buf, entry_offset + 8)

  # Bytes 12-15: Number of sectors (little-endian)
  var num_sectors: int32 = read_le32(buf, entry_offset + 12)

  if num_sectors == 0:
    return 0

  # Store partition info
  if part_count < PART_MAX:
    var idx: int32 = part_count
    part_parent_dev[idx] = dev
    part_start_lba[idx] = lba_start
    part_sectors[idx] = num_sectors
    part_type[idx] = ptype
    part_count = part_count + 1

    # Create partition name (e.g., "hdb1")
    var part_name: array[8, uint8]
    var parent_name: ptr uint8 = blkdev_get_name(dev)
    var i: int32 = 0
    while i < 6:
      var c: uint8 = parent_name[i]
      if c == cast[uint8](0):
        break
      part_name[i] = c
      i = i + 1
    # Add partition number (1-4)
    part_name[i] = cast[uint8](49 + entry_num)  # '1' + entry_num
    part_name[i + 1] = cast[uint8](0)

    # Register partition as block device
    discard blkdev_register(5, idx, num_sectors, addr(part_name[0]))  # 5 = BLKDEV_TYPE_PARTITION

    ser_print(cast[ptr uint8]("  Partition "))
    ser_print_int(entry_num + 1)
    ser_print(cast[ptr uint8](": "))
    ser_print(part_type_name(ptype))
    ser_print(cast[ptr uint8](" @ LBA "))
    ser_print_int(lba_start)
    ser_print(cast[ptr uint8](", "))
    ser_print_int(num_sectors / 2048)
    ser_println(cast[ptr uint8](" MB"))

    return 1

  return 0

# Scan a block device for MBR partitions
# Returns: number of partitions found
proc partition_scan(dev: int32): int32 =
  if dev < 0 or dev >= blkdev_count:
    return 0

  ser_print(cast[ptr uint8]("[PART] Scanning "))
  ser_print(blkdev_get_name(dev))
  ser_println(cast[ptr uint8](" for partitions..."))

  # Read sector 0 (MBR)
  var result: int32 = blkdev_read(dev, 0, 1, addr(part_sector_buf[0]))
  if result < 0:
    ser_println(cast[ptr uint8]("[PART] Failed to read MBR"))
    return 0

  # Check MBR signature (0x55AA at offset 510)
  var sig_lo: int32 = cast[int32](part_sector_buf[510])
  var sig_hi: int32 = cast[int32](part_sector_buf[511])
  if sig_lo != 0x55 or sig_hi != 0xAA:
    ser_println(cast[ptr uint8]("[PART] No MBR signature found"))
    return 0

  # Parse 4 primary partition entries
  var found: int32 = 0
  var i: int32 = 0
  while i < 4:
    found = found + parse_mbr_entry(addr(part_sector_buf[0]), i, dev)
    i = i + 1

  if found == 0:
    ser_println(cast[ptr uint8]("[PART] No partitions found"))

  return found

# Scan all block devices for partitions
# Only scan physical devices (ATA, AHCI, NVMe), not partitions
proc partition_scan_all(): int32 =
  var total: int32 = 0
  var num_devices: int32 = blkdev_count  # Capture count before adding partitions
  var i: int32 = 0
  while i < num_devices:
    # Skip partition devices - only scan physical drives
    var dev_type: int32 = blkdev_types[i]
    if dev_type != 5:  # 5 = BLKDEV_TYPE_PARTITION
      total = total + partition_scan(i)
    i = i + 1
  return total

# Get partition start LBA
proc partition_get_start(idx: int32): int32 =
  if idx < 0 or idx >= part_count:
    return 0
  return part_start_lba[idx]

# Get partition size in sectors
proc partition_get_sectors(idx: int32): int32 =
  if idx < 0 or idx >= part_count:
    return 0
  return part_sectors[idx]

# Get partition type
proc partition_get_type(idx: int32): int32 =
  if idx < 0 or idx >= part_count:
    return PART_TYPE_EMPTY
  return part_type[idx]

# Get parent device
proc partition_get_device(idx: int32): int32 =
  if idx < 0 or idx >= part_count:
    return -1
  return part_parent_dev[idx]

# Read sectors from a partition (LBA relative to partition start)
proc partition_read(idx: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if idx < 0 or idx >= part_count:
    return -1
  if lba < 0 or count <= 0:
    return -1
  if lba + count > part_sectors[idx]:
    return -1

  var dev: int32 = part_parent_dev[idx]
  var abs_lba: int32 = part_start_lba[idx] + lba
  return blkdev_read(dev, abs_lba, count, buf)

# Write sectors to a partition (LBA relative to partition start)
proc partition_write(idx: int32, lba: int32, count: int32, buf: ptr uint8): int32 =
  if idx < 0 or idx >= part_count:
    return -1
  if lba < 0 or count <= 0:
    return -1
  if lba + count > part_sectors[idx]:
    return -1

  var dev: int32 = part_parent_dev[idx]
  var abs_lba: int32 = part_start_lba[idx] + lba
  return blkdev_write(dev, abs_lba, count, buf)

# List all partitions
proc partition_list() =
  ser_println(cast[ptr uint8]("Partitions:"))
  ser_println(cast[ptr uint8]("==========="))

  if part_count == 0:
    ser_println(cast[ptr uint8]("  No partitions found"))
    return

  var i: int32 = 0
  while i < part_count:
    ser_print(cast[ptr uint8]("  "))
    ser_print(blkdev_get_name(part_parent_dev[i]))
    ser_print_int(i + 1)
    ser_print(cast[ptr uint8](": "))
    ser_print(part_type_name(part_type[i]))
    ser_print(cast[ptr uint8](" "))
    ser_print_int(part_sectors[i] / 2048)
    ser_println(cast[ptr uint8](" MB"))
    i = i + 1

# =============================================================================
# BrainFS - Persistent ext2-like Filesystem
# =============================================================================

# BrainFS uses 1KB blocks (2 sectors per block)
const BRFS_BLOCK_SIZE: int32 = 1024
const BRFS_SECTORS_PER_BLOCK: int32 = 2
const BRFS_MAGIC: int32 = 1112560962  # 0x42524653 = "BRFS" (little-endian: 0x53465242)
const BRFS_VERSION: int32 = 1
const BRFS_INODE_SIZE: int32 = 32
const BRFS_INODES_PER_BLOCK: int32 = 32  # 1024 / 32 = 32
const BRFS_ROOT_INODE: int32 = 1
const BRFS_MAX_MOUNTS: int32 = 4
const BRFS_DIRENTRY_SIZE: int32 = 32

# File types for mode field
const BRFS_S_IFREG: int32 = 32768   # 0x8000 - regular file
const BRFS_S_IFDIR: int32 = 16384   # 0x4000 - directory
const BRFS_S_IFLNK: int32 = 40960   # 0xA000 - symbolic link

# Mount table - tracks mounted BrainFS filesystems
var brfs_mount_dev: array[4, int32]         # Block device ID
var brfs_mount_active: array[4, int32]      # 1 if mounted
var brfs_mount_total_blocks: array[4, int32]
var brfs_mount_total_inodes: array[4, int32]
var brfs_mount_free_blocks: array[4, int32]
var brfs_mount_free_inodes: array[4, int32]
var brfs_mount_inode_bmp_start: array[4, int32]
var brfs_mount_block_bmp_start: array[4, int32]
var brfs_mount_inode_tbl_start: array[4, int32]
var brfs_mount_first_data_block: array[4, int32]

# Block buffer for disk I/O (1KB = 2 sectors)
var brfs_block_buf: array[1024, uint8]
var brfs_block_buf2: array[1024, uint8]  # Second buffer for operations needing two

# Initialize BrainFS mount table
proc brfs_init() =
  var i: int32 = 0
  while i < BRFS_MAX_MOUNTS:
    brfs_mount_dev[i] = -1
    brfs_mount_active[i] = 0
    i = i + 1

# Read a block from mounted filesystem
proc brfs_bread(mount_id: int32, blk: int32, buf: ptr uint8): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1
  var dev: int32 = brfs_mount_dev[mount_id]
  var lba: int32 = blk * BRFS_SECTORS_PER_BLOCK
  return blkdev_read(dev, lba, BRFS_SECTORS_PER_BLOCK, buf)

# Write a block to mounted filesystem
proc brfs_bwrite(mount_id: int32, blk: int32, buf: ptr uint8): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1
  var dev: int32 = brfs_mount_dev[mount_id]
  var lba: int32 = blk * BRFS_SECTORS_PER_BLOCK
  return blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, buf)

# Calculate filesystem layout for given size in sectors
# Returns: number of data blocks available
proc brfs_calc_layout(total_sectors: int32, out_inode_blocks: ptr int32, out_first_data: ptr int32): int32 =
  var total_blocks: int32 = total_sectors / BRFS_SECTORS_PER_BLOCK

  # Block 0: superblock
  # Block 1: inode bitmap (can track 8192 inodes with 1KB)
  # Block 2: block bitmap (can track 8192 blocks with 1KB)
  # Block 3+: inode table + data blocks

  # Calculate how many inodes we can have (1 inode per 4 data blocks is reasonable)
  var max_inodes: int32 = total_blocks / 4
  if max_inodes > 8192:
    max_inodes = 8192  # Max for 1 block bitmap
  if max_inodes < 64:
    max_inodes = 64  # Minimum

  # How many blocks for inode table?
  var inode_blocks: int32 = (max_inodes + BRFS_INODES_PER_BLOCK - 1) / BRFS_INODES_PER_BLOCK

  # First data block
  var first_data: int32 = 3 + inode_blocks

  out_inode_blocks[0] = inode_blocks
  out_first_data[0] = first_data

  return total_blocks - first_data

# Format a block device as BrainFS
proc brfs_mkfs(dev: int32): int32 =
  var sectors: int32 = blkdev_get_sectors(dev)
  if sectors < 32:  # Minimum 16KB
    ser_println(cast[ptr uint8]("[BRFS] Device too small"))
    return -1

  ser_print(cast[ptr uint8]("[BRFS] Formatting device "))
  ser_print_int(dev)
  ser_print(cast[ptr uint8](" ("))
  ser_print_int(sectors)
  ser_println(cast[ptr uint8](" sectors)"))

  var total_blocks: int32 = sectors / BRFS_SECTORS_PER_BLOCK
  var inode_blocks: int32 = 0
  var first_data: int32 = 0
  var data_blocks: int32 = brfs_calc_layout(sectors, addr(inode_blocks), addr(first_data))
  var total_inodes: int32 = inode_blocks * BRFS_INODES_PER_BLOCK

  ser_print(cast[ptr uint8]("[BRFS] Layout: "))
  ser_print_int(total_blocks)
  ser_print(cast[ptr uint8](" blocks, "))
  ser_print_int(total_inodes)
  ser_print(cast[ptr uint8](" inodes, "))
  ser_print_int(data_blocks)
  ser_println(cast[ptr uint8](" data blocks"))

  # Clear block buffer
  var i: int32 = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1

  # Write superblock (block 0)
  write32(addr(brfs_block_buf[0]), BRFS_MAGIC)      # Magic
  write32(addr(brfs_block_buf[4]), BRFS_VERSION)    # Version
  write32(addr(brfs_block_buf[8]), BRFS_BLOCK_SIZE) # Block size
  write32(addr(brfs_block_buf[12]), total_blocks)   # Total blocks
  write32(addr(brfs_block_buf[16]), total_inodes)   # Total inodes
  write32(addr(brfs_block_buf[20]), data_blocks - 1) # Free blocks (root dir uses 1)
  write32(addr(brfs_block_buf[24]), total_inodes - 1) # Free inodes (root uses 1)
  write32(addr(brfs_block_buf[28]), first_data)     # First data block
  write32(addr(brfs_block_buf[32]), 1)              # Inode bitmap at block 1
  write32(addr(brfs_block_buf[36]), 2)              # Block bitmap at block 2
  write32(addr(brfs_block_buf[40]), 3)              # Inode table at block 3
  write32(addr(brfs_block_buf[44]), BRFS_ROOT_INODE) # Root inode number

  var lba: int32 = 0
  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to write superblock"))
    return -1

  # Clear and write inode bitmap (block 1)
  i = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1
  # Mark inode 0 and 1 as used (0 is reserved, 1 is root)
  brfs_block_buf[0] = cast[uint8](3)  # Bits 0 and 1 set
  lba = BRFS_SECTORS_PER_BLOCK
  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to write inode bitmap"))
    return -1

  # Clear and write block bitmap (block 2)
  i = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1
  # Mark blocks 0 to first_data-1 as used (superblock, bitmaps, inode table)
  # Also mark first data block as used (for root directory)
  i = 0
  while i <= first_data:
    var byte_idx: int32 = i / 8
    var bit_idx: int32 = i & 7
    var byte_val: int32 = cast[int32](brfs_block_buf[byte_idx])
    brfs_block_buf[byte_idx] = cast[uint8](byte_val | (1 << bit_idx))
    i = i + 1
  lba = 2 * BRFS_SECTORS_PER_BLOCK
  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to write block bitmap"))
    return -1

  # Clear inode table blocks
  i = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1
  i = 0
  while i < inode_blocks:
    lba = (3 + i) * BRFS_SECTORS_PER_BLOCK
    if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
      ser_println(cast[ptr uint8]("[BRFS] Failed to clear inode table"))
      return -1
    i = i + 1

  # Create root inode (inode 1) - it's in the first inode table block (block 3)
  # Read block 3
  lba = 3 * BRFS_SECTORS_PER_BLOCK
  var read_result: int32 = blkdev_read(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0]))
  if read_result < 0:
    return -1

  # Root inode is at offset 0 (inode 1 is first, inode 0 doesn't exist)
  # Actually, inode 1 is at offset 0 in the table (inodes are 1-indexed)
  var root_offset: int32 = 0  # Inode 1 at offset 0
  write16(addr(brfs_block_buf[root_offset]), BRFS_S_IFDIR | 493)  # drwxr-xr-x (0755 + dir flag)
  write16(addr(brfs_block_buf[root_offset + 2]), 2)   # Link count (. and ..)
  write32(addr(brfs_block_buf[root_offset + 4]), 64)  # Size (2 entries * 32 bytes)
  write32(addr(brfs_block_buf[root_offset + 8]), 0)   # Created timestamp
  write32(addr(brfs_block_buf[root_offset + 12]), 0)  # Modified timestamp
  write32(addr(brfs_block_buf[root_offset + 16]), first_data)  # Block 0 = first data block
  write32(addr(brfs_block_buf[root_offset + 20]), 0)  # Block 1 = none
  write32(addr(brfs_block_buf[root_offset + 24]), 0)  # Block 2 = none
  write32(addr(brfs_block_buf[root_offset + 28]), 0)  # Indirect block = none

  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to write root inode"))
    return -1

  # Create root directory data block with . and .. entries
  i = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1

  # Entry 1: "." -> inode 1
  write32(addr(brfs_block_buf[0]), 1)     # Inode 1
  write16(addr(brfs_block_buf[4]), 32)    # Entry length
  brfs_block_buf[6] = cast[uint8](1)      # Name length
  brfs_block_buf[7] = cast[uint8](2)      # Type: directory
  brfs_block_buf[8] = cast[uint8](46)     # '.'

  # Entry 2: ".." -> inode 1 (parent of root is itself)
  write32(addr(brfs_block_buf[32]), 1)    # Inode 1
  write16(addr(brfs_block_buf[36]), 32)   # Entry length
  brfs_block_buf[38] = cast[uint8](2)     # Name length
  brfs_block_buf[39] = cast[uint8](2)     # Type: directory
  brfs_block_buf[40] = cast[uint8](46)    # '.'
  brfs_block_buf[41] = cast[uint8](46)    # '.'

  lba = first_data * BRFS_SECTORS_PER_BLOCK
  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to write root directory"))
    return -1

  ser_println(cast[ptr uint8]("[BRFS] Filesystem created successfully"))
  return 0

# Mount a BrainFS filesystem
proc brfs_mount(dev: int32): int32 =
  # Find free mount slot
  var mount_id: int32 = -1
  var i: int32 = 0
  while i < BRFS_MAX_MOUNTS:
    if brfs_mount_active[i] == 0:
      mount_id = i
      i = BRFS_MAX_MOUNTS  # break
    i = i + 1

  if mount_id < 0:
    ser_println(cast[ptr uint8]("[BRFS] No free mount slots"))
    return -1

  # Read superblock
  var lba: int32 = 0
  if blkdev_read(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    ser_println(cast[ptr uint8]("[BRFS] Failed to read superblock"))
    return -1

  # Verify magic
  var magic: int32 = read32(addr(brfs_block_buf[0]))
  if magic != BRFS_MAGIC:
    ser_print(cast[ptr uint8]("[BRFS] Bad magic: "))
    ser_print_hex(magic)
    ser_println(cast[ptr uint8](""))
    return -1

  # Read superblock fields
  brfs_mount_dev[mount_id] = dev
  brfs_mount_total_blocks[mount_id] = read32(addr(brfs_block_buf[12]))
  brfs_mount_total_inodes[mount_id] = read32(addr(brfs_block_buf[16]))
  brfs_mount_free_blocks[mount_id] = read32(addr(brfs_block_buf[20]))
  brfs_mount_free_inodes[mount_id] = read32(addr(brfs_block_buf[24]))
  brfs_mount_first_data_block[mount_id] = read32(addr(brfs_block_buf[28]))
  brfs_mount_inode_bmp_start[mount_id] = read32(addr(brfs_block_buf[32]))
  brfs_mount_block_bmp_start[mount_id] = read32(addr(brfs_block_buf[36]))
  brfs_mount_inode_tbl_start[mount_id] = read32(addr(brfs_block_buf[40]))
  brfs_mount_active[mount_id] = 1

  ser_print(cast[ptr uint8]("[BRFS] Mounted device "))
  ser_print_int(dev)
  ser_print(cast[ptr uint8](" as mount "))
  ser_print_int(mount_id)
  ser_print(cast[ptr uint8](" ("))
  ser_print_int(brfs_mount_total_blocks[mount_id])
  ser_print(cast[ptr uint8](" blocks, "))
  ser_print_int(brfs_mount_free_blocks[mount_id])
  ser_println(cast[ptr uint8](" free)"))

  return mount_id

# Unmount a BrainFS filesystem
proc brfs_unmount(mount_id: int32): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1

  # Sync superblock with updated free counts
  var dev: int32 = brfs_mount_dev[mount_id]
  var lba: int32 = 0
  if blkdev_read(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    return -1

  write32(addr(brfs_block_buf[20]), brfs_mount_free_blocks[mount_id])
  write32(addr(brfs_block_buf[24]), brfs_mount_free_inodes[mount_id])

  if blkdev_write(dev, lba, BRFS_SECTORS_PER_BLOCK, addr(brfs_block_buf[0])) < 0:
    return -1

  brfs_mount_active[mount_id] = 0
  brfs_mount_dev[mount_id] = -1

  ser_print(cast[ptr uint8]("[BRFS] Unmounted mount "))
  ser_print_int(mount_id)
  ser_println(cast[ptr uint8](""))

  return 0

# Read an inode from disk
proc brfs_iget(mount_id: int32, ino: int32, buf: ptr uint8): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1
  if ino < 1 or ino > brfs_mount_total_inodes[mount_id]:
    return -1

  # Calculate which block the inode is in
  var inode_idx: int32 = ino - 1  # Inodes are 1-indexed
  var block_in_table: int32 = inode_idx / BRFS_INODES_PER_BLOCK
  var offset_in_block: int32 = (inode_idx & 31) * BRFS_INODE_SIZE  # & 31 = % 32
  var block_num: int32 = brfs_mount_inode_tbl_start[mount_id] + block_in_table

  if brfs_bread(mount_id, block_num, addr(brfs_block_buf[0])) < 0:
    return -1

  # Copy inode to output buffer
  var i: int32 = 0
  while i < BRFS_INODE_SIZE:
    buf[i] = brfs_block_buf[offset_in_block + i]
    i = i + 1

  return 0

# Write an inode to disk
proc brfs_iput(mount_id: int32, ino: int32, buf: ptr uint8): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1
  if ino < 1 or ino > brfs_mount_total_inodes[mount_id]:
    return -1

  var inode_idx: int32 = ino - 1
  var block_in_table: int32 = inode_idx / BRFS_INODES_PER_BLOCK
  var offset_in_block: int32 = (inode_idx & 31) * BRFS_INODE_SIZE
  var block_num: int32 = brfs_mount_inode_tbl_start[mount_id] + block_in_table

  # Read the block first
  if brfs_bread(mount_id, block_num, addr(brfs_block_buf[0])) < 0:
    return -1

  # Copy inode data
  var i: int32 = 0
  while i < BRFS_INODE_SIZE:
    brfs_block_buf[offset_in_block + i] = buf[i]
    i = i + 1

  # Write back
  return brfs_bwrite(mount_id, block_num, addr(brfs_block_buf[0]))

# Allocate a new inode
proc brfs_ialloc(mount_id: int32): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_active[mount_id] == 0:
    return -1
  if brfs_mount_free_inodes[mount_id] <= 0:
    return -1

  # Read inode bitmap
  var bmp_block: int32 = brfs_mount_inode_bmp_start[mount_id]
  if brfs_bread(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  # Find first free bit (starting from bit 1, since 0 is reserved)
  var i: int32 = 1
  var max_inodes: int32 = brfs_mount_total_inodes[mount_id]
  while i <= max_inodes:
    var byte_idx: int32 = i / 8
    var bit_idx: int32 = i & 7
    var byte_val: int32 = cast[int32](brfs_block_buf[byte_idx])
    if (byte_val & (1 << bit_idx)) == 0:
      # Found free inode - mark as used
      brfs_block_buf[byte_idx] = cast[uint8](byte_val | (1 << bit_idx))
      if brfs_bwrite(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
        return -1
      brfs_mount_free_inodes[mount_id] = brfs_mount_free_inodes[mount_id] - 1
      return i
    i = i + 1

  return -1

# Free an inode
proc brfs_ifree(mount_id: int32, ino: int32): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if ino < 1 or ino > brfs_mount_total_inodes[mount_id]:
    return -1

  var bmp_block: int32 = brfs_mount_inode_bmp_start[mount_id]
  if brfs_bread(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  var byte_idx: int32 = ino / 8
  var bit_idx: int32 = ino & 7
  var byte_val: int32 = cast[int32](brfs_block_buf[byte_idx])
  var mask: int32 = 255 - (1 << bit_idx)
  brfs_block_buf[byte_idx] = cast[uint8](byte_val & mask)

  if brfs_bwrite(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  brfs_mount_free_inodes[mount_id] = brfs_mount_free_inodes[mount_id] + 1
  return 0

# Allocate a data block
proc brfs_balloc(mount_id: int32): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if brfs_mount_free_blocks[mount_id] <= 0:
    return -1

  var bmp_block: int32 = brfs_mount_block_bmp_start[mount_id]
  if brfs_bread(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  var first_data: int32 = brfs_mount_first_data_block[mount_id]
  var total_blocks: int32 = brfs_mount_total_blocks[mount_id]
  var i: int32 = first_data
  while i < total_blocks:
    var byte_idx: int32 = i / 8
    var bit_idx: int32 = i & 7
    var byte_val: int32 = cast[int32](brfs_block_buf[byte_idx])
    if (byte_val & (1 << bit_idx)) == 0:
      brfs_block_buf[byte_idx] = cast[uint8](byte_val | (1 << bit_idx))
      if brfs_bwrite(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
        return -1
      brfs_mount_free_blocks[mount_id] = brfs_mount_free_blocks[mount_id] - 1
      return i
    i = i + 1

  return -1

# Free a data block
proc brfs_bfree(mount_id: int32, blk: int32): int32 =
  if mount_id < 0 or mount_id >= BRFS_MAX_MOUNTS:
    return -1
  if blk < brfs_mount_first_data_block[mount_id] or blk >= brfs_mount_total_blocks[mount_id]:
    return -1

  var bmp_block: int32 = brfs_mount_block_bmp_start[mount_id]
  if brfs_bread(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  var byte_idx: int32 = blk / 8
  var bit_idx: int32 = blk & 7
  var byte_val: int32 = cast[int32](brfs_block_buf[byte_idx])
  var mask: int32 = 255 - (1 << bit_idx)
  brfs_block_buf[byte_idx] = cast[uint8](byte_val & mask)

  if brfs_bwrite(mount_id, bmp_block, addr(brfs_block_buf[0])) < 0:
    return -1

  brfs_mount_free_blocks[mount_id] = brfs_mount_free_blocks[mount_id] + 1
  return 0

# Lookup a name in a directory, returns inode number or -1
proc brfs_lookup(mount_id: int32, dir_ino: int32, name: ptr uint8): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, dir_ino, addr(inode_buf[0])) < 0:
    return -1

  var mode: int32 = read16(addr(inode_buf[0]))
  if (mode & 61440) != BRFS_S_IFDIR:  # 61440 = 0xF000 mask
    return -1  # Not a directory

  var size: int32 = read32(addr(inode_buf[4]))
  var name_len: int32 = fs_strlen(name)

  # Read each data block of directory
  var blk_idx: int32 = 0
  while blk_idx < 3:
    var blk: int32 = read32(addr(inode_buf[16 + blk_idx * 4]))
    if blk == 0:
      blk_idx = blk_idx + 1
      continue

    if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      return -1

    # Scan directory entries
    var offset: int32 = 0
    while offset < BRFS_BLOCK_SIZE:
      var entry_ino: int32 = read32(addr(brfs_block_buf2[offset]))
      if entry_ino == 0:
        offset = offset + BRFS_DIRENTRY_SIZE
        continue

      var entry_name_len: int32 = cast[int32](brfs_block_buf2[offset + 6])
      if entry_name_len == name_len:
        # Compare names
        var is_match: int32 = 1
        var j: int32 = 0
        while j < name_len:
          if brfs_block_buf2[offset + 8 + j] != name[j]:
            is_match = 0
            j = name_len
          j = j + 1
        if is_match == 1:
          return entry_ino
      offset = offset + BRFS_DIRENTRY_SIZE
    blk_idx = blk_idx + 1

  # TODO: Handle indirect block for large directories

  return -1

# Read directory entries
# Returns next offset, or -1 if done
proc brfs_readdir(mount_id: int32, dir_ino: int32, offset: int32, out_ino: ptr int32, out_name: ptr uint8, out_type: ptr int32): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, dir_ino, addr(inode_buf[0])) < 0:
    return -1

  var size: int32 = read32(addr(inode_buf[4]))

  # Calculate which block and offset within block
  var entries_per_block: int32 = BRFS_BLOCK_SIZE / BRFS_DIRENTRY_SIZE
  var entry_num: int32 = offset / BRFS_DIRENTRY_SIZE
  var blk_idx: int32 = entry_num / entries_per_block
  var entry_in_block: int32 = entry_num - (blk_idx * entries_per_block)

  while blk_idx < 3:
    var blk: int32 = read32(addr(inode_buf[16 + blk_idx * 4]))
    if blk == 0:
      blk_idx = blk_idx + 1
      entry_in_block = 0
      continue

    if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      return -1

    while entry_in_block < entries_per_block:
      var off: int32 = entry_in_block * BRFS_DIRENTRY_SIZE
      var entry_ino: int32 = read32(addr(brfs_block_buf2[off]))

      if entry_ino != 0:
        out_ino[0] = entry_ino
        out_type[0] = cast[int32](brfs_block_buf2[off + 7])
        var name_len: int32 = cast[int32](brfs_block_buf2[off + 6])
        var j: int32 = 0
        while j < name_len:
          out_name[j] = brfs_block_buf2[off + 8 + j]
          j = j + 1
        out_name[name_len] = cast[uint8](0)
        return (blk_idx * entries_per_block + entry_in_block + 1) * BRFS_DIRENTRY_SIZE

      entry_in_block = entry_in_block + 1

    blk_idx = blk_idx + 1
    entry_in_block = 0

  return -1

# Add an entry to a directory
proc brfs_add_direntry(mount_id: int32, dir_ino: int32, name: ptr uint8, new_ino: int32, ftype: int32): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, dir_ino, addr(inode_buf[0])) < 0:
    return -1

  var name_len: int32 = fs_strlen(name)
  if name_len > 24:
    name_len = 24

  # Find first free slot in directory
  var blk_idx: int32 = 0
  while blk_idx < 3:
    var blk: int32 = read32(addr(inode_buf[16 + blk_idx * 4]))
    if blk == 0:
      # Need to allocate a new block
      blk = brfs_balloc(mount_id)
      if blk < 0:
        return -1
      # Clear the new block
      var k: int32 = 0
      while k < BRFS_BLOCK_SIZE:
        brfs_block_buf2[k] = cast[uint8](0)
        k = k + 1
      if brfs_bwrite(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
        discard brfs_bfree(mount_id, blk)
        return -1
      # Update inode
      write32(addr(inode_buf[16 + blk_idx * 4]), blk)
      if brfs_iput(mount_id, dir_ino, addr(inode_buf[0])) < 0:
        discard brfs_bfree(mount_id, blk)
        return -1

    if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      return -1

    var offset: int32 = 0
    while offset < BRFS_BLOCK_SIZE:
      var entry_ino: int32 = read32(addr(brfs_block_buf2[offset]))
      if entry_ino == 0:
        # Found free slot
        write32(addr(brfs_block_buf2[offset]), new_ino)
        write16(addr(brfs_block_buf2[offset + 4]), BRFS_DIRENTRY_SIZE)
        brfs_block_buf2[offset + 6] = cast[uint8](name_len)
        brfs_block_buf2[offset + 7] = cast[uint8](ftype)
        var j: int32 = 0
        while j < name_len:
          brfs_block_buf2[offset + 8 + j] = name[j]
          j = j + 1
        while j < 24:
          brfs_block_buf2[offset + 8 + j] = cast[uint8](0)
          j = j + 1
        if brfs_bwrite(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
          return -1
        # Update directory size
        var old_size: int32 = read32(addr(inode_buf[4]))
        var new_offset: int32 = blk_idx * BRFS_BLOCK_SIZE + offset + BRFS_DIRENTRY_SIZE
        if new_offset > old_size:
          write32(addr(inode_buf[4]), new_offset)
          discard brfs_iput(mount_id, dir_ino, addr(inode_buf[0]))
        return 0
      offset = offset + BRFS_DIRENTRY_SIZE
    blk_idx = blk_idx + 1

  return -1  # Directory full

# Create a file in a directory
proc brfs_create(mount_id: int32, dir_ino: int32, name: ptr uint8): int32 =
  # Check if name already exists
  if brfs_lookup(mount_id, dir_ino, name) > 0:
    return -1  # Already exists

  # Allocate new inode
  var new_ino: int32 = brfs_ialloc(mount_id)
  if new_ino < 0:
    return -1

  # Initialize inode
  var inode_buf: array[32, uint8]
  var i: int32 = 0
  while i < 32:
    inode_buf[i] = cast[uint8](0)
    i = i + 1
  write16(addr(inode_buf[0]), BRFS_S_IFREG | 420)  # -rw-r--r-- (0644)
  write16(addr(inode_buf[2]), 1)  # Link count

  if brfs_iput(mount_id, new_ino, addr(inode_buf[0])) < 0:
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Add directory entry
  if brfs_add_direntry(mount_id, dir_ino, name, new_ino, 1) < 0:
    discard brfs_ifree(mount_id, new_ino)
    return -1

  return new_ino

# Create a directory
proc brfs_mkdir(mount_id: int32, parent_ino: int32, name: ptr uint8): int32 =
  # Check if name already exists
  if brfs_lookup(mount_id, parent_ino, name) > 0:
    return -1

  # Allocate new inode
  var new_ino: int32 = brfs_ialloc(mount_id)
  if new_ino < 0:
    return -1

  # Allocate block for directory data
  var blk: int32 = brfs_balloc(mount_id)
  if blk < 0:
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Initialize directory block with . and ..
  var i: int32 = 0
  while i < BRFS_BLOCK_SIZE:
    brfs_block_buf2[i] = cast[uint8](0)
    i = i + 1

  # Entry for "."
  write32(addr(brfs_block_buf2[0]), new_ino)
  write16(addr(brfs_block_buf2[4]), 32)
  brfs_block_buf2[6] = cast[uint8](1)
  brfs_block_buf2[7] = cast[uint8](2)  # Directory type
  brfs_block_buf2[8] = cast[uint8](46)  # '.'

  # Entry for ".."
  write32(addr(brfs_block_buf2[32]), parent_ino)
  write16(addr(brfs_block_buf2[36]), 32)
  brfs_block_buf2[38] = cast[uint8](2)
  brfs_block_buf2[39] = cast[uint8](2)
  brfs_block_buf2[40] = cast[uint8](46)
  brfs_block_buf2[41] = cast[uint8](46)

  if brfs_bwrite(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Initialize inode
  var inode_buf: array[32, uint8]
  i = 0
  while i < 32:
    inode_buf[i] = cast[uint8](0)
    i = i + 1
  write16(addr(inode_buf[0]), BRFS_S_IFDIR | 493)  # drwxr-xr-x (0755)
  write16(addr(inode_buf[2]), 2)  # Link count (. and ..)
  write32(addr(inode_buf[4]), 64)  # Size (2 entries)
  write32(addr(inode_buf[16]), blk)  # First block

  if brfs_iput(mount_id, new_ino, addr(inode_buf[0])) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Add entry in parent directory
  if brfs_add_direntry(mount_id, parent_ino, name, new_ino, 2) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Update parent link count
  var parent_buf: array[32, uint8]
  if brfs_iget(mount_id, parent_ino, addr(parent_buf[0])) == 0:
    var links: int32 = read16(addr(parent_buf[2]))
    write16(addr(parent_buf[2]), links + 1)
    discard brfs_iput(mount_id, parent_ino, addr(parent_buf[0]))

  return new_ino

# Create a symbolic link
proc brfs_symlink(mount_id: int32, dir_ino: int32, name: ptr uint8, target: ptr uint8): int32 =
  # Check if name already exists
  if brfs_lookup(mount_id, dir_ino, name) > 0:
    return -1

  # Allocate new inode for symlink
  var new_ino: int32 = brfs_ialloc(mount_id)
  if new_ino < 0:
    return -1

  # Allocate block for symlink target
  var blk: int32 = brfs_balloc(mount_id)
  if blk < 0:
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Calculate target length
  var target_len: int32 = 0
  while target[target_len] != cast[uint8](0):
    target_len = target_len + 1
  if target_len > 1023:
    target_len = 1023

  # Write target to block
  var i: int32 = 0
  while i < 1024:
    brfs_block_buf[i] = cast[uint8](0)
    i = i + 1
  i = 0
  while i < target_len:
    brfs_block_buf[i] = target[i]
    i = i + 1

  if brfs_bwrite(mount_id, blk, addr(brfs_block_buf[0])) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Initialize symlink inode
  var inode_buf: array[32, uint8]
  i = 0
  while i < 32:
    inode_buf[i] = cast[uint8](0)
    i = i + 1
  write16(addr(inode_buf[0]), BRFS_S_IFLNK | 511)  # lrwxrwxrwx (0777)
  write16(addr(inode_buf[2]), 1)  # Link count
  write32(addr(inode_buf[4]), target_len)  # Size = target length
  write32(addr(inode_buf[16]), blk)  # First data block

  if brfs_iput(mount_id, new_ino, addr(inode_buf[0])) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  # Add directory entry (type 3 = symlink)
  if brfs_add_direntry(mount_id, dir_ino, name, new_ino, 3) < 0:
    discard brfs_bfree(mount_id, blk)
    discard brfs_ifree(mount_id, new_ino)
    return -1

  return new_ino

# Read symbolic link target
proc brfs_readlink(mount_id: int32, ino: int32, buf: ptr uint8, bufsize: int32): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, ino, addr(inode_buf[0])) < 0:
    return -1

  # Check if this is a symlink
  var mode: int32 = read16(addr(inode_buf[0]))
  if (mode & 61440) != BRFS_S_IFLNK:  # 0xF000 mask
    return -1  # Not a symlink

  var size: int32 = read32(addr(inode_buf[4]))
  if size == 0:
    return 0

  var blk: int32 = read32(addr(inode_buf[16]))
  if blk == 0:
    return -1

  if brfs_bread(mount_id, blk, addr(brfs_block_buf[0])) < 0:
    return -1

  var to_copy: int32 = size
  if to_copy >= bufsize:
    to_copy = bufsize - 1

  var i: int32 = 0
  while i < to_copy:
    buf[i] = brfs_block_buf[i]
    i = i + 1
  buf[to_copy] = cast[uint8](0)

  return to_copy

# Create a hard link
proc brfs_link(mount_id: int32, dir_ino: int32, name: ptr uint8, target_ino: int32): int32 =
  # Check if name already exists
  if brfs_lookup(mount_id, dir_ino, name) > 0:
    return -1

  # Get target inode
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, target_ino, addr(inode_buf[0])) < 0:
    return -1

  # Check it's a regular file (not directory or symlink)
  var mode: int32 = read16(addr(inode_buf[0]))
  if (mode & 61440) == BRFS_S_IFDIR:  # Cannot hardlink directories
    return -1

  # Increment link count
  var nlinks: int32 = read16(addr(inode_buf[2]))
  nlinks = nlinks + 1
  write16(addr(inode_buf[2]), nlinks)

  if brfs_iput(mount_id, target_ino, addr(inode_buf[0])) < 0:
    return -1

  # Determine file type for directory entry
  var ftype: int32 = 1  # Regular file
  if (mode & 61440) == BRFS_S_IFLNK:
    ftype = 3  # Symlink

  # Add directory entry pointing to same inode
  if brfs_add_direntry(mount_id, dir_ino, name, target_ino, ftype) < 0:
    # Rollback link count
    discard brfs_iget(mount_id, target_ino, addr(inode_buf[0]))
    nlinks = read16(addr(inode_buf[2])) - 1
    write16(addr(inode_buf[2]), nlinks)
    discard brfs_iput(mount_id, target_ino, addr(inode_buf[0]))
    return -1

  return 0

# Unlink (remove) a file or symlink from a directory
# Decrements link count; frees inode and data blocks when count reaches 0
proc brfs_unlink(mount_id: int32, dir_ino: int32, name: ptr uint8): int32 =
  # Look up the file to get its inode
  var target_ino: int32 = brfs_lookup(mount_id, dir_ino, name)
  if target_ino <= 0:
    return -1  # File not found

  # Get target inode info
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, target_ino, addr(inode_buf[0])) < 0:
    return -1

  # Check it's not a directory
  var mode: int32 = read16(addr(inode_buf[0]))
  if (mode & 61440) == BRFS_S_IFDIR:
    return -1  # Cannot unlink directories (use rmdir)

  # Find and remove directory entry
  var dir_buf: array[32, uint8]
  if brfs_iget(mount_id, dir_ino, addr(dir_buf[0])) < 0:
    return -1

  var name_len: int32 = fs_strlen(name)
  var found: int32 = 0
  var blk_idx: int32 = 0

  while blk_idx < 3 and found == 0:
    var blk: int32 = read32(addr(dir_buf[16 + blk_idx * 4]))
    if blk == 0:
      blk_idx = blk_idx + 1
      continue

    if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      return -1

    var offset: int32 = 0
    while offset < BRFS_BLOCK_SIZE:
      var entry_ino: int32 = read32(addr(brfs_block_buf2[offset]))
      if entry_ino == target_ino:
        var entry_name_len: int32 = cast[int32](brfs_block_buf2[offset + 6])
        if entry_name_len == name_len:
          # Compare names
          var is_match: int32 = 1
          var j: int32 = 0
          while j < name_len:
            if brfs_block_buf2[offset + 8 + j] != name[j]:
              is_match = 0
            j = j + 1
          if is_match == 1:
            # Clear directory entry
            write32(addr(brfs_block_buf2[offset]), 0)
            if brfs_bwrite(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
              return -1
            found = 1
      offset = offset + BRFS_DIRENTRY_SIZE
    blk_idx = blk_idx + 1

  if found == 0:
    return -1  # Entry not found

  # Decrement link count
  var nlinks: int32 = read16(addr(inode_buf[2]))
  nlinks = nlinks - 1

  if nlinks > 0:
    # Still has links, just update link count
    write16(addr(inode_buf[2]), nlinks)
    discard brfs_iput(mount_id, target_ino, addr(inode_buf[0]))
  else:
    # No more links, free blocks and inode
    var bi: int32 = 0
    while bi < 3:
      var blk: int32 = read32(addr(inode_buf[16 + bi * 4]))
      if blk != 0:
        discard brfs_bfree(mount_id, blk)
      bi = bi + 1
    discard brfs_ifree(mount_id, target_ino)

  return 0

# Read file data
proc brfs_read_file(mount_id: int32, ino: int32, offset: int32, buf: ptr uint8, len: int32): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, ino, addr(inode_buf[0])) < 0:
    return -1

  var size: int32 = read32(addr(inode_buf[4]))
  if offset >= size:
    return 0

  var to_read: int32 = len
  if offset + to_read > size:
    to_read = size - offset

  var bytes_read: int32 = 0
  while bytes_read < to_read:
    var file_offset: int32 = offset + bytes_read
    var blk_idx: int32 = file_offset / BRFS_BLOCK_SIZE
    var off_in_block: int32 = file_offset - (blk_idx * BRFS_BLOCK_SIZE)

    if blk_idx >= 3:
      break  # TODO: Handle indirect blocks

    var blk: int32 = read32(addr(inode_buf[16 + blk_idx * 4]))
    if blk == 0:
      break

    if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      return -1

    var chunk: int32 = BRFS_BLOCK_SIZE - off_in_block
    if chunk > to_read - bytes_read:
      chunk = to_read - bytes_read

    var j: int32 = 0
    while j < chunk:
      buf[bytes_read + j] = brfs_block_buf2[off_in_block + j]
      j = j + 1

    bytes_read = bytes_read + chunk

  return bytes_read

# Write file data
proc brfs_write_file(mount_id: int32, ino: int32, offset: int32, buf: ptr uint8, len: int32): int32 =
  var inode_buf: array[32, uint8]
  if brfs_iget(mount_id, ino, addr(inode_buf[0])) < 0:
    return -1

  var bytes_written: int32 = 0
  while bytes_written < len:
    var file_offset: int32 = offset + bytes_written
    var blk_idx: int32 = file_offset / BRFS_BLOCK_SIZE
    var off_in_block: int32 = file_offset - (blk_idx * BRFS_BLOCK_SIZE)

    if blk_idx >= 3:
      break  # TODO: Handle indirect blocks

    var blk: int32 = read32(addr(inode_buf[16 + blk_idx * 4]))
    if blk == 0:
      # Allocate new block
      blk = brfs_balloc(mount_id)
      if blk < 0:
        break
      # Clear the block
      var k: int32 = 0
      while k < BRFS_BLOCK_SIZE:
        brfs_block_buf2[k] = cast[uint8](0)
        k = k + 1
      write32(addr(inode_buf[16 + blk_idx * 4]), blk)
    else:
      if brfs_bread(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
        break

    var chunk: int32 = BRFS_BLOCK_SIZE - off_in_block
    if chunk > len - bytes_written:
      chunk = len - bytes_written

    var j: int32 = 0
    while j < chunk:
      brfs_block_buf2[off_in_block + j] = buf[bytes_written + j]
      j = j + 1

    if brfs_bwrite(mount_id, blk, addr(brfs_block_buf2[0])) < 0:
      break

    bytes_written = bytes_written + chunk

  # Update size if needed
  var old_size: int32 = read32(addr(inode_buf[4]))
  if offset + bytes_written > old_size:
    write32(addr(inode_buf[4]), offset + bytes_written)

  if brfs_iput(mount_id, ino, addr(inode_buf[0])) < 0:
    return -1

  return bytes_written

# Global active mount for shell commands
var brfs_active_mount: int32 = -1

# Try to auto-mount or auto-format BrainFS partitions
# Returns: mount_id or -1 if failed
# IMPORTANT: Never format device 0 (boot disk) - it contains the bootloader!
proc brfs_auto_mount(): int32 =
  ser_println(cast[ptr uint8]("[BRFS] Auto-detecting filesystems..."))

  # First pass: try to mount existing BrainFS on secondary devices/partitions
  var i: int32 = 1  # Start from 1 to skip boot disk
  while i < blkdev_count:
    var dev_type: int32 = blkdev_get_type(i)

    # Only consider partitions (type 5) or full disks (type 1)
    if dev_type == 5 or dev_type == 1:
      var sectors: int32 = blkdev_get_sectors(i)
      # Need at least 64KB for a useful filesystem
      if sectors >= 128:
        ser_print(cast[ptr uint8]("[BRFS] Trying "))
        ser_print(blkdev_get_name(i))
        ser_println(cast[ptr uint8]("..."))

        var mount_id: int32 = brfs_mount(i)
        if mount_id >= 0:
          ser_print(cast[ptr uint8]("[BRFS] Mounted "))
          ser_print(blkdev_get_name(i))
          ser_println(cast[ptr uint8](" as root filesystem"))
          return mount_id
    i = i + 1

  # Second pass: no BrainFS found, try to format a suitable partition (not boot disk)
  ser_println(cast[ptr uint8]("[BRFS] No existing filesystem found"))
  ser_println(cast[ptr uint8]("[BRFS] Looking for partition to format..."))

  i = 1  # Skip device 0 (boot disk with bootloader)
  while i < blkdev_count:
    var dev_type: int32 = blkdev_get_type(i)

    # Prefer partitions over raw disks
    if dev_type == 5:
      var sectors: int32 = blkdev_get_sectors(i)
      # Need at least 1MB for a useful filesystem
      if sectors >= 2048:
        ser_print(cast[ptr uint8]("[BRFS] Formatting "))
        ser_print(blkdev_get_name(i))
        ser_println(cast[ptr uint8]("..."))

        if brfs_mkfs(i) == 0:
          var mount_id: int32 = brfs_mount(i)
          if mount_id >= 0:
            ser_print(cast[ptr uint8]("[BRFS] Created and mounted new filesystem on "))
            ser_print(blkdev_get_name(i))
            ser_println(cast[ptr uint8](""))
            return mount_id
    i = i + 1

  # Third pass: no partitions, try secondary raw disks (never device 0!)
  i = 1  # Start from 1 to protect boot disk
  while i < blkdev_count:
    var dev_type: int32 = blkdev_get_type(i)

    if dev_type == 1:
      var sectors: int32 = blkdev_get_sectors(i)
      if sectors >= 2048:
        ser_print(cast[ptr uint8]("[BRFS] Formatting secondary disk "))
        ser_print(blkdev_get_name(i))
        ser_println(cast[ptr uint8]("..."))

        if brfs_mkfs(i) == 0:
          var mount_id: int32 = brfs_mount(i)
          if mount_id >= 0:
            ser_print(cast[ptr uint8]("[BRFS] Created filesystem on secondary disk "))
            ser_print(blkdev_get_name(i))
            ser_println(cast[ptr uint8](""))
            return mount_id
    i = i + 1

  ser_println(cast[ptr uint8]("[BRFS] No secondary disk found for filesystem"))
  ser_println(cast[ptr uint8]("[BRFS] Add a second disk with: qemu ... -hdb data.img"))
  return -1

# =============================================================================
# TmpFS - In-memory temporary filesystem
# =============================================================================

const TMPFS_DEFAULT_SIZE: int32 = 1048576  # 1MB default
const TMPFS_MAX_INODES: int32 = 64
const TMPFS_MAX_NAME: int32 = 32
const TMPFS_MAX_FILESIZE: int32 = 65536  # 64KB max per file

# Inode types
const TMPFS_TYPE_UNUSED: int32 = 0
const TMPFS_TYPE_FILE: int32 = 1
const TMPFS_TYPE_DIR: int32 = 2

# TmpFS state
var tmpfs_active_mount: int32 = -1
var tmpfs_mounted: int32 = 0

# Inode table - stored as parallel arrays
var tmpfs_inode_type: array[64, int32]    # Type (unused/file/dir)
var tmpfs_inode_parent: array[64, int32]  # Parent inode
var tmpfs_inode_size: array[64, int32]    # Size (files only)
var tmpfs_inode_data: array[64, int32]    # Pointer to data
var tmpfs_inode_names: array[2048, uint8] # Name storage (64 * 32)

# Simple string compare
proc tmpfs_strcmp(a: ptr uint8, b: ptr uint8): int32 =
  var i: int32 = 0
  while a[i] != cast[uint8](0) and b[i] != cast[uint8](0):
    if a[i] != b[i]:
      return 1
    i = i + 1
  if a[i] != b[i]:
    return 1
  return 0

# Get name for inode
proc tmpfs_get_name(ino: int32): ptr uint8 =
  var offset: int32 = ino * TMPFS_MAX_NAME
  return addr(tmpfs_inode_names[offset])

# Set name for inode
proc tmpfs_set_name(ino: int32, name: ptr uint8) =
  var offset: int32 = ino * TMPFS_MAX_NAME
  var i: int32 = 0
  while name[i] != cast[uint8](0) and i < TMPFS_MAX_NAME - 1:
    tmpfs_inode_names[offset + i] = name[i]
    i = i + 1
  tmpfs_inode_names[offset + i] = cast[uint8](0)

# Create tmpfs filesystem
proc tmpfs_mkfs(max_size: int32): int32 =
  discard max_size
  if tmpfs_mounted != 0:
    return -1  # Already mounted

  # Initialize all inodes as unused
  var i: int32 = 0
  while i < TMPFS_MAX_INODES:
    tmpfs_inode_type[i] = TMPFS_TYPE_UNUSED
    tmpfs_inode_parent[i] = -1
    tmpfs_inode_size[i] = 0
    tmpfs_inode_data[i] = 0
    i = i + 1

  # Create root directory as inode 0
  tmpfs_inode_type[0] = TMPFS_TYPE_DIR
  tmpfs_inode_parent[0] = 0
  tmpfs_set_name(0, cast[ptr uint8]("/"))

  tmpfs_mounted = 1
  return 0  # Return mount ID 0

# Unmount tmpfs
proc tmpfs_unmount(mount_id: int32): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  tmpfs_mounted = 0
  return 0

# Read directory entries
# Returns number of entries written to buffer
proc tmpfs_readdir(mount_id: int32, dir_ino: int32, buf: ptr uint8, max_entries: int32): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  if dir_ino < 0 or dir_ino >= TMPFS_MAX_INODES:
    return -1
  if tmpfs_inode_type[dir_ino] != TMPFS_TYPE_DIR:
    return -1

  var count: int32 = 0
  var buf_pos: int32 = 0
  var i: int32 = 0

  while i < TMPFS_MAX_INODES and count < max_entries:
    if tmpfs_inode_type[i] != TMPFS_TYPE_UNUSED and tmpfs_inode_parent[i] == dir_ino and i != dir_ino:
      # Copy name to buffer
      var name: ptr uint8 = tmpfs_get_name(i)
      var j: int32 = 0
      while name[j] != cast[uint8](0) and j < 31:
        buf[buf_pos] = name[j]
        buf_pos = buf_pos + 1
        j = j + 1
      buf[buf_pos] = cast[uint8](0)
      buf_pos = buf_pos + 1
      count = count + 1
    i = i + 1

  return count

# Allocate a new inode
proc tmpfs_alloc_inode(): int32 =
  var i: int32 = 1  # Skip root
  while i < TMPFS_MAX_INODES:
    if tmpfs_inode_type[i] == TMPFS_TYPE_UNUSED:
      return i
    i = i + 1
  return -1  # No free inodes

# Create file or directory
proc tmpfs_create(mount_id: int32, dir_ino: int32, name: ptr uint8, is_dir: int32): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  if dir_ino < 0 or dir_ino >= TMPFS_MAX_INODES:
    return -1
  if tmpfs_inode_type[dir_ino] != TMPFS_TYPE_DIR:
    return -1

  # Check if already exists
  if tmpfs_lookup(mount_id, dir_ino, name) >= 0:
    return -1

  var new_ino: int32 = tmpfs_alloc_inode()
  if new_ino < 0:
    return -1

  if is_dir != 0:
    tmpfs_inode_type[new_ino] = TMPFS_TYPE_DIR
  else:
    tmpfs_inode_type[new_ino] = TMPFS_TYPE_FILE

  tmpfs_inode_parent[new_ino] = dir_ino
  tmpfs_inode_size[new_ino] = 0
  tmpfs_inode_data[new_ino] = 0
  tmpfs_set_name(new_ino, name)

  return new_ino

# Look up file/directory by name in parent
proc tmpfs_lookup(mount_id: int32, dir_ino: int32, name: ptr uint8): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  if dir_ino < 0 or dir_ino >= TMPFS_MAX_INODES:
    return -1

  var i: int32 = 0
  while i < TMPFS_MAX_INODES:
    if tmpfs_inode_type[i] != TMPFS_TYPE_UNUSED and tmpfs_inode_parent[i] == dir_ino:
      var inode_name: ptr uint8 = tmpfs_get_name(i)
      if tmpfs_strcmp(inode_name, name) == 0:
        return i
    i = i + 1

  return -1  # Not found

# Write data to file (replaces existing content)
proc tmpfs_write(mount_id: int32, ino: int32, data: ptr uint8, len: int32): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  if ino < 0 or ino >= TMPFS_MAX_INODES:
    return -1
  if tmpfs_inode_type[ino] != TMPFS_TYPE_FILE:
    return -1
  if len > TMPFS_MAX_FILESIZE:
    len = TMPFS_MAX_FILESIZE

  # Allocate memory for data if needed
  if tmpfs_inode_data[ino] == 0 and len > 0:
    # Use static buffer per inode (simplified - uses inode index * 64KB offset)
    tmpfs_inode_data[ino] = 0x800000 + (ino * TMPFS_MAX_FILESIZE)

  if len > 0:
    var dest: ptr uint8 = cast[ptr uint8](tmpfs_inode_data[ino])
    var i: int32 = 0
    while i < len:
      dest[i] = data[i]
      i = i + 1

  tmpfs_inode_size[ino] = len
  return len

# Read data from file
proc tmpfs_read(mount_id: int32, ino: int32, buf: ptr uint8, max_len: int32): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1
  if ino < 0 or ino >= TMPFS_MAX_INODES:
    return -1
  if tmpfs_inode_type[ino] != TMPFS_TYPE_FILE:
    return -1

  var size: int32 = tmpfs_inode_size[ino]
  if size == 0:
    return 0

  var to_read: int32 = size
  if to_read > max_len:
    to_read = max_len

  var src: ptr uint8 = cast[ptr uint8](tmpfs_inode_data[ino])
  var i: int32 = 0
  while i < to_read:
    buf[i] = src[i]
    i = i + 1

  return to_read

# Delete file or empty directory
proc tmpfs_unlink(mount_id: int32, dir_ino: int32, name: ptr uint8): int32 =
  discard mount_id
  if tmpfs_mounted == 0:
    return -1

  var ino: int32 = tmpfs_lookup(mount_id, dir_ino, name)
  if ino < 0:
    return -1

  # If directory, check if empty
  if tmpfs_inode_type[ino] == TMPFS_TYPE_DIR:
    var i: int32 = 0
    while i < TMPFS_MAX_INODES:
      if tmpfs_inode_type[i] != TMPFS_TYPE_UNUSED and tmpfs_inode_parent[i] == ino:
        return -1  # Directory not empty
      i = i + 1

  # Free the inode
  tmpfs_inode_type[ino] = TMPFS_TYPE_UNUSED
  tmpfs_inode_parent[ino] = -1
  tmpfs_inode_size[ino] = 0
  tmpfs_inode_data[ino] = 0

  return 0

# =============================================================================
# Init System - Reads startup configuration from disk
# =============================================================================

# Init configuration
const INIT_MODE_DESKTOP: int32 = 1
const INIT_MODE_SHELL: int32 = 2
const INIT_MODE_MULTI: int32 = 3  # Multi-user (shell after desktop exit)

var init_mode: int32 = INIT_MODE_DESKTOP  # Default to desktop

# Check if a file exists on BrainFS
proc brfs_file_exists(name: ptr uint8): int32 =
  if brfs_active_mount < 0:
    return 0
  var ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, name)
  if ino > 0:
    return 1
  return 0

# Read init configuration from /etc/inittab on BrainFS
# Format: "default:mode" where mode is "desktop", "shell", or "multi"
proc init_read_config(): int32 =
  if brfs_active_mount < 0:
    ser_println(cast[ptr uint8]("[INIT] No filesystem, using default"))
    return INIT_MODE_DESKTOP

  # First check for /etc directory
  var etc_ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("etc"))
  if etc_ino <= 0:
    # Create /etc directory
    ser_println(cast[ptr uint8]("[INIT] Creating /etc..."))
    etc_ino = brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("etc"))
    if etc_ino <= 0:
      ser_println(cast[ptr uint8]("[INIT] Failed to create /etc"))
      return INIT_MODE_DESKTOP

  # Look for inittab
  var inittab_ino: int32 = brfs_lookup(brfs_active_mount, etc_ino, cast[ptr uint8]("inittab"))
  if inittab_ino <= 0:
    # No inittab - create default one
    ser_println(cast[ptr uint8]("[INIT] Creating default /etc/inittab..."))
    inittab_ino = brfs_create(brfs_active_mount, etc_ino, cast[ptr uint8]("inittab"))
    if inittab_ino > 0:
      # Write default config
      var default_config: ptr uint8 = cast[ptr uint8]("# BrainhairOS Init Configuration\n# Modes: desktop, shell, multi\ndefault:desktop\n")
      var config_len: int32 = 70
      discard brfs_write_file(brfs_active_mount, inittab_ino, 0, default_config, config_len)
    return INIT_MODE_DESKTOP

  # Read inittab
  var config_buf: array[128, uint8]
  var bytes: int32 = brfs_read_file(brfs_active_mount, inittab_ino, 0, addr(config_buf[0]), 127)
  if bytes <= 0:
    return INIT_MODE_DESKTOP

  config_buf[bytes] = cast[uint8](0)
  ser_print(cast[ptr uint8]("[INIT] Read /etc/inittab: "))
  ser_print_int(bytes)
  ser_println(cast[ptr uint8](" bytes"))

  # Parse config - look for "default:mode"
  var i: int32 = 0
  while i < bytes - 8:
    # Check for "default:"
    if config_buf[i] == cast[uint8](100):       # 'd'
      if config_buf[i+1] == cast[uint8](101):   # 'e'
        if config_buf[i+2] == cast[uint8](102): # 'f'
          if config_buf[i+3] == cast[uint8](97): # 'a'
            if config_buf[i+4] == cast[uint8](117): # 'u'
              if config_buf[i+5] == cast[uint8](108): # 'l'
                if config_buf[i+6] == cast[uint8](116): # 't'
                  if config_buf[i+7] == cast[uint8](58):  # ':'
                    # Found "default:", check mode
                    var mode_start: int32 = i + 8
                    if config_buf[mode_start] == cast[uint8](115):  # 's' for shell
                      ser_println(cast[ptr uint8]("[INIT] Mode: shell"))
                      return INIT_MODE_SHELL
                    if config_buf[mode_start] == cast[uint8](109):  # 'm' for multi
                      ser_println(cast[ptr uint8]("[INIT] Mode: multi"))
                      return INIT_MODE_MULTI
                    ser_println(cast[ptr uint8]("[INIT] Mode: desktop"))
                    return INIT_MODE_DESKTOP
    i = i + 1

  return INIT_MODE_DESKTOP

# Run the init system
proc init_run() =
  ser_println(cast[ptr uint8]("[INIT] BrainhairOS Init System"))

  # Read configuration from disk
  init_mode = init_read_config()

  # Create some default files on first boot
  if brfs_active_mount >= 0:
    # Check if this is first boot (no /home directory)
    var home_ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("home"))
    if home_ino <= 0:
      ser_println(cast[ptr uint8]("[INIT] First boot - creating directories..."))
      discard brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("home"))
      discard brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("tmp"))
      discard brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("var"))
      discard brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("bin"))

      # Create a welcome file
      var welcome_ino: int32 = brfs_create(brfs_active_mount, BRFS_ROOT_INODE, cast[ptr uint8]("README"))
      if welcome_ino > 0:
        var welcome_text: ptr uint8 = cast[ptr uint8]("Welcome to BrainhairOS!\n\nThis filesystem is persistent.\nEdit /etc/inittab to change boot mode.\n")
        discard brfs_write_file(brfs_active_mount, welcome_ino, 0, welcome_text, 95)

      ser_println(cast[ptr uint8]("[INIT] Created /home, /tmp, /var, /bin, /README"))

  # Execute based on mode
  if init_mode == INIT_MODE_SHELL:
    ser_println(cast[ptr uint8]("[INIT] Starting shell..."))
    shell_main()
  elif init_mode == INIT_MODE_MULTI:
    ser_println(cast[ptr uint8]("[INIT] Starting desktop (shell on exit)..."))
    run_vtn_desktop()
    ser_println(cast[ptr uint8]("[INIT] Desktop exited, starting shell..."))
    shell_main()
  else:
    ser_println(cast[ptr uint8]("[INIT] Starting desktop..."))
    run_vtn_desktop()
    ser_println(cast[ptr uint8]("[INIT] Desktop exited"))
    shell_main()

# =============================================================================
# Main Entry Point
# =============================================================================

proc main() =
  # Initialize serial first for debug output
  serial_init()

  # Clear screen and show boot banner
  vga_clear()
  vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
  kprintln(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  kprintln(cast[ptr uint8](""))

  # Initialize IDT (Interrupt Descriptor Table)
  print_pending(cast[ptr uint8]("Initializing IDT"))
  init_idt()
  remap_pic()
  print_ok(cast[ptr uint8]("IDT initialized"))

  # Initialize paging
  print_pending(cast[ptr uint8]("Initializing paging"))
  init_paging()
  print_ok(cast[ptr uint8]("Paging enabled (16MB identity mapped)"))

  # Initialize VTNext graphics using multiboot framebuffer info
  print_pending(cast[ptr uint8]("Initializing VTNext graphics"))
  vtn_init()

  # Get framebuffer info from multiboot (set by GRUB)
  var fb_addr: int32 = multiboot_fb_addr()
  var fb_width: int32 = multiboot_fb_width()
  var fb_height: int32 = multiboot_fb_height()
  var fb_bpp: int32 = multiboot_fb_bpp()

  # If no framebuffer from multiboot, use QEMU defaults
  if fb_addr == 0:
    fb_addr = 0xE0000000
    fb_width = 1024
    fb_height = 768
    fb_bpp = 32

  # Calculate framebuffer size and map it
  var fb_size: int32 = fb_width * fb_height * (fb_bpp / 8)
  var page_addr: int32 = fb_addr
  var PTE_KERNEL: int32 = 0x03  # Present + R/W

  # Map framebuffer pages (align to page boundary)
  var fb_end: int32 = fb_addr + fb_size
  while page_addr < fb_end:
    discard map_page(page_addr, page_addr, PTE_KERNEL)
    page_addr = page_addr + 4096
  flush_tlb()

  # Configure VTNext with framebuffer info
  vtn_set_fb_info(fb_addr, fb_width, fb_height, fb_bpp)
  print_ok(cast[ptr uint8]("VTNext graphics ready"))

  # Initialize ATA disk driver
  print_pending(cast[ptr uint8]("Initializing ATA"))
  var ata_drives: int32 = ata_init()
  if ata_drives > 0:
    print_ok(cast[ptr uint8]("ATA initialized"))
  else:
    print_skip(cast[ptr uint8]("ATA: no drives"))

  # Initialize block device layer
  print_pending(cast[ptr uint8]("Initializing block devices"))
  blkdev_init()
  if blkdev_count > 0:
    print_ok(cast[ptr uint8]("Block devices registered"))
  else:
    print_skip(cast[ptr uint8]("No block devices"))

  # Scan for partitions
  print_pending(cast[ptr uint8]("Scanning partitions"))
  var partitions: int32 = partition_scan_all()
  if partitions > 0:
    print_ok(cast[ptr uint8]("Partitions found"))
  else:
    print_skip(cast[ptr uint8]("No partitions"))

  # Initialize BrainFS and try to mount a persistent filesystem
  print_pending(cast[ptr uint8]("Initializing BrainFS"))
  brfs_init()
  brfs_active_mount = brfs_auto_mount()
  if brfs_active_mount >= 0:
    print_ok(cast[ptr uint8]("BrainFS mounted"))
  else:
    print_skip(cast[ptr uint8]("BrainFS: no disk filesystem"))

  # Initialize scheduler
  print_pending(cast[ptr uint8]("Initializing scheduler"))
  init_scheduler()
  print_ok(cast[ptr uint8]("Scheduler initialized"))

  # Initialize pipes and file descriptors
  print_pending(cast[ptr uint8]("Initializing pipes"))
  init_pipes()
  setup_std_fds(0)  # Set up stdin/stdout/stderr for kernel process
  print_ok(cast[ptr uint8]("Pipes initialized"))

  # Initialize file locking
  print_pending(cast[ptr uint8]("Initializing file locks"))
  flock_init()
  print_ok(cast[ptr uint8]("File locks initialized"))

  # Initialize VFS
  print_pending(cast[ptr uint8]("Initializing VFS"))
  vfs_init()
  # Mount root filesystem (ramfs for now)
  vfs_mount(cast[ptr uint8]("/"), FS_TYPE_RAMFS, 0, 1)
  # Mount /dev
  vfs_mount(cast[ptr uint8]("/dev"), FS_TYPE_DEVFS, 0, 1)
  # Mount /proc
  vfs_mount(cast[ptr uint8]("/proc"), FS_TYPE_PROCFS, 0, 1)
  # Mount /sys
  vfs_mount(cast[ptr uint8]("/sys"), FS_TYPE_SYSFS, 0, 1)
  print_ok(cast[ptr uint8]("VFS initialized"))

  # Initialize signals
  print_pending(cast[ptr uint8]("Initializing signals"))
  init_signals()
  print_ok(cast[ptr uint8]("Signals initialized"))

  # Initialize device filesystem
  print_pending(cast[ptr uint8]("Initializing /dev"))
  devfs_init()
  print_ok(cast[ptr uint8]("/dev initialized"))

  # Initialize TTY subsystem
  print_pending(cast[ptr uint8]("Initializing TTY"))
  tty_init()
  print_ok(cast[ptr uint8]("TTY initialized"))

  # Enable interrupts
  print_pending(cast[ptr uint8]("Enabling interrupts"))
  enable_interrupts()
  print_ok(cast[ptr uint8]("Interrupts enabled"))

  # Boot complete
  kprintln(cast[ptr uint8](""))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  kprintln(cast[ptr uint8]("Kernel initialization complete!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  ser_println(cast[ptr uint8](""))
  ser_println(cast[ptr uint8]("Kernel initialization complete!"))

  # Initialize keyboard
  print_pending(cast[ptr uint8]("Initializing keyboard"))
  keyboard_init()
  print_ok(cast[ptr uint8]("Keyboard initialized"))

  # Initialize filesystem
  print_pending(cast[ptr uint8]("Initializing ramdisk"))
  fs_init()
  print_ok(cast[ptr uint8]("Ramdisk initialized (8KB)"))

  # Initialize environment variables
  env_init()

  # Initialize tab completion
  init_builtins()

  # Initialize networking (DISABLED - mmio_write32 stalls)
  # TODO: Fix e1000_init_rx mmio writes
  print_ok(cast[ptr uint8]("Network: DISABLED"))

  kprintln(cast[ptr uint8](""))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  kprintln(cast[ptr uint8]("Welcome to BrainhairOS!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  kprintln(cast[ptr uint8]("Type 'help' for available commands."))
  kprintln(cast[ptr uint8](""))

  ser_println(cast[ptr uint8](""))

  # === Thread Test (automatic on boot) ===
  ser_println(cast[ptr uint8]("[THREAD TEST] Starting thread test..."))
  ser_print(cast[ptr uint8]("[THREAD TEST] Main PID: "))
  ser_print_int(get_current_pid())
  ser_print(cast[ptr uint8](", TID: "))
  ser_print_int(get_thread_id())
  ser_print(cast[ptr uint8](", is_thread: "))
  ser_print_int(is_thread())
  ser_println(cast[ptr uint8](""))

  var test_tid: int32 = thread_create(cast[int32](addr(test_thread_func)), 42)
  if test_tid < 0:
    ser_println(cast[ptr uint8]("[THREAD TEST] ERROR: Failed to create thread"))
  else:
    ser_print(cast[ptr uint8]("[THREAD TEST] Created thread PID: "))
    ser_print_int(test_tid)
    ser_println(cast[ptr uint8](""))
    # Yield multiple times to let thread run
    var test_i: int32 = 0
    while test_i < 10:
      thread_yield()
      test_i = test_i + 1
    ser_println(cast[ptr uint8]("[THREAD TEST] Thread test complete"))
  ser_println(cast[ptr uint8](""))

  # === Unix Socket Test (automatic on boot) ===
  ser_println(cast[ptr uint8]("[SOCKET TEST] Starting Unix socket test..."))
  unix_init()  # Initialize Unix sockets
  ser_println(cast[ptr uint8]("[SOCKET TEST] unix_init completed"))

  # Create server thread
  var server_tid: int32 = thread_create(cast[int32](addr(socket_test_server)), 0)
  if server_tid < 0:
    ser_println(cast[ptr uint8]("[SOCKET TEST] ERROR: Failed to create server thread"))
  else:
    ser_print(cast[ptr uint8]("[SOCKET TEST] Server thread PID: "))
    ser_print_int(server_tid)
    ser_println(cast[ptr uint8](""))

    # Create client thread
    var client_tid: int32 = thread_create(cast[int32](addr(socket_test_client)), 0)
    if client_tid < 0:
      ser_println(cast[ptr uint8]("[SOCKET TEST] ERROR: Failed to create client thread"))
    else:
      ser_print(cast[ptr uint8]("[SOCKET TEST] Client thread PID: "))
      ser_print_int(client_tid)
      ser_println(cast[ptr uint8](""))

      # Yield to let threads run
      var sock_test_i: int32 = 0
      while sock_test_i < 200 and socket_test_server_done == 0:
        thread_yield()
        sock_test_i = sock_test_i + 1

      ser_println(cast[ptr uint8]("[SOCKET TEST] Socket test complete"))
  ser_println(cast[ptr uint8](""))

  # Test ChaCha20 encryption
  ser_println(cast[ptr uint8]("[CHACHA20 TEST] Starting ChaCha20 test..."))

  # Test key (32 bytes) - using simple pattern for testing
  var chacha_key: array[32, uint8]
  var ki: int32 = 0
  while ki < 32:
    chacha_key[ki] = cast[uint8](ki)
    ki = ki + 1

  # Test nonce (12 bytes)
  var chacha_nonce: array[12, uint8]
  var ni: int32 = 0
  while ni < 12:
    chacha_nonce[ni] = cast[uint8](ni + 32)
    ni = ni + 1

  # Test plaintext
  var plaintext: array[64, uint8]
  var pi: int32 = 0
  while pi < 64:
    # A-Z repeating pattern (use % for modulo)
    var letter: int32 = pi - ((pi / 26) * 26)  # manual modulo
    plaintext[pi] = cast[uint8](65 + letter)
    pi = pi + 1

  # Ciphertext buffer
  var ciphertext: array[64, uint8]

  # Encrypt
  chacha20_encrypt(addr(plaintext[0]), addr(ciphertext[0]), 64, addr(chacha_key[0]), addr(chacha_nonce[0]), 0)

  # Verify ciphertext is different from plaintext
  var diff_count: int32 = 0
  var ci: int32 = 0
  while ci < 64:
    if ciphertext[ci] != plaintext[ci]:
      diff_count = diff_count + 1
    ci = ci + 1

  if diff_count > 0:
    ser_print(cast[ptr uint8]("[CHACHA20 TEST] Encryption changed "))
    ser_print_int(diff_count)
    ser_println(cast[ptr uint8]("/64 bytes"))
  else:
    ser_println(cast[ptr uint8]("[CHACHA20 TEST] ERROR: Encryption didn't change data!"))

  # Decrypt (same operation for stream cipher)
  var decrypted: array[64, uint8]
  chacha20_encrypt(addr(ciphertext[0]), addr(decrypted[0]), 64, addr(chacha_key[0]), addr(chacha_nonce[0]), 0)

  # Verify decrypted matches plaintext
  var match_count: int32 = 0
  var di: int32 = 0
  while di < 64:
    if decrypted[di] == plaintext[di]:
      match_count = match_count + 1
    di = di + 1

  if match_count == 64:
    ser_println(cast[ptr uint8]("[CHACHA20 TEST] Decryption verified - all 64 bytes match!"))
  else:
    ser_print(cast[ptr uint8]("[CHACHA20 TEST] ERROR: Only "))
    ser_print_int(match_count)
    ser_println(cast[ptr uint8]("/64 bytes match after decryption"))

  ser_println(cast[ptr uint8]("[CHACHA20 TEST] ChaCha20 test complete"))
  ser_println(cast[ptr uint8](""))

  ser_println(cast[ptr uint8]("Starting kernel shell..."))

  # Run init system (reads /etc/inittab from disk)
  init_run()
  # init_run() never returns - it runs the appropriate startup mode

# ============================================================================
# Test Process (runs as a separate process)
# ============================================================================

proc test_process() =
  # This runs as a new process
  # For now, just print a message and loop
  vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
  kprint(cast[ptr uint8]("[Process "))
  var pid: int32 = get_current_pid()
  kprint_dec(pid)
  kprintln(cast[ptr uint8]("] Hello from child process!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  # Simple counter loop - shows process is running
  var count: int32 = 0
  while count < 5:
    var delay: int32 = 0
    while delay < 2000000:
      delay = delay + 1
    count = count + 1

  vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
  kprint(cast[ptr uint8]("[Process "))
  kprint_dec(pid)
  kprintln(cast[ptr uint8]("] Done, exiting."))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  # Exit (for now just return, later use exit syscall)
  # The scheduler will reclaim this slot

# ============================================================================
# Shell Implementation
# ============================================================================

# Command buffer
var cmd_buffer: array[256, uint8]
var cmd_len: int32 = 0
var escape_seq: int32 = 0  # Tracks escape sequence state
var escape_buf: array[8, uint8]  # Buffer to collect escape sequence
var escape_idx: int32 = 0

# Command history
const HISTORY_SIZE: int32 = 16
const HISTORY_LINE_LEN: int32 = 128
var history: array[2048, uint8]  # 16 * 128 = 2048
var history_count: int32 = 0     # Number of entries in history
var history_pos: int32 = 0       # Current position when browsing (-1 = current line)
var saved_cmd: array[256, uint8] # Saved current command when browsing history
var saved_len: int32 = 0

# Exit code of last command (for $? support)
var last_exit_code: int32 = 0

# Find && operator in command (returns position or -1)
proc find_and_chain(buf: ptr uint8, len: int32): int32 =
  var i: int32 = 0
  while i < len - 1:
    if cast[int32](buf[i]) == 38:       # '&'
      if cast[int32](buf[i + 1]) == 38:  # '&'
        return i
    i = i + 1
  return -1

# Find || operator in command (returns position or -1)
proc find_or_chain(buf: ptr uint8, len: int32): int32 =
  var i: int32 = 0
  while i < len - 1:
    if cast[int32](buf[i]) == 124:       # '|'
      if cast[int32](buf[i + 1]) == 124:  # '|'
        return i
    i = i + 1
  return -1

# Find ; operator in command (returns position or -1)
proc find_semicolon(buf: ptr uint8, len: int32): int32 =
  var i: int32 = 0
  while i < len:
    if cast[int32](buf[i]) == 59:  # ';'
      return i
    i = i + 1
  return -1

# Get pointer to history entry
proc history_ptr(idx: int32): ptr uint8 =
  return addr(history[idx * HISTORY_LINE_LEN])

# Add command to history
proc history_add(cmd: ptr uint8, len: int32) =
  if len == 0:
    return
  # Don't add duplicates of the last command
  if history_count > 0:
    var last: ptr uint8 = history_ptr(history_count - 1)
    if str_equals(cmd, last) == 1:
      return
  # If history is full, shift everything up
  if history_count >= HISTORY_SIZE:
    var i: int32 = 0
    while i < HISTORY_SIZE - 1:
      var src: ptr uint8 = history_ptr(i + 1)
      var dst: ptr uint8 = history_ptr(i)
      var j: int32 = 0
      while j < HISTORY_LINE_LEN:
        dst[j] = src[j]
        j = j + 1
      i = i + 1
    history_count = HISTORY_SIZE - 1
  # Add new entry
  var entry: ptr uint8 = history_ptr(history_count)
  var k: int32 = 0
  while k < len:
    if k < HISTORY_LINE_LEN - 1:
      entry[k] = cmd[k]
    k = k + 1
  entry[k] = cast[uint8](0)
  history_count = history_count + 1
  history_pos = history_count  # Reset position to end

# Clear the current command line on screen
proc clear_cmdline() =
  # Move cursor back and clear
  var i: int32 = 0
  while i < cmd_len:
    vga_col = vga_col - 1
    vga_putchar(32)  # space
    vga_col = vga_col - 1
    ser_putchar(8)   # backspace
    ser_putchar(32)  # space
    ser_putchar(8)   # backspace
    i = i + 1

# Set command line to a string
proc set_cmdline(s: ptr uint8) =
  clear_cmdline()
  cmd_len = 0
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    if cmd_len < 255:
      cmd_buffer[cmd_len] = s[i]
      vga_putchar(cast[int32](s[i]))
      serial_putchar(cast[int32](s[i]))
      cmd_len = cmd_len + 1
    i = i + 1

# ============================================================================
# BrainhairFS - ext2-like Hierarchical Filesystem
# ============================================================================
#
# Layout (16 x 512-byte blocks = 8KB):
#   Block 0: Superblock
#   Block 1: Inode bitmap (64 inodes max)
#   Block 2: Block bitmap (16 blocks)
#   Blocks 3-4: Inode table (32 inodes x 32 bytes = 2 blocks)
#   Blocks 5-15: Data blocks (11 blocks = 5632 bytes)
#
# Inode structure (32 bytes):
#   0-1: mode (0x4000=dir, 0x8000=file)
#   2-3: links
#   4-7: size
#   8-11: block[0]
#   12-15: block[1]
#   16-19: block[2]
#   20-23: block[3]
#   24-31: reserved
#
# Directory entry (32 bytes):
#   0-3: inode
#   4-5: rec_len
#   6: name_len
#   7: file_type (1=file, 2=dir)
#   8-31: name (24 chars)

const BLOCK_SIZE: int32 = 512
const BLOCK_COUNT: int32 = 64
const INODE_COUNT: int32 = 64
const INODE_SIZE: int32 = 32
const DIRENT_SIZE: int32 = 32
const FIRST_DATA_BLOCK: int32 = 7  # 0=sb, 1=inode_bmp, 2=block_bmp, 3-6=inode_tbl
const DATA_BLOCKS: int32 = 57
const MAX_NAME_LEN: int32 = 24

# File types
const FT_FILE: int32 = 1
const FT_DIR: int32 = 2

# Inode modes
const S_IFDIR: int32 = 0x4000
const S_IFREG: int32 = 0x8000

# The entire filesystem in one array (32KB)
var fs_data: array[32768, uint8]

# Current working directory inode
var cwd_inode: int32 = 1  # Start at root

# ============================================================================
# Environment Variables
# ============================================================================

const MAX_ENV_VARS: int32 = 16
const MAX_ENV_NAME: int32 = 32
const MAX_ENV_VALUE: int32 = 64

# Environment storage: names and values
var env_names: array[512, uint8]   # 16 * 32 = 512
var env_values: array[1024, uint8] # 16 * 64 = 1024
var env_count: int32 = 0

# ============================================================================
# Networking Variables (forward declarations for shell_execute)
# ============================================================================
var e1000_mmio_base: int32 = 0          # Memory-mapped I/O base address
var e1000_irq: int32 = 0                # IRQ line
var e1000_found: int32 = 0              # 1 if E1000 found
var my_mac: array[6, uint8]             # Our MAC address
var my_ip: array[4, uint8]              # Our IP address (set by DHCP or static)
var broadcast_mac: array[6, uint8]      # Broadcast MAC (FF:FF:FF:FF:FF:FF)
var arp_ip: array[64, uint8]            # 16 * 4 bytes for ARP cache IPs
var arp_mac: array[96, uint8]           # 16 * 6 bytes for ARP cache MACs
var arp_count: int32 = 0                # Number of ARP entries
var ping_pending: int32 = 0             # Ping request pending
var ping_seq: int32 = 0                 # Ping sequence number
var ping_received: int32 = 0            # Ping reply received flag
var ping_reply_seq: int32 = 0           # Received ping sequence
var ping_send_time: int32 = 0           # Time ping was sent
var ping_reply_time: int32 = 0          # Time ping reply received
var ping_id: int32 = 0x1234             # Ping identifier
var ping_target_ip: array[4, uint8]     # Target IP for ping
var net_debug: int32 = 0                # Debug output toggle
var dns_result_ip: array[4, uint8]      # DNS resolution result
var dns_result_ready: int32 = 0         # DNS result ready flag

# Static buffers for TCP send (avoid stack overflow)
var tcp_send_pkt: array[1500, uint8]    # TCP packet buffer
var tcp_send_ip_pkt: array[1500, uint8] # IP packet buffer
var tcp_send_in_progress: int32 = 0     # Guard against recursion
var eth_send_frame: array[1518, uint8]  # Ethernet frame buffer (avoid stack overflow)

# UDP receive state
var udp_recv_port: int32 = 0                      # Port to listen on
var udp_recv_data: ptr uint8 = cast[ptr uint8](0) # Received data pointer
var udp_recv_len: int32 = 0                       # Received data length
var udp_recv_ready: int32 = 0                     # Data ready flag

# DHCP state
var dhcp_state: int32 = 0                         # 0=idle, 1=discovering, 2=requesting, 3=bound
var dhcp_xid: int32 = 0                           # Transaction ID
var dhcp_server_ip: array[4, uint8]               # DHCP server IP
var dhcp_offered_ip: array[4, uint8]              # Offered IP address
var dhcp_gateway: array[4, uint8]                 # Gateway/router IP
var dhcp_subnet: array[4, uint8]                  # Subnet mask
var dhcp_dns: array[4, uint8]                     # DNS server IP
var dhcp_lease_time: int32 = 0                    # Lease time in seconds

# NTP state
var ntp_synced: int32 = 0                         # 1 if time is synced
var ntp_timestamp: int32 = 0                      # Unix timestamp (seconds since 1970)
var ntp_sync_tick: int32 = 0                      # Tick count when synced

# TCP connection state
const TCP_MAX_CONNS: int32 = 16
const TCP_BUF_SIZE: int32 = 1024
# States: 0=closed, 1=syn_sent, 2=established, 3=fin_wait, 4=close_wait
var tcp_state: array[16, int32]                   # Connection states
var tcp_local_port: array[16, int32]              # Local ports
var tcp_remote_port: array[16, int32]             # Remote ports
var tcp_remote_ip: array[64, uint8]               # Remote IPs (4 bytes each)
var tcp_seq: array[16, int32]                     # Sequence numbers
var tcp_ack: array[16, int32]                     # Ack numbers
var tcp_recv_buf: array[16384, uint8]             # Receive buffers (1024 per conn)
var tcp_recv_len: array[16, int32]                # Bytes in receive buffer
var tcp_recv_ready: array[16, int32]              # Data ready flags

# ============================================================================
# Unix Domain Sockets
# ============================================================================
const UNIX_MAX_SOCKETS: int32 = 8
const UNIX_BUF_SIZE: int32 = 1024
const UNIX_PATH_MAX: int32 = 64

# Unix socket states
const UNIX_STATE_CLOSED: int32 = 0
const UNIX_STATE_LISTENING: int32 = 1
const UNIX_STATE_CONNECTING: int32 = 2
const UNIX_STATE_CONNECTED: int32 = 3

# Unix socket data
var unix_state: array[8, int32]                   # Socket states
var unix_path: array[512, uint8]                  # Paths (64 bytes each)
var unix_listen_pid: array[8, int32]              # PID of listening socket
var unix_peer_socket: array[8, int32]             # Connected peer socket (-1 if none)
var unix_recv_buf: array[8192, uint8]             # Receive buffers (1024 per socket)
var unix_recv_len: array[8, int32]                # Bytes in receive buffer
var unix_recv_ready: array[8, int32]              # Data ready flags
var unix_pending_pid: array[8, int32]             # PID of pending connection
var unix_pending_socket: array[8, int32]          # Socket of pending connection

# Get path pointer for socket
proc unix_get_path(socket_id: int32): ptr uint8 =
  return addr(unix_path[socket_id * UNIX_PATH_MAX])

# Get receive buffer pointer for socket
proc unix_get_buf(socket_id: int32): ptr uint8 =
  return addr(unix_recv_buf[socket_id * UNIX_BUF_SIZE])

# Initialize Unix socket system
proc unix_init() =
  var i: int32 = 0
  while i < UNIX_MAX_SOCKETS:
    unix_state[i] = UNIX_STATE_CLOSED
    unix_listen_pid[i] = -1
    unix_peer_socket[i] = -1
    unix_recv_len[i] = 0
    unix_recv_ready[i] = 0
    unix_pending_pid[i] = -1
    unix_pending_socket[i] = -1
    i = i + 1

# Find free Unix socket
proc unix_find_free(): int32 =
  var i: int32 = 0
  while i < UNIX_MAX_SOCKETS:
    if unix_state[i] == UNIX_STATE_CLOSED:
      return i
    i = i + 1
  return -1

# Find listening socket by path
proc unix_find_listener(path: ptr uint8): int32 =
  var i: int32 = 0
  while i < UNIX_MAX_SOCKETS:
    if unix_state[i] == UNIX_STATE_LISTENING:
      var sock_path: ptr uint8 = unix_get_path(i)
      if str_equals(path, sock_path) == 1:
        return i
    i = i + 1
  return -1

# Create listening Unix socket
# Returns socket ID on success, -1 on failure
proc unix_listen(path: ptr uint8): int32 =
  # Check if path already in use
  if unix_find_listener(path) >= 0:
    return -1  # Address already in use

  # Find free socket
  var socket_id: int32 = unix_find_free()
  if socket_id < 0:
    return -1  # No free sockets

  # Copy path
  var sock_path: ptr uint8 = unix_get_path(socket_id)
  str_copy(sock_path, path, UNIX_PATH_MAX - 1)

  # Set up socket state
  unix_state[socket_id] = UNIX_STATE_LISTENING
  unix_listen_pid[socket_id] = get_current_pid()
  unix_peer_socket[socket_id] = -1
  unix_recv_len[socket_id] = 0
  unix_recv_ready[socket_id] = 0
  unix_pending_pid[socket_id] = -1
  unix_pending_socket[socket_id] = -1

  return socket_id

# Connect to Unix socket
# Returns socket ID on success, -1 on failure
proc unix_connect(path: ptr uint8): int32 =
  # Find listening socket
  var listen_id: int32 = unix_find_listener(path)
  if listen_id < 0:
    return -1  # No such socket

  # Find free socket for client
  var client_id: int32 = unix_find_free()
  if client_id < 0:
    return -1  # No free sockets

  # Set up client socket
  unix_state[client_id] = UNIX_STATE_CONNECTING
  unix_listen_pid[client_id] = get_current_pid()
  unix_peer_socket[client_id] = -1
  unix_recv_len[client_id] = 0
  unix_recv_ready[client_id] = 0

  # Register pending connection on listener
  unix_pending_pid[listen_id] = get_current_pid()
  unix_pending_socket[listen_id] = client_id

  return client_id

# Check if listener has pending connection
proc unix_accept_ready(socket_id: int32): int32 =
  if socket_id < 0 or socket_id >= UNIX_MAX_SOCKETS:
    return 0
  if unix_state[socket_id] != UNIX_STATE_LISTENING:
    return 0
  if unix_pending_pid[socket_id] >= 0:
    return 1
  return 0

# Accept connection on listening socket
# Returns new connected socket ID, -1 on failure
proc unix_accept(listen_id: int32): int32 =
  if listen_id < 0 or listen_id >= UNIX_MAX_SOCKETS:
    return -1
  if unix_state[listen_id] != UNIX_STATE_LISTENING:
    return -1
  if unix_pending_pid[listen_id] < 0:
    return -1  # No pending connection

  # Get client socket that's connecting
  var client_id: int32 = unix_pending_socket[listen_id]

  # Create server-side socket for this connection
  var server_id: int32 = unix_find_free()
  if server_id < 0:
    return -1  # No free sockets

  # Set up server socket
  unix_state[server_id] = UNIX_STATE_CONNECTED
  unix_listen_pid[server_id] = get_current_pid()
  unix_peer_socket[server_id] = client_id
  unix_recv_len[server_id] = 0
  unix_recv_ready[server_id] = 0

  # Complete client connection
  unix_state[client_id] = UNIX_STATE_CONNECTED
  unix_peer_socket[client_id] = server_id

  # Clear pending connection on listener
  unix_pending_pid[listen_id] = -1
  unix_pending_socket[listen_id] = -1

  return server_id

# Send data on Unix socket
# Returns bytes sent, -1 on error
proc unix_send(socket_id: int32, data: ptr uint8, length: int32): int32 =
  if socket_id < 0 or socket_id >= UNIX_MAX_SOCKETS:
    return -1
  if unix_state[socket_id] != UNIX_STATE_CONNECTED:
    return -1

  var peer_id: int32 = unix_peer_socket[socket_id]
  if peer_id < 0 or peer_id >= UNIX_MAX_SOCKETS:
    return -1

  # Check buffer space in peer
  var available: int32 = UNIX_BUF_SIZE - unix_recv_len[peer_id]
  if length > available:
    length = available
  if length <= 0:
    return 0  # Buffer full

  # Copy data to peer's receive buffer
  var peer_buf: ptr uint8 = unix_get_buf(peer_id)
  var offset: int32 = unix_recv_len[peer_id]
  var i: int32 = 0
  while i < length:
    peer_buf[offset + i] = data[i]
    i = i + 1

  unix_recv_len[peer_id] = offset + length
  unix_recv_ready[peer_id] = 1

  return length

# Receive data from Unix socket
# Returns bytes received, -1 on error
proc unix_recv(socket_id: int32, buf: ptr uint8, max_len: int32): int32 =
  if socket_id < 0 or socket_id >= UNIX_MAX_SOCKETS:
    return -1
  if unix_state[socket_id] != UNIX_STATE_CONNECTED:
    return -1

  var available: int32 = unix_recv_len[socket_id]
  if available <= 0:
    return 0  # No data

  if max_len > available:
    max_len = available

  # Copy data from receive buffer
  var sock_buf: ptr uint8 = unix_get_buf(socket_id)
  var i: int32 = 0
  while i < max_len:
    buf[i] = sock_buf[i]
    i = i + 1

  # Shift remaining data
  var remaining: int32 = available - max_len
  i = 0
  while i < remaining:
    sock_buf[i] = sock_buf[max_len + i]
    i = i + 1

  unix_recv_len[socket_id] = remaining
  if remaining == 0:
    unix_recv_ready[socket_id] = 0

  return max_len

# Check if socket has data available
proc unix_has_data(socket_id: int32): int32 =
  if socket_id < 0 or socket_id >= UNIX_MAX_SOCKETS:
    return 0
  return unix_recv_ready[socket_id]

# Close Unix socket
proc unix_close(socket_id: int32) =
  if socket_id < 0 or socket_id >= UNIX_MAX_SOCKETS:
    return

  # If connected, close peer too
  if unix_state[socket_id] == UNIX_STATE_CONNECTED:
    var peer_id: int32 = unix_peer_socket[socket_id]
    if peer_id >= 0 and peer_id < UNIX_MAX_SOCKETS:
      unix_state[peer_id] = UNIX_STATE_CLOSED
      unix_peer_socket[peer_id] = -1

  # Close this socket
  unix_state[socket_id] = UNIX_STATE_CLOSED
  unix_listen_pid[socket_id] = -1
  unix_peer_socket[socket_id] = -1
  unix_recv_len[socket_id] = 0
  unix_recv_ready[socket_id] = 0
  unix_pending_pid[socket_id] = -1
  unix_pending_socket[socket_id] = -1

# Get environment variable name at index
proc env_name_ptr(idx: int32): ptr uint8 =
  return addr(env_names[idx * MAX_ENV_NAME])

# Get environment variable value at index
proc env_value_ptr(idx: int32): ptr uint8 =
  return addr(env_values[idx * MAX_ENV_VALUE])

# Find environment variable by name, return index or -1
proc env_find(name: ptr uint8): int32 =
  var i: int32 = 0
  while i < env_count:
    var env_n: ptr uint8 = env_name_ptr(i)
    if str_equals(name, env_n) == 1:
      return i
    i = i + 1
  return -1

# Get environment variable value, return null if not found
proc env_get(name: ptr uint8): ptr uint8 =
  var idx: int32 = env_find(name)
  if idx < 0:
    return cast[ptr uint8](0)
  return env_value_ptr(idx)

# Set environment variable
proc env_set(name: ptr uint8, value: ptr uint8): int32 =
  var idx: int32 = env_find(name)
  if idx < 0:
    # New variable
    if env_count >= MAX_ENV_VARS:
      return -1  # No space
    idx = env_count
    env_count = env_count + 1
    # Copy name
    var np: ptr uint8 = env_name_ptr(idx)
    var i: int32 = 0
    while i < MAX_ENV_NAME - 1:
      if cast[int32](name[i]) == 0:
        break
      np[i] = name[i]
      i = i + 1
    np[i] = cast[uint8](0)
  # Copy value
  var vp: ptr uint8 = env_value_ptr(idx)
  var j: int32 = 0
  while j < MAX_ENV_VALUE - 1:
    if cast[int32](value[j]) == 0:
      break
    vp[j] = value[j]
    j = j + 1
  vp[j] = cast[uint8](0)
  return 0

# Initialize default environment variables
proc env_init() =
  env_set(cast[ptr uint8]("HOME"), cast[ptr uint8]("/home"))
  env_set(cast[ptr uint8]("PATH"), cast[ptr uint8]("/bin"))
  env_set(cast[ptr uint8]("SHELL"), cast[ptr uint8]("/bin/bsh"))
  env_set(cast[ptr uint8]("USER"), cast[ptr uint8]("root"))
  env_set(cast[ptr uint8]("HOSTNAME"), cast[ptr uint8]("brainhair"))
  env_set(cast[ptr uint8]("PS1"), cast[ptr uint8]("bhos> "))

# ============================================================================
# Low-level block/inode access
# ============================================================================

# Get pointer to a block
proc fs_block_ptr(block_num: int32): ptr uint8 =
  var offset: int32 = block_num * BLOCK_SIZE
  return addr(fs_data[offset])

# Get pointer to inode
proc fs_inode_ptr(ino: int32): ptr uint8 =
  # Inodes start at block 3
  var offset: int32 = 3 * BLOCK_SIZE + (ino - 1) * INODE_SIZE
  return addr(fs_data[offset])

# Read 16-bit value from pointer
proc read16(p: ptr uint8): int32 =
  var lo: int32 = cast[int32](p[0])
  var hi: int32 = cast[int32](p[1])
  return lo + (hi << 8)

# Write 16-bit value to pointer
proc write16(p: ptr uint8, val: int32) =
  p[0] = cast[uint8](val & 0xFF)
  p[1] = cast[uint8]((val >> 8) & 0xFF)

# Read 32-bit value from pointer
proc read32(p: ptr uint8): int32 =
  var b0: int32 = cast[int32](p[0])
  var b1: int32 = cast[int32](p[1])
  var b2: int32 = cast[int32](p[2])
  var b3: int32 = cast[int32](p[3])
  return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

# Write 32-bit value to pointer
proc write32(p: ptr uint8, val: int32) =
  p[0] = cast[uint8](val & 0xFF)
  p[1] = cast[uint8]((val >> 8) & 0xFF)
  p[2] = cast[uint8]((val >> 16) & 0xFF)
  p[3] = cast[uint8]((val >> 24) & 0xFF)

# ============================================================================
# Inode operations
# ============================================================================

# Get inode mode
proc inode_get_mode(ino: int32): int32 =
  var p: ptr uint8 = fs_inode_ptr(ino)
  return read16(p)

# Set inode mode
proc inode_set_mode(ino: int32, mode: int32) =
  var p: ptr uint8 = fs_inode_ptr(ino)
  write16(p, mode)

# Get inode size
proc inode_get_size(ino: int32): int32 =
  var p: ptr uint8 = fs_inode_ptr(ino)
  return read32(addr(p[4]))

# Set inode size
proc inode_set_size(ino: int32, size: int32) =
  var p: ptr uint8 = fs_inode_ptr(ino)
  write32(addr(p[4]), size)

# Get inode block pointer (0-3)
proc inode_get_block(ino: int32, idx: int32): int32 =
  var p: ptr uint8 = fs_inode_ptr(ino)
  return read32(addr(p[8 + idx * 4]))

# Set inode block pointer
proc inode_set_block(ino: int32, idx: int32, blk: int32) =
  var p: ptr uint8 = fs_inode_ptr(ino)
  write32(addr(p[8 + idx * 4]), blk)

# Check if inode is directory
proc inode_is_dir(ino: int32): int32 =
  var mode: int32 = inode_get_mode(ino)
  if (mode & 0xF000) == S_IFDIR:
    return 1
  return 0

# ============================================================================
# Bitmap operations
# ============================================================================

# Get bit in bitmap
proc bitmap_get(block: int32, bit: int32): int32 =
  var p: ptr uint8 = fs_block_ptr(block)
  var byte_idx: int32 = bit / 8
  var bit_idx: int32 = bit & 7
  var byte_val: int32 = cast[int32](p[byte_idx])
  if (byte_val & (1 << bit_idx)) != 0:
    return 1
  return 0

# Set bit in bitmap
proc bitmap_set(block: int32, bit: int32) =
  var p: ptr uint8 = fs_block_ptr(block)
  var byte_idx: int32 = bit / 8
  var bit_idx: int32 = bit & 7
  var byte_val: int32 = cast[int32](p[byte_idx])
  p[byte_idx] = cast[uint8](byte_val | (1 << bit_idx))

# Clear bit in bitmap
proc bitmap_clear(block: int32, bit: int32) =
  var p: ptr uint8 = fs_block_ptr(block)
  var byte_idx: int32 = bit / 8
  var bit_idx: int32 = bit & 7
  var byte_val: int32 = cast[int32](p[byte_idx])
  var mask: int32 = 255 - (1 << bit_idx)
  p[byte_idx] = cast[uint8](byte_val & mask)

# Allocate an inode, returns inode number or 0
proc alloc_inode(): int32 =
  var i: int32 = 1  # Inode 0 is reserved
  while i < INODE_COUNT:
    if bitmap_get(1, i) == 0:
      bitmap_set(1, i)
      return i
    i = i + 1
  return 0

# Free an inode
proc free_inode(ino: int32) =
  bitmap_clear(1, ino)
  # Clear inode data
  var p: ptr uint8 = fs_inode_ptr(ino)
  var i: int32 = 0
  while i < INODE_SIZE:
    p[i] = cast[uint8](0)
    i = i + 1

# Allocate a data block, returns block number or 0
proc alloc_block(): int32 =
  var i: int32 = FIRST_DATA_BLOCK
  while i < BLOCK_COUNT:
    if bitmap_get(2, i) == 0:
      bitmap_set(2, i)
      # Clear block
      var p: ptr uint8 = fs_block_ptr(i)
      var j: int32 = 0
      while j < BLOCK_SIZE:
        p[j] = cast[uint8](0)
        j = j + 1
      return i
    i = i + 1
  return 0

# Free a data block
proc free_block(blk: int32) =
  bitmap_clear(2, blk)

# ============================================================================
# Directory operations
# ============================================================================

# Find entry in directory, returns inode or 0
proc dir_lookup(dir_ino: int32, name: ptr uint8, name_len: int32): int32 =
  var blk: int32 = inode_get_block(dir_ino, 0)
  if blk == 0:
    return 0
  var p: ptr uint8 = fs_block_ptr(blk)
  var offset: int32 = 0
  while offset < BLOCK_SIZE:
    var ent_ino: int32 = read32(addr(p[offset]))
    if ent_ino != 0:
      var ent_name_len: int32 = cast[int32](p[offset + 6])
      if ent_name_len == name_len:
        # Compare names
        var matched: int32 = 1
        var i: int32 = 0
        while i < name_len:
          if p[offset + 8 + i] != name[i]:
            matched = 0
            i = name_len  # break
          i = i + 1
        if matched == 1:
          return ent_ino
    offset = offset + DIRENT_SIZE
  return 0

# Add entry to directory
proc dir_add_entry(dir_ino: int32, name: ptr uint8, name_len: int32, ino: int32, ftype: int32): int32 =
  var blk: int32 = inode_get_block(dir_ino, 0)
  if blk == 0:
    # Allocate block for directory
    blk = alloc_block()
    if blk == 0:
      return -1
    inode_set_block(dir_ino, 0, blk)
    inode_set_size(dir_ino, BLOCK_SIZE)
  var p: ptr uint8 = fs_block_ptr(blk)
  # Find empty slot
  var offset: int32 = 0
  while offset < BLOCK_SIZE:
    var ent_ino: int32 = read32(addr(p[offset]))
    if ent_ino == 0:
      # Found empty slot
      write32(addr(p[offset]), ino)
      write16(addr(p[offset + 4]), DIRENT_SIZE)
      p[offset + 6] = cast[uint8](name_len)
      p[offset + 7] = cast[uint8](ftype)
      var i: int32 = 0
      while i < name_len:
        p[offset + 8 + i] = name[i]
        i = i + 1
      return 0
    offset = offset + DIRENT_SIZE
  return -1  # Directory full

# Remove entry from directory
proc dir_remove_entry(dir_ino: int32, name: ptr uint8, name_len: int32): int32 =
  var blk: int32 = inode_get_block(dir_ino, 0)
  if blk == 0:
    return -1
  var p: ptr uint8 = fs_block_ptr(blk)
  var offset: int32 = 0
  while offset < BLOCK_SIZE:
    var ent_ino: int32 = read32(addr(p[offset]))
    if ent_ino != 0:
      var ent_name_len: int32 = cast[int32](p[offset + 6])
      if ent_name_len == name_len:
        var matched: int32 = 1
        var i: int32 = 0
        while i < name_len:
          if p[offset + 8 + i] != name[i]:
            matched = 0
            i = name_len
          i = i + 1
        if matched == 1:
          # Clear entry
          write32(addr(p[offset]), 0)
          return ent_ino
    offset = offset + DIRENT_SIZE
  return -1

# ============================================================================
# Path resolution
# ============================================================================

# Get string length
proc fs_strlen(s: ptr uint8): int32 =
  var len: int32 = 0
  while cast[int32](s[len]) != 0:
    len = len + 1
  return len

# Resolve path to inode (simplified: /a/b/c style)
proc path_resolve(path: ptr uint8): int32 =
  var len: int32 = fs_strlen(path)
  if len == 0:
    return cwd_inode

  # Start from root or cwd
  var ino: int32 = cwd_inode
  if cast[int32](path[0]) == 47:  # '/'
    ino = 1  # root inode
    path = addr(path[1])
    len = len - 1

  if len == 0:
    return ino

  # Parse path components
  var start: int32 = 0
  var i: int32 = 0
  while i <= len:
    var c: int32 = 0
    if i < len:
      c = cast[int32](path[i])
    if c == 47 or c == 0:  # '/' or end
      if i > start:
        var comp_len: int32 = i - start
        var next_ino: int32 = dir_lookup(ino, addr(path[start]), comp_len)
        if next_ino == 0:
          return 0  # Not found
        ino = next_ino
      start = i + 1
    i = i + 1

  return ino

# Get parent directory inode
proc path_parent(path: ptr uint8): int32 =
  var len: int32 = fs_strlen(path)
  if len == 0:
    return cwd_inode

  # Find last slash
  var last_slash: int32 = -1
  var i: int32 = 0
  while i < len:
    if cast[int32](path[i]) == 47:
      last_slash = i
    i = i + 1

  if last_slash < 0:
    return cwd_inode  # No slash, parent is cwd
  if last_slash == 0:
    return 1  # Parent is root

  # Resolve up to last slash
  # Temporarily null-terminate
  var saved: uint8 = path[last_slash]
  path[last_slash] = cast[uint8](0)
  var parent: int32 = path_resolve(path)
  path[last_slash] = saved
  return parent

# Get basename from path
proc path_basename(path: ptr uint8): ptr uint8 =
  var len: int32 = fs_strlen(path)
  var last_slash: int32 = -1
  var i: int32 = 0
  while i < len:
    if cast[int32](path[i]) == 47:
      last_slash = i
    i = i + 1
  if last_slash < 0:
    return path
  return addr(path[last_slash + 1])

# =============================================================================
# Filesystem Syscalls (link/symlink/readlink/unlink)
# =============================================================================

# sys_link - Create a hard link
proc sys_link(target: ptr uint8, linkname: ptr uint8): int32 =
  if brfs_active_mount < 0:
    return -1
  var target_ino: int32 = path_resolve(target)
  if target_ino <= 0:
    return -1
  var parent_ino: int32 = path_parent(linkname)
  if parent_ino <= 0:
    return -1
  var name: ptr uint8 = path_basename(linkname)
  return brfs_link(brfs_active_mount, parent_ino, name, target_ino)

# sys_unlink - Remove a file or link
proc sys_unlink(path: ptr uint8): int32 =
  if brfs_active_mount < 0:
    return -1
  var parent_ino: int32 = path_parent(path)
  if parent_ino <= 0:
    return -1
  var name: ptr uint8 = path_basename(path)
  return brfs_unlink(brfs_active_mount, parent_ino, name)

# sys_symlink - Create a symbolic link
proc sys_symlink(target: ptr uint8, linkpath: ptr uint8): int32 =
  if brfs_active_mount < 0:
    return -1
  var parent_ino: int32 = path_parent(linkpath)
  if parent_ino <= 0:
    return -1
  var name: ptr uint8 = path_basename(linkpath)
  return brfs_symlink(brfs_active_mount, parent_ino, name, target)

# sys_readlink - Read the target of a symbolic link
proc sys_readlink(path: ptr uint8, buf: ptr uint8, bufsize: int32): int32 =
  if brfs_active_mount < 0:
    return -1
  var ino: int32 = path_resolve(path)
  if ino <= 0:
    return -1
  return brfs_readlink(brfs_active_mount, ino, buf, bufsize)

# ============================================================================
# High-level filesystem operations
# ============================================================================

# Create a file
proc fs_create_file(path: ptr uint8, content: ptr uint8, size: int32): int32 =
  var parent_ino: int32 = path_parent(path)
  if parent_ino == 0:
    return -1  # Parent not found
  if inode_is_dir(parent_ino) == 0:
    return -2  # Parent not a directory

  var name: ptr uint8 = path_basename(path)
  var name_len: int32 = fs_strlen(name)
  if name_len == 0:
    return -3
  if name_len > MAX_NAME_LEN:
    return -3

  # Check if already exists
  if dir_lookup(parent_ino, name, name_len) != 0:
    return -4  # Already exists

  # Allocate inode
  var ino: int32 = alloc_inode()
  if ino == 0:
    return -5  # No inodes

  # Set up inode
  inode_set_mode(ino, S_IFREG)
  inode_set_size(ino, size)

  # Allocate block for content if needed
  if size > 0:
    var blk: int32 = alloc_block()
    if blk == 0:
      free_inode(ino)
      return -6  # No blocks
    inode_set_block(ino, 0, blk)
    # Copy content
    var p: ptr uint8 = fs_block_ptr(blk)
    var i: int32 = 0
    while i < size:
      if i < BLOCK_SIZE:
        p[i] = content[i]
      i = i + 1

  # Add to parent directory
  if dir_add_entry(parent_ino, name, name_len, ino, FT_FILE) < 0:
    free_inode(ino)
    return -7

  return 0

# Create a directory
proc fs_mkdir(path: ptr uint8): int32 =
  var parent_ino: int32 = path_parent(path)
  if parent_ino == 0:
    return -1
  if inode_is_dir(parent_ino) == 0:
    return -2

  var name: ptr uint8 = path_basename(path)
  var name_len: int32 = fs_strlen(name)
  if name_len == 0:
    return -3
  if name_len > MAX_NAME_LEN:
    return -3

  if dir_lookup(parent_ino, name, name_len) != 0:
    return -4  # Exists

  var ino: int32 = alloc_inode()
  if ino == 0:
    return -5

  inode_set_mode(ino, S_IFDIR)

  # Allocate block for directory entries
  var blk: int32 = alloc_block()
  if blk == 0:
    free_inode(ino)
    return -6
  inode_set_block(ino, 0, blk)
  inode_set_size(ino, BLOCK_SIZE)

  # Add . and .. entries
  dir_add_entry(ino, cast[ptr uint8]("."), 1, ino, FT_DIR)
  dir_add_entry(ino, cast[ptr uint8](".."), 2, parent_ino, FT_DIR)

  # Add to parent
  if dir_add_entry(parent_ino, name, name_len, ino, FT_DIR) < 0:
    free_inode(ino)
    free_block(blk)
    return -7

  return 0

# Delete a file
proc fs_unlink(path: ptr uint8): int32 =
  var ino: int32 = path_resolve(path)
  if ino == 0:
    return -1
  if inode_is_dir(ino) == 1:
    return -2  # Is a directory

  var parent_ino: int32 = path_parent(path)
  var name: ptr uint8 = path_basename(path)
  var name_len: int32 = fs_strlen(name)

  # Remove from parent
  dir_remove_entry(parent_ino, name, name_len)

  # Free blocks
  var i: int32 = 0
  while i < 4:
    var blk: int32 = inode_get_block(ino, i)
    if blk != 0:
      free_block(blk)
    i = i + 1

  free_inode(ino)
  return 0

# Read file content
proc fs_read(path: ptr uint8, buf: ptr uint8, max_size: int32): int32 =
  var ino: int32 = path_resolve(path)
  if ino == 0:
    return -1
  if inode_is_dir(ino) == 1:
    return -2

  var size: int32 = inode_get_size(ino)
  if size > max_size:
    size = max_size

  var blk: int32 = inode_get_block(ino, 0)
  if blk == 0:
    return 0  # Empty file

  var p: ptr uint8 = fs_block_ptr(blk)
  var i: int32 = 0
  while i < size:
    buf[i] = p[i]
    i = i + 1

  return size

# Write to file (create if doesn't exist, overwrite if does)
proc fs_write(path: ptr uint8, content: ptr uint8, size: int32): int32 =
  var ino: int32 = path_resolve(path)

  if ino == 0:
    # File doesn't exist, create it
    return fs_create_file(path, content, size)

  if inode_is_dir(ino) == 1:
    return -2  # Can't write to directory

  # File exists, update content
  var blk: int32 = inode_get_block(ino, 0)
  if blk == 0:
    # No block allocated, allocate one
    blk = alloc_block()
    if blk == 0:
      return -3  # No blocks
    inode_set_block(ino, 0, blk)

  # Update size
  inode_set_size(ino, size)

  # Write content
  var p: ptr uint8 = fs_block_ptr(blk)
  var i: int32 = 0
  while i < size:
    if i < BLOCK_SIZE:
      p[i] = content[i]
    i = i + 1

  return 0

# ============================================================================
# Filesystem initialization
# ============================================================================

proc fs_init() =
  # Clear all filesystem data (32KB)
  # Work around Brainhair compiler bug with large constants (>= 0x8000)
  var i: int32 = 0
  var limit: int32 = 16000
  while i < limit:
    fs_data[i] = cast[uint8](0)
    i = i + 1
  limit = 31000
  while i < limit:
    fs_data[i] = cast[uint8](0)
    i = i + 1
  limit = 32767
  while i < limit:
    fs_data[i] = cast[uint8](0)
    i = i + 1
  fs_data[32767] = cast[uint8](0)

  # Set up superblock (block 0)
  var sb: ptr uint8 = fs_block_ptr(0)
  write32(addr(sb[0]), 0xBF5F5342)  # Magic "BSFS"
  write32(addr(sb[4]), 1)           # Version
  write32(addr(sb[8]), BLOCK_SIZE)
  write32(addr(sb[12]), BLOCK_COUNT)
  write32(addr(sb[16]), INODE_COUNT)

  # Mark reserved blocks as used in block bitmap
  i = 0
  while i < FIRST_DATA_BLOCK:
    bitmap_set(2, i)
    i = i + 1

  # Mark inode 0 as used (reserved)
  bitmap_set(1, 0)

  # Create root directory (inode 1)
  bitmap_set(1, 1)
  inode_set_mode(1, S_IFDIR)
  var root_blk: int32 = alloc_block()
  inode_set_block(1, 0, root_blk)
  inode_set_size(1, BLOCK_SIZE)

  # Add . and .. to root
  dir_add_entry(1, cast[ptr uint8]("."), 1, 1, FT_DIR)
  dir_add_entry(1, cast[ptr uint8](".."), 2, 1, FT_DIR)

  # Create essential directories (limited to avoid stack overflow)
  fs_mkdir(cast[ptr uint8]("/bin"))
  fs_mkdir(cast[ptr uint8]("/etc"))
  fs_mkdir(cast[ptr uint8]("/home"))
  fs_mkdir(cast[ptr uint8]("/tmp"))
  fs_mkdir(cast[ptr uint8]("/dev"))
  fs_mkdir(cast[ptr uint8]("/proc"))

  # Create a few essential files
  fs_create_file(cast[ptr uint8]("/etc/hostname"), cast[ptr uint8]("brainhair"), 9)
  fs_create_file(cast[ptr uint8]("/etc/motd"), cast[ptr uint8]("Welcome to BrainhairOS!"), 23)

  cwd_inode = 1  # Start in root

# ============================================================================
# Virtual Filesystem (procfs/sysfs) handlers
# ============================================================================

# Format integer to decimal string, return length
proc int_to_str(num: int32, buf: ptr uint8): int32 =
  if num == 0:
    buf[0] = cast[uint8](48)
    buf[1] = cast[uint8](0)
    return 1
  var temp: array[12, uint8]
  var pos: int32 = 0
  var n: int32 = num
  if n < 0:
    n = 0 - n
  while n > 0:
    temp[pos] = cast[uint8](48 + (n - (n / 10) * 10))
    n = n / 10
    pos = pos + 1
  # Reverse
  var i: int32 = 0
  while i < pos:
    buf[i] = temp[pos - 1 - i]
    i = i + 1
  buf[pos] = cast[uint8](0)
  return pos

# Append string to buffer, return new position
proc buf_append(buf: ptr uint8, pos: int32, s: ptr uint8): int32 =
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    buf[pos] = s[i]
    pos = pos + 1
    i = i + 1
  return pos

# Append newline
proc buf_newline(buf: ptr uint8, pos: int32): int32 =
  buf[pos] = cast[uint8](10)
  return pos + 1

# Check if path matches a pattern (simple prefix check)
proc path_starts_with(path: ptr uint8, prefix: ptr uint8): int32 =
  var i: int32 = 0
  while cast[int32](prefix[i]) != 0:
    if cast[int32](path[i]) != cast[int32](prefix[i]):
      return 0
    i = i + 1
  return 1

# Check if path exactly equals a string
proc path_equals(path: ptr uint8, target: ptr uint8): int32 =
  var i: int32 = 0
  while true:
    var c1: int32 = cast[int32](path[i])
    var c2: int32 = cast[int32](target[i])
    # Handle space as null for path (command line args)
    if c1 == 32:
      c1 = 0
    if c1 != c2:
      return 0
    if c1 == 0:
      return 1
    i = i + 1
  return 0

# Generate /proc/version content
proc vfs_proc_version(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("BrainhairOS version 0.1 (brainhair@localhost) (bcc 1.0) #1"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/uptime content
proc vfs_proc_uptime(buf: ptr uint8): int32 =
  var ticks: int32 = get_tick_count()
  var secs: int32 = ticks / 18  # ~18 ticks per second
  var pos: int32 = 0
  pos = pos + int_to_str(secs, addr(buf[pos]))
  pos = buf_append(buf, pos, cast[ptr uint8](".0 0.0"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/meminfo content
proc vfs_proc_meminfo(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("MemTotal:       32768 kB"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("MemFree:        30720 kB"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("MemAvailable:   30720 kB"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("Buffers:            0 kB"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("Cached:          1024 kB"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/cpuinfo content
proc vfs_proc_cpuinfo(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("processor       : 0"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("vendor_id       : BrainhairCPU"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("model name      : Brainhair Virtual CPU"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("cpu MHz         : 100.0"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("bogomips        : 200.00"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/filesystems content
proc vfs_proc_filesystems(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("nodev   brainhairfs"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("nodev   procfs"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("nodev   sysfs"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("nodev   devfs"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("nodev   tmpfs"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/mounts content
proc vfs_proc_mounts(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("none / brainhairfs rw 0 0"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("proc /proc procfs rw 0 0"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("sys /sys sysfs rw 0 0"))
  pos = buf_newline(buf, pos)
  pos = buf_append(buf, pos, cast[ptr uint8]("dev /dev devfs rw 0 0"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /proc/cmdline content
proc vfs_proc_cmdline(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("root=/dev/ram0 console=ttyS0"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /sys/kernel/hostname content
proc vfs_sys_hostname(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("brainhair"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /sys/kernel/version content
proc vfs_sys_version(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("#1 BrainhairOS 0.1"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Generate /sys/kernel/ostype content
proc vfs_sys_ostype(buf: ptr uint8): int32 =
  var pos: int32 = 0
  pos = buf_append(buf, pos, cast[ptr uint8]("BrainhairOS"))
  pos = buf_newline(buf, pos)
  buf[pos] = cast[uint8](0)
  return pos

# Build absolute path from relative path and cwd
# Returns length of absolute path
proc build_absolute_path(rel_path: ptr uint8, abs_path: ptr uint8, max_len: int32): int32 =
  var pos: int32 = 0

  # If already absolute, just copy
  if cast[int32](rel_path[0]) == 47:  # '/'
    while cast[int32](rel_path[pos]) != 0:
      if cast[int32](rel_path[pos]) == 32:  # space terminates
        break
      if pos < max_len - 1:
        abs_path[pos] = rel_path[pos]
      pos = pos + 1
    abs_path[pos] = cast[uint8](0)
    return pos

  # Build cwd + "/" + relative path
  var cwd_buf: array[64, uint8]
  fs_getcwd(addr(cwd_buf[0]), 64)

  # Copy cwd
  var i: int32 = 0
  while cast[int32](cwd_buf[i]) != 0:
    if pos < max_len - 1:
      abs_path[pos] = cwd_buf[i]
      pos = pos + 1
    i = i + 1

  # Add / if not at root
  if pos > 1:
    if pos < max_len - 1:
      abs_path[pos] = cast[uint8](47)
      pos = pos + 1
  elif pos == 1:
    if cast[int32](abs_path[0]) != 47:
      abs_path[pos] = cast[uint8](47)
      pos = pos + 1

  # Copy relative path
  i = 0
  while cast[int32](rel_path[i]) != 0:
    if cast[int32](rel_path[i]) == 32:  # space terminates
      break
    if pos < max_len - 1:
      abs_path[pos] = rel_path[i]
      pos = pos + 1
    i = i + 1

  abs_path[pos] = cast[uint8](0)
  return pos

# /etc/passwd content generator
# Returns the content: "root:x:0:0:root:/root:/bin/sh\nnobody:x:65534:65534:nobody:/:/bin/false\n"
proc vfs_etc_passwd(buf: ptr uint8): int32 =
  # Use string copy approach
  var passwd_str: ptr uint8 = cast[ptr uint8]("root:x:0:0:root:/root:/bin/sh\nnobody:x:65534:65534:nobody:/:/bin/false\n")
  var i: int32 = 0
  while cast[int32](passwd_str[i]) != 0:
    buf[i] = passwd_str[i]
    i = i + 1
  buf[i] = cast[uint8](0)
  return i

# /etc/group content generator
# Returns the content: "root:x:0:\nwheel:x:10:root\nnogroup:x:65534:\n"
proc vfs_etc_group(buf: ptr uint8): int32 =
  var group_str: ptr uint8 = cast[ptr uint8]("root:x:0:\nwheel:x:10:root\nnogroup:x:65534:\n")
  var i: int32 = 0
  while cast[int32](group_str[i]) != 0:
    buf[i] = group_str[i]
    i = i + 1
  buf[i] = cast[uint8](0)
  return i

# Check if path is a virtual file and generate content
# Returns: content length, or -1 if not a virtual file
proc vfs_read(path: ptr uint8, buf: ptr uint8, max_size: int32): int32 =
  # /proc files
  if path_equals(path, cast[ptr uint8]("/proc/version")) == 1:
    return vfs_proc_version(buf)
  if path_equals(path, cast[ptr uint8]("/proc/uptime")) == 1:
    return vfs_proc_uptime(buf)
  if path_equals(path, cast[ptr uint8]("/proc/meminfo")) == 1:
    return vfs_proc_meminfo(buf)
  if path_equals(path, cast[ptr uint8]("/proc/cpuinfo")) == 1:
    return vfs_proc_cpuinfo(buf)
  if path_equals(path, cast[ptr uint8]("/proc/filesystems")) == 1:
    return vfs_proc_filesystems(buf)
  if path_equals(path, cast[ptr uint8]("/proc/mounts")) == 1:
    return vfs_proc_mounts(buf)
  if path_equals(path, cast[ptr uint8]("/proc/cmdline")) == 1:
    return vfs_proc_cmdline(buf)
  # /sys files
  if path_equals(path, cast[ptr uint8]("/sys/kernel/hostname")) == 1:
    return vfs_sys_hostname(buf)
  if path_equals(path, cast[ptr uint8]("/sys/kernel/version")) == 1:
    return vfs_sys_version(buf)
  if path_equals(path, cast[ptr uint8]("/sys/kernel/ostype")) == 1:
    return vfs_sys_ostype(buf)
  # /etc files
  if path_equals(path, cast[ptr uint8]("/etc/passwd")) == 1:
    return vfs_etc_passwd(buf)
  if path_equals(path, cast[ptr uint8]("/etc/group")) == 1:
    return vfs_etc_group(buf)
  # Not a virtual file
  return -1

# ============================================================================
# Helper function for cwd path
# ============================================================================

# Find name of inode in parent directory
proc find_name_in_dir(parent_ino: int32, target_ino: int32, name_buf: ptr uint8, max_len: int32): int32 =
  var blk: int32 = inode_get_block(parent_ino, 0)
  if blk == 0:
    return 0
  var p: ptr uint8 = fs_block_ptr(blk)
  var offset: int32 = 0
  while offset < BLOCK_SIZE:
    var ent_ino: int32 = read32(addr(p[offset]))
    if ent_ino == target_ino:
      var name_len: int32 = cast[int32](p[offset + 6])
      if name_len > max_len - 1:
        name_len = max_len - 1
      var i: int32 = 0
      while i < name_len:
        name_buf[i] = p[offset + 8 + i]
        i = i + 1
      name_buf[name_len] = cast[uint8](0)
      return name_len
    offset = offset + DIRENT_SIZE
  return 0

# Get current working directory path
proc fs_getcwd(buf: ptr uint8, size: int32) =
  if cwd_inode == 1:
    buf[0] = cast[uint8](47)  # '/'
    buf[1] = cast[uint8](0)
    return

  # Simple approach: store inodes, then look up names
  var inodes: array[8, int32]
  var count: int32 = 0
  var current: int32 = cwd_inode

  # Walk up to root, recording inode numbers
  while current != 1:
    if count >= 8:
      break
    inodes[count] = current
    count = count + 1
    var parent: int32 = dir_lookup(current, cast[ptr uint8](".."), 2)
    if parent == 0:
      parent = 1
    current = parent

  # Build path from root down
  var pos: int32 = 0
  var i: int32 = count - 1
  while i >= 0:
    buf[pos] = cast[uint8](47)  # '/'
    pos = pos + 1
    # Find this inode's parent
    var ino: int32 = inodes[i]
    var parent_ino: int32 = 1
    if i < count - 1:
      parent_ino = inodes[i + 1]
    else:
      parent_ino = 1  # root is parent
    # Get parent for this inode via ..
    var real_parent: int32 = dir_lookup(ino, cast[ptr uint8](".."), 2)
    if real_parent == 0:
      real_parent = 1
    # Look up name in parent
    var name_buf: array[32, uint8]
    var name_len: int32 = find_name_in_dir(real_parent, ino, addr(name_buf[0]), 32)
    var j: int32 = 0
    while j < name_len:
      if pos < size - 1:
        buf[pos] = name_buf[j]
        pos = pos + 1
      j = j + 1
    i = i - 1
  buf[pos] = cast[uint8](0)

# Parse decimal string to integer
proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  var neg: int32 = 0

  # Skip leading spaces
  while cast[int32](s[i]) == 32:
    i = i + 1

  # Check for negative
  if cast[int32](s[i]) == 45:  # '-'
    neg = 1
    i = i + 1

  while true:
    var c: int32 = cast[int32](s[i])
    if c == 0:
      break
    if c == 32:  # space terminates
      break
    if c < 48:
      break
    if c > 57:
      break
    result = result * 10 + (c - 48)
    i = i + 1

  if neg == 1:
    return 0 - result
  return result

# Parse hex string to integer
proc parse_hex(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0

  # Skip 0x prefix if present
  if s[0] == cast[uint8](48):  # '0'
    if s[1] == cast[uint8](120):  # 'x'
      i = 2
    elif s[1] == cast[uint8](88):  # 'X'
      i = 2

  while true:
    var c: int32 = cast[int32](s[i])
    if c == 0:
      return result
    if c == 32:  # space terminates
      return result

    result = result << 4

    if c >= 48:
      if c <= 57:  # 0-9
        result = result + (c - 48)
      elif c >= 65:
        if c <= 70:  # A-F
          result = result + (c - 55)
        elif c >= 97:
          if c <= 102:  # a-f
            result = result + (c - 87)
    i = i + 1
  return result

# Find next argument in command buffer
proc find_arg(buf: ptr uint8, argnum: int32): ptr uint8 =
  var i: int32 = 0
  var spaces: int32 = 0

  while cast[int32](buf[i]) != 0:
    if cast[int32](buf[i]) == 32:  # space
      spaces = spaces + 1
      # Skip consecutive spaces
      while cast[int32](buf[i + 1]) == 32:
        i = i + 1
      if spaces == argnum:
        return addr(buf[i + 1])
    i = i + 1

  return cast[ptr uint8](0)

# Find output redirection in command buffer
# Returns: position of '>' (or first '>' of '>>'), or -1 if not found
proc find_redirect(buf: ptr uint8, len: int32): int32 =
  var i: int32 = 0
  while i < len:
    if cast[int32](buf[i]) == 62:  # '>'
      return i
    i = i + 1
  return -1

# Check if it's append mode (>>)
proc is_append_redirect(buf: ptr uint8, pos: int32, len: int32): int32 =
  if pos + 1 < len:
    if cast[int32](buf[pos + 1]) == 62:  # second '>'
      return 1
  return 0

# Get filename after redirect, skipping spaces
proc get_redirect_filename(buf: ptr uint8, pos: int32, len: int32): ptr uint8 =
  var i: int32 = pos + 1
  # Skip second '>' if present
  if i < len:
    if cast[int32](buf[i]) == 62:
      i = i + 1
  # Skip spaces
  while i < len:
    if cast[int32](buf[i]) != 32:
      break
    i = i + 1
  if i >= len:
    return cast[ptr uint8](0)
  return addr(buf[i])

# Null-terminate the redirect filename (at first space or end)
proc terminate_filename(filename: ptr uint8) =
  var i: int32 = 0
  while cast[int32](filename[i]) != 0:
    if cast[int32](filename[i]) == 32:  # space
      filename[i] = cast[uint8](0)
      return
    i = i + 1

# Find pipe character in command buffer
# Returns: position of '|', or -1 if not found
proc find_pipe(buf: ptr uint8, len: int32): int32 =
  var i: int32 = 0
  while i < len:
    if cast[int32](buf[i]) == 124:  # '|'
      return i
    i = i + 1
  return -1

# Pipe output buffer (for capturing command output)
var pipe_buf: array[1024, uint8]
var pipe_len: int32 = 0
var pipe_mode: int32 = 0  # 0 = normal, 1 = capturing to pipe_buf

# Add character to pipe buffer
proc pipe_putchar(c: int32) =
  if pipe_len < 1020:
    pipe_buf[pipe_len] = cast[uint8](c)
    pipe_len = pipe_len + 1

# Add string to pipe buffer
proc pipe_print(s: ptr uint8) =
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    pipe_putchar(cast[int32](s[i]))
    i = i + 1

# Add string with newline to pipe buffer
proc pipe_println(s: ptr uint8) =
  pipe_print(s)
  pipe_putchar(10)  # newline

# Check if s2 is a substring starting at position in s1
proc str_contains_at(s1: ptr uint8, pos: int32, s2: ptr uint8, s2_len: int32): int32 =
  var i: int32 = 0
  while i < s2_len:
    if cast[int32](s1[pos + i]) != cast[int32](s2[i]):
      return 0
    i = i + 1
  return 1

# String comparison
proc str_equals(s1: ptr uint8, s2: ptr uint8): int32 =
  var i: int32 = 0
  while true:
    var c1: int32 = cast[int32](s1[i])
    var c2: int32 = cast[int32](s2[i])
    if c1 != c2:
      return 0
    if c1 == 0:
      return 1
    i = i + 1
  return 0

# String copy with max length
proc str_copy(dest: ptr uint8, src: ptr uint8, max_len: int32) =
  var i: int32 = 0
  while i < max_len:
    dest[i] = src[i]
    if src[i] == cast[uint8](0):
      return
    i = i + 1
  dest[max_len - 1] = cast[uint8](0)  # Ensure null-termination

# Print prompt (kprint outputs to both VGA and serial)
proc shell_prompt() =
  vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
  kprint(cast[ptr uint8]("bhos"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  kprint(cast[ptr uint8]("> "))

# Execute a command
proc shell_execute() =
  # Null-terminate the command
  cmd_buffer[cmd_len] = cast[uint8](0)

  # Trim trailing whitespace
  while cmd_len > 0:
    var last_ch: int32 = cast[int32](cmd_buffer[cmd_len - 1])
    if last_ch != 32:  # Not a space
      if last_ch != 9:  # Not a tab
        break
    cmd_len = cmd_len - 1
    cmd_buffer[cmd_len] = cast[uint8](0)

  # Skip empty commands
  if cmd_len == 0:
    return

  # Check for command chaining operators (;, &&, ||)
  # Process ; first (lowest precedence)
  var semi_pos: int32 = find_semicolon(addr(cmd_buffer[0]), cmd_len)
  if semi_pos >= 0:
    # Split at semicolon
    var right_chain: array[128, uint8]
    var chain_start: int32 = semi_pos + 1
    # Skip leading spaces
    while chain_start < cmd_len:
      if cast[int32](cmd_buffer[chain_start]) != 32:
        break
      chain_start = chain_start + 1
    var ci: int32 = 0
    while chain_start + ci < cmd_len:
      right_chain[ci] = cmd_buffer[chain_start + ci]
      ci = ci + 1
    right_chain[ci] = cast[uint8](0)
    var right_chain_len: int32 = ci

    # Terminate left command
    cmd_buffer[semi_pos] = cast[uint8](0)
    cmd_len = semi_pos
    # Trim trailing spaces
    while cmd_len > 0:
      if cast[int32](cmd_buffer[cmd_len - 1]) != 32:
        break
      cmd_len = cmd_len - 1
      cmd_buffer[cmd_len] = cast[uint8](0)

    # Execute left command
    if cmd_len > 0:
      shell_execute()

    # Execute right command unconditionally
    if right_chain_len > 0:
      var cj: int32 = 0
      while cj < right_chain_len:
        cmd_buffer[cj] = right_chain[cj]
        cj = cj + 1
      cmd_buffer[cj] = cast[uint8](0)
      cmd_len = right_chain_len
      shell_execute()
    return

  # Check for && (run second only if first succeeds)
  var and_pos: int32 = find_and_chain(addr(cmd_buffer[0]), cmd_len)
  if and_pos >= 0:
    # Split at &&
    var right_and: array[128, uint8]
    var and_start: int32 = and_pos + 2  # Skip both &
    # Skip leading spaces
    while and_start < cmd_len:
      if cast[int32](cmd_buffer[and_start]) != 32:
        break
      and_start = and_start + 1
    var ai: int32 = 0
    while and_start + ai < cmd_len:
      right_and[ai] = cmd_buffer[and_start + ai]
      ai = ai + 1
    right_and[ai] = cast[uint8](0)
    var right_and_len: int32 = ai

    # Terminate left command
    cmd_buffer[and_pos] = cast[uint8](0)
    cmd_len = and_pos
    # Trim trailing spaces
    while cmd_len > 0:
      if cast[int32](cmd_buffer[cmd_len - 1]) != 32:
        break
      cmd_len = cmd_len - 1
      cmd_buffer[cmd_len] = cast[uint8](0)

    # Execute left command
    last_exit_code = 0  # Assume success
    if cmd_len > 0:
      shell_execute()

    # Execute right command only if left succeeded
    if last_exit_code == 0:
      if right_and_len > 0:
        var aj: int32 = 0
        while aj < right_and_len:
          cmd_buffer[aj] = right_and[aj]
          aj = aj + 1
        cmd_buffer[aj] = cast[uint8](0)
        cmd_len = right_and_len
        shell_execute()
    return

  # Check for || (run second only if first fails)
  var or_pos: int32 = find_or_chain(addr(cmd_buffer[0]), cmd_len)
  if or_pos >= 0:
    # Split at ||
    var right_or: array[128, uint8]
    var or_start: int32 = or_pos + 2  # Skip both |
    # Skip leading spaces
    while or_start < cmd_len:
      if cast[int32](cmd_buffer[or_start]) != 32:
        break
      or_start = or_start + 1
    var oi: int32 = 0
    while or_start + oi < cmd_len:
      right_or[oi] = cmd_buffer[or_start + oi]
      oi = oi + 1
    right_or[oi] = cast[uint8](0)
    var right_or_len: int32 = oi

    # Terminate left command
    cmd_buffer[or_pos] = cast[uint8](0)
    cmd_len = or_pos
    # Trim trailing spaces
    while cmd_len > 0:
      if cast[int32](cmd_buffer[cmd_len - 1]) != 32:
        break
      cmd_len = cmd_len - 1
      cmd_buffer[cmd_len] = cast[uint8](0)

    # Execute left command
    last_exit_code = 1  # Assume failure
    if cmd_len > 0:
      shell_execute()

    # Execute right command only if left failed
    if last_exit_code != 0:
      if right_or_len > 0:
        var oj: int32 = 0
        while oj < right_or_len:
          cmd_buffer[oj] = right_or[oj]
          oj = oj + 1
        cmd_buffer[oj] = cast[uint8](0)
        cmd_len = right_or_len
        shell_execute()
    return

  # Check for pipe
  var pipe_pos: int32 = find_pipe(addr(cmd_buffer[0]), cmd_len)
  if pipe_pos > 0:
    # Found pipe - split and execute
    # Left side: cmd_buffer[0..pipe_pos-1]
    # Right side: cmd_buffer[pipe_pos+1..end]

    # Save right side command
    var right_cmd: array[128, uint8]
    var right_start: int32 = pipe_pos + 1
    # Skip leading spaces
    while right_start < cmd_len:
      if cast[int32](cmd_buffer[right_start]) != 32:
        break
      right_start = right_start + 1
    var ri: int32 = 0
    while right_start + ri < cmd_len:
      right_cmd[ri] = cmd_buffer[right_start + ri]
      ri = ri + 1
    right_cmd[ri] = cast[uint8](0)
    var right_len: int32 = ri

    # Terminate left command at pipe position (skip trailing spaces)
    var left_end: int32 = pipe_pos
    while left_end > 0:
      if cast[int32](cmd_buffer[left_end - 1]) != 32:
        break
      left_end = left_end - 1
    cmd_buffer[left_end] = cast[uint8](0)
    var saved_len: int32 = cmd_len
    cmd_len = left_end

    # Execute left command, capturing output to pipe_buf
    pipe_mode = 1
    pipe_len = 0
    shell_execute()  # Recursive call for left side
    pipe_buf[pipe_len] = cast[uint8](0)
    pipe_mode = 0

    # Now execute right command with pipe input
    # Copy right command to cmd_buffer
    var ci: int32 = 0
    while ci < right_len:
      cmd_buffer[ci] = right_cmd[ci]
      ci = ci + 1
    cmd_buffer[ci] = cast[uint8](0)
    cmd_len = right_len

    # Execute right command with pipe_buf as input
    # For now, support "grep pattern" on piped input
    if cmd_len >= 5:
      if cmd_buffer[0] == cast[uint8](103):  # 'g'
        if cmd_buffer[1] == cast[uint8](114):  # 'r'
          if cmd_buffer[2] == cast[uint8](101):  # 'e'
            if cmd_buffer[3] == cast[uint8](112):  # 'p'
              if cmd_buffer[4] == cast[uint8](32):  # ' '
                # grep on piped input
                var pattern: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                if cast[int32](pattern) != 0:
                  var pattern_len: int32 = fs_strlen(pattern)
                  # Search through pipe_buf line by line
                  var line_start: int32 = 0
                  var pi: int32 = 0
                  while pi <= pipe_len:
                    if pi == pipe_len or cast[int32](pipe_buf[pi]) == 10:
                      # End of line - check if pattern matches
                      var li: int32 = line_start
                      while li < pi:
                        if str_contains_at(addr(pipe_buf[0]), li, pattern, pattern_len) == 1:
                          # Match found - print line
                          var pj: int32 = line_start
                          while pj < pi:
                            var ch: int32 = cast[int32](pipe_buf[pj])
                            vga_putchar(ch)
                            serial_putchar(ch)
                            pj = pj + 1
                          kprintln(cast[ptr uint8](""))
                          li = pi  # Exit inner loop
                        li = li + 1
                      line_start = pi + 1
                    pi = pi + 1
                  cmd_len = saved_len
                  return
    # Support "head" or "head -n N" on piped input
    if cmd_len >= 4:
      if cmd_buffer[0] == cast[uint8](104):  # 'h'
        if cmd_buffer[1] == cast[uint8](101):  # 'e'
          if cmd_buffer[2] == cast[uint8](97):  # 'a'
            if cmd_buffer[3] == cast[uint8](100):  # 'd'
              var num_lines: int32 = 10  # default
              if cmd_len >= 6:
                if cmd_buffer[4] == cast[uint8](32):  # space after head
                  var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  if cast[int32](arg) != 0:
                    num_lines = parse_int(arg)
                    if num_lines <= 0:
                      num_lines = 10
              # Print first N lines from pipe_buf
              var lines_printed: int32 = 0
              var pi: int32 = 0
              while pi < pipe_len:
                if lines_printed >= num_lines:
                  break
                var ch: int32 = cast[int32](pipe_buf[pi])
                vga_putchar(ch)
                serial_putchar(ch)
                if ch == 10:
                  lines_printed = lines_printed + 1
                pi = pi + 1
              if pipe_buf[pipe_len - 1] != cast[uint8](10):
                kprintln(cast[ptr uint8](""))
              cmd_len = saved_len
              return
    # Support "wc" on piped input
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("wc")) == 1:
      var lines: int32 = 0
      var words: int32 = 0
      var chars: int32 = pipe_len
      var in_word: int32 = 0
      var pi: int32 = 0
      while pi < pipe_len:
        var ch: int32 = cast[int32](pipe_buf[pi])
        if ch == 10:
          lines = lines + 1
        if ch == 32 or ch == 10 or ch == 9:
          in_word = 0
        else:
          if in_word == 0:
            words = words + 1
            in_word = 1
        pi = pi + 1
      kprint_dec(lines)
      kprint(cast[ptr uint8](" "))
      kprint_dec(words)
      kprint(cast[ptr uint8](" "))
      kprint_dec(chars)
      kprintln(cast[ptr uint8](""))
      cmd_len = saved_len
      return

    cmd_len = saved_len
    kprintln(cast[ptr uint8]("Pipe error: unsupported right-side command"))
    return

  # Parse and execute command (using if/return to work around elif bug)
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("help")) == 1:
    kprintln(cast[ptr uint8]("Available commands:"))
    kprintln(cast[ptr uint8]("  System: help, clear, ver, uptime, date, reboot"))
    kprintln(cast[ptr uint8]("  Info:   mem, ps, ticks, sysinfo, about"))
    kprintln(cast[ptr uint8]("  Files:  ls, cat, write, touch, rm, cp, mv, mkdir"))
    kprintln(cast[ptr uint8]("  Nav:    cd, pwd, stat, size, df"))
    kprintln(cast[ptr uint8]("  Text:   wc, head, grep, xxd, echo"))
    kprintln(cast[ptr uint8]("  Env:    env, export VAR=value"))
    kprintln(cast[ptr uint8]("  Net:    ping, ifconfig, arp, dns, ntp, httpd, uweb"))
    kprintln(cast[ptr uint8]("  Fun:    banner, hello, spin, guess, countdown"))
    kprintln(cast[ptr uint8]("  Debug:  peek, poke, dump, fill, run, calc"))
    kprintln(cast[ptr uint8]("  Disk:   lsblk, mkfs, mount, lsmnt, dls, dcat, dwrite, dmkdir, dtouch, dinfo"))
    kprintln(cast[ptr uint8]("  User:   id, whoami, groups"))
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("Shell features:"))
    kprintln(cast[ptr uint8]("  Pipes: cmd1 | cmd2 (grep, head, wc)"))
    kprintln(cast[ptr uint8]("  Redirect: echo text > file, echo text >> file"))
    kprintln(cast[ptr uint8]("  Variables: echo $HOME, echo $?, export MY_VAR=value"))
    kprintln(cast[ptr uint8]("  Chaining: cmd1 && cmd2, cmd1 || cmd2, cmd1 ; cmd2"))
    kprintln(cast[ptr uint8]("  Builtins: true, false, exit [code], test, ["))
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("Virtual filesystems:"))
    kprintln(cast[ptr uint8]("  /proc - kernel info (cat /proc/version)"))
    kprintln(cast[ptr uint8]("  /sys  - system config (cat /sys/kernel/ostype)"))
    kprintln(cast[ptr uint8]("  /dev  - device files"))
    return
  # Use byte comparison for commands that don't work with str_equals
  # clear command
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](108):  # 'l'
      if cmd_buffer[2] == cast[uint8](101):  # 'e'
        if cmd_buffer[3] == cast[uint8](97):  # 'a'
          if cmd_buffer[4] == cast[uint8](114):  # 'r'
            if cmd_buffer[5] == cast[uint8](0):
              vga_clear()
              return
  # cls command
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](108):  # 'l'
      if cmd_buffer[2] == cast[uint8](115):  # 's'
        if cmd_buffer[3] == cast[uint8](0):
          vga_clear()
          return
  # pwd command
  if cmd_buffer[0] == cast[uint8](112):  # 'p'
    if cmd_buffer[1] == cast[uint8](119):  # 'w'
      if cmd_buffer[2] == cast[uint8](100):  # 'd'
        if cmd_buffer[3] == cast[uint8](0):
          var pwd_buf: array[64, uint8]
          fs_getcwd(addr(pwd_buf[0]), 64)
          kprintln(addr(pwd_buf[0]))
          return
  # cd command
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](100):  # 'd'
      if cmd_buffer[2] == cast[uint8](0):  # just "cd" - go to root
        cwd_inode = 1
        return
      if cmd_buffer[2] == cast[uint8](32):  # "cd <path>"
        var cd_path: ptr uint8 = addr(cmd_buffer[3])
        var new_ino: int32 = path_resolve(cd_path)
        if new_ino == 0:
          vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
          kprint(cast[ptr uint8]("cd: no such directory: "))
          kprintln(cd_path)
          vga_set_color(VGA_WHITE, VGA_BLACK)
          return
        if inode_is_dir(new_ino) == 0:
          vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
          kprint(cast[ptr uint8]("cd: not a directory: "))
          kprintln(cd_path)
          vga_set_color(VGA_WHITE, VGA_BLACK)
          return
        cwd_inode = new_ino
        return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ticks")) == 1:
    var ticks: int32 = get_tick_count()
    kprint(cast[ptr uint8]("Timer ticks: "))
    vga_print_hex(ticks)
    kprintln(cast[ptr uint8](""))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ver")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8]("Written in Brainhair programming language"))
    kprintln(cast[ptr uint8]("Self-hosted on x86-32 architecture"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("uptime")) == 1:
    var ticks: int32 = get_tick_count()
    # PIT runs at ~18.2 Hz, so ticks/18 ~ seconds
    var seconds: int32 = ticks / 18
    var minutes: int32 = seconds / 60
    seconds = seconds - (minutes * 60)
    kprint(cast[ptr uint8]("System uptime: "))
    kprint_dec(minutes)
    kprint(cast[ptr uint8]("m "))
    kprint_dec(seconds)
    kprintln(cast[ptr uint8]("s"))
    return
  # history - show command history
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("history")) == 1:
    var hi: int32 = 0
    while hi < history_count:
      vga_set_color(VGA_DARK_GREY, VGA_BLACK)
      kprint_dec(hi + 1)
      kprint(cast[ptr uint8]("  "))
      vga_set_color(VGA_WHITE, VGA_BLACK)
      kprintln(history_ptr(hi))
      hi = hi + 1
    return
  # env - show all environment variables
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("env")) == 1:
    var ei: int32 = 0
    while ei < env_count:
      var en: ptr uint8 = env_name_ptr(ei)
      var ev: ptr uint8 = env_value_ptr(ei)
      vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
      kprint(en)
      vga_set_color(VGA_WHITE, VGA_BLACK)
      kprint(cast[ptr uint8]("="))
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      kprintln(ev)
      vga_set_color(VGA_WHITE, VGA_BLACK)
      ei = ei + 1
    return
  # export VAR=value - set environment variable
  if cmd_buffer[0] == cast[uint8](101):  # 'e'
    if cmd_buffer[1] == cast[uint8](120):  # 'x'
      if cmd_buffer[2] == cast[uint8](112):  # 'p'
        if cmd_buffer[3] == cast[uint8](111):  # 'o'
          if cmd_buffer[4] == cast[uint8](114):  # 'r'
            if cmd_buffer[5] == cast[uint8](116):  # 't'
              if cmd_buffer[6] == cast[uint8](32):  # ' '
                # Parse VAR=value
                var name_buf: array[64, uint8]
                var value_buf: array[128, uint8]
                var src: int32 = 7
                var dst: int32 = 0
                # Copy name until '='
                while src < cmd_len:
                  if cast[int32](cmd_buffer[src]) == 61:  # '='
                    break
                  name_buf[dst] = cmd_buffer[src]
                  dst = dst + 1
                  src = src + 1
                name_buf[dst] = cast[uint8](0)
                if cast[int32](cmd_buffer[src]) == 61:
                  src = src + 1
                  # Copy value
                  dst = 0
                  while src < cmd_len:
                    value_buf[dst] = cmd_buffer[src]
                    dst = dst + 1
                    src = src + 1
                  value_buf[dst] = cast[uint8](0)
                  env_set(addr(name_buf[0]), addr(value_buf[0]))
                  return
                kprintln(cast[ptr uint8]("Usage: export VAR=value"))
                return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ps")) == 1:
    kprintln(cast[ptr uint8]("PID  STATE"))
    kprintln(cast[ptr uint8]("---  --------"))
    var ps_pid: int32 = 0
    var ps_count: int32 = 0
    while ps_pid < 16:
      var state: int32 = get_process_state(ps_pid)
      if state > 0:  # Not unused (state >= 1)
        kprint_dec(ps_pid)
        kprint(cast[ptr uint8]("    "))
        if state == 1:
          vga_set_color(VGA_YELLOW, VGA_BLACK)
          kprintln(cast[ptr uint8]("READY"))
        elif state == 2:
          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
          kprintln(cast[ptr uint8]("RUNNING"))
        elif state == 3:
          vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
          kprintln(cast[ptr uint8]("BLOCKED"))
        elif state == 4:
          vga_set_color(VGA_DARK_GREY, VGA_BLACK)
          kprintln(cast[ptr uint8]("ZOMBIE"))
        elif state == 5:
          vga_set_color(VGA_BROWN, VGA_BLACK)
          kprintln(cast[ptr uint8]("STOPPED"))
        else:
          kprintln(cast[ptr uint8]("UNKNOWN"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        ps_count = ps_count + 1
      ps_pid = ps_pid + 1
    kprint(cast[ptr uint8]("Total: "))
    kprint_dec(ps_count)
    kprintln(cast[ptr uint8](" process(es)"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("mounts")) == 1:
    kprintln(cast[ptr uint8]("Filesystem   Mount Point"))
    kprintln(cast[ptr uint8]("---------    -----------"))
    var m_idx: int32 = 0
    var m_count: int32 = vfs_mount_count()
    while m_idx < m_count:
      var fs_type: int32 = vfs_get_mount_type(m_idx)
      if fs_type == FS_TYPE_RAMFS:
        kprint(cast[ptr uint8]("ramfs        "))
      elif fs_type == FS_TYPE_BRAINFS:
        kprint(cast[ptr uint8]("brainfs      "))
      elif fs_type == FS_TYPE_DEVFS:
        kprint(cast[ptr uint8]("devfs        "))
      elif fs_type == FS_TYPE_PROCFS:
        kprint(cast[ptr uint8]("procfs       "))
      elif fs_type == FS_TYPE_SYSFS:
        kprint(cast[ptr uint8]("sysfs        "))
      elif fs_type == FS_TYPE_TMPFS:
        kprint(cast[ptr uint8]("tmpfs        "))
      else:
        kprint(cast[ptr uint8]("unknown      "))
      var m_path: ptr uint8 = vfs_get_mount_path(m_idx)
      if m_path != cast[ptr uint8](0):
        kprintln(m_path)
      else:
        kprintln(cast[ptr uint8]("(null)"))
      m_idx = m_idx + 1
    return
  # devices - list /dev devices
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("devices")) == 1:
    kprintln(cast[ptr uint8]("Name       Type"))
    kprintln(cast[ptr uint8]("----       ----"))
    var dev_idx: int32 = 0
    var dev_count: int32 = devfs_get_device_count()
    while dev_idx < dev_count:
      var dev_name: ptr uint8 = devfs_get_name(dev_idx)
      if dev_name != cast[ptr uint8](0):
        kprint(dev_name)
        # Pad with spaces
        var name_len: int32 = fs_strlen(dev_name)
        while name_len < 11:
          kprint(cast[ptr uint8](" "))
          name_len = name_len + 1
        var dev_type: int32 = devfs_get_type(dev_idx)
        if dev_type == DEV_TYPE_CHAR:
          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
          kprintln(cast[ptr uint8]("char"))
        elif dev_type == DEV_TYPE_BLOCK:
          vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
          kprintln(cast[ptr uint8]("block"))
        else:
          kprintln(cast[ptr uint8]("unknown"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
      dev_idx = dev_idx + 1
    kprint(cast[ptr uint8]("Total: "))
    kprint_dec(dev_count)
    kprintln(cast[ptr uint8](" device(s)"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("fork")) == 1:
    kprintln(cast[ptr uint8]("Testing fork()..."))
    var pid: int32 = fork()
    if pid < 0:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("fork() failed!"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
      return
    if pid == 0:
      # Child process
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      kprint(cast[ptr uint8]("Child process (PID "))
      kprint_dec(get_current_pid())
      kprintln(cast[ptr uint8](") running!"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
      exit_process(42)  # Exit with code 42
      # Never returns
    # Parent process
    kprint(cast[ptr uint8]("Parent: forked child PID "))
    kprint_dec(pid)
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("Parent: waiting for child..."))
    var status: int32 = 0
    var wpid: int32 = waitpid(pid, addr(status))
    kprint(cast[ptr uint8]("Parent: child "))
    kprint_dec(wpid)
    kprint(cast[ptr uint8](" exited with code "))
    kprint_dec(status)
    kprintln(cast[ptr uint8](""))
    return
  # kill <pid> [signal] - send signal to process
  # Check for "kill " (k=107, i=105, l=108, l=108, space=32)
  if cmd_buffer[0] == cast[uint8](107):  # 'k'
    if cmd_buffer[1] == cast[uint8](105):  # 'i'
      if cmd_buffer[2] == cast[uint8](108):  # 'l'
        if cmd_buffer[3] == cast[uint8](108):  # 'l'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # Parse PID
            var kill_ptr: ptr uint8 = addr(cmd_buffer[5])
            var kill_pid: int32 = parse_int(kill_ptr)
            # Check for signal arg (default is SIGTERM=15)
            var kill_sig: int32 = SIGTERM
            # Find space after PID
            var kill_idx: int32 = 0
            while cast[int32](kill_ptr[kill_idx]) != 0 and cast[int32](kill_ptr[kill_idx]) != 32:
              kill_idx = kill_idx + 1
            if cast[int32](kill_ptr[kill_idx]) == 32:
              # Skip spaces
              while cast[int32](kill_ptr[kill_idx]) == 32:
                kill_idx = kill_idx + 1
              if cast[int32](kill_ptr[kill_idx]) != 0:
                kill_sig = parse_int(addr(kill_ptr[kill_idx]))
            # Validate
            if kill_pid <= 0:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprintln(cast[ptr uint8]("Usage: kill <pid> [signal]"))
              vga_set_color(VGA_WHITE, VGA_BLACK)
              return
            # Send signal
            var kill_result: int32 = sys_kill(kill_pid, kill_sig)
            if kill_result == 0:
              vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
              kprint(cast[ptr uint8]("Sent signal "))
              kprint_dec(kill_sig)
              kprint(cast[ptr uint8](" to PID "))
              kprint_dec(kill_pid)
              kprintln(cast[ptr uint8](""))
              vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprintln(cast[ptr uint8]("Failed to send signal"))
              vga_set_color(VGA_WHITE, VGA_BLACK)
            return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("color")) == 1:
    kprint(cast[ptr uint8]("Colors: "))
    var c: int32 = 0
    while c < 16:
      vga_set_color(c, VGA_BLACK)
      vga_putchar(42)  # '*'
      c = c + 1
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("banner")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("  ____            _       _           _       ___  ____  "))
    kprintln(cast[ptr uint8](" | __ ) _ __ __ _(_)_ __ | |__   __ _(_)_ __ / _ \\/ ___| "))
    kprintln(cast[ptr uint8](" |  _ \\| '__/ _` | | '_ \\| '_ \\ / _` | | '__| | | \\___ \\ "))
    kprintln(cast[ptr uint8](" | |_) | | | (_| | | | | | | | | (_| | | |  | |_| |___) |"))
    kprintln(cast[ptr uint8](" |____/|_|  \\__,_|_|_| |_|_| |_|\\__,_|_|_|   \\___/|____/ "))
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("hello")) == 1:
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("Hello, World from BrainhairOS!"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("spin")) == 1:
    # Show a spinning animation
    var frames: array[4, uint8]
    frames[0] = cast[uint8](124)  # |
    frames[1] = cast[uint8](47)   # /
    frames[2] = cast[uint8](45)   # -
    frames[3] = cast[uint8](92)   # \
    kprint(cast[ptr uint8]("Spinning: "))
    var spin_col: int32 = vga_col
    var spin_row: int32 = vga_row
    var frame: int32 = 0
    var count: int32 = 0
    while count < 40:
      vga_putchar_at(cast[int32](frames[frame]), spin_col, spin_row, vga_color)
      frame = (frame + 1) - ((frame + 1) / 4) * 4  # frame % 4
      # Delay
      var d: int32 = 0
      while d < 1000000:
        d = d + 1
      count = count + 1
    vga_col = spin_col + 1
    kprintln(cast[ptr uint8](" Done!"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("guess")) == 1:
    # Simple number guessing game
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("=== Number Guessing Game ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8]("I'm thinking of a number 1-100."))
    kprintln(cast[ptr uint8]("Type a number and press Enter."))
    kprintln(cast[ptr uint8](""))

    # Generate "random" number using tick count
    var secret: int32 = get_tick_count()
    secret = ((secret * 1103515245 + 12345) / 65536) - (((secret * 1103515245 + 12345) / 65536) / 100) * 100
    if secret < 1:
      secret = secret + 100
    if secret > 100:
      secret = secret - 100

    var guess_count: int32 = 0
    var game_buf: array[16, uint8]
    var game_len: int32 = 0
    var game_done: int32 = 0

    while game_done == 0:
      kprint(cast[ptr uint8]("Guess: "))
      game_len = 0

      # Read guess
      var reading: int32 = 1
      while reading == 1:
        var avail: int32 = keyboard_available()
        if avail > 0:
          var c: int32 = keyboard_read_char()
          if c == 13:  # Enter
            kprintln(cast[ptr uint8](""))
            reading = 0
          elif c >= 48:
            if c <= 57:  # 0-9
              if game_len < 15:
                game_buf[game_len] = cast[uint8](c)
                game_len = game_len + 1
                vga_putchar(c)

      # Parse number
      game_buf[game_len] = cast[uint8](0)
      var guess: int32 = 0
      var gi: int32 = 0
      while gi < game_len:
        guess = guess * 10 + (cast[int32](game_buf[gi]) - 48)
        gi = gi + 1

      guess_count = guess_count + 1

      if guess == secret:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        kprint(cast[ptr uint8]("Correct! You got it in "))
        kprint_dec(guess_count)
        kprintln(cast[ptr uint8](" guesses!"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        game_done = 1
      elif guess < secret:
        kprintln(cast[ptr uint8]("Too low!"))
      else:
        kprintln(cast[ptr uint8]("Too high!"))
  if cmd_buffer[0] == cast[uint8](112):  # 'p'
    if cmd_buffer[1] == cast[uint8](101):  # 'e'
      if cmd_buffer[2] == cast[uint8](101):  # 'e'
        if cmd_buffer[3] == cast[uint8](107):  # 'k'
          # peek command
          var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](arg) != 0:
            var addr_val: int32 = parse_hex(arg)
            var mem: ptr uint8 = cast[ptr uint8](addr_val)
            var val: int32 = cast[int32](mem[0])
            kprint(cast[ptr uint8]("["))
            vga_print_hex(addr_val)
            kprint(cast[ptr uint8]("] = "))
            vga_print_hex(val)
            kprintln(cast[ptr uint8](""))
          else:
            kprintln(cast[ptr uint8]("Usage: peek <hex_addr>"))
      elif cmd_buffer[2] == cast[uint8](111):  # 'o'
        if cmd_buffer[3] == cast[uint8](107):  # 'k'
          if cmd_buffer[4] == cast[uint8](101):  # 'e'
            # poke command
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                var addr_val: int32 = parse_hex(arg1)
                var val: int32 = parse_hex(arg2)
                var mem: ptr uint8 = cast[ptr uint8](addr_val)
                mem[0] = cast[uint8](val)
                kprint(cast[ptr uint8]("Wrote "))
                vga_print_hex(val)
                kprint(cast[ptr uint8](" to "))
                vga_print_hex(addr_val)
                kprintln(cast[ptr uint8](""))
              else:
                kprintln(cast[ptr uint8]("Usage: poke <hex_addr> <hex_val>"))
            else:
              kprintln(cast[ptr uint8]("Usage: poke <hex_addr> <hex_val>"))
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](117):  # 'u'
      if cmd_buffer[2] == cast[uint8](109):  # 'm'
        if cmd_buffer[3] == cast[uint8](112):  # 'p'
          # dump command - show 64 bytes
          var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](arg) != 0:
            var addr_val: int32 = parse_hex(arg)
            var mem: ptr uint8 = cast[ptr uint8](addr_val)
            var row: int32 = 0
            while row < 4:
              vga_print_hex(addr_val + row * 16)
              kprint(cast[ptr uint8](": "))
              var col: int32 = 0
              while col < 16:
                var byte_val: int32 = cast[int32](mem[row * 16 + col])
                # Print hex byte (2 digits)
                var hi: int32 = (byte_val >> 4) & 0xF
                var lo: int32 = byte_val & 0xF
                if hi < 10:
                  vga_putchar(48 + hi)
                else:
                  vga_putchar(55 + hi)
                if lo < 10:
                  vga_putchar(48 + lo)
                else:
                  vga_putchar(55 + lo)
                vga_putchar(32)  # space
                col = col + 1
              # Print ASCII
              kprint(cast[ptr uint8](" |"))
              col = 0
              while col < 16:
                var byte_val: int32 = cast[int32](mem[row * 16 + col])
                if byte_val >= 32:
                  if byte_val < 127:
                    vga_putchar(byte_val)
                  else:
                    vga_putchar(46)  # '.'
                else:
                  vga_putchar(46)  # '.'
                col = col + 1
              kprintln(cast[ptr uint8]("|"))
              row = row + 1
            return
          else:
            kprintln(cast[ptr uint8]("Usage: dump <hex_addr>"))
            return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("run")) == 1:
    kprintln(cast[ptr uint8]("Spawning test process..."))
    var pid: int32 = sys_spawn(cast[int32](addr(test_process)))
    if pid >= 0:
      kprint(cast[ptr uint8]("Created process with PID "))
      kprint_dec(pid)
      kprintln(cast[ptr uint8](""))
      kprintln(cast[ptr uint8]("(Process runs in background - use 'ps' to see)"))
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("Failed to spawn process!"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  # ping command - check "pi" prefix (pwd has 'w' at pos 1, so "pi" is unique)
  if cmd_buffer[0] == cast[uint8](112):  # 'p'
    if cmd_buffer[1] == cast[uint8](105):  # 'i' (not 'w' as in pwd)
      if cmd_buffer[4] == cast[uint8](32) or cmd_buffer[4] == cast[uint8](0):  # ' ' or null
        if cmd_len < 6:
          kprintln(cast[ptr uint8]("Usage: ping <ip>"))
          kprintln(cast[ptr uint8]("Example: ping 10.0.2.2"))
          return
        # Parse IP address from argument
        var arg_start: int32 = 5  # After "ping "
        var dest_ip: array[4, uint8]
        var octet: int32 = 0
        var octet_idx: int32 = 0
        var parse_i: int32 = arg_start
        while parse_i < cmd_len:
          var c: int32 = cast[int32](cmd_buffer[parse_i])
          if c >= 48:
            if c <= 57:
              octet = octet * 10 + (c - 48)
          if c == 46:  # '.'
            if octet_idx < 4:
              dest_ip[octet_idx] = cast[uint8](octet)
              octet_idx = octet_idx + 1
              octet = 0
          parse_i = parse_i + 1
        if octet_idx < 4:
          dest_ip[octet_idx] = cast[uint8](octet)

        kprint(cast[ptr uint8]("PING "))
        kprint_dec(cast[int32](dest_ip[0]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](dest_ip[1]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](dest_ip[2]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](dest_ip[3]))
        kprintln(cast[ptr uint8](":"))

        # Send 4 pings
        var ping_count: int32 = 0
        var recv_count: int32 = 0
        while ping_count < 4:
          icmp_send_ping(addr(dest_ip[0]))
          kprint(cast[ptr uint8]("  seq="))
          kprint_dec(ping_seq)
          kprint(cast[ptr uint8](" "))

          # Wait up to 2 seconds for reply (poll network every 10ms)
          var wait: int32 = 0
          while wait < 200:
            net_poll()
            if ping_received == 1:
              wait = 300  # Break
            else:
              # Simple delay
              var delay: int32 = 0
              while delay < 50000:
                delay = delay + 1
              wait = wait + 1

          if ping_received == 1:
            var rtt: int32 = ping_reply_time - ping_send_time
            vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
            kprint(cast[ptr uint8]("Reply: time="))
            kprint_dec(rtt)
            kprintln(cast[ptr uint8]("ms"))
            vga_set_color(VGA_WHITE, VGA_BLACK)
            recv_count = recv_count + 1
            ping_received = 0
          else:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            kprintln(cast[ptr uint8]("timeout"))
            vga_set_color(VGA_WHITE, VGA_BLACK)

          ping_count = ping_count + 1

        kprint(cast[ptr uint8]("--- "))
        kprint_dec(recv_count)
        kprint(cast[ptr uint8]("/"))
        kprint_dec(ping_count)
        kprintln(cast[ptr uint8](" packets received ---"))
        return
  # ifconfig command - check "if" prefix + length 8 (fewer nesting levels)
  if cmd_buffer[0] == cast[uint8](105):  # 'i'
    if cmd_buffer[1] == cast[uint8](102):  # 'f'
      if cmd_buffer[8] == cast[uint8](0):  # null at position 8 = 8-char command
        kprintln(cast[ptr uint8]("Network Configuration:"))
        kprint(cast[ptr uint8]("  MAC: "))
        var mac_i: int32 = 0
        while mac_i < 6:
          if cast[int32](my_mac[mac_i]) < 16:
            kprint(cast[ptr uint8]("0"))
          vga_print_hex(cast[int32](my_mac[mac_i]))
          if mac_i < 5:
            kprint(cast[ptr uint8](":"))
          mac_i = mac_i + 1
        kprintln(cast[ptr uint8](""))
        kprint(cast[ptr uint8]("  IP:  "))
        kprint_dec(cast[int32](my_ip[0]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](my_ip[1]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](my_ip[2]))
        kprint(cast[ptr uint8]("."))
        kprint_dec(cast[int32](my_ip[3]))
        kprintln(cast[ptr uint8](""))
        kprint(cast[ptr uint8]("  ARP entries: "))
        kprint_dec(arp_count)
        kprintln(cast[ptr uint8](""))
        return
  # arp command - use byte comparison for "arp"
  if cmd_buffer[0] == cast[uint8](97):   # 'a'
    if cmd_buffer[1] == cast[uint8](114):  # 'r'
      if cmd_buffer[2] == cast[uint8](112):  # 'p'
        if cmd_buffer[3] == cast[uint8](0):  # null terminator
          kprintln(cast[ptr uint8]("ARP Cache:"))
          if arp_count == 0:
            kprintln(cast[ptr uint8]("  (empty)"))
          else:
            var arp_i: int32 = 0
            while arp_i < arp_count:
              kprint(cast[ptr uint8]("  "))
              kprint_dec(cast[int32](arp_ip[arp_i * 4]))
              kprint(cast[ptr uint8]("."))
              kprint_dec(cast[int32](arp_ip[arp_i * 4 + 1]))
              kprint(cast[ptr uint8]("."))
              kprint_dec(cast[int32](arp_ip[arp_i * 4 + 2]))
              kprint(cast[ptr uint8]("."))
              kprint_dec(cast[int32](arp_ip[arp_i * 4 + 3]))
              kprint(cast[ptr uint8](" -> "))
              var mac_j: int32 = 0
              while mac_j < 6:
                if cast[int32](arp_mac[arp_i * 6 + mac_j]) < 16:
                  kprint(cast[ptr uint8]("0"))
                vga_print_hex(cast[int32](arp_mac[arp_i * 6 + mac_j]))
                if mac_j < 5:
                  kprint(cast[ptr uint8](":"))
                mac_j = mac_j + 1
              kprintln(cast[ptr uint8](""))
              arp_i = arp_i + 1
          return
  # netdebug command - toggle network debug mode (n-e-t-d = 110,101,116,100)
  if cmd_buffer[0] == cast[uint8](110):  # 'n'
    if cmd_buffer[1] == cast[uint8](101):  # 'e'
      if cmd_buffer[2] == cast[uint8](116):  # 't'
        if cmd_buffer[3] == cast[uint8](100):  # 'd'
          if cmd_buffer[4] == cast[uint8](0):  # null (just "netd")
            if net_debug == 0:
              net_debug = 1
              kprintln(cast[ptr uint8]("Network debug: ON"))
            else:
              net_debug = 0
              kprintln(cast[ptr uint8]("Network debug: OFF"))
            return
  # dns command - resolve hostname to IP (d-n-s = 100,110,115)
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](110):  # 'n'
      if cmd_buffer[2] == cast[uint8](115):  # 's'
        if cmd_buffer[3] == cast[uint8](32):  # ' '
          # Get hostname from argument
          var dns_hostname: ptr uint8 = addr(cmd_buffer[4])
          if cast[int32](dns_hostname[0]) == 0:
            kprintln(cast[ptr uint8]("Usage: dns <hostname>"))
            kprintln(cast[ptr uint8]("Example: dns google.com"))
            return
          kprint(cast[ptr uint8]("Resolving "))
          kprint(dns_hostname)
          kprintln(cast[ptr uint8]("..."))
          var result: int32 = dns_resolve(dns_hostname)
          if result == 1:
            vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
            kprint(dns_hostname)
            kprint(cast[ptr uint8](" -> "))
            kprint_dec(cast[int32](dns_result_ip[0]))
            kprint(cast[ptr uint8]("."))
            kprint_dec(cast[int32](dns_result_ip[1]))
            kprint(cast[ptr uint8]("."))
            kprint_dec(cast[int32](dns_result_ip[2]))
            kprint(cast[ptr uint8]("."))
            kprint_dec(cast[int32](dns_result_ip[3]))
            kprintln(cast[ptr uint8](""))
            vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            kprintln(cast[ptr uint8]("DNS lookup failed (timeout or no answer)"))
            vga_set_color(VGA_WHITE, VGA_BLACK)
          return
        if cmd_buffer[3] == cast[uint8](0):  # Just "dns" with no args
          kprintln(cast[ptr uint8]("Usage: dns <hostname>"))
          kprintln(cast[ptr uint8]("Example: dns google.com"))
          return
  # ntp command - sync time (n-t-p = 110,116,112)
  if cmd_buffer[0] == cast[uint8](110):  # 'n'
    if cmd_buffer[1] == cast[uint8](116):  # 't'
      if cmd_buffer[2] == cast[uint8](112):  # 'p'
        if cmd_buffer[3] == cast[uint8](0):  # null terminator
          ntp_sync()
          return
  # date command - show current time (d-a-t-e = 100,97,116,101)
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](97):  # 'a'
      if cmd_buffer[2] == cast[uint8](116):  # 't'
        if cmd_buffer[3] == cast[uint8](101):  # 'e'
          if cmd_buffer[4] == cast[uint8](0):  # null terminator
            print_time()
            return
  # httpd command - start simple HTTP server (h-t-t-p-d = 104,116,116,112,100)
  if cmd_buffer[0] == cast[uint8](104):  # 'h'
    if cmd_buffer[1] == cast[uint8](116):  # 't'
      if cmd_buffer[2] == cast[uint8](116):  # 't'
        if cmd_buffer[3] == cast[uint8](112):  # 'p'
          if cmd_buffer[4] == cast[uint8](100):  # 'd'
            if cmd_buffer[5] == cast[uint8](0):  # null terminator
              run_httpd()
              return
  # webapp - Flask-style demo (kernel mode)
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("webapp")) == 1:
    run_webapp()
    return
  # uweb - userland webapp (ELF binary)
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("uweb")) == 1:
    run_userland_webapp()
    return
  # VTNext applications
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("desktop")) == 1:
    run_vtn_desktop()
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("vtn_demo")) == 1:
    run_vtn_demo_kernel()
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("pong")) == 1:
    run_vtn_app(get_vtn_pong_bin(), get_vtn_pong_bin_size(), cast[ptr uint8]("VTNext Pong"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("edit")) == 1:
    run_vtn_app(get_vtn_edit_bin(), get_vtn_edit_bin_size(), cast[ptr uint8]("VTNext Editor"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("vtn_shell")) == 1:
    run_vtn_app(get_vtn_shell_bin(), get_vtn_shell_bin_size(), cast[ptr uint8]("VTNext Shell"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("2048")) == 1:
    run_vtn_app(get_2048_bin(), get_2048_bin_size(), cast[ptr uint8]("2048 Game"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("rand")) == 1:
    # Generate pseudo-random number using tick count and LCG
    var seed: int32 = get_tick_count()
    seed = seed * 1103515245 + 12345
    seed = (seed / 65536) & 0x7FFF
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprint(cast[ptr uint8]("Random: "))
    kprint_dec(seed)
    kprint(cast[ptr uint8](" ("))
    vga_print_hex(seed)
    kprintln(cast[ptr uint8](")"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("test")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("=== Kernel Self-Tests ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    # Test 1: Memory write/read
    kprint(cast[ptr uint8]("[1] Memory test...   "))
    var test_addr: ptr uint8 = cast[ptr uint8](0x90000)
    test_addr[0] = cast[uint8](0xAB)
    test_addr[1] = cast[uint8](0xCD)
    if cast[int32](test_addr[0]) == 0xAB:
      if cast[int32](test_addr[1]) == 0xCD:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        kprintln(cast[ptr uint8]("PASS"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
      else:
        vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
        kprintln(cast[ptr uint8]("FAIL"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 2: Timer running
    kprint(cast[ptr uint8]("[2] Timer test...    "))
    var t1: int32 = get_tick_count()
    var delay: int32 = 0
    while delay < 500000:
      delay = delay + 1
    var t2: int32 = get_tick_count()
    if t2 > t1:
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      kprint(cast[ptr uint8]("PASS ("))
      kprint_dec(t2 - t1)
      kprintln(cast[ptr uint8](" ticks)"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 3: Arithmetic
    kprint(cast[ptr uint8]("[3] Arithmetic...    "))
    var arith_pass: int32 = 1
    if 5 + 3 != 8:
      arith_pass = 0
    if 10 - 7 != 3:
      arith_pass = 0
    if 6 * 7 != 42:
      arith_pass = 0
    if 100 / 5 != 20:
      arith_pass = 0
    if arith_pass == 1:
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      kprintln(cast[ptr uint8]("PASS"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 4: String comparison
    kprint(cast[ptr uint8]("[4] String cmp...    "))
    if str_equals(cast[ptr uint8]("hello"), cast[ptr uint8]("hello")) == 1:
      if str_equals(cast[ptr uint8]("hello"), cast[ptr uint8]("world")) == 0:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        kprintln(cast[ptr uint8]("PASS"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
      else:
        vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
        kprintln(cast[ptr uint8]("FAIL"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      kprintln(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("All tests complete!"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  if cmd_buffer[0] == cast[uint8](102):  # 'f'
    if cmd_buffer[1] == cast[uint8](105):  # 'i'
      if cmd_buffer[2] == cast[uint8](108):  # 'l'
        if cmd_buffer[3] == cast[uint8](108):  # 'l'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # fill command: fill <addr> <value> <count>
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            var arg3: ptr uint8 = find_arg(addr(cmd_buffer[0]), 3)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                if cast[int32](arg3) != 0:
                  var addr_val: int32 = parse_hex(arg1)
                  var val: int32 = parse_hex(arg2)
                  var count: int32 = parse_int(arg3)
                  if count > 0:
                    if count > 4096:
                      count = 4096
                      kprintln(cast[ptr uint8]("(limited to 4096 bytes)"))
                    var mem: ptr uint8 = cast[ptr uint8](addr_val)
                    var i: int32 = 0
                    while i < count:
                      mem[i] = cast[uint8](val)
                      i = i + 1
                    kprint(cast[ptr uint8]("Filled "))
                    kprint_dec(count)
                    kprint(cast[ptr uint8](" bytes at "))
                    vga_print_hex(addr_val)
                    kprint(cast[ptr uint8](" with "))
                    vga_print_hex(val)
                    kprintln(cast[ptr uint8](""))
                  else:
                    kprintln(cast[ptr uint8]("Count must be > 0"))
                else:
                  kprintln(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
              else:
                kprintln(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
            else:
              kprintln(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](97):  # 'a'
      if cmd_buffer[2] == cast[uint8](108):  # 'l'
        if cmd_buffer[3] == cast[uint8](99):  # 'c'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # calc command: calc <num> <op> <num>
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            var arg3: ptr uint8 = find_arg(addr(cmd_buffer[0]), 3)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                if cast[int32](arg3) != 0:
                  var num1: int32 = parse_int(arg1)
                  var num2: int32 = parse_int(arg3)
                  var op: int32 = cast[int32](arg2[0])
                  var result: int32 = 0
                  var valid: int32 = 1
                  if op == 43:  # '+'
                    result = num1 + num2
                  elif op == 45:  # '-'
                    result = num1 - num2
                  elif op == 42:  # '*'
                    result = num1 * num2
                  elif op == 47:  # '/'
                    if num2 == 0:
                      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                      kprintln(cast[ptr uint8]("Error: Division by zero"))
                      vga_set_color(VGA_WHITE, VGA_BLACK)
                      valid = 0
                    else:
                      result = num1 / num2
                  elif op == 37:  # '%'
                    if num2 == 0:
                      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                      kprintln(cast[ptr uint8]("Error: Division by zero"))
                      vga_set_color(VGA_WHITE, VGA_BLACK)
                      valid = 0
                    else:
                      result = num1 - (num1 / num2) * num2
                  elif op == 38:  # '&'
                    result = num1 & num2
                  elif op == 124:  # '|'
                    result = num1 | num2
                  elif op == 94:  # '^'
                    result = num1 ^ num2
                  else:
                    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                    kprint(cast[ptr uint8]("Unknown operator: "))
                    vga_putchar(op)
                    kprintln(cast[ptr uint8](""))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                    valid = 0
                  if valid == 1:
                    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                    kprint(cast[ptr uint8]("= "))
                    kprint_dec(result)
                    kprint(cast[ptr uint8](" ("))
                    vga_print_hex(result)
                    kprintln(cast[ptr uint8](")"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  kprintln(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
                  kprintln(cast[ptr uint8]("  Ops: + - * / % & | ^"))
              else:
                kprintln(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
            else:
              kprintln(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
              kprintln(cast[ptr uint8]("  Ops: + - * / % & | ^"))
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](111):  # 'o'
      if cmd_buffer[2] == cast[uint8](117):  # 'u'
        if cmd_buffer[3] == cast[uint8](110):  # 'n'
          if cmd_buffer[4] == cast[uint8](116):  # 't'
            if cmd_buffer[5] == cast[uint8](100):  # 'd'
              if cmd_buffer[6] == cast[uint8](111):  # 'o'
                if cmd_buffer[7] == cast[uint8](119):  # 'w'
                  if cmd_buffer[8] == cast[uint8](110):  # 'n'
                    if cmd_buffer[9] == cast[uint8](32):  # ' '
                      # countdown N
                      var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                      if cast[int32](arg) != 0:
                        var n: int32 = parse_int(arg)
                        if n > 100:
                          n = 100
                        if n > 0:
                          kprintln(cast[ptr uint8](""))
                          while n >= 0:
                            vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                            kprint(cast[ptr uint8]("\r"))
                            kprint(cast[ptr uint8]("  "))
                            kprint_dec(n)
                            kprint(cast[ptr uint8]("   "))
                            vga_set_color(VGA_WHITE, VGA_BLACK)
                            # Delay ~1 second (18 ticks)
                            var start_tick: int32 = get_tick_count()
                            while get_tick_count() - start_tick < 18:
                              discard
                            n = n - 1
                          kprintln(cast[ptr uint8](""))
                          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                          kprintln(cast[ptr uint8]("*** BOOM! ***"))
                          vga_set_color(VGA_WHITE, VGA_BLACK)
                        else:
                          kprintln(cast[ptr uint8]("Number must be > 0"))
                      else:
                        kprintln(cast[ptr uint8]("Usage: countdown <number>"))
                      return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("logo")) == 1:
    kprintln(cast[ptr uint8](""))
    # Draw a colorful logo
    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
    kprintln(cast[ptr uint8]("    ____  _   _ ___  ____"))
    vga_set_color(VGA_YELLOW, VGA_BLACK)
    kprintln(cast[ptr uint8]("   | __ )| | | / _ \\/ ___|"))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("   |  _ \\| |_| | | | \\___ \\"))
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("   | |_) |  _  | |_| |___) |"))
    vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
    kprintln(cast[ptr uint8]("   |____/|_| |_|\\___/|____/"))
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
    kprintln(cast[ptr uint8]("   B R A I N H A I R O S"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    kprintln(cast[ptr uint8]("   Self-hosted microkernel"))
    kprintln(cast[ptr uint8]("   Written in Brainhair"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("cls")) == 1:
    vga_clear()
    return
  # ls command - list directory contents
  if cmd_buffer[0] == cast[uint8](108):  # 'l'
    if cmd_buffer[1] == cast[uint8](115):  # 's'
      var ls_ino: int32 = cwd_inode  # Default to cwd
      if cmd_buffer[2] == cast[uint8](32):  # "ls <path>"
        ls_ino = path_resolve(addr(cmd_buffer[3]))
        if ls_ino == 0:
          vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
          kprint(cast[ptr uint8]("ls: no such file or directory: "))
          kprintln(addr(cmd_buffer[3]))
          vga_set_color(VGA_WHITE, VGA_BLACK)
          return
      if cmd_buffer[2] != cast[uint8](0):
        if cmd_buffer[2] != cast[uint8](32):
          # Not "ls" or "ls ", skip
          ls_ino = 0
      if ls_ino != 0:
        if inode_is_dir(ls_ino) == 0:
          # It's a file, just show the filename
          var fsize: int32 = inode_get_size(ls_ino)
          kprint(addr(cmd_buffer[3]))
          kprint(cast[ptr uint8]("  "))
          kprint_dec(fsize)
          kprintln(cast[ptr uint8](" bytes"))
          return
        # It's a directory, list contents
        var blk: int32 = inode_get_block(ls_ino, 0)
        if blk != 0:
          var dp: ptr uint8 = fs_block_ptr(blk)
          var off: int32 = 0
          var count: int32 = 0
          while off < BLOCK_SIZE:
            var ent_ino: int32 = read32(addr(dp[off]))
            if ent_ino != 0:
              var ent_type: int32 = cast[int32](dp[off + 7])
              var ent_name_len: int32 = cast[int32](dp[off + 6])
              if pipe_mode == 1:
                # Pipe mode: plain text output
                if ent_type == FT_DIR:
                  pipe_print(cast[ptr uint8]("d "))
                else:
                  pipe_print(cast[ptr uint8]("- "))
                var ni: int32 = 0
                while ni < ent_name_len:
                  pipe_putchar(cast[int32](dp[off + 8 + ni]))
                  ni = ni + 1
                pipe_putchar(10)  # newline
              else:
                # Normal mode: colored output
                # Print type indicator
                if ent_type == FT_DIR:
                  vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
                  kprint(cast[ptr uint8]("d "))
                else:
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                  kprint(cast[ptr uint8]("- "))
                # Print name
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                var ni: int32 = 0
                while ni < ent_name_len:
                  vga_putchar(cast[int32](dp[off + 8 + ni]))
                  serial_putchar(cast[int32](dp[off + 8 + ni]))
                  ni = ni + 1
                # Print size for files
                if ent_type == FT_FILE:
                  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                  kprint(cast[ptr uint8]("  "))
                  var fsize: int32 = inode_get_size(ent_ino)
                  kprint_dec(fsize)
                vga_set_color(VGA_WHITE, VGA_BLACK)
                kprintln(cast[ptr uint8](""))
              count = count + 1
            off = off + DIRENT_SIZE
        return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("df")) == 1:
    # Count used blocks and inodes
    var used_blocks: int32 = 0
    var used_inodes: int32 = 0
    var bi: int32 = 0
    while bi < BLOCK_COUNT:
      if bitmap_get(2, bi) == 1:
        used_blocks = used_blocks + 1
      bi = bi + 1
    var ii: int32 = 0
    while ii < INODE_COUNT:
      if bitmap_get(1, ii) == 1:
        used_inodes = used_inodes + 1
      ii = ii + 1
    var total_size: int32 = BLOCK_COUNT * BLOCK_SIZE
    var used_size: int32 = used_blocks * BLOCK_SIZE
    var free_size: int32 = total_size - used_size
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("BrainhairFS Usage:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprint(cast[ptr uint8]("  Blocks: "))
    kprint_dec(used_blocks)
    kprint(cast[ptr uint8](" / "))
    kprint_dec(BLOCK_COUNT)
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("  Inodes: "))
    kprint_dec(used_inodes)
    kprint(cast[ptr uint8](" / "))
    kprint_dec(INODE_COUNT)
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("  Used:   "))
    kprint_dec(used_size)
    kprint(cast[ptr uint8](" / "))
    kprint_dec(total_size)
    kprintln(cast[ptr uint8](" bytes"))
    kprint(cast[ptr uint8]("  Free:   "))
    kprint_dec(free_size)
    kprintln(cast[ptr uint8](" bytes"))
    # Show a usage bar
    kprint(cast[ptr uint8]("  ["))
    var bar_used: int32 = (used_blocks * 40) / BLOCK_COUNT
    bi = 0
    while bi < 40:
      if bi < bar_used:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_putchar(35)  # '#'
        serial_putchar(35)
      else:
        vga_set_color(VGA_DARK_GREY, VGA_BLACK)
        vga_putchar(45)  # '-'
        serial_putchar(45)
      bi = bi + 1
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8]("]"))
    return
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](97):  # 'a'
      if cmd_buffer[2] == cast[uint8](116):  # 't'
        if cmd_buffer[3] == cast[uint8](32):  # ' '
          # cat filename - check virtual files first
          var cat_path: ptr uint8 = addr(cmd_buffer[4])
          var cat_buf: array[512, uint8]

          # Build absolute path for virtual file lookup
          var abs_path: array[128, uint8]
          build_absolute_path(cat_path, addr(abs_path[0]), 128)

          # Try virtual filesystem first (with absolute path)
          var bytes_read: int32 = vfs_read(addr(abs_path[0]), addr(cat_buf[0]), 512)
          if bytes_read < 0:
            # Not a virtual file, try regular filesystem
            bytes_read = fs_read(cat_path, addr(cat_buf[0]), 512)

          if bytes_read < 0:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            kprint(cast[ptr uint8]("cat: "))
            kprint(cat_path)
            if bytes_read == -2:
              kprintln(cast[ptr uint8](" is a directory"))
            else:
              kprintln(cast[ptr uint8](": no such file"))
            vga_set_color(VGA_WHITE, VGA_BLACK)
            return
          # Print file contents (or to pipe buffer)
          var ci: int32 = 0
          while ci < bytes_read:
            var ch: int32 = cast[int32](cat_buf[ci])
            if pipe_mode == 1:
              # Output to pipe buffer
              pipe_putchar(ch)
            else:
              # Output to screen
              if ch == 10:
                vga_putchar(10)
                serial_putchar(10)
              if ch >= 32:
                if ch < 127:
                  vga_putchar(ch)
                  serial_putchar(ch)
            ci = ci + 1
          if pipe_mode == 0:
            kprintln(cast[ptr uint8](""))
          return
        kprintln(cast[ptr uint8]("Usage: cat <filename>"))
        return
  # write command - create file with content
  if cmd_buffer[0] == cast[uint8](119):  # 'w'
    if cmd_buffer[1] == cast[uint8](114):  # 'r'
      if cmd_buffer[2] == cast[uint8](105):  # 'i'
        if cmd_buffer[3] == cast[uint8](116):  # 't'
          if cmd_buffer[4] == cast[uint8](101):  # 'e'
            if cmd_buffer[5] == cast[uint8](32):  # ' '
              var w_filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              var w_text: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
              if cast[int32](w_filename) != 0:
                if cast[int32](w_text) != 0:
                  var tlen: int32 = 0
                  while cast[int32](w_text[tlen]) != 0:
                    tlen = tlen + 1
                  var result: int32 = fs_create_file(w_filename, w_text, tlen)
                  if result == 0:
                    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                    kprint(cast[ptr uint8]("Created: "))
                    kprint(w_filename)
                    kprint(cast[ptr uint8](" ("))
                    kprint_dec(tlen)
                    kprintln(cast[ptr uint8](" bytes)"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                    return
                  vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                  if result == -4:
                    kprintln(cast[ptr uint8]("File already exists"))
                  if result == -5:
                    kprintln(cast[ptr uint8]("No free inodes"))
                  if result == -6:
                    kprintln(cast[ptr uint8]("No free blocks"))
                  if result == -1:
                    kprintln(cast[ptr uint8]("Parent directory not found"))
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                  return
                kprintln(cast[ptr uint8]("Usage: write <path> <text>"))
                return
              kprintln(cast[ptr uint8]("Usage: write <path> <text>"))
              return
  # rm command - delete file
  if cmd_buffer[0] == cast[uint8](114):  # 'r'
    if cmd_buffer[1] == cast[uint8](109):  # 'm'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        var rm_path: ptr uint8 = addr(cmd_buffer[3])
        var result: int32 = fs_unlink(rm_path)
        if result == 0:
          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
          kprint(cast[ptr uint8]("Deleted: "))
          kprintln(rm_path)
          vga_set_color(VGA_WHITE, VGA_BLACK)
          return
        vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
        if result == -2:
          kprint(cast[ptr uint8]("rm: "))
          kprint(rm_path)
          kprintln(cast[ptr uint8](" is a directory"))
        else:
          kprint(cast[ptr uint8]("rm: "))
          kprint(rm_path)
          kprintln(cast[ptr uint8](": no such file"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        return
  # mkdir command - create directory
  if cmd_buffer[0] == cast[uint8](109):  # 'm'
    if cmd_buffer[1] == cast[uint8](107):  # 'k'
      if cmd_buffer[2] == cast[uint8](100):  # 'd'
        if cmd_buffer[3] == cast[uint8](105):  # 'i'
          if cmd_buffer[4] == cast[uint8](114):  # 'r'
            if cmd_buffer[5] == cast[uint8](32):  # ' '
              var mk_path: ptr uint8 = addr(cmd_buffer[6])
              var result: int32 = fs_mkdir(mk_path)
              if result == 0:
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                kprint(cast[ptr uint8]("Created directory: "))
                kprintln(mk_path)
                vga_set_color(VGA_WHITE, VGA_BLACK)
                return
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              if result == -4:
                kprintln(cast[ptr uint8]("Directory already exists"))
              if result == -1:
                kprintln(cast[ptr uint8]("Parent not found"))
              if result == -5:
                kprintln(cast[ptr uint8]("No free inodes"))
              if result == -6:
                kprintln(cast[ptr uint8]("No free blocks"))
              vga_set_color(VGA_WHITE, VGA_BLACK)
              return
  if cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](112):  # 'p'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # cp source dest
        var src_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        var dst_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
        if cast[int32](src_name) != 0:
          if cast[int32](dst_name) != 0:
            var cp_buf: array[512, uint8]
            var src_size: int32 = fs_read(src_name, addr(cp_buf[0]), 512)
            if src_size >= 0:
              var result: int32 = fs_create_file(dst_name, addr(cp_buf[0]), src_size)
              if result == 0:
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                kprint(cast[ptr uint8]("Copied: "))
                kprint(src_name)
                kprint(cast[ptr uint8](" -> "))
                kprintln(dst_name)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              elif result == -4:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprintln(cast[ptr uint8]("Destination already exists"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprintln(cast[ptr uint8]("Failed to create destination"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
            elif src_size == -2:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprintln(cast[ptr uint8]("cp: cannot copy directory"))
              vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprint(cast[ptr uint8]("Source not found: "))
              kprintln(src_name)
              vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            kprintln(cast[ptr uint8]("Usage: cp <source> <dest>"))
        else:
          kprintln(cast[ptr uint8]("Usage: cp <source> <dest>"))
        return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("whoami")) == 1:
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("root"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("hostname")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("brainhair"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if cmd_buffer[0] == cast[uint8](119):  # 'w'
    if cmd_buffer[1] == cast[uint8](99):  # 'c'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # wc filename
        var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        if cast[int32](filename) != 0:
          var wc_buf: array[512, uint8]
          var fsize: int32 = fs_read(filename, addr(wc_buf[0]), 512)
          if fsize >= 0:
            # Count lines, words, and chars
            var lines: int32 = 0
            var words: int32 = 0
            var chars: int32 = fsize
            var in_word: int32 = 0
            var wi: int32 = 0
            while wi < fsize:
              var ch: int32 = cast[int32](wc_buf[wi])
              if ch == 10:  # newline
                lines = lines + 1
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              elif ch == 32:  # space
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              elif ch == 9:  # tab
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              else:
                in_word = 1
              wi = wi + 1
            if in_word == 1:
              words = words + 1
            # Print results
            kprint(cast[ptr uint8]("  "))
            kprint_dec(lines)
            kprint(cast[ptr uint8]("  "))
            kprint_dec(words)
            kprint(cast[ptr uint8]("  "))
            kprint_dec(chars)
            kprint(cast[ptr uint8]("  "))
            kprintln(filename)
            return
          else:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            kprint(cast[ptr uint8]("File not found: "))
            kprintln(filename)
            vga_set_color(VGA_WHITE, VGA_BLACK)
            return
        else:
          kprintln(cast[ptr uint8]("Usage: wc <filename>"))
          return
  if cmd_buffer[0] == cast[uint8](104):  # 'h'
    if cmd_buffer[1] == cast[uint8](101):  # 'e'
      if cmd_buffer[2] == cast[uint8](97):  # 'a'
        if cmd_buffer[3] == cast[uint8](100):  # 'd'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # head filename
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](filename) != 0:
              var head_buf: array[512, uint8]
              var fsize: int32 = fs_read(filename, addr(head_buf[0]), 512)
              if fsize >= 0:
                # Print first 5 lines
                var lines_shown: int32 = 0
                var hi: int32 = 0
                while hi < fsize:
                  if lines_shown >= 5:
                    break
                  var ch: int32 = cast[int32](head_buf[hi])
                  if ch == 10:
                    vga_putchar(10)
                    lines_shown = lines_shown + 1
                  elif ch >= 32:
                    if ch < 127:
                      vga_putchar(ch)
                  hi = hi + 1
                if lines_shown < 5:
                  kprintln(cast[ptr uint8](""))
                return
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprint(cast[ptr uint8]("File not found: "))
                kprintln(filename)
                vga_set_color(VGA_WHITE, VGA_BLACK)
                return
            else:
              kprintln(cast[ptr uint8]("Usage: head <filename>"))
              return
  if cmd_buffer[0] == cast[uint8](103):  # 'g'
    if cmd_buffer[1] == cast[uint8](114):  # 'r'
      if cmd_buffer[2] == cast[uint8](101):  # 'e'
        if cmd_buffer[3] == cast[uint8](112):  # 'p'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # grep pattern filename
            var pattern: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            if cast[int32](pattern) != 0:
              if cast[int32](filename) != 0:
                var grep_buf: array[512, uint8]
                var fsize: int32 = fs_read(filename, addr(grep_buf[0]), 512)
                if fsize >= 0:
                  # Get pattern length
                  var plen: int32 = 0
                  while cast[int32](pattern[plen]) != 0:
                    if cast[int32](pattern[plen]) == 32:
                      break
                    plen = plen + 1
                  # Search for pattern in each line
                  var line_start: int32 = 0
                  var gi: int32 = 0
                  var found: int32 = 0
                  while gi <= fsize:
                    var ch: int32 = 0
                    if gi < fsize:
                      ch = cast[int32](grep_buf[gi])
                    if ch == 10:
                      ch = 0
                    if gi == fsize:
                      ch = 0
                    if ch == 0:
                      # End of line - check if pattern found in this line
                      var li: int32 = line_start
                      while li + plen <= gi:
                        if str_contains_at(addr(grep_buf[0]), li, pattern, plen) == 1:
                          # Print this line
                          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                          var pi: int32 = line_start
                          while pi < gi:
                            var pch: int32 = cast[int32](grep_buf[pi])
                            if pch >= 32:
                              if pch < 127:
                                vga_putchar(pch)
                            pi = pi + 1
                          kprintln(cast[ptr uint8](""))
                          vga_set_color(VGA_WHITE, VGA_BLACK)
                          found = found + 1
                          break
                        li = li + 1
                      line_start = gi + 1
                    gi = gi + 1
                  if found == 0:
                    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                    kprintln(cast[ptr uint8]("(no matches)"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                  return
                else:
                  vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                  kprint(cast[ptr uint8]("File not found: "))
                  kprintln(filename)
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                  return
              else:
                kprintln(cast[ptr uint8]("Usage: grep <pattern> <filename>"))
                return
            else:
              kprintln(cast[ptr uint8]("Usage: grep <pattern> <filename>"))
              return
  if cmd_buffer[0] == cast[uint8](109):  # 'm'
    if cmd_buffer[1] == cast[uint8](118):  # 'v'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # mv oldname newname (copy + delete)
        var old_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        var new_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
        if cast[int32](old_name) != 0:
          if cast[int32](new_name) != 0:
            var mv_buf: array[512, uint8]
            var src_size: int32 = fs_read(old_name, addr(mv_buf[0]), 512)
            if src_size >= 0:
              var result: int32 = fs_create_file(new_name, addr(mv_buf[0]), src_size)
              if result == 0:
                fs_unlink(old_name)
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                kprint(cast[ptr uint8]("Moved: "))
                kprint(old_name)
                kprint(cast[ptr uint8](" -> "))
                kprintln(new_name)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              elif result == -4:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprintln(cast[ptr uint8]("Destination already exists"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprintln(cast[ptr uint8]("Failed to create destination"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
            elif src_size == -2:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprintln(cast[ptr uint8]("mv: cannot move directory"))
              vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprint(cast[ptr uint8]("Source not found: "))
              kprintln(old_name)
              vga_set_color(VGA_WHITE, VGA_BLACK)
            return
          else:
            kprintln(cast[ptr uint8]("Usage: mv <old_name> <new_name>"))
            return
        else:
          kprintln(cast[ptr uint8]("Usage: mv <old_name> <new_name>"))
          return
  if cmd_buffer[0] == cast[uint8](116):  # 't'
    if cmd_buffer[1] == cast[uint8](111):  # 'o'
      if cmd_buffer[2] == cast[uint8](117):  # 'u'
        if cmd_buffer[3] == cast[uint8](99):  # 'c'
          if cmd_buffer[4] == cast[uint8](104):  # 'h'
            if cmd_buffer[5] == cast[uint8](32):  # ' '
              # touch filename
              var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](filename) != 0:
                # Create empty file
                var empty: ptr uint8 = cast[ptr uint8]("")
                var result: int32 = fs_create_file(filename, empty, 0)
                if result == 0:
                  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                  kprint(cast[ptr uint8]("Created: "))
                  kprintln(filename)
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                elif result == -4:
                  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                  kprintln(cast[ptr uint8]("(file already exists)"))
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                  kprintln(cast[ptr uint8]("Failed to create file"))
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                return
              else:
                kprintln(cast[ptr uint8]("Usage: touch <filename>"))
                return
  if cmd_buffer[0] == cast[uint8](120):  # 'x'
    if cmd_buffer[1] == cast[uint8](120):  # 'x'
      if cmd_buffer[2] == cast[uint8](100):  # 'd'
        if cmd_buffer[3] == cast[uint8](32):  # ' '
          # xxd filename - hexdump file
          var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](filename) != 0:
            var xxd_buf: array[128, uint8]
            var fsize: int32 = fs_read(filename, addr(xxd_buf[0]), 128)
            if fsize >= 0:
              var row: int32 = 0
              while row * 16 < fsize:
                # Print offset
                vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                var row_off: int32 = row * 16
                # Print as 4-digit hex
                var hi: int32 = (row_off >> 4) & 0xF
                var lo: int32 = row_off & 0xF
                if hi < 10:
                  vga_putchar(48 + hi)
                else:
                  vga_putchar(55 + hi)
                if lo < 10:
                  vga_putchar(48 + lo)
                else:
                  vga_putchar(55 + lo)
                kprint(cast[ptr uint8](": "))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                # Print hex bytes
                var col: int32 = 0
                while col < 16:
                  if row * 16 + col < fsize:
                    var byte_val: int32 = cast[int32](xxd_buf[row * 16 + col])
                    var bhi: int32 = (byte_val >> 4) & 0xF
                    var blo: int32 = byte_val & 0xF
                    if bhi < 10:
                      vga_putchar(48 + bhi)
                    else:
                      vga_putchar(55 + bhi)
                    if blo < 10:
                      vga_putchar(48 + blo)
                    else:
                      vga_putchar(55 + blo)
                  else:
                    kprint(cast[ptr uint8]("  "))
                  vga_putchar(32)
                  col = col + 1
                # Print ASCII
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                kprint(cast[ptr uint8]("|"))
                col = 0
                while col < 16:
                  if row * 16 + col < fsize:
                    var ch: int32 = cast[int32](xxd_buf[row * 16 + col])
                    if ch >= 32:
                      if ch < 127:
                        vga_putchar(ch)
                      else:
                        vga_putchar(46)
                    else:
                      vga_putchar(46)
                  col = col + 1
                kprintln(cast[ptr uint8]("|"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                row = row + 1
              return
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              kprint(cast[ptr uint8]("File not found: "))
              kprintln(filename)
              vga_set_color(VGA_WHITE, VGA_BLACK)
              return
          else:
            kprintln(cast[ptr uint8]("Usage: xxd <filename>"))
            return
  # size command
  if cmd_buffer[0] == cast[uint8](115):  # 's'
    if cmd_buffer[1] == cast[uint8](105):  # 'i'
      if cmd_buffer[2] == cast[uint8](122):  # 'z'
        if cmd_buffer[3] == cast[uint8](101):  # 'e'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](filename) != 0:
              var ino: int32 = path_resolve(filename)
              if ino > 0:
                var fsize: int32 = inode_get_size(ino)
                kprint_dec(fsize)
                kprint(cast[ptr uint8](" "))
                kprintln(filename)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprint(cast[ptr uint8]("File not found: "))
                kprintln(filename)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              return
            else:
              kprintln(cast[ptr uint8]("Usage: size <filename>"))
              return
  # stat command (separate block to avoid elif bug)
  if cmd_buffer[0] == cast[uint8](115):  # 's'
    if cmd_buffer[1] == cast[uint8](116):  # 't'
      if cmd_buffer[2] == cast[uint8](97):  # 'a'
        if cmd_buffer[3] == cast[uint8](116):  # 't'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            var stat_file: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](stat_file) != 0:
              var ino: int32 = path_resolve(stat_file)
              if ino > 0:
                var fsize: int32 = inode_get_size(ino)
                var fmode: int32 = inode_get_mode(ino)
                var fblock: int32 = inode_get_block(ino, 0)
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                kprint(cast[ptr uint8]("  File: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                kprintln(stat_file)
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                kprint(cast[ptr uint8]("  Type: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                if inode_is_dir(ino) == 1:
                  kprintln(cast[ptr uint8]("directory"))
                else:
                  kprintln(cast[ptr uint8]("regular file"))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                kprint(cast[ptr uint8]("  Size: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                kprint_dec(fsize)
                kprintln(cast[ptr uint8](" bytes"))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                kprint(cast[ptr uint8]("  Inode: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                kprint_dec(ino)
                kprintln(cast[ptr uint8](""))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                kprint(cast[ptr uint8]("  Block: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                kprint_dec(fblock)
                kprintln(cast[ptr uint8](""))
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                kprint(cast[ptr uint8]("File not found: "))
                kprintln(stat_file)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              return
            else:
              kprintln(cast[ptr uint8]("Usage: stat <filename>"))
              return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("date")) == 1:
    # Show uptime-based fake time since we don't have RTC
    var ticks: int32 = get_tick_count()
    var total_secs: int32 = ticks / 18
    var hours: int32 = total_secs / 3600
    var mins: int32 = (total_secs - hours * 3600) / 60
    var secs: int32 = total_secs - hours * 3600 - mins * 60
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprint(cast[ptr uint8]("Uptime: "))
    if hours < 10:
      vga_putchar(48)  # '0'
    kprint_dec(hours)
    vga_putchar(58)  # ':'
    if mins < 10:
      vga_putchar(48)
    kprint_dec(mins)
    vga_putchar(58)  # ':'
    if secs < 10:
      vga_putchar(48)
    kprint_dec(secs)
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    kprintln(cast[ptr uint8]("(No RTC - showing uptime as HH:MM:SS)"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("matrix")) == 1:
    # Matrix rain effect
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_clear()

    # Column drop positions (80 columns)
    var drops: array[80, int32]
    var speeds: array[80, int32]
    var chars: array[80, int32]

    # Initialize drops with random positions
    var col: int32 = 0
    while col < 80:
      var seed: int32 = get_tick_count() + col * 17
      seed = seed * 1103515245 + 12345
      drops[col] = (seed / 65536) & 0x1F  # 0-31
      seed = seed * 1103515245 + 12345
      speeds[col] = 1 + ((seed / 65536) & 0x03)  # 1-4
      seed = seed * 1103515245 + 12345
      chars[col] = 33 + ((seed / 65536) & 0x3F)  # Random ASCII
      col = col + 1

    # Run animation for ~200 frames
    var frame: int32 = 0
    while frame < 200:
      # Check for keypress to exit early
      if keyboard_available() > 0:
        var key: int32 = keyboard_read_char()
        if key > 0:
          frame = 200  # Exit loop

      col = 0
      while col < 80:
        # Update drop position
        var y: int32 = drops[col]

        # Draw the bright head
        if y >= 0:
          if y < 25:
            vga_set_color(VGA_WHITE, VGA_BLACK)
            vga_putchar_at(chars[col], col, y, vga_color)

        # Draw trail above
        if y > 0:
          if y - 1 < 25:
            vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
            var trail_char: int32 = chars[col] ^ 0x20
            vga_putchar_at(trail_char, col, y - 1, vga_color)

        # Fade old positions
        if y > 4:
          if y - 5 < 25:
            vga_set_color(VGA_GREEN, VGA_BLACK)
            vga_putchar_at(32, col, y - 5, vga_color)

        # Move drop down
        drops[col] = drops[col] + speeds[col]

        # Reset drop when it goes off screen
        if drops[col] > 30:
          var seed: int32 = get_tick_count() + col + frame
          seed = seed * 1103515245 + 12345
          drops[col] = 0 - ((seed / 65536) & 0x0F)  # Negative = delay
          seed = seed * 1103515245 + 12345
          chars[col] = 33 + ((seed / 65536) & 0x3F)
          seed = seed * 1103515245 + 12345
          speeds[col] = 1 + ((seed / 65536) & 0x03)

        # Change character occasionally
        if (frame + col) & 0x07 == 0:
          var seed: int32 = get_tick_count() + col
          seed = seed * 1103515245 + 12345
          chars[col] = 33 + ((seed / 65536) & 0x3F)

        col = col + 1

      # Small delay
      var delay: int32 = 0
      while delay < 50000:
        delay = delay + 1

      frame = frame + 1

    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_clear()
    kprintln(cast[ptr uint8]("Press any key to exit..."))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("sysinfo")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8]("=== System Information ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("OS:         "))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("BrainhairOS v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprint(cast[ptr uint8]("Arch:       "))
    kprintln(cast[ptr uint8]("x86-32 (i386)"))
    kprint(cast[ptr uint8]("CPU Mode:   "))
    kprintln(cast[ptr uint8]("Protected mode"))
    kprint(cast[ptr uint8]("Paging:     "))
    kprintln(cast[ptr uint8]("Enabled (16MB identity map)"))
    kprint(cast[ptr uint8]("Kernel:     "))
    kprint(cast[ptr uint8]("0x10000 - 0x"))
    # Show approximate kernel end
    kprint(cast[ptr uint8]("14000"))
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("Stack:      "))
    kprintln(cast[ptr uint8]("0x90000"))
    var ticks: int32 = get_tick_count()
    var seconds: int32 = ticks / 18
    kprint(cast[ptr uint8]("Uptime:     "))
    kprint_dec(seconds)
    kprintln(cast[ptr uint8](" seconds"))
    kprint(cast[ptr uint8]("Ticks:      "))
    kprint_dec(ticks)
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("Max procs:  "))
    kprintln(cast[ptr uint8]("64"))
    kprint(cast[ptr uint8]("Current PID:"))
    kprint_dec(get_current_pid())
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8](""))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("about")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    kprintln(cast[ptr uint8]("A self-hosted operating system written in"))
    kprintln(cast[ptr uint8]("the Brainhair programming language."))
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("Kernel Features:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8]("  * x86-32 protected mode"))
    kprintln(cast[ptr uint8]("  * Paging with 16MB identity map"))
    kprintln(cast[ptr uint8]("  * Preemptive multitasking (64 processes)"))
    kprintln(cast[ptr uint8]("  * Synchronous IPC (send/recv/call/reply)"))
    kprintln(cast[ptr uint8]("  * PS/2 keyboard with IRQ"))
    kprintln(cast[ptr uint8]("  * VGA text mode (80x25, 16 colors)"))
    kprintln(cast[ptr uint8]("  * Ramdisk filesystem (8KB, 16 files)"))
    kprintln(cast[ptr uint8]("  * ELF32 program loader"))
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    kprintln(cast[ptr uint8]("Shell Features:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8]("  * 45+ built-in commands"))
    kprintln(cast[ptr uint8]("  * File operations (ls, cat, cp, mv, rm...)"))
    kprintln(cast[ptr uint8]("  * Memory tools (peek, poke, dump, fill)"))
    kprintln(cast[ptr uint8]("  * Calculator with bitwise ops"))
    kprintln(cast[ptr uint8]("  * Process management (ps, run)"))
    kprintln(cast[ptr uint8]("  * Fun stuff (matrix, banner, guess)"))
    kprintln(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    kprintln(cast[ptr uint8]("Coded with love by Claude :)"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(cast[ptr uint8](""))
    return
  # lsblk - list block devices
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("lsblk")) == 1:
    kprintln(cast[ptr uint8]("Block devices:"))
    var i: int32 = 0
    while i < blkdev_count:
      kprint(cast[ptr uint8]("  "))
      kprint(addr(blkdev_names[i * 16]))
      kprint(cast[ptr uint8](": "))
      kprint_dec(blkdev_sectors[i])
      kprintln(cast[ptr uint8](" sectors"))
      i = i + 1
    return
  # mkfs <dev> - format device with BrainFS
  if cmd_len >= 5:
    if cmd_buffer[0] == cast[uint8](109):  # 'm'
      if cmd_buffer[1] == cast[uint8](107):  # 'k'
        if cmd_buffer[2] == cast[uint8](102):  # 'f'
          if cmd_buffer[3] == cast[uint8](115):  # 's'
            if cmd_buffer[4] == cast[uint8](32):  # ' '
              var dev_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](dev_name) == 0:
                kprintln(cast[ptr uint8]("Usage: mkfs <device>"))
                return
              # Find device by name
              var dev: int32 = blkdev_find(dev_name)
              if dev < 0:
                kprint(cast[ptr uint8]("Device not found: "))
                kprintln(dev_name)
                return
              var result: int32 = brfs_mkfs(dev)
              if result == 0:
                kprintln(cast[ptr uint8]("Filesystem created successfully"))
              else:
                kprint(cast[ptr uint8]("mkfs failed: "))
                kprint_dec(result)
                kprintln(cast[ptr uint8](""))
              return
  # mount <dev> - mount BrainFS device
  if cmd_len >= 6:
    if cmd_buffer[0] == cast[uint8](109):  # 'm'
      if cmd_buffer[1] == cast[uint8](111):  # 'o'
        if cmd_buffer[2] == cast[uint8](117):  # 'u'
          if cmd_buffer[3] == cast[uint8](110):  # 'n'
            if cmd_buffer[4] == cast[uint8](116):  # 't'
              if cmd_buffer[5] == cast[uint8](32):  # ' '
                var dev_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                if cast[int32](dev_name) == 0:
                  kprintln(cast[ptr uint8]("Usage: mount <device>"))
                  return
                var dev: int32 = blkdev_find(dev_name)
                if dev < 0:
                  kprint(cast[ptr uint8]("Device not found: "))
                  kprintln(dev_name)
                  return
                var result: int32 = brfs_mount(dev)
                if result >= 0:
                  kprint(cast[ptr uint8]("Mounted as mount "))
                  kprint_dec(result)
                  kprintln(cast[ptr uint8](""))
                else:
                  kprint(cast[ptr uint8]("mount failed: "))
                  kprint_dec(result)
                  kprintln(cast[ptr uint8](""))
                return
  # lsmnt - list mounted filesystems
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("lsmnt")) == 1:
    kprintln(cast[ptr uint8]("Mounted filesystems:"))
    var i: int32 = 0
    var found: int32 = 0
    while i < BRFS_MAX_MOUNTS:
      if brfs_mount_active[i] == 1:
        var dev: int32 = brfs_mount_dev[i]
        kprint(cast[ptr uint8]("  mount "))
        kprint_dec(i)
        kprint(cast[ptr uint8](": "))
        kprint(addr(blkdev_names[dev * 16]))
        kprint(cast[ptr uint8](" ("))
        kprint_dec(brfs_mount_total_blocks[i])
        kprintln(cast[ptr uint8](" blocks)"))
        found = 1
      i = i + 1
    if found == 0:
      kprintln(cast[ptr uint8]("  (none)"))
    return
  # dls [path] - list directory on active BrainFS mount
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](108):  # 'l'
      if cmd_buffer[2] == cast[uint8](115):  # 's'
        if cmd_buffer[3] == cast[uint8](0) or cmd_buffer[3] == cast[uint8](32):  # end or space
          if brfs_active_mount < 0:
            kprintln(cast[ptr uint8]("No filesystem mounted"))
            return
          var dir_ino: int32 = BRFS_ROOT_INODE
          # Parse optional path argument
          if cmd_buffer[3] == cast[uint8](32):
            var path: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](path) != 0:
              dir_ino = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, path)
              if dir_ino < 0:
                kprint(cast[ptr uint8]("Directory not found: "))
                kprintln(path)
                return
          # List directory
          var offset: int32 = 0
          var entry_ino: int32 = 0
          var entry_type: int32 = 0
          var entry_name: array[32, uint8]
          while offset >= 0:
            offset = brfs_readdir(brfs_active_mount, dir_ino, offset, addr(entry_ino), addr(entry_name[0]), addr(entry_type))
            if offset < 0:
              break
            if entry_type == 2:
              vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
              kprint(addr(entry_name[0]))
              kprintln(cast[ptr uint8]("/"))
            else:
              vga_set_color(VGA_WHITE, VGA_BLACK)
              kprintln(addr(entry_name[0]))
          vga_set_color(VGA_WHITE, VGA_BLACK)
          return
  # dcat <file> - read file from active BrainFS mount
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](99):  # 'c'
      if cmd_buffer[2] == cast[uint8](97):  # 'a'
        if cmd_buffer[3] == cast[uint8](116):  # 't'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            if brfs_active_mount < 0:
              kprintln(cast[ptr uint8]("No filesystem mounted"))
              return
            var file_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](file_name) == 0:
              kprintln(cast[ptr uint8]("Usage: dcat <file>"))
              return
            var file_ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, file_name)
            if file_ino < 0:
              kprint(cast[ptr uint8]("File not found: "))
              kprintln(file_name)
              return
            var read_buf: array[256, uint8]
            var bytes: int32 = brfs_read_file(brfs_active_mount, file_ino, 0, addr(read_buf[0]), 255)
            if bytes > 0:
              read_buf[bytes] = cast[uint8](0)
              kprint(addr(read_buf[0]))
              if read_buf[bytes - 1] != cast[uint8](10):
                kprintln(cast[ptr uint8](""))
            else:
              kprintln(cast[ptr uint8]("(empty file)"))
            return
  # dmkdir <name> - create directory on active BrainFS mount
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](109):  # 'm'
      if cmd_buffer[2] == cast[uint8](107):  # 'k'
        if cmd_buffer[3] == cast[uint8](100):  # 'd'
          if cmd_buffer[4] == cast[uint8](105):  # 'i'
            if cmd_buffer[5] == cast[uint8](114):  # 'r'
              if cmd_buffer[6] == cast[uint8](32):  # ' '
                if brfs_active_mount < 0:
                  kprintln(cast[ptr uint8]("No filesystem mounted"))
                  return
                var dir_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                if cast[int32](dir_name) == 0:
                  kprintln(cast[ptr uint8]("Usage: dmkdir <name>"))
                  return
                var new_ino: int32 = brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, dir_name)
                if new_ino > 0:
                  kprint(cast[ptr uint8]("Created directory: "))
                  kprintln(dir_name)
                else:
                  kprint(cast[ptr uint8]("Failed to create directory: "))
                  kprintln(dir_name)
                return
  # dtouch <name> - create file on active BrainFS mount
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](116):  # 't'
      if cmd_buffer[2] == cast[uint8](111):  # 'o'
        if cmd_buffer[3] == cast[uint8](117):  # 'u'
          if cmd_buffer[4] == cast[uint8](99):  # 'c'
            if cmd_buffer[5] == cast[uint8](104):  # 'h'
              if cmd_buffer[6] == cast[uint8](32):  # ' '
                if brfs_active_mount < 0:
                  kprintln(cast[ptr uint8]("No filesystem mounted"))
                  return
                var file_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                if cast[int32](file_name) == 0:
                  kprintln(cast[ptr uint8]("Usage: dtouch <name>"))
                  return
                var new_ino: int32 = brfs_create(brfs_active_mount, BRFS_ROOT_INODE, file_name)
                if new_ino > 0:
                  kprint(cast[ptr uint8]("Created file: "))
                  kprintln(file_name)
                else:
                  kprint(cast[ptr uint8]("Failed to create file: "))
                  kprintln(file_name)
                return
  # dwrite <file> <content> - write to file on active BrainFS mount
  if cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](119):  # 'w'
      if cmd_buffer[2] == cast[uint8](114):  # 'r'
        if cmd_buffer[3] == cast[uint8](105):  # 'i'
          if cmd_buffer[4] == cast[uint8](116):  # 't'
            if cmd_buffer[5] == cast[uint8](101):  # 'e'
              if cmd_buffer[6] == cast[uint8](32):  # ' '
                if brfs_active_mount < 0:
                  kprintln(cast[ptr uint8]("No filesystem mounted"))
                  return
                var file_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                if cast[int32](file_name) == 0:
                  kprintln(cast[ptr uint8]("Usage: dwrite <file> <content>"))
                  return
                var content: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
                if cast[int32](content) == 0:
                  kprintln(cast[ptr uint8]("Usage: dwrite <file> <content>"))
                  return
                var file_ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, file_name)
                if file_ino < 0:
                  # Create the file first
                  file_ino = brfs_create(brfs_active_mount, BRFS_ROOT_INODE, file_name)
                  if file_ino < 0:
                    kprintln(cast[ptr uint8]("Failed to create file"))
                    return
                var content_len: int32 = fs_strlen(content)
                var bytes: int32 = brfs_write_file(brfs_active_mount, file_ino, 0, content, content_len)
                if bytes > 0:
                  kprint(cast[ptr uint8]("Wrote "))
                  kprint_dec(bytes)
                  kprintln(cast[ptr uint8](" bytes"))
                else:
                  kprintln(cast[ptr uint8]("Write failed"))
                return
  # dinfo - show info about active BrainFS mount
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("dinfo")) == 1:
    if brfs_active_mount < 0:
      kprintln(cast[ptr uint8]("No filesystem mounted"))
      return
    var m: int32 = brfs_active_mount
    kprintln(cast[ptr uint8]("Mounted filesystem info:"))
    kprint(cast[ptr uint8]("  Device: "))
    kprintln(addr(blkdev_names[brfs_mount_dev[m] * 16]))
    kprint(cast[ptr uint8]("  Total blocks: "))
    kprint_dec(brfs_mount_total_blocks[m])
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("  Free blocks: "))
    kprint_dec(brfs_mount_free_blocks[m])
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("  Total inodes: "))
    kprint_dec(brfs_mount_total_inodes[m])
    kprintln(cast[ptr uint8](""))
    kprint(cast[ptr uint8]("  Free inodes: "))
    kprint_dec(brfs_mount_free_inodes[m])
    kprintln(cast[ptr uint8](""))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("mem")) == 1:
    kprintln(cast[ptr uint8]("Memory Map:"))
    kprintln(cast[ptr uint8]("  Kernel: 0x10000 - 0x1FFFF (64KB)"))
    kprintln(cast[ptr uint8]("  Paging: 16MB identity mapped"))
    kprintln(cast[ptr uint8]("  Stack:  0x90000"))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ttest")) == 1:
    kprintln(cast[ptr uint8]("=== Kernel Thread Test ==="))
    kprint(cast[ptr uint8]("Main PID: "))
    ser_print_int(get_current_pid())
    kprint(cast[ptr uint8](", TID: "))
    ser_print_int(get_thread_id())
    kprint(cast[ptr uint8](", is_thread: "))
    ser_print_int(is_thread())
    kprintln(cast[ptr uint8](""))

    kprintln(cast[ptr uint8]("Creating test thread..."))
    var tid: int32 = thread_create(cast[int32](addr(test_thread_func)), 42)
    if tid < 0:
      kprintln(cast[ptr uint8]("ERROR: Failed to create thread"))
      return
    kprint(cast[ptr uint8]("Thread created with PID: "))
    ser_print_int(tid)
    kprintln(cast[ptr uint8](""))

    # Yield to let thread run
    kprintln(cast[ptr uint8]("Yielding to thread..."))
    var i: int32 = 0
    while i < 5:
      thread_yield()
      i = i + 1

    kprintln(cast[ptr uint8]("=== Thread Test Complete ==="))
    return
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("reboot")) == 1:
    kprintln(cast[ptr uint8]("Rebooting..."))
    # Triple fault to reboot
    disable_interrupts()
    # Write invalid value to IDTR
    # For now just halt
    halt()
  else:
    # Check for echo command with redirection support
    if cmd_len >= 5:
      if cmd_buffer[0] == cast[uint8](101):  # 'e'
        if cmd_buffer[1] == cast[uint8](99):  # 'c'
          if cmd_buffer[2] == cast[uint8](104):  # 'h'
            if cmd_buffer[3] == cast[uint8](111):  # 'o'
              if cmd_buffer[4] == cast[uint8](32):  # ' '
                # Check for output redirection
                var redir_pos: int32 = find_redirect(addr(cmd_buffer[0]), cmd_len)
                if redir_pos > 5:
                  # Found redirection - get filename
                  var append_mode: int32 = is_append_redirect(addr(cmd_buffer[0]), redir_pos, cmd_len)
                  var redir_file: ptr uint8 = get_redirect_filename(addr(cmd_buffer[0]), redir_pos, cmd_len)
                  if cast[int32](redir_file) != 0:
                    terminate_filename(redir_file)
                    # Build content to write (from position 5 to redir_pos-1, skip trailing space)
                    var content_end: int32 = redir_pos
                    while content_end > 5:
                      if cast[int32](cmd_buffer[content_end - 1]) != 32:
                        break
                      content_end = content_end - 1
                    # Build content buffer with newline
                    var echo_buf: array[256, uint8]
                    var echo_i: int32 = 0
                    var src_i: int32 = 5
                    while src_i < content_end:
                      echo_buf[echo_i] = cmd_buffer[src_i]
                      echo_i = echo_i + 1
                      src_i = src_i + 1
                    echo_buf[echo_i] = cast[uint8](10)  # newline
                    echo_i = echo_i + 1
                    echo_buf[echo_i] = cast[uint8](0)
                    # Write or append to file
                    if append_mode == 1:
                      # Append mode: read existing content, add new
                      var existing_buf: array[512, uint8]
                      var existing_len: int32 = fs_read(redir_file, addr(existing_buf[0]), 500)
                      if existing_len < 0:
                        existing_len = 0
                      # Append new content
                      var app_i: int32 = 0
                      while app_i < echo_i:
                        existing_buf[existing_len + app_i] = echo_buf[app_i]
                        app_i = app_i + 1
                      existing_buf[existing_len + app_i] = cast[uint8](0)
                      fs_write(redir_file, addr(existing_buf[0]), existing_len + echo_i)
                    else:
                      # Overwrite mode (echo_i includes newline)
                      fs_write(redir_file, addr(echo_buf[0]), echo_i)
                    return
                  else:
                    kprintln(cast[ptr uint8]("Error: no filename after redirect"))
                    return
                else:
                  # No redirection - print to terminal with $VAR expansion
                  var i: int32 = 5
                  while i < cmd_len:
                    var ch: int32 = cast[int32](cmd_buffer[i])
                    if ch == 36:  # '$' - variable expansion
                      i = i + 1
                      if i < cmd_len:
                        # Check for special $? (exit code)
                        if cast[int32](cmd_buffer[i]) == 63:  # '?'
                          kprint_dec(last_exit_code)
                          i = i + 1
                        else:
                          # Extract regular variable name
                          var var_name: array[32, uint8]
                          var vi: int32 = 0
                          while i < cmd_len:
                            var vc: int32 = cast[int32](cmd_buffer[i])
                            if vc == 32 or vc == 0 or vc == 36 or vc == 10:
                              break
                            var_name[vi] = cast[uint8](vc)
                            vi = vi + 1
                            i = i + 1
                          var_name[vi] = cast[uint8](0)
                          # Look up variable
                          var val: ptr uint8 = env_get(addr(var_name[0]))
                          if cast[int32](val) != 0:
                            kprint(val)
                      # Don't increment i again, loop will check current position
                    else:
                      vga_putchar(ch)
                      serial_putchar(ch)
                      i = i + 1
                  kprintln(cast[ptr uint8](""))
                return

    # BrainFS commands: mkfs, dmount, dumount, dls, dcat, dwrite, dmkdir
    # mkfs <dev> - Format a partition as BrainFS
    if cmd_buffer[0] == cast[uint8](109):  # 'm'
      if cmd_buffer[1] == cast[uint8](107):  # 'k'
        if cmd_buffer[2] == cast[uint8](102):  # 'f'
          if cmd_buffer[3] == cast[uint8](115):  # 's'
            if cmd_buffer[4] == cast[uint8](32):  # ' '
              var dev_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](dev_arg) == 0:
                kprintln(cast[ptr uint8]("Usage: mkfs <device>"))
                return
              var dev: int32 = parse_int(dev_arg)
              if dev < 0 or dev >= blkdev_count:
                kprintln(cast[ptr uint8]("Invalid device"))
                return
              kprint(cast[ptr uint8]("Formatting device "))
              kprint_dec(dev)
              kprintln(cast[ptr uint8](" as BrainFS..."))
              if brfs_mkfs(dev) == 0:
                kprintln(cast[ptr uint8]("Filesystem created successfully"))
              else:
                kprintln(cast[ptr uint8]("Failed to create filesystem"))
              return

    # dmount <dev> - Mount a BrainFS partition
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](109):  # 'm'
        if cmd_buffer[2] == cast[uint8](111):  # 'o'
          if cmd_buffer[3] == cast[uint8](117):  # 'u'
            if cmd_buffer[4] == cast[uint8](110):  # 'n'
              if cmd_buffer[5] == cast[uint8](116):  # 't'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  var dev_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  if cast[int32](dev_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: dmount <device>"))
                    return
                  var dev: int32 = parse_int(dev_arg)
                  if dev < 0 or dev >= blkdev_count:
                    kprintln(cast[ptr uint8]("Invalid device"))
                    return
                  var mount_id: int32 = brfs_mount(dev)
                  if mount_id >= 0:
                    brfs_active_mount = mount_id
                    kprint(cast[ptr uint8]("Mounted as mount "))
                    kprint_dec(mount_id)
                    kprintln(cast[ptr uint8](""))
                  else:
                    kprintln(cast[ptr uint8]("Failed to mount"))
                  return

    # dumount - Unmount the active BrainFS mount
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](117):  # 'u'
        if cmd_buffer[2] == cast[uint8](109):  # 'm'
          if cmd_buffer[3] == cast[uint8](111):  # 'o'
            if cmd_buffer[4] == cast[uint8](117):  # 'u'
              if cmd_buffer[5] == cast[uint8](110):  # 'n'
                if cmd_buffer[6] == cast[uint8](116):  # 't'
                  if cmd_buffer[7] == cast[uint8](0):
                    if brfs_active_mount < 0:
                      kprintln(cast[ptr uint8]("No filesystem mounted"))
                      return
                    if brfs_unmount(brfs_active_mount) == 0:
                      kprintln(cast[ptr uint8]("Unmounted successfully"))
                      brfs_active_mount = -1
                    else:
                      kprintln(cast[ptr uint8]("Failed to unmount"))
                    return

    # dls [path] - List directory on mounted disk
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](108):  # 'l'
        if cmd_buffer[2] == cast[uint8](115):  # 's'
          if cmd_buffer[3] == cast[uint8](0) or cmd_buffer[3] == cast[uint8](32):
            if brfs_active_mount < 0:
              kprintln(cast[ptr uint8]("No filesystem mounted (use dmount)"))
              return
            var dir_ino: int32 = BRFS_ROOT_INODE
            # TODO: Handle path argument
            kprintln(cast[ptr uint8]("Directory listing:"))
            var offset: int32 = 0
            var entry_ino: int32 = 0
            var entry_name: array[32, uint8]
            var entry_type: int32 = 0
            while true:
              offset = brfs_readdir(brfs_active_mount, dir_ino, offset, addr(entry_ino), addr(entry_name[0]), addr(entry_type))
              if offset < 0:
                break
              if entry_type == 2:
                vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
                kprint(addr(entry_name[0]))
                kprint(cast[ptr uint8]("/"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                kprint(addr(entry_name[0]))
              kprintln(cast[ptr uint8](""))
            return

    # dcat <filename> - Show file contents from mounted disk
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](99):  # 'c'
        if cmd_buffer[2] == cast[uint8](97):  # 'a'
          if cmd_buffer[3] == cast[uint8](116):  # 't'
            if cmd_buffer[4] == cast[uint8](32):  # ' '
              if brfs_active_mount < 0:
                kprintln(cast[ptr uint8]("No filesystem mounted"))
                return
              var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](name_arg) == 0:
                kprintln(cast[ptr uint8]("Usage: dcat <filename>"))
                return
              var ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, name_arg)
              if ino < 0:
                kprintln(cast[ptr uint8]("File not found"))
                return
              var file_buf: array[1024, uint8]
              var bytes: int32 = brfs_read_file(brfs_active_mount, ino, 0, addr(file_buf[0]), 1024)
              if bytes > 0:
                var k: int32 = 0
                while k < bytes:
                  vga_putchar(cast[int32](file_buf[k]))
                  serial_putchar(cast[int32](file_buf[k]))
                  k = k + 1
                if file_buf[bytes - 1] != cast[uint8](10):
                  kprintln(cast[ptr uint8](""))
              return

    # dwrite <filename> <text> - Write to file on disk
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](119):  # 'w'
        if cmd_buffer[2] == cast[uint8](114):  # 'r'
          if cmd_buffer[3] == cast[uint8](105):  # 'i'
            if cmd_buffer[4] == cast[uint8](116):  # 't'
              if cmd_buffer[5] == cast[uint8](101):  # 'e'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  if brfs_active_mount < 0:
                    kprintln(cast[ptr uint8]("No filesystem mounted"))
                    return
                  var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  var text_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
                  if cast[int32](name_arg) == 0 or cast[int32](text_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: dwrite <filename> <text>"))
                    return
                  var ino: int32 = brfs_lookup(brfs_active_mount, BRFS_ROOT_INODE, name_arg)
                  if ino < 0:
                    # Create file
                    ino = brfs_create(brfs_active_mount, BRFS_ROOT_INODE, name_arg)
                    if ino < 0:
                      kprintln(cast[ptr uint8]("Failed to create file"))
                      return
                  var text_len: int32 = fs_strlen(text_arg)
                  var written: int32 = brfs_write_file(brfs_active_mount, ino, 0, text_arg, text_len)
                  if written > 0:
                    kprint(cast[ptr uint8]("Wrote "))
                    kprint_dec(written)
                    kprintln(cast[ptr uint8](" bytes"))
                  else:
                    kprintln(cast[ptr uint8]("Write failed"))
                  return

    # dmkdir <dirname> - Create directory on disk
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](109):  # 'm'
        if cmd_buffer[2] == cast[uint8](107):  # 'k'
          if cmd_buffer[3] == cast[uint8](100):  # 'd'
            if cmd_buffer[4] == cast[uint8](105):  # 'i'
              if cmd_buffer[5] == cast[uint8](114):  # 'r'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  if brfs_active_mount < 0:
                    kprintln(cast[ptr uint8]("No filesystem mounted"))
                    return
                  var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  if cast[int32](name_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: dmkdir <dirname>"))
                    return
                  var ino: int32 = brfs_mkdir(brfs_active_mount, BRFS_ROOT_INODE, name_arg)
                  if ino > 0:
                    kprintln(cast[ptr uint8]("Directory created"))
                  else:
                    kprintln(cast[ptr uint8]("Failed to create directory"))
                  return

    # dinfo - Show mounted disk info
    if cmd_buffer[0] == cast[uint8](100):  # 'd'
      if cmd_buffer[1] == cast[uint8](105):  # 'i'
        if cmd_buffer[2] == cast[uint8](110):  # 'n'
          if cmd_buffer[3] == cast[uint8](102):  # 'f'
            if cmd_buffer[4] == cast[uint8](111):  # 'o'
              if cmd_buffer[5] == cast[uint8](0):
                if brfs_active_mount < 0:
                  kprintln(cast[ptr uint8]("No filesystem mounted"))
                  return
                var m: int32 = brfs_active_mount
                kprint(cast[ptr uint8]("Mount ID: "))
                kprint_dec(m)
                kprintln(cast[ptr uint8](""))
                kprint(cast[ptr uint8]("Device:   "))
                kprint_dec(brfs_mount_dev[m])
                kprintln(cast[ptr uint8](""))
                kprint(cast[ptr uint8]("Blocks:   "))
                kprint_dec(brfs_mount_total_blocks[m])
                kprint(cast[ptr uint8](" total, "))
                kprint_dec(brfs_mount_free_blocks[m])
                kprintln(cast[ptr uint8](" free"))
                kprint(cast[ptr uint8]("Inodes:   "))
                kprint_dec(brfs_mount_total_inodes[m])
                kprint(cast[ptr uint8](" total, "))
                kprint_dec(brfs_mount_free_inodes[m])
                kprintln(cast[ptr uint8](" free"))
                last_exit_code = 0
                return

    # id command - show user and group IDs
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("id")) == 1:
      var uid: int32 = sys_getuid()
      var gid: int32 = sys_getgid()
      var euid: int32 = sys_geteuid()
      var egid: int32 = sys_getegid()
      kprint(cast[ptr uint8]("uid="))
      kprint_dec(uid)
      if uid == 0:
        kprint(cast[ptr uint8]("(root)"))
      kprint(cast[ptr uint8](" gid="))
      kprint_dec(gid)
      if gid == 0:
        kprint(cast[ptr uint8]("(root)"))
      if euid != uid:
        kprint(cast[ptr uint8](" euid="))
        kprint_dec(euid)
      if egid != gid:
        kprint(cast[ptr uint8](" egid="))
        kprint_dec(egid)
      kprintln(cast[ptr uint8](""))
      last_exit_code = 0
      return

    # whoami command - show current user
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("whoami")) == 1:
      var uid: int32 = sys_geteuid()
      if uid == 0:
        kprintln(cast[ptr uint8]("root"))
      else:
        if uid == 65534:
          kprintln(cast[ptr uint8]("nobody"))
        else:
          kprint(cast[ptr uint8]("user"))
          kprint_dec(uid)
          kprintln(cast[ptr uint8](""))
      last_exit_code = 0
      return

    # groups command - show group membership
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("groups")) == 1:
      var gid: int32 = sys_getgid()
      if gid == 0:
        kprintln(cast[ptr uint8]("root wheel"))
      else:
        if gid == 65534:
          kprintln(cast[ptr uint8]("nogroup"))
        else:
          kprint(cast[ptr uint8]("group"))
          kprint_dec(gid)
          kprintln(cast[ptr uint8](""))
      last_exit_code = 0
      return

    # true command - always succeeds
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("true")) == 1:
      last_exit_code = 0
      return

    # false command - always fails
    if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("false")) == 1:
      last_exit_code = 1
      return

    # test command (also [ ... ]) - evaluate conditional expressions
    # Usage: test -e file | test -d file | test -f file | test -z string | test -n string
    #        test str1 = str2 | test str1 != str2 | test n1 -eq n2 | test n1 -ne n2
    #        test n1 -lt n2 | test n1 -gt n2 | test n1 -le n2 | test n1 -ge n2
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](101):  # 'e'
        if cmd_buffer[2] == cast[uint8](115):  # 's'
          if cmd_buffer[3] == cast[uint8](116):  # 't'
            if cmd_buffer[4] == cast[uint8](32):  # ' '
              var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
              var arg3: ptr uint8 = find_arg(addr(cmd_buffer[0]), 3)
              if cast[int32](arg1) != 0:
                # File tests: -e, -d, -f
                if cast[int32](arg1[0]) == 45:  # '-'
                  if cast[int32](arg1[1]) == 101:  # 'e' - file exists
                    if cast[int32](arg2) != 0:
                      var inode: int32 = path_resolve(arg2)
                      if inode > 0:
                        last_exit_code = 0
                      else:
                        last_exit_code = 1
                      return
                  if cast[int32](arg1[1]) == 100:  # 'd' - is directory
                    if cast[int32](arg2) != 0:
                      var inode: int32 = path_resolve(arg2)
                      if inode > 0:
                        if inode_is_dir(inode) == 1:
                          last_exit_code = 0
                        else:
                          last_exit_code = 1
                      else:
                        last_exit_code = 1
                      return
                  if cast[int32](arg1[1]) == 102:  # 'f' - is regular file
                    if cast[int32](arg2) != 0:
                      var inode: int32 = path_resolve(arg2)
                      if inode > 0:
                        if inode_is_dir(inode) == 0:
                          last_exit_code = 0
                        else:
                          last_exit_code = 1
                      else:
                        last_exit_code = 1
                      return
                  if cast[int32](arg1[1]) == 122:  # 'z' - string is empty
                    if cast[int32](arg2) != 0:
                      if cast[int32](arg2[0]) == 0:
                        last_exit_code = 0
                      else:
                        last_exit_code = 1
                    else:
                      last_exit_code = 0  # no arg = empty
                    return
                  if cast[int32](arg1[1]) == 110:  # 'n' - string is not empty
                    if cast[int32](arg2) != 0:
                      if cast[int32](arg2[0]) != 0:
                        last_exit_code = 0
                      else:
                        last_exit_code = 1
                    else:
                      last_exit_code = 1  # no arg = fail
                    return
                else:
                  # Binary comparisons: str1 = str2, str1 != str2, n1 -op n2
                  if cast[int32](arg2) != 0:
                    # String equality: arg1 = arg2
                    if cast[int32](arg2[0]) == 61:  # '='
                      if cast[int32](arg2[1]) == 0:
                        if cast[int32](arg3) != 0:
                          if str_equals(arg1, arg3) == 1:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                    # String inequality: arg1 != arg2
                    if cast[int32](arg2[0]) == 33:  # '!'
                      if cast[int32](arg2[1]) == 61:  # '='
                        if cast[int32](arg3) != 0:
                          if str_equals(arg1, arg3) == 1:
                            last_exit_code = 1
                          else:
                            last_exit_code = 0
                          return
                    # Integer comparisons: arg1 -op arg2
                    if cast[int32](arg2[0]) == 45:  # '-'
                      var n1: int32 = parse_int(arg1)
                      var n2: int32 = parse_int(arg3)
                      # -eq
                      if cast[int32](arg2[1]) == 101:  # 'e'
                        if cast[int32](arg2[2]) == 113:  # 'q'
                          if n1 == n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                      # -ne
                      if cast[int32](arg2[1]) == 110:  # 'n'
                        if cast[int32](arg2[2]) == 101:  # 'e'
                          if n1 != n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                      # -lt
                      if cast[int32](arg2[1]) == 108:  # 'l'
                        if cast[int32](arg2[2]) == 116:  # 't'
                          if n1 < n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                      # -le
                      if cast[int32](arg2[1]) == 108:  # 'l'
                        if cast[int32](arg2[2]) == 101:  # 'e'
                          if n1 <= n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                      # -gt
                      if cast[int32](arg2[1]) == 103:  # 'g'
                        if cast[int32](arg2[2]) == 116:  # 't'
                          if n1 > n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
                      # -ge
                      if cast[int32](arg2[1]) == 103:  # 'g'
                        if cast[int32](arg2[2]) == 101:  # 'e'
                          if n1 >= n2:
                            last_exit_code = 0
                          else:
                            last_exit_code = 1
                          return
              kprintln(cast[ptr uint8]("Usage: test -e file | test str1 = str2 | test n1 -eq n2"))
              last_exit_code = 2
              return

    # [ ... ] command (alias for test)
    if cmd_buffer[0] == cast[uint8](91):  # '['
      if cmd_buffer[1] == cast[uint8](32):  # ' '
        # Strip trailing ] if present
        var test_len: int32 = cmd_len
        if cmd_buffer[test_len - 1] == cast[uint8](93):  # ']'
          test_len = test_len - 1
          # Also strip space before ]
          if test_len > 0:
            if cmd_buffer[test_len - 1] == cast[uint8](32):
              test_len = test_len - 1
          cmd_buffer[test_len] = cast[uint8](0)
        # Convert [ to test and run
        cmd_buffer[0] = cast[uint8](116)  # 't'
        cmd_buffer[1] = cast[uint8](101)  # 'e'
        var shift_i: int32 = 2
        while shift_i < test_len:
          cmd_buffer[shift_i] = cmd_buffer[shift_i]
          shift_i = shift_i + 1
        # Insert "st " after "te"
        # Actually easier: just insert "test" at the beginning
        # Move everything right by 3 chars
        var move_i: int32 = test_len + 2
        while move_i >= 2:
          cmd_buffer[move_i + 2] = cmd_buffer[move_i]
          move_i = move_i - 1
        cmd_buffer[0] = cast[uint8](116)  # 't'
        cmd_buffer[1] = cast[uint8](101)  # 'e'
        cmd_buffer[2] = cast[uint8](115)  # 's'
        cmd_buffer[3] = cast[uint8](116)  # 't'
        cmd_len = test_len + 3
        cmd_buffer[cmd_len] = cast[uint8](0)
        shell_execute()
        return

    # exit command - exit the shell (for scripts)
    if cmd_buffer[0] == cast[uint8](101):  # 'e'
      if cmd_buffer[1] == cast[uint8](120):  # 'x'
        if cmd_buffer[2] == cast[uint8](105):  # 'i'
          if cmd_buffer[3] == cast[uint8](116):  # 't'
            if cmd_buffer[4] == cast[uint8](0) or cmd_buffer[4] == cast[uint8](32):
              # Check for exit code argument
              if cmd_buffer[4] == cast[uint8](32):
                var exit_code: int32 = parse_int(addr(cmd_buffer[5]))
                last_exit_code = exit_code
              kprintln(cast[ptr uint8]("exit"))
              # In a real shell this would exit - for now just set exit code
              return

    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
    kprint(cast[ptr uint8]("Unknown command: "))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    kprintln(addr(cmd_buffer[0]))
    last_exit_code = 127  # Command not found

# Built-in commands for tab completion
var builtin_cmds: array[512, uint8]
var builtin_count: int32 = 0

proc add_builtin(name: ptr uint8) =
  var i: int32 = 0
  var pos: int32 = 0
  # Find end of current list - look for double-null
  while pos < 500:
    if cast[int32](builtin_cmds[pos]) == 0:
      # Found a null - check if it's end of list (next is also null or pos is 0)
      if pos == 0:
        break  # Empty list
      if cast[int32](builtin_cmds[pos + 1]) == 0:
        pos = pos + 1  # Move past the terminator
        break
      # Otherwise, this is just a string terminator - skip to next string
      pos = pos + 1
    else:
      pos = pos + 1
  # Copy name
  while cast[int32](name[i]) != 0:
    builtin_cmds[pos] = name[i]
    pos = pos + 1
    i = i + 1
  builtin_cmds[pos] = cast[uint8](0)
  builtin_count = builtin_count + 1

proc init_builtins() =
  builtin_count = 0
  var i: int32 = 0
  while i < 512:
    builtin_cmds[i] = cast[uint8](0)
    i = i + 1
  add_builtin(cast[ptr uint8]("help"))
  add_builtin(cast[ptr uint8]("clear"))
  add_builtin(cast[ptr uint8]("cls"))
  add_builtin(cast[ptr uint8]("ver"))
  add_builtin(cast[ptr uint8]("uptime"))
  add_builtin(cast[ptr uint8]("history"))
  add_builtin(cast[ptr uint8]("env"))
  add_builtin(cast[ptr uint8]("export"))
  add_builtin(cast[ptr uint8]("ps"))
  add_builtin(cast[ptr uint8]("mem"))
  add_builtin(cast[ptr uint8]("ticks"))
  add_builtin(cast[ptr uint8]("sysinfo"))
  add_builtin(cast[ptr uint8]("about"))
  add_builtin(cast[ptr uint8]("ls"))
  add_builtin(cast[ptr uint8]("cat"))
  add_builtin(cast[ptr uint8]("cd"))
  add_builtin(cast[ptr uint8]("pwd"))
  add_builtin(cast[ptr uint8]("mkdir"))
  add_builtin(cast[ptr uint8]("rm"))
  add_builtin(cast[ptr uint8]("cp"))
  add_builtin(cast[ptr uint8]("mv"))
  add_builtin(cast[ptr uint8]("touch"))
  add_builtin(cast[ptr uint8]("stat"))
  add_builtin(cast[ptr uint8]("size"))
  add_builtin(cast[ptr uint8]("df"))
  add_builtin(cast[ptr uint8]("write"))
  add_builtin(cast[ptr uint8]("wc"))
  add_builtin(cast[ptr uint8]("head"))
  add_builtin(cast[ptr uint8]("grep"))
  add_builtin(cast[ptr uint8]("xxd"))
  add_builtin(cast[ptr uint8]("echo"))
  add_builtin(cast[ptr uint8]("date"))
  add_builtin(cast[ptr uint8]("reboot"))
  add_builtin(cast[ptr uint8]("banner"))
  add_builtin(cast[ptr uint8]("hello"))
  add_builtin(cast[ptr uint8]("calc"))
  add_builtin(cast[ptr uint8]("ping"))
  add_builtin(cast[ptr uint8]("ifconfig"))
  add_builtin(cast[ptr uint8]("arp"))
  add_builtin(cast[ptr uint8]("dns"))

# Check if string starts with prefix
proc starts_with(s: ptr uint8, prefix: ptr uint8, prefix_len: int32): int32 =
  var i: int32 = 0
  while i < prefix_len:
    if cast[int32](s[i]) != cast[int32](prefix[i]):
      return 0
    i = i + 1
  return 1

# Tab completion
proc shell_tab_complete() =
  if cmd_len == 0:
    return


  # Find the word to complete (last word in command)
  var word_start: int32 = cmd_len - 1
  while word_start > 0:
    if cast[int32](cmd_buffer[word_start - 1]) == 32:  # space
      break
    word_start = word_start - 1
  var word_len: int32 = cmd_len - word_start
  var word: ptr uint8 = addr(cmd_buffer[word_start])

  # Check if it looks like a path (contains '/')
  var is_path: int32 = 0
  var pi: int32 = 0
  while pi < word_len:
    if cast[int32](word[pi]) == 47:  # '/'
      is_path = 1
      break
    pi = pi + 1

  if is_path == 1:
    # Path completion - find matching files
    # Get directory and partial filename
    var dir_end: int32 = word_len - 1
    while dir_end >= 0:
      if cast[int32](word[dir_end]) == 47:
        break
      dir_end = dir_end - 1

    var dir_path: array[128, uint8]
    var partial: array[64, uint8]
    var di: int32 = 0
    while di <= dir_end:
      dir_path[di] = word[di]
      di = di + 1
    if di == 0:
      dir_path[0] = cast[uint8](47)  # '/'
      di = 1
    dir_path[di] = cast[uint8](0)

    var pti: int32 = 0
    var src: int32 = dir_end + 1
    while src < word_len:
      partial[pti] = word[src]
      pti = pti + 1
      src = src + 1
    partial[pti] = cast[uint8](0)
    var partial_len: int32 = pti

    # Find directory
    var dir_ino: int32 = path_resolve(addr(dir_path[0]))
    if dir_ino == 0:
      return
    if inode_is_dir(dir_ino) == 0:
      return

    # Search for matching entries
    var blk: int32 = inode_get_block(dir_ino, 0)
    if blk == 0:
      return
    var dp: ptr uint8 = fs_block_ptr(blk)
    var off: int32 = 0
    var match_count: int32 = 0
    var last_match: array[64, uint8]
    while off < BLOCK_SIZE:
      var ent_ino: int32 = read32(addr(dp[off]))
      if ent_ino != 0:
        var ent_name_len: int32 = cast[int32](dp[off + 6])
        var ent_name: ptr uint8 = addr(dp[off + 8])
        if ent_name_len >= partial_len:
          if starts_with(ent_name, addr(partial[0]), partial_len) == 1:
            # Match found
            match_count = match_count + 1
            var mi: int32 = 0
            while mi < ent_name_len:
              last_match[mi] = ent_name[mi]
              mi = mi + 1
            last_match[mi] = cast[uint8](0)
      off = off + DIRENT_SIZE

    if match_count == 1:
      # Single match - complete it
      var ci: int32 = partial_len
      while cast[int32](last_match[ci]) != 0:
        if cmd_len < 255:
          cmd_buffer[cmd_len] = last_match[ci]
          vga_putchar(cast[int32](last_match[ci]))
          serial_putchar(cast[int32](last_match[ci]))
          cmd_len = cmd_len + 1
        ci = ci + 1
  else:
    # Command completion - search built-in commands
    var i: int32 = 0
    var match_count: int32 = 0
    var last_match: array[64, uint8]
    while i < 512:
      if cast[int32](builtin_cmds[i]) == 0:
        if cast[int32](builtin_cmds[i + 1]) == 0:
          break
        i = i + 1
      else:
        # Check if this command matches
        var cmd_start: int32 = i
        var cmd_len_bi: int32 = 0
        while cast[int32](builtin_cmds[i + cmd_len_bi]) != 0:
          cmd_len_bi = cmd_len_bi + 1
        if cmd_len_bi >= word_len:
          if starts_with(addr(builtin_cmds[cmd_start]), word, word_len) == 1:
            match_count = match_count + 1
            var mi: int32 = 0
            while mi < cmd_len_bi:
              last_match[mi] = builtin_cmds[cmd_start + mi]
              mi = mi + 1
            last_match[mi] = cast[uint8](0)
        i = i + cmd_len_bi + 1

    if match_count == 1:
      # Single match - complete it
      var ci: int32 = word_len
      while cast[int32](last_match[ci]) != 0:
        if cmd_len < 255:
          cmd_buffer[cmd_len] = last_match[ci]
          vga_putchar(cast[int32](last_match[ci]))
          serial_putchar(cast[int32](last_match[ci]))
          cmd_len = cmd_len + 1
        ci = ci + 1
      # Add space after command
      if cmd_len < 255:
        cmd_buffer[cmd_len] = cast[uint8](32)
        vga_putchar(32)
        serial_putchar(32)
        cmd_len = cmd_len + 1

# Process a character from any input source
proc shell_process_char(c: int32) =
  # Handle escape sequences (arrow keys: ESC [ A/B/C/D)
  if escape_seq > 0:
    escape_buf[escape_idx] = cast[uint8](c)
    escape_idx = escape_idx + 1
    escape_seq = escape_seq - 1
    if escape_seq == 0:
      # Process completed escape sequence
      if escape_buf[0] == cast[uint8](91):  # '['
        if escape_buf[1] == cast[uint8](65):  # 'A' - Up arrow
          # Go back in history
          if history_pos > 0:
            if history_pos == history_count:
              # Save current command before browsing
              var si: int32 = 0
              while si < cmd_len:
                saved_cmd[si] = cmd_buffer[si]
                si = si + 1
              saved_cmd[si] = cast[uint8](0)
              saved_len = cmd_len
            history_pos = history_pos - 1
            var hist_entry: ptr uint8 = history_ptr(history_pos)
            set_cmdline(hist_entry)
        if escape_buf[1] == cast[uint8](66):  # 'B' - Down arrow
          # Go forward in history
          if history_pos < history_count:
            history_pos = history_pos + 1
            if history_pos == history_count:
              # Restore saved command
              set_cmdline(addr(saved_cmd[0]))
            else:
              var hist_entry: ptr uint8 = history_ptr(history_pos)
              set_cmdline(hist_entry)
      escape_idx = 0
    return
  if c == 27:  # ESC - start escape sequence
    escape_seq = 2  # Expect 2 more chars ([ + letter)
    escape_idx = 0
    return
  if c == 13 or c == 10:  # Enter (CR or LF)
    kprintln(cast[ptr uint8](""))
    # Add to history before executing
    cmd_buffer[cmd_len] = cast[uint8](0)
    history_add(addr(cmd_buffer[0]), cmd_len)
    shell_execute()
    cmd_len = 0
    history_pos = history_count  # Reset history position
    shell_prompt()
    return
  if c == 8 or c == 127:  # Backspace or DEL
    if cmd_len > 0:
      cmd_len = cmd_len - 1
      vga_col = vga_col - 1
      vga_putchar(32)
      vga_col = vga_col - 1
      ser_putchar(8)
      ser_putchar(32)
      ser_putchar(8)
    return
  # Tab - trigger completion
  if c == 9:
    shell_tab_complete()
    return
  # Any printable char (c >= 32 and c < 127)
  if c >= 32:
    if c < 127:
      if cmd_len < 255:
        cmd_buffer[cmd_len] = cast[uint8](c)
        cmd_len = cmd_len + 1
        vga_putchar(c)
        ser_putchar(c)

# ============================================================================
# NETWORKING STACK
# ============================================================================

# PCI vendor/device IDs
const E1000_VENDOR_ID: int32 = 0x8086  # Intel
const E1000_DEVICE_ID: int32 = 0x100E  # 82540EM (QEMU default)
const E1000_DEVICE_ID_2: int32 = 0x100F  # 82545EM
const E1000_DEVICE_ID_3: int32 = 0x10D3  # 82574L

# PCI configuration space offsets
const PCI_VENDOR_ID: int32 = 0x00
const PCI_DEVICE_ID: int32 = 0x02
const PCI_COMMAND: int32 = 0x04
const PCI_STATUS: int32 = 0x06
const PCI_BAR0: int32 = 0x10
const PCI_BAR1: int32 = 0x14
const PCI_IRQ_LINE: int32 = 0x3C

# E1000 Register offsets (from BAR0)
const E1000_CTRL: int32 = 0x0000      # Device Control
const E1000_STATUS: int32 = 0x0008    # Device Status
const E1000_EECD: int32 = 0x0010      # EEPROM Control
const E1000_EERD: int32 = 0x0014      # EEPROM Read
const E1000_ICR: int32 = 0x00C0       # Interrupt Cause Read
const E1000_IMS: int32 = 0x00D0       # Interrupt Mask Set
const E1000_IMC: int32 = 0x00D8       # Interrupt Mask Clear
const E1000_RCTL: int32 = 0x0100      # Receive Control
const E1000_TCTL: int32 = 0x0400      # Transmit Control
const E1000_TIPG: int32 = 0x0410      # Transmit Inter-Packet Gap
const E1000_RDBAL: int32 = 0x2800     # RX Descriptor Base Low
const E1000_RDBAH: int32 = 0x2804     # RX Descriptor Base High
const E1000_RDLEN: int32 = 0x2808     # RX Descriptor Length
const E1000_RDH: int32 = 0x2810       # RX Descriptor Head
const E1000_RDT: int32 = 0x2818       # RX Descriptor Tail
const E1000_TDBAL: int32 = 0x3800     # TX Descriptor Base Low
const E1000_TDBAH: int32 = 0x3804     # TX Descriptor Base High
const E1000_TDLEN: int32 = 0x3808     # TX Descriptor Length
const E1000_TDH: int32 = 0x3810       # TX Descriptor Head
const E1000_TDT: int32 = 0x3818       # TX Descriptor Tail
const E1000_TXDCTL: int32 = 0x3828    # TX Descriptor Control
const E1000_RAL: int32 = 0x5400       # Receive Address Low
const E1000_RAH: int32 = 0x5404       # Receive Address High
const E1000_MTA: int32 = 0x5200       # Multicast Table Array

# E1000 Control Register bits
const E1000_CTRL_RST: int32 = 0x04000000   # Device Reset
const E1000_CTRL_SLU: int32 = 0x00000040   # Set Link Up
const E1000_CTRL_ASDE: int32 = 0x00000020  # Auto-Speed Detection

# E1000 RCTL bits
const E1000_RCTL_EN: int32 = 0x00000002    # Receiver Enable
const E1000_RCTL_BAM: int32 = 0x00008000   # Broadcast Accept Mode
const E1000_RCTL_BSIZE_2048: int32 = 0x00000000  # Buffer Size 2048
const E1000_RCTL_SECRC: int32 = 0x04000000 # Strip Ethernet CRC

# E1000 TCTL bits
const E1000_TCTL_EN: int32 = 0x00000002    # Transmit Enable
const E1000_TCTL_PSP: int32 = 0x00000008   # Pad Short Packets

# Descriptor ring sizes (must be multiple of 8, each descriptor is 16 bytes)
const RX_DESC_COUNT: int32 = 16         # Increased for better handling
const TX_DESC_COUNT: int32 = 32         # Enough for HTTP responses
const RX_BUFFER_SIZE: int32 = 2048
const TX_BUFFER_SIZE: int32 = 2048

# RX/TX descriptor rings (aligned to 16 bytes)
# Each descriptor: 16 bytes = 4 dwords
# [0-7]: buffer address (64-bit), [8-9]: length, [10]: checksum, [11]: status, [12-15]: special/errors
# Add padding for 16-byte alignment
var rx_descs_raw: array[272, uint8]     # 16 * 16 bytes + 16 for alignment
var tx_descs_raw: array[144, uint8]     # 8 * 16 bytes + 16 for alignment
var rx_buffers: array[32768, uint8]     # 16 * 2048 bytes
var tx_buffers: array[16384, uint8]     # 8 * 2048 bytes
var rx_descs_aligned: int32 = 0         # Aligned pointer (set during init)
var tx_descs_aligned: int32 = 0         # Aligned pointer (set during init)
var rx_cur: int32 = 0                   # Current RX descriptor index
var tx_cur: int32 = 0                   # Current TX descriptor index

# Packet buffer for receiving
var packet_buf: array[2048, uint8]
var packet_len: int32 = 0

# ARP cache size constant
const ARP_CACHE_SIZE: int32 = 16

# TCP connection state
const TCP_STATE_CLOSED: int32 = 0
const TCP_STATE_LISTEN: int32 = 1
const TCP_STATE_SYN_SENT: int32 = 2
const TCP_STATE_SYN_RECEIVED: int32 = 3
const TCP_STATE_ESTABLISHED: int32 = 4
const TCP_STATE_FIN_WAIT_1: int32 = 5
const TCP_STATE_FIN_WAIT_2: int32 = 6
const TCP_STATE_CLOSE_WAIT: int32 = 7
const TCP_STATE_CLOSING: int32 = 8
const TCP_STATE_LAST_ACK: int32 = 9
const TCP_STATE_TIME_WAIT: int32 = 10

# ============================================================================
# E1000 Register Access
# ============================================================================

proc e1000_read(reg: int32): int32 =
  return mmio_read32(e1000_mmio_base + reg)

proc e1000_write(reg: int32, value: int32) =
  mmio_write32(e1000_mmio_base + reg, value)

# ============================================================================
# PCI Enumeration
# ============================================================================

proc pci_scan_device(bus: int32, slot: int32): int32 =
  var vendor: int32 = pci_config_read16(bus, slot, 0, PCI_VENDOR_ID)
  if vendor == 0xFFFF:
    return 0  # No device

  var device: int32 = pci_config_read16(bus, slot, 0, PCI_DEVICE_ID)

  # Check for Intel E1000
  if vendor == E1000_VENDOR_ID:
    if device == E1000_DEVICE_ID:
      return 1
    if device == E1000_DEVICE_ID_2:
      return 1
    if device == E1000_DEVICE_ID_3:
      return 1

  return 0

proc pci_find_e1000(): int32 =
  var bus: int32 = 0
  while bus < 256:
    var slot: int32 = 0
    while slot < 32:
      if pci_scan_device(bus, slot) == 1:
        # Found E1000! Get BAR0 (MMIO address)
        var bar0: int32 = pci_config_read32(bus, slot, 0, PCI_BAR0)
        e1000_mmio_base = bar0 & 0xFFFFFFF0  # Mask lower bits

        # Get IRQ
        e1000_irq = pci_config_read8(bus, slot, 0, PCI_IRQ_LINE)

        # Enable bus mastering and memory space
        var cmd: int32 = pci_config_read16(bus, slot, 0, PCI_COMMAND)
        cmd = cmd | 0x06  # Memory Space + Bus Master
        pci_config_write32(bus, slot, 0, PCI_COMMAND, cmd)

        return 1
      slot = slot + 1
    bus = bus + 1
  return 0

    # tmount [size] - Mount a tmpfs filesystem (default 16MB)
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](109):  # 'm'
        if cmd_buffer[2] == cast[uint8](111):  # 'o'
          if cmd_buffer[3] == cast[uint8](117):  # 'u'
            if cmd_buffer[4] == cast[uint8](110):  # 'n'
              if cmd_buffer[5] == cast[uint8](116):  # 't'
                if cmd_buffer[6] == cast[uint8](0) or cmd_buffer[6] == cast[uint8](32):  # ' ' or end
                  var max_size: int32 = TMPFS_DEFAULT_SIZE
                  if cmd_buffer[6] == cast[uint8](32):
                    var size_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                    if cast[int32](size_arg) != 0:
                      var size_mb: int32 = parse_int(size_arg)
                      if size_mb > 0 and size_mb <= 512:
                        max_size = size_mb * 1048576  # Convert MB to bytes
                  var mount_id: int32 = tmpfs_mkfs(max_size)
                  if mount_id >= 0:
                    tmpfs_active_mount = mount_id
                    kprint(cast[ptr uint8]("Tmpfs mounted as mount "))
                    kprint_dec(mount_id)
                    kprint(cast[ptr uint8](" ("))
                    kprint_dec(max_size / 1024)
                    kprintln(cast[ptr uint8]("KB max)"))
                  else:
                    kprintln(cast[ptr uint8]("Failed to mount tmpfs"))
                  return

    # tumount - Unmount the active tmpfs mount
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](117):  # 'u'
        if cmd_buffer[2] == cast[uint8](109):  # 'm'
          if cmd_buffer[3] == cast[uint8](111):  # 'o'
            if cmd_buffer[4] == cast[uint8](117):  # 'u'
              if cmd_buffer[5] == cast[uint8](110):  # 'n'
                if cmd_buffer[6] == cast[uint8](116):  # 't'
                  if cmd_buffer[7] == cast[uint8](0):
                    if tmpfs_active_mount < 0:
                      kprintln(cast[ptr uint8]("No tmpfs mounted"))
                      return
                    if tmpfs_unmount(tmpfs_active_mount) == 0:
                      kprintln(cast[ptr uint8]("Tmpfs unmounted successfully"))
                      tmpfs_active_mount = -1
                    else:
                      kprintln(cast[ptr uint8]("Failed to unmount tmpfs"))
                    return

    # tls - List directory on tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](108):  # 'l'
        if cmd_buffer[2] == cast[uint8](115):  # 's'
          if cmd_buffer[3] == cast[uint8](0):
            if tmpfs_active_mount < 0:
              kprintln(cast[ptr uint8]("No tmpfs mounted (use tmount)"))
              return
            var list_buf: array[1024, uint8]
            var num_entries: int32 = tmpfs_readdir(tmpfs_active_mount, 0, addr(list_buf[0]), 32)
            if num_entries > 0:
              kprintln(cast[ptr uint8]("Tmpfs directory listing:"))
              var i: int32 = 0
              while i < num_entries:
                kprint(cast[ptr uint8]("  "))
                kprintln(addr(list_buf[i * 32]))
                i = i + 1
            else:
              kprintln(cast[ptr uint8]("Empty directory"))
            return

    # tmkdir <name> - Create directory on tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](109):  # 'm'
        if cmd_buffer[2] == cast[uint8](107):  # 'k'
          if cmd_buffer[3] == cast[uint8](100):  # 'd'
            if cmd_buffer[4] == cast[uint8](105):  # 'i'
              if cmd_buffer[5] == cast[uint8](114):  # 'r'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  if tmpfs_active_mount < 0:
                    kprintln(cast[ptr uint8]("No tmpfs mounted"))
                    return
                  var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  if cast[int32](name_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: tmkdir <name>"))
                    return
                  if tmpfs_create(tmpfs_active_mount, 0, name_arg, 1) >= 0:
                    kprintln(cast[ptr uint8]("Directory created"))
                  else:
                    kprintln(cast[ptr uint8]("Failed to create directory"))
                  return

    # ttouch <name> - Create file on tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](116):  # 't'
        if cmd_buffer[2] == cast[uint8](111):  # 'o'
          if cmd_buffer[3] == cast[uint8](117):  # 'u'
            if cmd_buffer[4] == cast[uint8](99):  # 'c'
              if cmd_buffer[5] == cast[uint8](104):  # 'h'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  if tmpfs_active_mount < 0:
                    kprintln(cast[ptr uint8]("No tmpfs mounted"))
                    return
                  var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  if cast[int32](name_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: ttouch <name>"))
                    return
                  if tmpfs_create(tmpfs_active_mount, 0, name_arg, 0) >= 0:
                    kprintln(cast[ptr uint8]("File created"))
                  else:
                    kprintln(cast[ptr uint8]("Failed to create file"))
                  return

    # twrite <file> <content> - Write to file on tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](119):  # 'w'
        if cmd_buffer[2] == cast[uint8](114):  # 'r'
          if cmd_buffer[3] == cast[uint8](105):  # 'i'
            if cmd_buffer[4] == cast[uint8](116):  # 't'
              if cmd_buffer[5] == cast[uint8](101):  # 'e'
                if cmd_buffer[6] == cast[uint8](32):  # ' '
                  if tmpfs_active_mount < 0:
                    kprintln(cast[ptr uint8]("No tmpfs mounted"))
                    return
                  var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                  var content_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
                  if cast[int32](name_arg) == 0 or cast[int32](content_arg) == 0:
                    kprintln(cast[ptr uint8]("Usage: twrite <file> <content>"))
                    return
                  var ino: int32 = tmpfs_lookup(tmpfs_active_mount, 0, name_arg)
                  if ino < 0:
                    kprintln(cast[ptr uint8]("File not found"))
                    return
                  var len: int32 = 0
                  while content_arg[len] != cast[uint8](0):
                    len = len + 1
                  if tmpfs_write(tmpfs_active_mount, ino, content_arg, len) >= 0:
                    kprintln(cast[ptr uint8]("File written"))
                  else:
                    kprintln(cast[ptr uint8]("Failed to write file"))
                  return

    # tcat <file> - Read file from tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](99):  # 'c'
        if cmd_buffer[2] == cast[uint8](97):  # 'a'
          if cmd_buffer[3] == cast[uint8](116):  # 't'
            if cmd_buffer[4] == cast[uint8](32):  # ' '
              if tmpfs_active_mount < 0:
                kprintln(cast[ptr uint8]("No tmpfs mounted"))
                return
              var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](name_arg) == 0:
                kprintln(cast[ptr uint8]("Usage: tcat <file>"))
                return
              var ino: int32 = tmpfs_lookup(tmpfs_active_mount, 0, name_arg)
              if ino < 0:
                kprintln(cast[ptr uint8]("File not found"))
                return
              var read_buf: array[1024, uint8]
              var bytes_read: int32 = tmpfs_read(tmpfs_active_mount, ino, addr(read_buf[0]), 1023)
              if bytes_read >= 0:
                read_buf[bytes_read] = cast[uint8](0)
                kprintln(addr(read_buf[0]))
              else:
                kprintln(cast[ptr uint8]("Failed to read file"))
              return

    # trm <name> - Remove file/directory from tmpfs
    if cmd_buffer[0] == cast[uint8](116):  # 't'
      if cmd_buffer[1] == cast[uint8](114):  # 'r'
        if cmd_buffer[2] == cast[uint8](109):  # 'm'
          if cmd_buffer[3] == cast[uint8](32):  # ' '
            if tmpfs_active_mount < 0:
              kprintln(cast[ptr uint8]("No tmpfs mounted"))
              return
            var name_arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](name_arg) == 0:
              kprintln(cast[ptr uint8]("Usage: trm <name>"))
              return
            if tmpfs_unlink(tmpfs_active_mount, 0, name_arg) == 0:
              kprintln(cast[ptr uint8]("Removed"))
            else:
              kprintln(cast[ptr uint8]("Failed to remove (does not exist or directory not empty)"))
            return

# ============================================================================
# E1000 Driver
# ============================================================================

proc e1000_read_mac() =
  # Read MAC from RAL/RAH registers (set by EEPROM)
  var ral: int32 = e1000_read(E1000_RAL)
  var rah: int32 = e1000_read(E1000_RAH)

  my_mac[0] = cast[uint8](ral & 0xFF)
  my_mac[1] = cast[uint8]((ral >> 8) & 0xFF)
  my_mac[2] = cast[uint8]((ral >> 16) & 0xFF)
  my_mac[3] = cast[uint8]((ral >> 24) & 0xFF)
  my_mac[4] = cast[uint8](rah & 0xFF)
  my_mac[5] = cast[uint8]((rah >> 8) & 0xFF)

  # Write back with Address Valid bit set
  e1000_write(E1000_RAL, ral)
  e1000_write(E1000_RAH, (rah & 0xFFFF) | 0x80000000)  # Set AV bit

proc e1000_reset_rx() =
  # Sync rx_cur with hardware's RDH (where next packet will arrive)
  # This is safer than trying to reset the entire ring
  var rdh: int32 = e1000_read(E1000_RDH)
  var rdt: int32 = e1000_read(E1000_RDT)
  ser_print(cast[ptr uint8]("[RX] RDH="))
  ser_print_hex(rdh)
  ser_print(cast[ptr uint8](" RDT="))
  ser_print_hex(rdt)
  ser_print(cast[ptr uint8](" old_cur="))
  ser_print_hex(rx_cur)
  ser_println(cast[ptr uint8](""))
  rx_cur = rdh

proc e1000_init_rx() =
  kprint(cast[ptr uint8]("r0"))
  # Set up RX descriptor ring
  var i: int32 = 0
  while i < RX_DESC_COUNT:
    kprint(cast[ptr uint8]("."))
    var desc_addr: int32 = rx_descs_aligned + (i * 16)
    var buf_addr: int32 = cast[int32](addr(rx_buffers[0])) + (i * RX_BUFFER_SIZE)
    kprint(cast[ptr uint8]("a"))

    # Buffer address (64-bit, low 32 bits)
    mmio_write32(desc_addr, buf_addr)
    kprint(cast[ptr uint8]("b"))
    mmio_write32(desc_addr + 4, 0)  # High 32 bits
    kprint(cast[ptr uint8]("c"))

    # Clear status
    mmio_write32(desc_addr + 8, 0)
    kprint(cast[ptr uint8]("d"))
    mmio_write32(desc_addr + 12, 0)
    kprint(cast[ptr uint8]("e"))

    i = i + 1

  kprint(cast[ptr uint8]("r1"))
  # Set RX descriptor base address
  e1000_write(E1000_RDBAL, rx_descs_aligned)
  e1000_write(E1000_RDBAH, 0)

  kprint(cast[ptr uint8]("r2"))
  # Set RX descriptor length (in bytes)
  e1000_write(E1000_RDLEN, RX_DESC_COUNT * 16)

  kprint(cast[ptr uint8]("r3"))
  # Set head and tail
  e1000_write(E1000_RDH, 0)
  e1000_write(E1000_RDT, RX_DESC_COUNT - 1)

  kprint(cast[ptr uint8]("r4"))
  # Enable receiver (with promiscuous mode for debugging)
  # UPE = Unicast Promiscuous Enable (bit 3)
  # MPE = Multicast Promiscuous Enable (bit 4)
  var rctl: int32 = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_BSIZE_2048 | E1000_RCTL_SECRC
  rctl = rctl | 0x18  # Add UPE and MPE bits
  e1000_write(E1000_RCTL, rctl)
  kprint(cast[ptr uint8]("r5"))


proc e1000_init_tx() =
  # Set up TX descriptor ring
  var i: int32 = 0
  while i < TX_DESC_COUNT:
    var desc_addr: int32 = tx_descs_aligned + (i * 16)
    var buf_addr: int32 = cast[int32](addr(tx_buffers[0])) + (i * TX_BUFFER_SIZE)

    # Buffer address
    mmio_write32(desc_addr, buf_addr)
    mmio_write32(desc_addr + 4, 0)

    # Set status as done (DD bit) so we can use it
    mmio_write32(desc_addr + 8, 0)
    mmio_write32(desc_addr + 12, 0x01)  # DD bit set

    i = i + 1

  # Set TX descriptor base address
  e1000_write(E1000_TDBAL, tx_descs_aligned)
  e1000_write(E1000_TDBAH, 0)

  # Set TX descriptor length
  e1000_write(E1000_TDLEN, TX_DESC_COUNT * 16)

  # Set head and tail
  e1000_write(E1000_TDH, 0)
  e1000_write(E1000_TDT, 0)

  # Configure TXDCTL for write-back
  # GRAN=1 (bit 24), WTHRESH=1 (bits 16-22), PTHRESH=0 (bits 0-5)
  var txdctl: int32 = (1 << 24) | (1 << 16)
  e1000_write(E1000_TXDCTL, txdctl)

  # Set Transmit Inter-Packet Gap (required for TX to work)
  # IPGT=10, IPGR1=8, IPGR2=6 (typical values for 802.3)
  var tipg: int32 = 10 | (8 << 10) | (6 << 20)
  e1000_write(E1000_TIPG, tipg)

  # Enable transmitter
  var tctl: int32 = E1000_TCTL_EN | E1000_TCTL_PSP
  tctl = tctl | (0x10 << 4)   # Collision Threshold
  tctl = tctl | (0x40 << 12)  # Collision Distance
  e1000_write(E1000_TCTL, tctl)

proc e1000_reset() =
  # Reset the device
  var ctrl: int32 = e1000_read(E1000_CTRL)
  e1000_write(E1000_CTRL, ctrl | E1000_CTRL_RST)

  # Wait for reset to complete
  # (Using nested loops to work around compiler bug with large constants)
  var i: int32 = 0
  var j: int32 = 0
  while i < 100:
    j = 0
    while j < 1000:
      j = j + 1
    i = i + 1

  # Set link up
  ctrl = e1000_read(E1000_CTRL)
  ctrl = ctrl | E1000_CTRL_SLU | E1000_CTRL_ASDE
  ctrl = ctrl & 0xFFFFFFBF  # Clear LRST
  e1000_write(E1000_CTRL, ctrl)

  # Clear multicast table
  i = 0
  while i < 128:
    e1000_write(E1000_MTA + (i * 4), 0)
    i = i + 1

proc net_init(): int32 =
  kprint(cast[ptr uint8]("1"))
  # Calculate 16-byte aligned descriptor ring addresses
  # Round up to next 16-byte boundary using bitmask
  var rx_raw: int32 = cast[int32](addr(rx_descs_raw[0]))
  rx_descs_aligned = (rx_raw + 15) & cast[int32](0xFFFFFFF0)

  var tx_raw: int32 = cast[int32](addr(tx_descs_raw[0]))
  tx_descs_aligned = (tx_raw + 15) & cast[int32](0xFFFFFFF0)

  # Set default IP (can be changed via DHCP)
  my_ip[0] = cast[uint8](10)
  my_ip[1] = cast[uint8](0)
  my_ip[2] = cast[uint8](2)
  my_ip[3] = cast[uint8](15)  # 10.0.2.15 (QEMU default)

  # Set broadcast MAC
  var j: int32 = 0
  while j < 6:
    broadcast_mac[j] = cast[uint8](0xFF)
    j = j + 1

  kprint(cast[ptr uint8]("2"))
  # Find E1000
  if pci_find_e1000() == 0:
    return 0  # Not found

  kprint(cast[ptr uint8]("3"))
  e1000_found = 1

  # Map MMIO region (128KB should be enough for E1000)
  var mmio_page: int32 = e1000_mmio_base & 0xFFFFF000
  var i: int32 = 0
  while i < 32:  # Map 32 pages (128KB)
    map_page(mmio_page + (i * 4096), mmio_page + (i * 4096), 3)  # Present + R/W
    i = i + 1
  flush_tlb()

  kprint(cast[ptr uint8]("4"))
  # Reset device
  e1000_reset()

  kprint(cast[ptr uint8]("5"))
  # Read MAC address
  e1000_read_mac()

  kprint(cast[ptr uint8]("6"))
  # Initialize RX and TX
  e1000_init_rx()
  kprint(cast[ptr uint8]("6b"))
  e1000_init_tx()

  kprint(cast[ptr uint8]("7"))
  # Enable interrupts for RX
  e1000_write(E1000_IMS, 0x1F6DC)  # RXT0, RXO, RXDMT0, etc.

  return 1

# ============================================================================
# Packet Send/Receive
# ============================================================================

proc e1000_send_packet(data: ptr uint8, length: int32): int32 =
  if e1000_found == 0:
    return -1

  if length > TX_BUFFER_SIZE:
    return -2

  # Get current TX descriptor
  var desc_idx: int32 = tx_cur
  var desc_addr: int32 = tx_descs_aligned + (desc_idx * 16)
  var buf_addr: int32 = cast[int32](addr(tx_buffers[0])) + (desc_idx * TX_BUFFER_SIZE)

  # Wait for descriptor to be available (DD bit set)
  var status: int32 = mmio_read32(desc_addr + 12)
  var wait: int32 = 0
  while (status & 0x01) == 0:
    wait = wait + 1
    if wait > 100000:
      return -3  # Timeout
    status = mmio_read32(desc_addr + 12)

  # Copy data to buffer
  net_memcpy(buf_addr, cast[int32](data), length)

  # Set up descriptor
  mmio_write32(desc_addr, buf_addr)       # Buffer address low
  mmio_write32(desc_addr + 4, 0)          # Buffer address high

  # Length + CMD (EOP=1, IFCS=1, RS=1)
  var cmd: int32 = length | (0x0B << 24)  # EOP | IFCS | RS
  mmio_write32(desc_addr + 8, cmd)
  mmio_write32(desc_addr + 12, 0)         # Clear status

  # Update tail pointer to trigger TX
  tx_cur = (tx_cur + 1) % TX_DESC_COUNT
  e1000_write(E1000_TDT, tx_cur)

  return 0

var rx_poll_count: int32 = 0

proc e1000_receive_packet(): int32 =
  if e1000_found == 0:
    return 0

  rx_poll_count = rx_poll_count + 1

  var desc_idx: int32 = rx_cur
  var desc_addr: int32 = rx_descs_aligned + (desc_idx * 16)

  # Check if packet received (DD bit set in status)
  # Status byte is at offset 12 of the RX descriptor (legacy format)
  # Read as 32-bit word, status is in bits 0-7
  var status_word: int32 = mmio_read32(desc_addr + 12)
  var status: int32 = status_word & 0xFF

  if (status & 0x01) == 0:
    return 0  # No packet - DD bit not set

  # Get packet length
  var info: int32 = mmio_read32(desc_addr + 8)
  var length: int32 = info & 0xFFFF

  # Copy to packet buffer
  var buf_addr: int32 = cast[int32](addr(rx_buffers[0])) + (desc_idx * RX_BUFFER_SIZE)
  net_memcpy(cast[int32](addr(packet_buf[0])), buf_addr, length)
  packet_len = length

  # Clear descriptor status and give back to hardware
  mmio_write32(desc_addr + 8, 0)
  mmio_write32(desc_addr + 12, 0)

  # Update tail
  var old_rx_cur: int32 = rx_cur
  rx_cur = (rx_cur + 1) % RX_DESC_COUNT
  e1000_write(E1000_RDT, old_rx_cur)

  # Debug: show rx ring state
  ser_print(cast[ptr uint8]("!"))
  ser_print_hex(old_rx_cur)
  ser_print(cast[ptr uint8]("/"))

  return length

# ============================================================================
# Ethernet Frame Handling
# ============================================================================

const ETH_TYPE_IP: int32 = 0x0800
const ETH_TYPE_ARP: int32 = 0x0806

proc eth_send(dest_mac: ptr uint8, eth_type: int32, data: ptr uint8, data_len: int32): int32 =
  # Use global eth_send_frame buffer to avoid 1518-byte stack allocation
  var i: int32 = 0

  # Destination MAC (6 bytes)
  while i < 6:
    eth_send_frame[i] = dest_mac[i]
    i = i + 1

  # Source MAC (6 bytes)
  i = 0
  while i < 6:
    eth_send_frame[6 + i] = my_mac[i]
    i = i + 1

  # EtherType (2 bytes, big-endian)
  eth_send_frame[12] = cast[uint8]((eth_type >> 8) & 0xFF)
  eth_send_frame[13] = cast[uint8](eth_type & 0xFF)

  # Data
  i = 0
  while i < data_len:
    eth_send_frame[14 + i] = data[i]
    i = i + 1

  # Pad to minimum 60 bytes if needed
  var total_len: int32 = 14 + data_len
  if total_len < 60:
    while total_len < 60:
      eth_send_frame[total_len] = cast[uint8](0)
      total_len = total_len + 1
    total_len = 60

  return e1000_send_packet(addr(eth_send_frame[0]), total_len)

# ============================================================================
# IP Checksum
# ============================================================================

proc ip_checksum(data: ptr uint8, length: int32): int32 =
  var sum: int32 = 0
  var i: int32 = 0

  # Sum 16-bit words
  while i < length - 1:
    var word: int32 = (cast[int32](data[i]) << 8) | cast[int32](data[i + 1])
    sum = sum + word
    i = i + 2

  # Handle odd byte
  if (length & 1) == 1:
    sum = sum + (cast[int32](data[length - 1]) << 8)

  # Fold 32-bit sum to 16 bits
  while (sum >> 16) != 0:
    sum = (sum & 0xFFFF) + (sum >> 16)

  return (0xFFFF - sum) & 0xFFFF

# ============================================================================
# ARP Protocol
# ============================================================================

const ARP_REQUEST: int32 = 1
const ARP_REPLY: int32 = 2

proc arp_send_request(target_ip: ptr uint8) =
  var packet: array[28, uint8]

  # Hardware type: Ethernet (1)
  packet[0] = cast[uint8](0)
  packet[1] = cast[uint8](1)

  # Protocol type: IPv4 (0x0800)
  packet[2] = cast[uint8](0x08)
  packet[3] = cast[uint8](0x00)

  # Hardware address length: 6
  packet[4] = cast[uint8](6)

  # Protocol address length: 4
  packet[5] = cast[uint8](4)

  # Operation: Request (1)
  packet[6] = cast[uint8](0)
  packet[7] = cast[uint8](1)

  # Sender hardware address (our MAC)
  var i: int32 = 0
  while i < 6:
    packet[8 + i] = my_mac[i]
    i = i + 1

  # Sender protocol address (our IP)
  i = 0
  while i < 4:
    packet[14 + i] = my_ip[i]
    i = i + 1

  # Target hardware address (zeros for request)
  i = 0
  while i < 6:
    packet[18 + i] = cast[uint8](0)
    i = i + 1

  # Target protocol address
  i = 0
  while i < 4:
    packet[24 + i] = target_ip[i]
    i = i + 1

  # Send as broadcast (use global broadcast_mac)
  eth_send(addr(broadcast_mac[0]), ETH_TYPE_ARP, addr(packet[0]), 28)

proc arp_handle_packet(data: ptr uint8, length: int32) =
  if length < 28:
    return

  var op: int32 = (cast[int32](data[6]) << 8) | cast[int32](data[7])

  if op == ARP_REQUEST:
    # Check if they're asking for our IP
    var target_ip_match: int32 = 1
    var i: int32 = 0
    while i < 4:
      if data[24 + i] != my_ip[i]:
        target_ip_match = 0
      i = i + 1

    if target_ip_match == 1:
      # Send ARP reply
      var reply: array[28, uint8]

      # Hardware type: Ethernet
      reply[0] = cast[uint8](0)
      reply[1] = cast[uint8](1)

      # Protocol type: IPv4
      reply[2] = cast[uint8](0x08)
      reply[3] = cast[uint8](0x00)

      # Lengths
      reply[4] = cast[uint8](6)
      reply[5] = cast[uint8](4)

      # Operation: Reply (2)
      reply[6] = cast[uint8](0)
      reply[7] = cast[uint8](2)

      # Sender hardware address (our MAC)
      i = 0
      while i < 6:
        reply[8 + i] = my_mac[i]
        i = i + 1

      # Sender protocol address (our IP)
      i = 0
      while i < 4:
        reply[14 + i] = my_ip[i]
        i = i + 1

      # Target hardware address (requester's MAC)
      i = 0
      while i < 6:
        reply[18 + i] = data[8 + i]
        i = i + 1

      # Target protocol address (requester's IP)
      i = 0
      while i < 4:
        reply[24 + i] = data[14 + i]
        i = i + 1

      # Send reply to requester
      eth_send(addr(data[8]), ETH_TYPE_ARP, addr(reply[0]), 28)

  if op == ARP_REPLY:
    # Add to ARP cache
    ser_println(cast[ptr uint8]("[ARP] reply received"))
    if net_debug == 1:
      kprint(cast[ptr uint8]("[ARP reply from "))
      kprint_dec(cast[int32](data[14]))
      kprint(cast[ptr uint8]("."))
      kprint_dec(cast[int32](data[15]))
      kprint(cast[ptr uint8]("."))
      kprint_dec(cast[int32](data[16]))
      kprint(cast[ptr uint8]("."))
      kprint_dec(cast[int32](data[17]))
      kprintln(cast[ptr uint8]("]"))
    if arp_count < ARP_CACHE_SIZE:
      var idx: int32 = arp_count
      var i: int32 = 0

      # Store IP
      while i < 4:
        arp_ip[idx * 4 + i] = data[14 + i]
        i = i + 1

      # Store MAC
      i = 0
      while i < 6:
        arp_mac[idx * 6 + i] = data[8 + i]
        i = i + 1

      arp_count = arp_count + 1

# ============================================================================
# ICMP (Ping)
# ============================================================================

const ICMP_ECHO_REQUEST: int32 = 8
const ICMP_ECHO_REPLY: int32 = 0

proc icmp_handle_packet(src_ip: ptr uint8, data: ptr uint8, length: int32) =
  if length < 8:
    return

  var icmp_type: int32 = cast[int32](data[0])

  if net_debug == 1:
    kprint(cast[ptr uint8]("[ICMP type="))
    kprint_dec(icmp_type)
    kprint(cast[ptr uint8]("] "))

  if icmp_type == ICMP_ECHO_REQUEST:
    # Build echo reply
    var reply: array[1500, uint8]
    var i: int32 = 0

    # IP header (20 bytes)
    reply[0] = cast[uint8](0x45)  # Version 4, IHL 5
    reply[1] = cast[uint8](0)     # TOS

    var total_len: int32 = 20 + length
    reply[2] = cast[uint8]((total_len >> 8) & 0xFF)
    reply[3] = cast[uint8](total_len & 0xFF)

    reply[4] = cast[uint8](0)     # ID
    reply[5] = cast[uint8](0)
    reply[6] = cast[uint8](0)     # Flags, Fragment
    reply[7] = cast[uint8](0)
    reply[8] = cast[uint8](64)    # TTL
    reply[9] = cast[uint8](1)     # Protocol: ICMP

    reply[10] = cast[uint8](0)    # Checksum (will calculate)
    reply[11] = cast[uint8](0)

    # Source IP (our IP)
    i = 0
    while i < 4:
      reply[12 + i] = my_ip[i]
      i = i + 1

    # Destination IP
    i = 0
    while i < 4:
      reply[16 + i] = src_ip[i]
      i = i + 1

    # Calculate IP header checksum
    var ip_csum: int32 = ip_checksum(addr(reply[0]), 20)
    reply[10] = cast[uint8]((ip_csum >> 8) & 0xFF)
    reply[11] = cast[uint8](ip_csum & 0xFF)

    # ICMP Echo Reply
    reply[20] = cast[uint8](ICMP_ECHO_REPLY)  # Type
    reply[21] = cast[uint8](0)                 # Code
    reply[22] = cast[uint8](0)                 # Checksum (will calculate)
    reply[23] = cast[uint8](0)

    # Copy rest of ICMP data (ID, sequence, data)
    i = 4
    while i < length:
      reply[20 + i] = data[i]
      i = i + 1

    # Calculate ICMP checksum
    var icmp_csum: int32 = ip_checksum(addr(reply[20]), length)
    reply[22] = cast[uint8]((icmp_csum >> 8) & 0xFF)
    reply[23] = cast[uint8](icmp_csum & 0xFF)

    # Look up destination MAC in ARP cache (or use gateway)
    # For simplicity, send ARP request and use broadcast
    var dest_mac: array[6, uint8]
    i = 0
    while i < 6:
      dest_mac[i] = cast[uint8](0xFF)  # Broadcast for now
      i = i + 1

    # Check ARP cache
    i = 0
    while i < arp_count:
      var matched: int32 = 1
      var j: int32 = 0
      while j < 4:
        if arp_ip[i * 4 + j] != src_ip[j]:
          matched = 0
        j = j + 1
      if matched == 1:
        j = 0
        while j < 6:
          dest_mac[j] = arp_mac[i * 6 + j]
          j = j + 1
      i = i + 1

    eth_send(addr(dest_mac[0]), ETH_TYPE_IP, addr(reply[0]), total_len)
  if icmp_type == ICMP_ECHO_REPLY:
    # Received ping reply
    if net_debug == 1:
      kprint(cast[ptr uint8]("[ICMP Reply, pending="))
      kprint_dec(ping_pending)
      kprint(cast[ptr uint8]("] "))
    if ping_pending == 1:
      ping_pending = 0
      ping_received = 1
      # Extract sequence number and record time
      ping_reply_seq = (cast[int32](data[6]) << 8) | cast[int32](data[7])
      ping_reply_time = get_tick_count()
      if net_debug == 1:
        kprint(cast[ptr uint8]("[Got reply seq="))
        kprint_dec(ping_reply_seq)
        kprintln(cast[ptr uint8]("]"))

proc icmp_send_ping(dest_ip: ptr uint8) =
  var pkt: array[128, uint8]
  var i: int32 = 0

  # IP header (20 bytes)
  pkt[0] = cast[uint8](0x45)   # Version 4, IHL 5
  pkt[1] = cast[uint8](0)      # TOS
  pkt[2] = cast[uint8](0)      # Total length high
  pkt[3] = cast[uint8](28)     # Total length low (20 IP + 8 ICMP)
  pkt[4] = cast[uint8](0)      # ID
  pkt[5] = cast[uint8](0)
  pkt[6] = cast[uint8](0x40)   # Don't fragment
  pkt[7] = cast[uint8](0)
  pkt[8] = cast[uint8](64)     # TTL
  pkt[9] = cast[uint8](1)      # Protocol: ICMP
  pkt[10] = cast[uint8](0)     # Checksum (will calculate)
  pkt[11] = cast[uint8](0)

  # Source IP (our IP)
  i = 0
  while i < 4:
    pkt[12 + i] = my_ip[i]
    i = i + 1

  # Destination IP
  i = 0
  while i < 4:
    pkt[16 + i] = dest_ip[i]
    ping_target_ip[i] = dest_ip[i]
    i = i + 1

  # Calculate IP header checksum
  var ip_csum: int32 = ip_checksum(addr(pkt[0]), 20)
  pkt[10] = cast[uint8]((ip_csum >> 8) & 0xFF)
  pkt[11] = cast[uint8](ip_csum & 0xFF)

  # ICMP Echo Request
  pkt[20] = cast[uint8](ICMP_ECHO_REQUEST)  # Type
  pkt[21] = cast[uint8](0)                   # Code
  pkt[22] = cast[uint8](0)                   # Checksum (will calculate)
  pkt[23] = cast[uint8](0)
  pkt[24] = cast[uint8]((ping_id >> 8) & 0xFF)   # ID
  pkt[25] = cast[uint8](ping_id & 0xFF)
  pkt[26] = cast[uint8]((ping_seq >> 8) & 0xFF)  # Sequence
  pkt[27] = cast[uint8](ping_seq & 0xFF)

  # Calculate ICMP checksum
  var icmp_csum: int32 = ip_checksum(addr(pkt[20]), 8)
  pkt[22] = cast[uint8]((icmp_csum >> 8) & 0xFF)
  pkt[23] = cast[uint8](icmp_csum & 0xFF)

  # Need to find MAC for destination (use gateway MAC for now - ARP for 10.0.2.2)
  var dest_mac: array[6, uint8]
  var gateway_ip: array[4, uint8]
  gateway_ip[0] = cast[uint8](10)
  gateway_ip[1] = cast[uint8](0)
  gateway_ip[2] = cast[uint8](2)
  gateway_ip[3] = cast[uint8](2)

  # Look up gateway in ARP cache
  var found: int32 = 0
  i = 0
  while i < arp_count:
    var matched: int32 = 1
    var j: int32 = 0
    while j < 4:
      if arp_ip[i * 4 + j] != gateway_ip[j]:
        matched = 0
      j = j + 1
    if matched == 1:
      j = 0
      while j < 6:
        dest_mac[j] = arp_mac[i * 6 + j]
        j = j + 1
      found = 1
    i = i + 1

  if found == 0:
    # Send ARP request for gateway and wait for reply
    arp_send_request(addr(gateway_ip[0]))

    # Small delay to let TX complete
    var tx_delay: int32 = 0
    while tx_delay < 5000:
      tx_delay = tx_delay + 1

    if net_debug == 1:
      kprint(cast[ptr uint8]("[Waiting for ARP..."))
    # Wait up to 1 second for ARP reply using real timer ticks
    var start_tick: int32 = get_tick_count()
    var poll_count: int32 = 0
    var timeout_ticks: int32 = 1000  # 1 second (assuming ~1ms per tick)
    while (get_tick_count() - start_tick) < timeout_ticks:
      # Poll for ARP reply
      net_poll()
      poll_count = poll_count + 1

      # Check if gateway is now in cache
      var k: int32 = 0
      while k < arp_count:
        var arp_matched: int32 = 1
        var m: int32 = 0
        while m < 4:
          if arp_ip[k * 4 + m] != gateway_ip[m]:
            arp_matched = 0
          m = m + 1
        if arp_matched == 1:
          m = 0
          while m < 6:
            dest_mac[m] = arp_mac[k * 6 + m]
            m = m + 1
          found = 1
          timeout_ticks = 0  # Break outer loop
        k = k + 1

    if net_debug == 1:
      kprint_dec(poll_count)
      kprintln(cast[ptr uint8](" polls]"))
    if found == 0:
      # Still no ARP reply, can't send ping
      kprintln(cast[ptr uint8]("  ARP: no reply from gateway"))
      return

  ping_pending = 1
  ping_received = 0
  ping_send_time = get_tick_count()
  ping_seq = ping_seq + 1

  eth_send(addr(dest_mac[0]), ETH_TYPE_IP, addr(pkt[0]), 28)

# ============================================================================
# IP Packet Handling
# ============================================================================

const IP_PROTO_ICMP: int32 = 1
const IP_PROTO_TCP: int32 = 6
const IP_PROTO_UDP: int32 = 17

proc ip_handle_packet(data: ptr uint8, length: int32) =
  if length < 20:
    return

  var version: int32 = (cast[int32](data[0]) >> 4) & 0x0F
  if version != 4:
    return  # IPv4 only

  var ihl: int32 = cast[int32](data[0]) & 0x0F
  var header_len: int32 = ihl * 4

  var protocol: int32 = cast[int32](data[9])
  var src_ip: ptr uint8 = addr(data[12])
  var dest_ip: ptr uint8 = addr(data[16])

  # Check if packet is for us
  var for_us: int32 = 1
  var i: int32 = 0
  while i < 4:
    if dest_ip[i] != my_ip[i]:
      for_us = 0
    i = i + 1

  # Also accept broadcast
  if for_us == 0:
    var is_broadcast: int32 = 1
    i = 0
    while i < 4:
      if dest_ip[i] != cast[uint8](255):
        is_broadcast = 0
      i = i + 1
    if is_broadcast == 1:
      for_us = 1

  if for_us == 0:
    if net_debug == 1:
      kprintln(cast[ptr uint8]("[IP: not for us]"))
    return

  if net_debug == 1:
    kprint(cast[ptr uint8]("[IP proto="))
    kprint_dec(protocol)
    kprint(cast[ptr uint8]("] "))

  var payload: ptr uint8 = addr(data[header_len])
  var payload_len: int32 = length - header_len

  if protocol == IP_PROTO_ICMP:
    icmp_handle_packet(src_ip, payload, payload_len)
  if protocol == IP_PROTO_TCP:
    ser_print(cast[ptr uint8]("T"))
    tcp_handle_packet(src_ip, payload, payload_len)
    ser_print(cast[ptr uint8]("."))
  if protocol == IP_PROTO_UDP:
    udp_handle_packet(src_ip, payload, payload_len)

# ============================================================================
# UDP Protocol
# ============================================================================

proc udp_handle_packet(src_ip: ptr uint8, data: ptr uint8, length: int32) =
  if length < 8:
    return

  # Parse UDP header
  var src_port: int32 = (cast[int32](data[0]) << 8) | cast[int32](data[1])
  var dest_port: int32 = (cast[int32](data[2]) << 8) | cast[int32](data[3])
  var udp_len: int32 = (cast[int32](data[4]) << 8) | cast[int32](data[5])
  # Skip checksum at data[6-7]

  var payload: ptr uint8 = addr(data[8])
  var payload_len: int32 = udp_len - 8

  if net_debug == 1:
    kprint(cast[ptr uint8]("[UDP "))
    kprint_dec(src_port)
    kprint(cast[ptr uint8]("->"))
    kprint_dec(dest_port)
    kprint(cast[ptr uint8](" len="))
    kprint_dec(payload_len)
    kprintln(cast[ptr uint8]("]"))

  # Check for DHCP (port 68)
  if dest_port == 68:
    if src_port == 67:
      dhcp_handle_packet(payload, payload_len)
    return

  # Check if someone is waiting for this port
  if dest_port == udp_recv_port:
    if payload_len > 0:
      udp_recv_data = payload
      udp_recv_len = payload_len
      udp_recv_ready = 1

proc udp_send(dest_ip: ptr uint8, src_port: int32, dest_port: int32, data: ptr uint8, length: int32) =
  var pkt: array[1500, uint8]
  var i: int32 = 0

  # IP header (20 bytes)
  pkt[0] = cast[uint8](0x45)   # Version 4, IHL 5
  pkt[1] = cast[uint8](0)      # TOS
  var total_len: int32 = 20 + 8 + length  # IP + UDP header + data
  pkt[2] = cast[uint8]((total_len >> 8) & 0xFF)
  pkt[3] = cast[uint8](total_len & 0xFF)
  pkt[4] = cast[uint8](0)      # ID
  pkt[5] = cast[uint8](0)
  pkt[6] = cast[uint8](0x40)   # Don't fragment
  pkt[7] = cast[uint8](0)
  pkt[8] = cast[uint8](64)     # TTL
  pkt[9] = cast[uint8](17)     # Protocol: UDP
  pkt[10] = cast[uint8](0)     # Checksum (will calculate)
  pkt[11] = cast[uint8](0)

  # Source IP (our IP)
  i = 0
  while i < 4:
    pkt[12 + i] = my_ip[i]
    i = i + 1

  # Destination IP
  i = 0
  while i < 4:
    pkt[16 + i] = dest_ip[i]
    i = i + 1

  # Calculate IP header checksum
  var ip_csum: int32 = ip_checksum(addr(pkt[0]), 20)
  pkt[10] = cast[uint8]((ip_csum >> 8) & 0xFF)
  pkt[11] = cast[uint8](ip_csum & 0xFF)

  # UDP header (8 bytes)
  pkt[20] = cast[uint8]((src_port >> 8) & 0xFF)
  pkt[21] = cast[uint8](src_port & 0xFF)
  pkt[22] = cast[uint8]((dest_port >> 8) & 0xFF)
  pkt[23] = cast[uint8](dest_port & 0xFF)
  var udp_len: int32 = 8 + length
  pkt[24] = cast[uint8]((udp_len >> 8) & 0xFF)
  pkt[25] = cast[uint8](udp_len & 0xFF)
  pkt[26] = cast[uint8](0)     # Checksum (0 = not used)
  pkt[27] = cast[uint8](0)

  # Copy payload
  i = 0
  while i < length:
    pkt[28 + i] = data[i]
    i = i + 1

  # Look up destination MAC via ARP
  var dest_mac: array[6, uint8]
  var gateway_ip: array[4, uint8]
  gateway_ip[0] = cast[uint8](10)
  gateway_ip[1] = cast[uint8](0)
  gateway_ip[2] = cast[uint8](2)
  gateway_ip[3] = cast[uint8](2)

  # Use gateway for external destinations
  var found: int32 = 0
  i = 0
  while i < arp_count:
    var matched: int32 = 1
    var j: int32 = 0
    while j < 4:
      if arp_ip[i * 4 + j] != gateway_ip[j]:
        matched = 0
      j = j + 1
    if matched == 1:
      j = 0
      while j < 6:
        dest_mac[j] = arp_mac[i * 6 + j]
        j = j + 1
      found = 1
    i = i + 1

  if found == 0:
    # Send ARP and wait
    arp_send_request(addr(gateway_ip[0]))
    var start_tick: int32 = get_tick_count()
    while (get_tick_count() - start_tick) < 500:
      net_poll()
      var k: int32 = 0
      while k < arp_count:
        var arp_matched: int32 = 1
        var m: int32 = 0
        while m < 4:
          if arp_ip[k * 4 + m] != gateway_ip[m]:
            arp_matched = 0
          m = m + 1
        if arp_matched == 1:
          m = 0
          while m < 6:
            dest_mac[m] = arp_mac[k * 6 + m]
            m = m + 1
          found = 1
        k = k + 1
      if found == 1:
        start_tick = 0  # Break

  if found == 1:
    eth_send(addr(dest_mac[0]), ETH_TYPE_IP, addr(pkt[0]), total_len)

# ============================================================================
# DHCP Client
# ============================================================================

# DHCP message types
const DHCP_DISCOVER: int32 = 1
const DHCP_OFFER: int32 = 2
const DHCP_REQUEST: int32 = 3
const DHCP_DECLINE: int32 = 4
const DHCP_ACK: int32 = 5
const DHCP_NAK: int32 = 6
const DHCP_RELEASE: int32 = 7

# DHCP ports
const DHCP_SERVER_PORT: int32 = 67
const DHCP_CLIENT_PORT: int32 = 68

# DHCP magic cookie
const DHCP_MAGIC_1: int32 = 0x63
const DHCP_MAGIC_2: int32 = 0x82
const DHCP_MAGIC_3: int32 = 0x53
const DHCP_MAGIC_4: int32 = 0x63

# Send a DHCP packet (broadcast UDP from 0.0.0.0:68 to 255.255.255.255:67)
proc dhcp_send_packet(data: ptr uint8, length: int32) =
  var pkt: array[600, uint8]
  var i: int32 = 0

  # IP header (20 bytes)
  pkt[0] = cast[uint8](0x45)   # Version 4, IHL 5
  pkt[1] = cast[uint8](0)      # TOS
  var total_len: int32 = 20 + 8 + length  # IP + UDP header + data
  pkt[2] = cast[uint8]((total_len >> 8) & 0xFF)
  pkt[3] = cast[uint8](total_len & 0xFF)
  pkt[4] = cast[uint8](0)      # ID
  pkt[5] = cast[uint8](0)
  pkt[6] = cast[uint8](0x40)   # Don't fragment
  pkt[7] = cast[uint8](0)
  pkt[8] = cast[uint8](64)     # TTL
  pkt[9] = cast[uint8](17)     # Protocol: UDP
  pkt[10] = cast[uint8](0)     # Checksum (will calculate)
  pkt[11] = cast[uint8](0)

  # Source IP: 0.0.0.0
  pkt[12] = cast[uint8](0)
  pkt[13] = cast[uint8](0)
  pkt[14] = cast[uint8](0)
  pkt[15] = cast[uint8](0)

  # Destination IP: 255.255.255.255 (broadcast)
  pkt[16] = cast[uint8](255)
  pkt[17] = cast[uint8](255)
  pkt[18] = cast[uint8](255)
  pkt[19] = cast[uint8](255)

  # Calculate IP header checksum
  var ip_csum: int32 = ip_checksum(addr(pkt[0]), 20)
  pkt[10] = cast[uint8]((ip_csum >> 8) & 0xFF)
  pkt[11] = cast[uint8](ip_csum & 0xFF)

  # UDP header (8 bytes)
  pkt[20] = cast[uint8]((DHCP_CLIENT_PORT >> 8) & 0xFF)  # Source port: 68
  pkt[21] = cast[uint8](DHCP_CLIENT_PORT & 0xFF)
  pkt[22] = cast[uint8]((DHCP_SERVER_PORT >> 8) & 0xFF)  # Dest port: 67
  pkt[23] = cast[uint8](DHCP_SERVER_PORT & 0xFF)
  var udp_len: int32 = 8 + length
  pkt[24] = cast[uint8]((udp_len >> 8) & 0xFF)
  pkt[25] = cast[uint8](udp_len & 0xFF)
  pkt[26] = cast[uint8](0)     # Checksum (0 = not used)
  pkt[27] = cast[uint8](0)

  # Copy DHCP payload
  i = 0
  while i < length:
    pkt[28 + i] = data[i]
    i = i + 1

  # Send as broadcast Ethernet frame
  var result: int32 = eth_send(addr(broadcast_mac[0]), ETH_TYPE_IP, addr(pkt[0]), total_len)
  if result != 0:
    serial_putchar(69)  # 'E'
    ser_print_hex(result)
    serial_putchar(10)

# Build DHCP DISCOVER message
proc dhcp_send_discover() =
  var pkt: array[548, uint8]
  var i: int32 = 0

  # Zero the packet
  while i < 548:
    pkt[i] = cast[uint8](0)
    i = i + 1

  # Generate transaction ID
  dhcp_xid = get_tick_count()

  # DHCP header
  pkt[0] = cast[uint8](1)      # op: BOOTREQUEST
  pkt[1] = cast[uint8](1)      # htype: Ethernet
  pkt[2] = cast[uint8](6)      # hlen: MAC address length
  pkt[3] = cast[uint8](0)      # hops

  # Transaction ID (4 bytes)
  pkt[4] = cast[uint8]((dhcp_xid >> 24) & 0xFF)
  pkt[5] = cast[uint8]((dhcp_xid >> 16) & 0xFF)
  pkt[6] = cast[uint8]((dhcp_xid >> 8) & 0xFF)
  pkt[7] = cast[uint8](dhcp_xid & 0xFF)

  # secs (2 bytes) = 0
  # flags (2 bytes) - set broadcast flag
  pkt[10] = cast[uint8](0x80)  # Broadcast flag
  pkt[11] = cast[uint8](0x00)

  # ciaddr, yiaddr, siaddr, giaddr = 0 (already zeroed)

  # chaddr: client hardware address (MAC) at offset 28
  i = 0
  while i < 6:
    pkt[28 + i] = my_mac[i]
    i = i + 1
  # Remaining 10 bytes of chaddr are zeros

  # sname (64 bytes) at offset 44 = zeros
  # file (128 bytes) at offset 108 = zeros

  # DHCP options start at offset 236
  # Magic cookie
  pkt[236] = cast[uint8](DHCP_MAGIC_1)
  pkt[237] = cast[uint8](DHCP_MAGIC_2)
  pkt[238] = cast[uint8](DHCP_MAGIC_3)
  pkt[239] = cast[uint8](DHCP_MAGIC_4)

  # Option 53: DHCP Message Type = DISCOVER
  pkt[240] = cast[uint8](53)   # Option code
  pkt[241] = cast[uint8](1)    # Length
  pkt[242] = cast[uint8](DHCP_DISCOVER)

  # Option 55: Parameter Request List
  pkt[243] = cast[uint8](55)   # Option code
  pkt[244] = cast[uint8](4)    # Length
  pkt[245] = cast[uint8](1)    # Subnet mask
  pkt[246] = cast[uint8](3)    # Router
  pkt[247] = cast[uint8](6)    # DNS
  pkt[248] = cast[uint8](51)   # Lease time

  # Option 255: End
  pkt[249] = cast[uint8](255)

  dhcp_state = 1  # Discovering
  dhcp_send_packet(addr(pkt[0]), 300)

# Build DHCP REQUEST message
proc dhcp_send_request() =
  var pkt: array[548, uint8]
  var i: int32 = 0

  # Zero the packet
  while i < 548:
    pkt[i] = cast[uint8](0)
    i = i + 1

  # DHCP header
  pkt[0] = cast[uint8](1)      # op: BOOTREQUEST
  pkt[1] = cast[uint8](1)      # htype: Ethernet
  pkt[2] = cast[uint8](6)      # hlen: MAC address length
  pkt[3] = cast[uint8](0)      # hops

  # Transaction ID (same as discover)
  pkt[4] = cast[uint8]((dhcp_xid >> 24) & 0xFF)
  pkt[5] = cast[uint8]((dhcp_xid >> 16) & 0xFF)
  pkt[6] = cast[uint8]((dhcp_xid >> 8) & 0xFF)
  pkt[7] = cast[uint8](dhcp_xid & 0xFF)

  # flags - broadcast
  pkt[10] = cast[uint8](0x80)
  pkt[11] = cast[uint8](0x00)

  # chaddr: client hardware address (MAC) at offset 28
  i = 0
  while i < 6:
    pkt[28 + i] = my_mac[i]
    i = i + 1

  # DHCP options start at offset 236
  # Magic cookie
  pkt[236] = cast[uint8](DHCP_MAGIC_1)
  pkt[237] = cast[uint8](DHCP_MAGIC_2)
  pkt[238] = cast[uint8](DHCP_MAGIC_3)
  pkt[239] = cast[uint8](DHCP_MAGIC_4)

  # Option 53: DHCP Message Type = REQUEST
  pkt[240] = cast[uint8](53)
  pkt[241] = cast[uint8](1)
  pkt[242] = cast[uint8](DHCP_REQUEST)

  # Option 50: Requested IP Address
  pkt[243] = cast[uint8](50)
  pkt[244] = cast[uint8](4)
  pkt[245] = dhcp_offered_ip[0]
  pkt[246] = dhcp_offered_ip[1]
  pkt[247] = dhcp_offered_ip[2]
  pkt[248] = dhcp_offered_ip[3]

  # Option 54: Server Identifier
  pkt[249] = cast[uint8](54)
  pkt[250] = cast[uint8](4)
  pkt[251] = dhcp_server_ip[0]
  pkt[252] = dhcp_server_ip[1]
  pkt[253] = dhcp_server_ip[2]
  pkt[254] = dhcp_server_ip[3]

  # Option 255: End
  pkt[255] = cast[uint8](255)

  dhcp_state = 2  # Requesting
  dhcp_send_packet(addr(pkt[0]), 300)

# Handle incoming DHCP packet (called from udp_handle_packet)
proc dhcp_handle_packet(data: ptr uint8, length: int32) =
  if length < 240:
    return

  # Check op = 2 (BOOTREPLY)
  if data[0] != cast[uint8](2):
    return

  # Check transaction ID
  var rxid: int32 = (cast[int32](data[4]) << 24) | (cast[int32](data[5]) << 16) | (cast[int32](data[6]) << 8) | cast[int32](data[7])
  if rxid != dhcp_xid:
    return

  # Check magic cookie at offset 236
  if data[236] != cast[uint8](DHCP_MAGIC_1):
    return
  if data[237] != cast[uint8](DHCP_MAGIC_2):
    return
  if data[238] != cast[uint8](DHCP_MAGIC_3):
    return
  if data[239] != cast[uint8](DHCP_MAGIC_4):
    return

  # Get offered IP (yiaddr at offset 16)
  dhcp_offered_ip[0] = data[16]
  dhcp_offered_ip[1] = data[17]
  dhcp_offered_ip[2] = data[18]
  dhcp_offered_ip[3] = data[19]

  # Parse DHCP options starting at offset 240
  var i: int32 = 240
  var msg_type: int32 = 0
  while i < length:
    var opt: int32 = cast[int32](data[i])
    if opt == 255:  # End
      i = length
    else:
      if opt == 0:  # Padding
        i = i + 1
      else:
        var opt_len: int32 = cast[int32](data[i + 1])
        if opt == 53:  # DHCP Message Type
          msg_type = cast[int32](data[i + 2])
        if opt == 54:  # Server Identifier
          dhcp_server_ip[0] = data[i + 2]
          dhcp_server_ip[1] = data[i + 3]
          dhcp_server_ip[2] = data[i + 4]
          dhcp_server_ip[3] = data[i + 5]
        if opt == 1:  # Subnet Mask
          dhcp_subnet[0] = data[i + 2]
          dhcp_subnet[1] = data[i + 3]
          dhcp_subnet[2] = data[i + 4]
          dhcp_subnet[3] = data[i + 5]
        if opt == 3:  # Router
          dhcp_gateway[0] = data[i + 2]
          dhcp_gateway[1] = data[i + 3]
          dhcp_gateway[2] = data[i + 4]
          dhcp_gateway[3] = data[i + 5]
        if opt == 6:  # DNS
          dhcp_dns[0] = data[i + 2]
          dhcp_dns[1] = data[i + 3]
          dhcp_dns[2] = data[i + 4]
          dhcp_dns[3] = data[i + 5]
        if opt == 51:  # Lease Time
          dhcp_lease_time = (cast[int32](data[i + 2]) << 24) | (cast[int32](data[i + 3]) << 16) | (cast[int32](data[i + 4]) << 8) | cast[int32](data[i + 5])
        i = i + 2 + opt_len

  # Handle message type
  if msg_type == DHCP_OFFER:
    if dhcp_state == 1:  # We were discovering
      # Print "Offer: " using putchar (kprint has issues in packet handler context)
      vga_putchar(79)
      serial_putchar(79)
      vga_putchar(102)
      serial_putchar(102)
      vga_putchar(102)
      serial_putchar(102)
      vga_putchar(101)
      serial_putchar(101)
      vga_putchar(114)
      serial_putchar(114)
      vga_putchar(58)
      serial_putchar(58)
      vga_putchar(32)
      serial_putchar(32)
      print_ip_addr(addr(dhcp_offered_ip[0]))
      vga_putchar(10)
      serial_putchar(10)
      dhcp_send_request()

  if msg_type == DHCP_ACK:
    if dhcp_state == 2:  # We were requesting
      # Apply the configuration
      my_ip[0] = dhcp_offered_ip[0]
      my_ip[1] = dhcp_offered_ip[1]
      my_ip[2] = dhcp_offered_ip[2]
      my_ip[3] = dhcp_offered_ip[3]
      dhcp_state = 3  # Bound
      # Print "Bound: " using putchar
      vga_putchar(66)
      serial_putchar(66)
      vga_putchar(111)
      serial_putchar(111)
      vga_putchar(117)
      serial_putchar(117)
      vga_putchar(110)
      serial_putchar(110)
      vga_putchar(100)
      serial_putchar(100)
      vga_putchar(58)
      serial_putchar(58)
      vga_putchar(32)
      serial_putchar(32)
      print_ip()
      vga_putchar(10)
      serial_putchar(10)

  if msg_type == DHCP_NAK:
    dhcp_state = 0  # Back to idle
    kprintln(cast[ptr uint8]("[DHCP] NAK received"))

# Run DHCP to get an IP address
proc dhcp_init(): int32 =
  vga_putchar(91)
  serial_putchar(91)
  vga_putchar(68)
  serial_putchar(68)
  vga_putchar(72)
  serial_putchar(72)
  vga_putchar(67)
  serial_putchar(67)
  vga_putchar(80)
  serial_putchar(80)
  vga_putchar(93)
  serial_putchar(93)
  vga_putchar(32)
  serial_putchar(32)
  vga_putchar(68)
  serial_putchar(68)
  vga_putchar(105)
  serial_putchar(105)
  vga_putchar(115)
  serial_putchar(115)
  vga_putchar(99)
  serial_putchar(99)
  vga_putchar(10)
  serial_putchar(10)
  dhcp_send_discover()

  # Wait for response
  var start_tick: int32 = get_tick_count()
  while (get_tick_count() - start_tick) < 300:  # ~3-5 seconds timeout
    wait_tick()  # Wait for timer interrupt
    net_poll()
    if dhcp_state == 3:  # Bound
      return 1
    if dhcp_state == 0:  # NAK or failed
      return 0

  kprintln(cast[ptr uint8]("[DHCP] Timeout"))
  return 0

# ============================================================================
# NTP Client
# ============================================================================

# NTP constants
const NTP_PORT: int32 = 123

# Get NTP offset as two parts (since 2208988800 > 2^31)
# 2208988800 = 2000000000 + 208988800
proc ntp_offset_high(): int32 =
  return 2000000000

proc ntp_offset_low(): int32 =
  return 208988800

# Get current Unix timestamp (seconds since 1970)
proc get_unix_time(): int32 =
  if ntp_synced == 0:
    return 0
  var elapsed_ticks: int32 = get_tick_count() - ntp_sync_tick
  var elapsed_secs: int32 = elapsed_ticks / 100  # Assuming 100 ticks per second
  return ntp_timestamp + elapsed_secs

# Send NTP request
proc ntp_send_request(server_ip: ptr uint8) =
  var pkt: array[48, uint8]
  var i: int32 = 0

  # Zero the packet
  while i < 48:
    pkt[i] = cast[uint8](0)
    i = i + 1

  # LI=0, VN=4, Mode=3 (client)
  pkt[0] = cast[uint8](0x23)  # 00 100 011 = LI=0, VN=4, Mode=3

  # Send via UDP
  udp_send(server_ip, 123, NTP_PORT, addr(pkt[0]), 48)

# Handle NTP response
proc ntp_handle_response(data: ptr uint8, length: int32) =
  if length < 48:
    return

  # Extract transmit timestamp (bytes 40-47)
  # NTP timestamp is seconds since 1900-01-01
  # We only use the seconds part (bytes 40-43), ignoring fraction (44-47)
  var ntp_secs: int32 = (cast[int32](data[40]) << 24) | (cast[int32](data[41]) << 16) | (cast[int32](data[42]) << 8) | cast[int32](data[43])

  # Convert to Unix timestamp (seconds since 1970)
  # NTP epoch is 1900, Unix epoch is 1970
  # Difference is 70 years = 2208988800 seconds
  # We subtract in two parts since 2208988800 > 2^31
  # ntp_secs - 2000000000 - 208988800
  ntp_timestamp = ntp_secs - ntp_offset_high() - ntp_offset_low()
  ntp_sync_tick = get_tick_count()
  ntp_synced = 1

# ============================================================================
# Simple HTTP Server
# ============================================================================

proc run_httpd() =
  kprintln(cast[ptr uint8]("[HTTP] Starting server on port 80..."))
  kprintln(cast[ptr uint8]("[HTTP] Press any key to stop"))

  # Listen on port 80
  var conn: int32 = tcp_listen(80)
  if conn < 0:
    kprintln(cast[ptr uint8]("[HTTP] Failed to create listening socket"))
    return

  kprintln(cast[ptr uint8]("[HTTP] Listening on 0.0.0.0:80"))
  kprintln(cast[ptr uint8]("[HTTP] Connect from host: curl http://localhost:5555"))

  # HTTP response header
  var http_header: ptr uint8 = cast[ptr uint8]("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n")
  var http_body: ptr uint8 = cast[ptr uint8]("<html><head><title>BrainhairOS</title></head><body><h1>Hello from BrainhairOS!</h1><p>This page is served by a TCP/IP stack written from scratch.</p></body></html>")

  var running: int32 = 1
  while running == 1:
    # Poll for keyboard input to stop
    if keyboard_available() > 0:
      keyboard_read_char()  # Consume the key
      running = 0
      break

    # Poll network
    net_poll()

    # Check if connection established (client connected)
    if tcp_state[conn] == TCP_STATE_ESTABLISHED:
      kprintln(cast[ptr uint8]("[HTTP] Client connected!"))

      # Wait for HTTP request
      var wait_start: int32 = get_tick_count()
      while (get_tick_count() - wait_start) < 2000:
        net_poll()
        if tcp_recv_ready[conn] == 1:
          # Got request - print first line
          kprint(cast[ptr uint8]("[HTTP] Request: "))
          var ri: int32 = 0
          while ri < tcp_recv_len[conn]:
            if ri > 40:
              break
            var ch: int32 = cast[int32](tcp_recv_buf[conn * TCP_BUF_SIZE + ri])
            if ch == 13 or ch == 10:
              break
            serial_putchar(ch)
            vga_putchar(ch)
            ri = ri + 1
          kprintln(cast[ptr uint8](""))
          tcp_recv_ready[conn] = 0

          # Send HTTP response
          kprintln(cast[ptr uint8]("[HTTP] Sending response..."))
          tcp_write(conn, http_header, fs_strlen(http_header))
          tcp_write(conn, http_body, fs_strlen(http_body))

          # Close connection
          tcp_close(conn)
          kprintln(cast[ptr uint8]("[HTTP] Connection closed"))

          # Re-listen for next connection
          conn = tcp_listen(80)
          if conn < 0:
            kprintln(cast[ptr uint8]("[HTTP] Failed to re-listen"))
            running = 0
          break

  # Clean up
  if conn >= 0:
    tcp_close(conn)
  kprintln(cast[ptr uint8]("[HTTP] Server stopped"))

# ============================================================================
# Flask-style Web App Demo
# ============================================================================

# Parse HTTP request path (returns length)
proc webapp_parse_path(req: ptr uint8, path: ptr uint8, max: int32): int32 =
  var i: int32 = 0
  # Skip method
  while cast[int32](req[i]) != 0 and cast[int32](req[i]) != 32:
    i = i + 1
  if cast[int32](req[i]) == 0:
    return 0
  i = i + 1
  # Copy path
  var len: int32 = 0
  while cast[int32](req[i]) != 0 and cast[int32](req[i]) != 32 and cast[int32](req[i]) != 63 and len < max - 1:
    path[len] = req[i]
    len = len + 1
    i = i + 1
  path[len] = cast[uint8](0)
  return len

# Send HTTP response helper
proc webapp_send(conn: int32, status: int32, ctype: ptr uint8, body: ptr uint8) =
  if status == 200:
    discard tcp_write(conn, cast[ptr uint8]("HTTP/1.0 200 OK\r\n"), 17)
  elif status == 404:
    discard tcp_write(conn, cast[ptr uint8]("HTTP/1.0 404 Not Found\r\n"), 24)
  else:
    discard tcp_write(conn, cast[ptr uint8]("HTTP/1.0 500 Error\r\n"), 20)

  discard tcp_write(conn, cast[ptr uint8]("Content-Type: "), 14)
  discard tcp_write(conn, ctype, fs_strlen(ctype))
  discard tcp_write(conn, cast[ptr uint8]("\r\n\r\n"), 4)
  discard tcp_write(conn, body, fs_strlen(body))

# Response helpers (Flask-style)
proc html(conn: int32, body: ptr uint8) =
  webapp_send(conn, 200, cast[ptr uint8]("text/html"), body)

proc json_resp(conn: int32, body: ptr uint8) =
  webapp_send(conn, 200, cast[ptr uint8]("application/json"), body)

proc not_found(conn: int32) =
  webapp_send(conn, 404, cast[ptr uint8]("text/html"),
    cast[ptr uint8]("<h1>404 Not Found</h1>"))

# Userland webapp - runs the embedded ELF binary
proc run_userland_webapp() =
  kprintln(cast[ptr uint8](" * Loading userland webapp..."))

  # Get pointer to embedded ELF
  var elf_ptr: int32 = get_webapp_bin()

  # Validate ELF
  var valid: int32 = elf_validate(elf_ptr)
  if valid == 0:
    kprintln(cast[ptr uint8](" * Error: invalid ELF binary"))
    return

  var elf_size: int32 = get_webapp_bin_size()
  kprint(cast[ptr uint8](" * ELF size: "))
  kprint_dec(elf_size)
  kprint(cast[ptr uint8](" bytes (0x"))
  vga_print_hex(elf_size)
  kprintln(cast[ptr uint8](")"))

  # Map the userland address space (0x08048000 - 0x08058000)
  # Map virtual addresses to physical addresses in available memory
  # Use physical 0x00200000 - 0x00210000 (2MB-2.0625MB, in kernel heap area)
  kprintln(cast[ptr uint8](" * Mapping userland pages..."))
  var vpage: int32 = 0x08048000
  var ppage: int32 = 0x00200000  # Physical address in available range
  while vpage < 0x08058000:
    discard map_page(vpage, ppage, 7)  # 7 = Present+Writable+User
    vpage = vpage + 4096
    ppage = ppage + 4096

  # Load ELF into memory (0 = use virtual addresses from ELF)
  var entry: int32 = elf_load(elf_ptr, 0)
  if entry == 0:
    kprintln(cast[ptr uint8](" * Error: failed to load ELF"))
    return

  kprint(cast[ptr uint8](" * Entry point: 0x"))
  vga_print_hex(entry)
  kprintln(cast[ptr uint8](""))

  # Debug: verify code was loaded correctly by printing first few bytes
  kprint(cast[ptr uint8](" * Code @ entry: "))
  var entry_ptr: ptr uint8 = cast[ptr uint8](entry)
  var j: int32 = 0
  while j < 8:
    vga_print_hex(cast[int32](entry_ptr[j]))
    kprint(cast[ptr uint8](" "))
    j = j + 1
  kprintln(cast[ptr uint8](""))

  # Debug: check code at expected index address (0x0804B9A3)
  kprint(cast[ptr uint8](" * Code @ 0x0804B9A3: "))
  var idx_ptr: ptr uint8 = cast[ptr uint8](0x0804B9A3)
  j = 0
  while j < 8:
    vga_print_hex(cast[int32](idx_ptr[j]))
    kprint(cast[ptr uint8](" "))
    j = j + 1
  kprintln(cast[ptr uint8](""))

  # Call entry point directly (for testing)
  # This runs the webapp in kernel mode
  kprintln(cast[ptr uint8](" * Calling webapp entry point directly..."))
  call_entry(entry)

  # Debug: print route_handlers[0] after webapp returns (it shouldn't return, but just in case)
  kprint(cast[ptr uint8](" * route_handlers[0] = 0x"))
  var rh_ptr: ptr int32 = cast[ptr int32](0x0804C560)  # Approximate address of route_handlers
  vga_print_hex(rh_ptr[0])
  kprintln(cast[ptr uint8](""))

# VTNext Desktop Environment
# A simple graphical desktop with taskbar, clock, and app launcher

var desktop_running: int32 = 0
var apps_menu_open: int32 = 0  # Is Apps menu popup visible?

proc vtn_send(cmd: ptr uint8) =
  # Send VTNext escape sequence: ESC ] vtn ; cmd BEL
  serial_putchar(27)   # ESC
  serial_putchar(93)   # ]
  ser_print(cast[ptr uint8]("vtn;"))
  ser_print(cmd)
  serial_putchar(7)    # BEL

proc vtn_clear(r: int32, g: int32, b: int32) =
  serial_putchar(27)
  serial_putchar(93)
  ser_print(cast[ptr uint8]("vtn;clear;"))
  ser_print_int(r)
  serial_putchar(59)  # ;
  ser_print_int(g)
  serial_putchar(59)
  ser_print_int(b)
  serial_putchar(59)
  ser_print(cast[ptr uint8]("255"))
  serial_putchar(7)

proc vtn_rect(x: int32, y: int32, w: int32, h: int32, r: int32, g: int32, b: int32, filled: int32) =
  serial_putchar(27)
  serial_putchar(93)
  ser_print(cast[ptr uint8]("vtn;rect;"))
  ser_print_int(x)
  serial_putchar(59)
  ser_print_int(y)
  ser_print(cast[ptr uint8](";1;"))
  ser_print_int(w)
  serial_putchar(59)
  ser_print_int(h)
  ser_print(cast[ptr uint8](";0;"))
  ser_print_int(r)
  serial_putchar(59)
  ser_print_int(g)
  serial_putchar(59)
  ser_print_int(b)
  ser_print(cast[ptr uint8](";255;"))
  ser_print_int(filled)
  serial_putchar(7)

proc vtn_circle(x: int32, y: int32, radius: int32, r: int32, g: int32, b: int32) =
  serial_putchar(27)
  serial_putchar(93)
  ser_print(cast[ptr uint8]("vtn;circle;"))
  ser_print_int(x)
  serial_putchar(59)
  ser_print_int(y)
  ser_print(cast[ptr uint8](";1;"))
  ser_print_int(radius)
  serial_putchar(59)
  ser_print_int(r)
  serial_putchar(59)
  ser_print_int(g)
  serial_putchar(59)
  ser_print_int(b)
  ser_print(cast[ptr uint8](";255;1"))
  serial_putchar(7)

proc vtn_text(x: int32, y: int32, r: int32, g: int32, b: int32, text: ptr uint8) =
  serial_putchar(27)
  serial_putchar(93)
  ser_print(cast[ptr uint8]("vtn;text;"))
  ser_print_int(x)
  serial_putchar(59)
  ser_print_int(y)
  ser_print(cast[ptr uint8](";1;0;1.0;"))
  ser_print_int(r)
  serial_putchar(59)
  ser_print_int(g)
  serial_putchar(59)
  ser_print_int(b)
  ser_print(cast[ptr uint8](";255;"))
  serial_putchar(34)  # "
  ser_print(text)
  serial_putchar(34)  # "
  serial_putchar(7)

proc desktop_draw_taskbar() =
  # Taskbar background (bottom of screen)
  vtn_rect(0, 720, 1024, 48, 40, 44, 52, 1)

  # Start button
  vtn_rect(4, 724, 80, 40, 60, 120, 200, 1)
  vtn_text(24, 744, 255, 255, 255, cast[ptr uint8]("Apps"))

  # App buttons
  vtn_rect(90, 724, 70, 40, 50, 55, 65, 1)
  vtn_text(100, 744, 200, 200, 200, cast[ptr uint8]("Term"))

  vtn_rect(165, 724, 70, 40, 50, 55, 65, 1)
  vtn_text(175, 744, 200, 200, 200, cast[ptr uint8]("Demo"))

  vtn_rect(240, 724, 70, 40, 50, 55, 65, 1)
  vtn_text(250, 744, 200, 200, 200, cast[ptr uint8]("Pong"))

# Draw Apps menu popup (if open)
proc desktop_draw_apps_menu() =
  if apps_menu_open == 0:
    return

  # Menu background (above Apps button)
  vtn_rect(4, 520, 140, 196, 50, 55, 65, 1)
  vtn_rect(6, 522, 136, 192, 35, 40, 50, 1)

  # Menu items
  vtn_rect(10, 528, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 544, 255, 255, 255, cast[ptr uint8]("Terminal"))

  vtn_rect(10, 560, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 576, 255, 255, 255, cast[ptr uint8]("Files"))

  vtn_rect(10, 592, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 608, 255, 255, 255, cast[ptr uint8]("Demo"))

  vtn_rect(10, 624, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 640, 255, 255, 255, cast[ptr uint8]("Pong"))

  vtn_rect(10, 656, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 672, 255, 255, 255, cast[ptr uint8]("Calculator"))

  vtn_rect(10, 688, 128, 28, 60, 65, 80, 1)
  vtn_text(18, 704, 255, 255, 255, cast[ptr uint8]("Quit"))

proc desktop_draw_icons() =
  # Desktop icons (top-left area)
  # Terminal icon
  vtn_rect(30, 30, 64, 64, 50, 50, 50, 1)
  vtn_rect(35, 35, 54, 44, 20, 20, 30, 1)
  vtn_text(35, 110, 255, 255, 255, cast[ptr uint8]("Terminal"))

  # Files icon
  vtn_rect(130, 30, 64, 64, 200, 180, 100, 1)
  vtn_rect(135, 25, 50, 10, 180, 160, 80, 1)
  vtn_text(140, 110, 255, 255, 255, cast[ptr uint8]("Files"))

  # Settings icon
  vtn_circle(192, 192, 30, 100, 100, 120)
  vtn_text(155, 235, 255, 255, 255, cast[ptr uint8]("Settings"))

proc desktop_draw_clock() =
  # Clock area (top-right)
  vtn_rect(900, 4, 120, 24, 30, 34, 42, 1)
  # Just show static time for now
  vtn_text(910, 16, 200, 200, 200, cast[ptr uint8]("12:00 PM"))

proc desktop_draw_window(x: int32, y: int32, w: int32, h: int32, title: ptr uint8) =
  # Window background
  vtn_rect(x, y, w, h, 45, 50, 60, 1)
  # Title bar
  vtn_rect(x, y, w, 28, 60, 70, 90, 1)
  vtn_text(x + 10, y + 14, 255, 255, 255, title)
  # Close button
  vtn_rect(x + w - 26, y + 4, 20, 20, 200, 60, 60, 1)
  vtn_text(x + w - 22, y + 14, 255, 255, 255, cast[ptr uint8]("X"))

# Mouse state
var mouse_x: int32 = 512
var mouse_y: int32 = 384
var mouse_buttons: int32 = 0  # Bit flags: 1=left, 2=middle, 4=right
var mouse_click_x: int32 = 0
var mouse_click_y: int32 = 0
var mouse_clicked: int32 = 0

# Window manager state
const MAX_WINDOWS: int32 = 16
const WIN_VISIBLE: int32 = 1
const WIN_FOCUSED: int32 = 2
const WIN_CLOSABLE: int32 = 16
const TITLEBAR_HEIGHT: int32 = 28

var win_x: array[16, int32]
var win_y: array[16, int32]
var win_w: array[16, int32]
var win_h: array[16, int32]
var win_flags: array[16, int32]
var win_count: int32 = 0
var win_focused: int32 = -1
var win_dragging: int32 = -1
var drag_offset_x: int32 = 0
var drag_offset_y: int32 = 0

# Window title pointers (stored separately due to type limitations)
var win_title_0: ptr uint8 = cast[ptr uint8](0)
var win_title_1: ptr uint8 = cast[ptr uint8](0)
var win_title_2: ptr uint8 = cast[ptr uint8](0)
var win_title_3: ptr uint8 = cast[ptr uint8](0)

# Parse numbers from buffer at position, returns value and updates pos
proc parse_num_at(buf: ptr uint8, pos: ptr int32, max_pos: int32): int32 =
  var num: int32 = 0
  var p: int32 = pos[0]
  while p < max_pos:
    var c: int32 = cast[int32](buf[p])
    if c >= 48 and c <= 57:
      num = num * 10 + (c - 48)
      p = p + 1
    elif c == 59 or c == 7:  # semicolon or BEL
      p = p + 1
      break
    else:
      p = p + 1
      break
  pos[0] = p
  return num

# Handle mouse down event
proc handle_mouse_down(x: int32, y: int32, button: int32) =
  mouse_x = x
  mouse_y = y
  if button == 1:
    mouse_buttons = mouse_buttons | 1

  # Check if clicking on a window titlebar to start drag
  var i: int32 = win_count - 1  # Check from front to back
  while i >= 0:
    if (win_flags[i] & WIN_VISIBLE) != 0:
      # Check titlebar hit
      if x >= win_x[i] and x < win_x[i] + win_w[i]:
        if y >= win_y[i] and y < win_y[i] + TITLEBAR_HEIGHT:
          # Check close button first
          if x >= win_x[i] + win_w[i] - 26 and x < win_x[i] + win_w[i] - 6:
            if y >= win_y[i] + 4 and y < win_y[i] + 24:
              # Close button clicked - destroy window
              win_flags[i] = 0
              win_count = win_count - 1
              return
          # Start dragging
          win_dragging = i
          drag_offset_x = x - win_x[i]
          drag_offset_y = y - win_y[i]
          win_focused = i
          return
      # Check window body hit
      if x >= win_x[i] and x < win_x[i] + win_w[i]:
        if y >= win_y[i] and y < win_y[i] + win_h[i]:
          win_focused = i
          return
    i = i - 1

  # No window hit - set click for taskbar handling
  mouse_click_x = x
  mouse_click_y = y
  mouse_clicked = 1

# Handle mouse up event
proc handle_mouse_up(x: int32, y: int32, button: int32) =
  mouse_x = x
  mouse_y = y
  if button == 1:
    mouse_buttons = mouse_buttons & 0xFFFFFFFE
    win_dragging = -1

# Handle mouse move event
proc handle_mouse_move(x: int32, y: int32) =
  mouse_x = x
  mouse_y = y

  # If dragging a window, move it
  if win_dragging >= 0 and win_dragging < win_count:
    win_x[win_dragging] = x - drag_offset_x
    win_y[win_dragging] = y - drag_offset_y
    # Clamp to screen bounds
    if win_x[win_dragging] < 0:
      win_x[win_dragging] = 0
    if win_y[win_dragging] < 0:
      win_y[win_dragging] = 0
    if win_x[win_dragging] > 1024 - 100:
      win_x[win_dragging] = 1024 - 100
    if win_y[win_dragging] > 768 - 50:
      win_y[win_dragging] = 768 - 50

# Parse mouse/keyboard input from serial
# Global flag for redraw request (set by mouse handlers)
var desktop_needs_redraw: int32 = 0

# Global key state tracking
var key_w_held: int32 = 0
var key_s_held: int32 = 0
var key_up_held: int32 = 0
var key_down_held: int32 = 0
var key_q_held: int32 = 0

# ============== Terminal State ==============
# Terminal output buffer - 12 lines of 48 chars each
var term_lines: array[576, uint8]  # 12 * 48 = 576
var term_line_count: int32 = 0      # Number of output lines
var term_cmd: array[50, uint8]      # Current command input
var term_cmd_len: int32 = 0         # Length of current command
var term_scroll: int32 = 0          # Scroll position
var term_active_win: int32 = -1     # Which window is the active terminal
var term_tmp_buf: array[64, uint8]  # Temp buffer for building strings

# Clear terminal output buffer
proc term_clear() =
  var i: int32 = 0
  while i < 576:
    term_lines[i] = 0
    i = i + 1
  term_line_count = 0
  term_scroll = 0

# Add a line to terminal output
proc term_add_line(text: ptr uint8) =
  # Shift lines up if buffer is full
  if term_line_count >= 12:
    var i: int32 = 0
    while i < 528:  # 11 * 48
      term_lines[i] = term_lines[i + 48]
      i = i + 1
    term_line_count = 11

  # Copy new line to buffer
  var dst: int32 = term_line_count * 48
  var j: int32 = 0
  while j < 47 and text[j] != 0:
    term_lines[dst + j] = text[j]
    j = j + 1
  term_lines[dst + j] = 0
  term_line_count = term_line_count + 1

# Execute terminal command
proc term_execute_cmd() =
  # Echo command to output using global buffer
  term_tmp_buf[0] = cast[uint8](62)  # '>'
  term_tmp_buf[1] = cast[uint8](32)  # ' '
  var i: int32 = 0
  while i < term_cmd_len and i < 46:
    term_tmp_buf[i + 2] = term_cmd[i]
    i = i + 1
  term_tmp_buf[i + 2] = 0
  term_add_line(cast[ptr uint8](term_tmp_buf))

  # Parse and execute command
  if term_cmd_len == 0:
    # Empty command
    discard 0

  # Check for 'help'
  if cast[int32](term_cmd[0]) == 104 and cast[int32](term_cmd[1]) == 101 and cast[int32](term_cmd[2]) == 108 and cast[int32](term_cmd[3]) == 112:
    term_add_line(cast[ptr uint8]("Commands: help clear echo uptime ps"))

  # Check for 'clear'
  if cast[int32](term_cmd[0]) == 99 and cast[int32](term_cmd[1]) == 108 and cast[int32](term_cmd[2]) == 101 and cast[int32](term_cmd[3]) == 97 and cast[int32](term_cmd[4]) == 114:
    term_clear()

  # Check for 'echo '
  if cast[int32](term_cmd[0]) == 101 and cast[int32](term_cmd[1]) == 99 and cast[int32](term_cmd[2]) == 104 and cast[int32](term_cmd[3]) == 111 and cast[int32](term_cmd[4]) == 32:
    var j: int32 = 5  # Skip 'echo '
    var k: int32 = 0
    while j < term_cmd_len and k < 47:
      term_tmp_buf[k] = term_cmd[j]
      j = j + 1
      k = k + 1
    term_tmp_buf[k] = 0
    term_add_line(cast[ptr uint8](term_tmp_buf))

  # Check for 'uptime'
  if cast[int32](term_cmd[0]) == 117 and cast[int32](term_cmd[1]) == 112 and cast[int32](term_cmd[2]) == 116 and cast[int32](term_cmd[3]) == 105 and cast[int32](term_cmd[4]) == 109 and cast[int32](term_cmd[5]) == 101:
    var ticks: int32 = get_tick_count()
    var secs: int32 = ticks / 18
    term_tmp_buf[0] = cast[uint8](85)  # U
    term_tmp_buf[1] = cast[uint8](112)  # p
    term_tmp_buf[2] = cast[uint8](58)  # :
    term_tmp_buf[3] = cast[uint8](32)  # space
    # Convert to string
    var num: int32 = secs
    var pos: int32 = 4
    if num == 0:
      term_tmp_buf[pos] = cast[uint8](48)
      pos = pos + 1
    else:
      # Store digits in reverse order at end of buffer
      var nd: int32 = 0
      while num > 0:
        term_tmp_buf[60 + nd] = cast[uint8](48 + (num % 10))
        num = num / 10
        nd = nd + 1
      while nd > 0:
        nd = nd - 1
        term_tmp_buf[pos] = term_tmp_buf[60 + nd]
        pos = pos + 1
    term_tmp_buf[pos] = cast[uint8](115)  # s
    pos = pos + 1
    term_tmp_buf[pos] = 0
    term_add_line(cast[ptr uint8](term_tmp_buf))

  # Check for 'ps'
  if cast[int32](term_cmd[0]) == 112 and cast[int32](term_cmd[1]) == 115 and term_cmd_len == 2:
    term_add_line(cast[ptr uint8]("PID  NAME"))
    term_add_line(cast[ptr uint8]("1    kernel"))
    term_add_line(cast[ptr uint8]("2    desktop"))

  # Clear command buffer
  term_cmd_len = 0
  i = 0
  while i < 50:
    term_cmd[i] = 0
    i = i + 1

# Handle terminal keyboard input
proc term_handle_key(ch: int32) =
  if ch == 13 or ch == 10:  # Enter
    term_execute_cmd()
    desktop_needs_redraw = 1
  if ch == 8 or ch == 127:  # Backspace
    if term_cmd_len > 0:
      term_cmd_len = term_cmd_len - 1
      term_cmd[term_cmd_len] = 0
      desktop_needs_redraw = 1
  # Printable characters (32-126)
  if ch >= 32 and ch <= 126:
    if term_cmd_len < 45:
      term_cmd[term_cmd_len] = cast[uint8](ch)
      term_cmd_len = term_cmd_len + 1
      desktop_needs_redraw = 1

# ============== File Manager State ==============
var fm_current_ino: int32 = 1  # Current directory inode (1 = root)
var fm_path: array[64, uint8]  # Current path string
var fm_use_brfs: int32 = 0     # 1 if using BrainFS, 0 if ramdisk

# Initialize file manager - prefer BrainFS if mounted
proc fm_init() =
  fm_current_ino = BRFS_ROOT_INODE  # Root inode
  fm_path[0] = cast[uint8](47)  # '/'
  fm_path[1] = 0
  if brfs_active_mount >= 0:
    fm_use_brfs = 1
  else:
    fm_use_brfs = 0

# Draw file manager content - uses BrainFS if available, otherwise ramdisk
proc draw_files_content(wx: int32, wy: int32, ww: int32, wh: int32) =
  var fx: int32 = wx + 8
  var fy: int32 = wy + 32
  var fw: int32 = ww - 16
  var fh: int32 = wh - 40

  # Background
  vtn_rect(fx, fy, fw, fh, 30, 32, 38, 1)

  # Path bar
  vtn_rect(fx, fy, fw, 24, 45, 48, 55, 1)
  vtn_text(fx + 5, fy + 14, 200, 200, 200, cast[ptr uint8]("Path:"))
  vtn_text(fx + 50, fy + 14, 150, 200, 255, addr(fm_path[0]))

  # Source indicator (disk or ramdisk)
  if fm_use_brfs == 1:
    vtn_text(fx + fw - 80, fy + 14, 100, 200, 100, cast[ptr uint8]("[Disk]"))
  else:
    vtn_text(fx + fw - 80, fy + 14, 200, 200, 100, cast[ptr uint8]("[RAM]"))

  # Parent button
  vtn_rect(fx + 2, fy + 2, 35, 20, 60, 80, 100, 1)
  vtn_text(fx + 7, fy + 12, 255, 255, 255, cast[ptr uint8](".."))

  # List directory entries
  var list_y: int32 = fy + 30
  var row: int32 = 0

  if fm_use_brfs == 1 and brfs_active_mount >= 0:
    # Use BrainFS (persistent disk filesystem)
    var offset: int32 = 0
    var entry_ino: int32 = 0
    var entry_type: int32 = 0
    var entry_name: array[32, uint8]

    while offset >= 0 and row < 12:
      offset = brfs_readdir(brfs_active_mount, fm_current_ino, offset, addr(entry_ino), addr(entry_name[0]), addr(entry_type))
      if offset < 0:
        break

      # Row background
      if row % 2 == 0:
        vtn_rect(fx + 2, list_y, fw - 4, 22, 38, 42, 50, 1)
      else:
        vtn_rect(fx + 2, list_y, fw - 4, 22, 42, 46, 55, 1)

      # Icon/type indicator
      if entry_type == 2:  # Directory
        vtn_rect(fx + 6, list_y + 3, 16, 16, 180, 150, 80, 1)
        vtn_text(fx + 8, list_y + 12, 255, 255, 255, cast[ptr uint8]("D"))
      else:
        vtn_rect(fx + 6, list_y + 3, 16, 16, 100, 130, 180, 1)
        vtn_text(fx + 8, list_y + 12, 255, 255, 255, cast[ptr uint8]("F"))

      vtn_text(fx + 28, list_y + 14, 220, 220, 220, addr(entry_name[0]))

      list_y = list_y + 24
      row = row + 1

    if row == 0:
      vtn_text(fx + 10, fy + 50, 150, 150, 150, cast[ptr uint8]("(empty directory)"))

  else:
    # Use in-memory ramdisk filesystem
    var blk: int32 = inode_get_block(fm_current_ino, 0)
    if blk != 0:
      var dp: ptr uint8 = fs_block_ptr(blk)
      var off: int32 = 0
      while off < BLOCK_SIZE and row < 12:
        var ent_ino: int32 = read32(addr(dp[off]))
        if ent_ino != 0:
          var ent_type: int32 = cast[int32](dp[off + 7])
          var ent_name_len: int32 = cast[int32](dp[off + 6])

          # Row background
          if row % 2 == 0:
            vtn_rect(fx + 2, list_y, fw - 4, 22, 38, 42, 50, 1)
          else:
            vtn_rect(fx + 2, list_y, fw - 4, 22, 42, 46, 55, 1)

          # Icon/type indicator
          if ent_type == FT_DIR:
            vtn_rect(fx + 6, list_y + 3, 16, 16, 180, 150, 80, 1)
            vtn_text(fx + 8, list_y + 12, 255, 255, 255, cast[ptr uint8]("D"))
          else:
            vtn_rect(fx + 6, list_y + 3, 16, 16, 100, 130, 180, 1)
            vtn_text(fx + 8, list_y + 12, 255, 255, 255, cast[ptr uint8]("F"))

          # Copy filename to temp buffer and display
          var ni: int32 = 0
          while ni < ent_name_len and ni < 30:
            term_tmp_buf[ni] = dp[off + 8 + ni]
            ni = ni + 1
          term_tmp_buf[ni] = 0
          vtn_text(fx + 28, list_y + 14, 220, 220, 220, addr(term_tmp_buf[0]))

          # Size for files
          if ent_type == FT_FILE:
            var fsize: int32 = inode_get_size(ent_ino)
            # Format size
            if fsize < 1024:
              term_tmp_buf[0] = 48 + cast[uint8]((fsize / 100) % 10)
              term_tmp_buf[1] = 48 + cast[uint8]((fsize / 10) % 10)
              term_tmp_buf[2] = 48 + cast[uint8](fsize % 10)
              term_tmp_buf[3] = cast[uint8](66)  # 'B'
              term_tmp_buf[4] = 0
            else:
              var kb: int32 = fsize / 1024
              term_tmp_buf[0] = 48 + cast[uint8]((kb / 10) % 10)
              term_tmp_buf[1] = 48 + cast[uint8](kb % 10)
              term_tmp_buf[2] = cast[uint8](75)  # 'K'
              term_tmp_buf[3] = 0
            vtn_text(fx + fw - 45, list_y + 14, 150, 150, 150, addr(term_tmp_buf[0]))

          list_y = list_y + 24
          row = row + 1
        off = off + DIRENT_SIZE
    else:
      vtn_text(fx + 10, fy + 50, 150, 150, 150, cast[ptr uint8]("(empty directory)"))

# ============== End File Manager ==============

# Draw terminal content in window
proc draw_terminal_content(wx: int32, wy: int32, ww: int32, wh: int32) =
  # Terminal area inside window
  var tx: int32 = wx + 8
  var ty: int32 = wy + 32
  var tw: int32 = ww - 16
  var th: int32 = wh - 40

  # Black background for terminal area
  vtn_rect(tx, ty, tw, th, 15, 15, 20, 1)

  # Draw output lines
  var line: int32 = 0
  var y_pos: int32 = ty + 5
  while line < term_line_count and line < 10:
    var line_start: int32 = line * 48
    vtn_text(tx + 5, y_pos, 100, 255, 100, addr(term_lines[line_start]))
    y_pos = y_pos + 18
    line = line + 1

  # Draw input prompt
  var prompt_y: int32 = ty + th - 22
  vtn_text(tx + 5, prompt_y, 100, 255, 100, cast[ptr uint8]("$ "))
  # Draw current command
  vtn_text(tx + 25, prompt_y, 200, 255, 200, addr(term_cmd[0]))
  # Draw cursor
  var cursor_x: int32 = tx + 25 + (term_cmd_len * 8)
  vtn_rect(cursor_x, prompt_y - 2, 8, 16, 100, 255, 100, 1)

# ============== End Terminal ==============

# Parse VTN input after ESC has been received
proc parse_mouse_input_with_esc() =
  var buf: array[32, uint8]
  var i: int32 = 0
  var timeout: int32 = 0
  var ch: int32 = 0
  while i < 28 and timeout < 50000:
    ch = serial_getchar()
    if ch != -1:
      buf[i] = cast[uint8](ch)
      i = i + 1
      timeout = 0  # Reset timeout when data received
      if ch == 7:  # BEL - end of sequence
        break
    else:
      timeout = timeout + 1

  # Check for ]vtn; format
  # Buffer: ]vtn;command;params  (buf[0]=']', buf[4]=';', buf[5]=command start)
  if i > 6 and cast[int32](buf[0]) == 93 and cast[int32](buf[1]) == 118:  # ]v
    var event_type: int32 = 0  # 0=unknown, 1=click, 2=move, 3=up
    var parse_start: int32 = 0

    # Check for "click" at buf[5..9] = c,l,i,c,k
    if cast[int32](buf[5]) == 99 and cast[int32](buf[6]) == 108 and cast[int32](buf[7]) == 105:  # c-l-i
      event_type = 1
      parse_start = 11  # After "]vtn;click;"
    # Check for "move" at buf[5..8] = m,o,v,e
    if cast[int32](buf[5]) == 109 and cast[int32](buf[6]) == 111 and cast[int32](buf[7]) == 118:  # m-o-v
      event_type = 2
      parse_start = 10  # After "]vtn;move;"
    # Check for "up" at buf[5..6] = u,p
    if cast[int32](buf[5]) == 117 and cast[int32](buf[6]) == 112:  # u-p
      event_type = 3
      parse_start = 8  # After "]vtn;up;"

    if event_type > 0:
      # Parse x;y coordinates
      var x: int32 = 0
      var y: int32 = 0
      var state: int32 = 0  # 0=reading x, 1=reading y
      var j: int32 = parse_start
      while j < i:
        var c: int32 = cast[int32](buf[j])
        if c >= 48 and c <= 57:  # digit
          if state == 0:
            x = x * 10 + (c - 48)
          if state == 1:
            y = y * 10 + (c - 48)
        if c == 59:  # semicolon
          state = state + 1
          if state > 1:
            j = i  # exit loop
        j = j + 1

      # Dispatch to appropriate handler
      if event_type == 1:
        handle_mouse_down(x, y, 1)
      if event_type == 2:
        handle_mouse_move(x, y)
        desktop_needs_redraw = 1
      if event_type == 3:
        handle_mouse_up(x, y, 1)
        desktop_needs_redraw = 1

    # Check for "keydown" at buf[5..11] = k,e,y,d,o,w,n
    if cast[int32](buf[5]) == 107 and cast[int32](buf[6]) == 101 and cast[int32](buf[7]) == 121 and cast[int32](buf[8]) == 100:  # k-e-y-d
      # Parse keycode after "]vtn;keydown;"
      var keycode: int32 = 0
      var j: int32 = 13  # After "]vtn;keydown;"
      while j < i:
        var c: int32 = cast[int32](buf[j])
        if c >= 48 and c <= 57:
          keycode = keycode * 10 + (c - 48)
        j = j + 1
      # Set key held state
      if keycode == 119:  # 'w'
        key_w_held = 1
      if keycode == 115:  # 's'
        key_s_held = 1
      if keycode == 38:   # up arrow
        key_up_held = 1
      if keycode == 40:   # down arrow
        key_down_held = 1
      if keycode == 113:  # 'q'
        key_q_held = 1

    # Check for "keyup" at buf[5..9] = k,e,y,u,p
    if cast[int32](buf[5]) == 107 and cast[int32](buf[6]) == 101 and cast[int32](buf[7]) == 121 and cast[int32](buf[8]) == 117:  # k-e-y-u
      # Parse keycode after "]vtn;keyup;"
      var keycode: int32 = 0
      var j: int32 = 11  # After "]vtn;keyup;"
      while j < i:
        var c: int32 = cast[int32](buf[j])
        if c >= 48 and c <= 57:
          keycode = keycode * 10 + (c - 48)
        j = j + 1
      # Clear key held state
      if keycode == 119:  # 'w'
        key_w_held = 0
      if keycode == 115:  # 's'
        key_s_held = 0
      if keycode == 38:   # up arrow
        key_up_held = 0
      if keycode == 40:   # down arrow
        key_down_held = 0
      if keycode == 113:  # 'q'
        key_q_held = 0

proc parse_mouse_input() =
  var ch: int32 = serial_getchar()
  if ch == -1:
    return

  # Check for ESC (start of VTN input)
  if ch == 27:
    parse_mouse_input_with_esc()
  elif ch == 113 or ch == 81:  # q/Q
    desktop_running = 0
  elif ch == 100 or ch == 68:  # d/D
    run_vtn_demo_kernel()
    vtn_send(cast[ptr uint8]("input;raw"))
    vtn_send(cast[ptr uint8]("cursor;hide"))
  elif ch == 112 or ch == 80:  # p/P
    run_vtn_pong_kernel()
    vtn_send(cast[ptr uint8]("input;raw"))
    vtn_send(cast[ptr uint8]("cursor;hide"))
  elif ch == 116 or ch == 84:  # t/T - launch terminal
    if win_count < 4:
      discard win_create(100, 100, 300, 200, cast[ptr uint8]("Terminal"), WIN_CLOSABLE)

# Check if click is within a rectangle
proc click_in_rect(cx: int32, cy: int32, x: int32, y: int32, w: int32, h: int32): int32 =
  if cx >= x and cx < x + w and cy >= y and cy < y + h:
    return 1
  return 0

# ============== Window Manager ==============

# Get window title by index
proc win_get_title(idx: int32): ptr uint8 =
  if idx == 0:
    return win_title_0
  if idx == 1:
    return win_title_1
  if idx == 2:
    return win_title_2
  if idx == 3:
    return win_title_3
  return cast[ptr uint8](0)

# Set window title by index
proc win_set_title(idx: int32, title: ptr uint8) =
  if idx == 0:
    win_title_0 = title
  if idx == 1:
    win_title_1 = title
  if idx == 2:
    win_title_2 = title
  if idx == 3:
    win_title_3 = title

# Create a new window, returns window index or -1
proc win_create(x: int32, y: int32, w: int32, h: int32, title: ptr uint8, flags: int32): int32 =
  if win_count >= MAX_WINDOWS:
    return -1
  var idx: int32 = win_count
  win_x[idx] = x
  win_y[idx] = y
  win_w[idx] = w
  win_h[idx] = h
  win_flags[idx] = flags | WIN_VISIBLE
  win_set_title(idx, title)
  win_count = win_count + 1
  win_focused = idx
  return idx

# Draw a single window
proc win_draw(idx: int32) =
  if idx < 0 or idx >= win_count:
    return
  if (win_flags[idx] & WIN_VISIBLE) == 0:
    return

  var x: int32 = win_x[idx]
  var y: int32 = win_y[idx]
  var w: int32 = win_w[idx]
  var h: int32 = win_h[idx]
  var title: ptr uint8 = win_get_title(idx)

  # Window body (dark)
  vtn_rect(x, y, w, h, 45, 50, 60, 1)

  # Title bar (lighter if focused)
  if idx == win_focused:
    vtn_rect(x, y, w, TITLEBAR_HEIGHT, 70, 100, 150, 1)
  else:
    vtn_rect(x, y, w, TITLEBAR_HEIGHT, 50, 60, 75, 1)

  # Title text
  if title != cast[ptr uint8](0):
    vtn_text(x + 10, y + 14, 255, 255, 255, title)

  # Close button (if closable)
  if (win_flags[idx] & WIN_CLOSABLE) != 0:
    vtn_rect(x + w - 26, y + 4, 20, 20, 200, 60, 60, 1)
    vtn_text(x + w - 22, y + 14, 255, 255, 255, cast[ptr uint8]("X"))

# Draw all windows (back to front)
proc win_draw_all() =
  var i: int32 = 0
  while i < win_count:
    win_draw(i)
    i = i + 1

# Initialize window manager
proc win_init() =
  # Explicitly zero all window arrays
  var i: int32 = 0
  while i < 16:
    win_x[i] = 0
    win_y[i] = 0
    win_w[i] = 0
    win_h[i] = 0
    win_flags[i] = 0
    i = i + 1
  win_count = 0
  win_focused = -1
  win_dragging = -1

# ============== End Window Manager ==============

# Simple kernel-mode pong game
proc run_vtn_pong_kernel() =
  ser_println(cast[ptr uint8]("Starting Pong... press Q to quit"))
  vtn_send(cast[ptr uint8]("input;raw"))
  vtn_send(cast[ptr uint8]("cursor;hide"))

  # Reset key states
  key_w_held = 0
  key_s_held = 0
  key_up_held = 0
  key_down_held = 0
  key_q_held = 0

  var ball_x: int32 = 512
  var ball_y: int32 = 384
  var ball_dx: int32 = 2  # Slow ball for playability
  var ball_dy: int32 = 1
  var player_y: int32 = 334   # Player paddle (right)
  var ai_y: int32 = 334       # AI paddle (left)
  var player_score: int32 = 0
  var ai_score: int32 = 0
  var running: int32 = 1

  while running != 0:
    # Clear
    vtn_clear(0, 20, 40)

    # Draw center line
    var line_y: int32 = 20
    while line_y < 748:
      vtn_rect(508, line_y, 8, 20, 60, 60, 80, 1)
      line_y = line_y + 40

    # Draw AI paddle (left side)
    vtn_rect(30, ai_y, 20, 100, 150, 150, 200, 1)

    # Draw player paddle (right side)
    vtn_rect(974, player_y, 20, 100, 200, 200, 200, 1)

    # Draw ball
    vtn_circle(ball_x, ball_y, 12, 255, 255, 100)

    # Draw scores
    vtn_text(400, 30, 255, 255, 255, cast[ptr uint8]("AI"))
    vtn_text(560, 30, 255, 255, 255, cast[ptr uint8]("You"))
    vtn_text(50, 740, 200, 200, 200, cast[ptr uint8]("W/S to move, Q to quit"))

    # Present frame
    vtn_send(cast[ptr uint8]("present"))

    # Move ball
    ball_x = ball_x + ball_dx
    ball_y = ball_y + ball_dy

    # Bounce off top/bottom walls
    if ball_y < 30:
      ball_y = 30
      ball_dy = 0 - ball_dy
    if ball_y > 738:
      ball_y = 738
      ball_dy = 0 - ball_dy

    # AI paddle follows ball (with some delay/imperfection)
    var ai_center: int32 = ai_y + 50
    if ball_x < 512:  # Only track when ball is on AI's side
      if ball_y < ai_center - 10:
        ai_y = ai_y - 2
      if ball_y > ai_center + 10:
        ai_y = ai_y + 2
    # Keep AI paddle in bounds
    if ai_y < 0:
      ai_y = 0
    if ai_y > 668:
      ai_y = 668

    # Check AI paddle collision (left)
    if ball_x < 60 and ball_x > 30:
      if ball_y > ai_y and ball_y < ai_y + 100:
        ball_dx = 0 - ball_dx
        ball_x = 60

    # Check player paddle collision (right)
    if ball_x > 964 and ball_x < 994:
      if ball_y > player_y and ball_y < player_y + 100:
        ball_dx = 0 - ball_dx
        ball_x = 964

    # Ball out of bounds - score and reset
    if ball_x < 10:
      player_score = player_score + 1
      ball_x = 512
      ball_y = 384
      ball_dx = 2
    if ball_x > 1014:
      ai_score = ai_score + 1
      ball_x = 512
      ball_y = 384
      ball_dx = 0 - 2

    # Check for input (parse VTN sequences for keydown/keyup)
    var ch: int32 = serial_getchar()
    if ch == 27:  # ESC - VTN sequence
      parse_mouse_input_with_esc()
    if ch == 113 or ch == 81:  # q/Q direct press
      running = 0
    if key_q_held == 1:  # q keydown event
      running = 0

    # Move paddle based on held keys (smooth movement)
    if key_w_held == 1 or key_up_held == 1:
      player_y = player_y - 4
      if player_y < 0:
        player_y = 0
    if key_s_held == 1 or key_down_held == 1:
      player_y = player_y + 4
      if player_y > 668:
        player_y = 668

    # Frame rate limiter
    var delay: int32 = 0
    while delay < 80000:
      delay = delay + 1

  vtn_send(cast[ptr uint8]("cursor;show"))
  vtn_send(cast[ptr uint8]("input;cooked"))

# Draw welcome window content
proc draw_welcome_content() =
  if win_count == 0:
    return
  # Draw in first window (Welcome)
  var x: int32 = win_x[0] + 20
  var y: int32 = win_y[0] + 50
  vtn_text(x, y, 200, 200, 200, cast[ptr uint8]("Welcome to BrainhairOS!"))
  vtn_text(x, y + 30, 180, 180, 180, cast[ptr uint8]("VTNext Desktop Environment"))
  vtn_text(x, y + 70, 150, 150, 150, cast[ptr uint8]("Drag windows by titlebar"))
  vtn_text(x, y + 100, 150, 150, 150, cast[ptr uint8]("Click X to close"))
  vtn_text(x, y + 140, 150, 200, 150, cast[ptr uint8]("Keys: Q=quit D=demo P=pong T=term"))

proc run_vtn_desktop() =
  ser_println(cast[ptr uint8]("Starting VTNext Desktop..."))

  # Wait 3 seconds for terminal to connect
  # Timer runs at ~18 ticks per second
  var start_tick: int32 = get_tick_count()
  while (get_tick_count() - start_tick) < 54:  # ~3 seconds
    discard 0

  vtn_send(cast[ptr uint8]("input;raw"))
  vtn_send(cast[ptr uint8]("cursor;hide"))

  # Initialize window manager
  win_init()

  # Create welcome window
  discard win_create(300, 150, 420, 280, cast[ptr uint8]("Welcome"), WIN_CLOSABLE)

  desktop_running = 1
  desktop_needs_redraw = 0
  mouse_clicked = 0
  mouse_x = 512
  mouse_y = 384

  # Draw initial desktop (once)
  var needs_redraw: int32 = 1

  while desktop_running != 0:
    # Check global redraw flag (set by mouse handlers)
    if desktop_needs_redraw == 1:
      desktop_needs_redraw = 0
      needs_redraw = 1

    # Only redraw when needed
    if needs_redraw == 1:
      needs_redraw = 0

      # Draw background
      vtn_clear(25, 35, 55)

      # Draw desktop elements
      desktop_draw_icons()
      desktop_draw_clock()

      # Draw all windows dynamically
      win_draw_all()

      # Draw window content for each window
      var wi: int32 = 0
      while wi < win_count:
        if (win_flags[wi] & WIN_VISIBLE) != 0:
          var title: ptr uint8 = win_get_title(wi)
          # Draw Welcome window content
          if cast[int32](title[0]) == 87:  # 'W' for Welcome
            var wx: int32 = win_x[wi] + 20
            var wy: int32 = win_y[wi] + 40
            vtn_text(wx, wy, 200, 200, 200, cast[ptr uint8]("Welcome to BrainhairOS!"))
            vtn_text(wx, wy + 30, 180, 180, 180, cast[ptr uint8]("VTNext Desktop Environment"))
            vtn_text(wx, wy + 70, 150, 150, 150, cast[ptr uint8]("Drag windows by titlebar"))
            vtn_text(wx, wy + 100, 150, 150, 150, cast[ptr uint8]("Click X to close"))
            vtn_text(wx, wy + 140, 150, 200, 150, cast[ptr uint8]("Q=quit D=demo P=pong T=term"))
          # Draw Terminal window content
          if cast[int32](title[0]) == 84:  # 'T' for Terminal
            draw_terminal_content(win_x[wi], win_y[wi], win_w[wi], win_h[wi])
            # Mark this as active terminal if focused
            if wi == win_focused:
              term_active_win = wi
          # Draw Files window content
          if cast[int32](title[0]) == 70:  # 'F' for Files
            draw_files_content(win_x[wi], win_y[wi], win_w[wi], win_h[wi])
          # Draw Calculator window content
          if cast[int32](title[0]) == 67:  # 'C' for Calculator
            var cx: int32 = win_x[wi] + 10
            var cy: int32 = win_y[wi] + 40
            vtn_rect(cx, cy, win_w[wi] - 20, 30, 40, 45, 55, 1)
            vtn_text(cx + 10, cy + 18, 200, 200, 200, cast[ptr uint8]("0"))
            vtn_text(cx + 10, cy + 50, 150, 150, 150, cast[ptr uint8]("(Coming soon)"))
        wi = wi + 1

      # Draw taskbar (always on top)
      desktop_draw_taskbar()

      # Draw Apps menu popup (if open)
      desktop_draw_apps_menu()

      # Flip buffers to display the frame
      vtn_send(cast[ptr uint8]("present"))

    # Process input events
    var input_ch: int32 = serial_getchar()

    # Handle input using separate ifs (workaround for elif bug)
    if input_ch == 27:
      # ESC - VTN sequence
      parse_mouse_input_with_esc()

    # Check if a terminal window is focused
    var term_focused: int32 = 0
    if win_focused >= 0 and win_focused < win_count:
      var focus_title: ptr uint8 = win_get_title(win_focused)
      if cast[int32](focus_title[0]) == 84:  # 'T' for Terminal
        term_focused = 1

    # If terminal focused, route keyboard to terminal
    if term_focused == 1 and input_ch > 0 and input_ch != 27:
      term_handle_key(input_ch)

    # Desktop shortcuts only when terminal not focused
    if term_focused == 0:
      if input_ch == 113 or input_ch == 81:
        # q/Q - quit
        desktop_running = 0
      if input_ch == 100 or input_ch == 68:
        # d/D - demo
        run_vtn_demo_kernel()
        vtn_send(cast[ptr uint8]("input;raw"))
        vtn_send(cast[ptr uint8]("cursor;hide"))
        needs_redraw = 1
      if input_ch == 112 or input_ch == 80:
        # p/P - pong
        run_vtn_pong_kernel()
        vtn_send(cast[ptr uint8]("input;raw"))
        vtn_send(cast[ptr uint8]("cursor;hide"))
        needs_redraw = 1
      if input_ch == 116 or input_ch == 84:
        # t/T - terminal window
        if win_count < 4:
          discard win_create(100, 100, 400, 300, cast[ptr uint8]("Terminal"), WIN_CLOSABLE)
          needs_redraw = 1

    # Handle taskbar clicks
    if mouse_clicked == 1:
      mouse_clicked = 0
      needs_redraw = 1  # Redraw after click

      # Handle Apps menu clicks first (if menu is open)
      if apps_menu_open == 1:
        var menu_handled: int32 = 0
        # Terminal menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 528, 128, 28) == 1:
          if win_count < 4:
            discard win_create(100, 100, 400, 300, cast[ptr uint8]("Terminal"), WIN_CLOSABLE)
          apps_menu_open = 0
          menu_handled = 1
        # Files menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 560, 128, 28) == 1:
          if win_count < 4:
            fm_init()  # Reset file manager state
            discard win_create(120, 120, 500, 400, cast[ptr uint8]("Files"), WIN_CLOSABLE)
          apps_menu_open = 0
          menu_handled = 1
        # Demo menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 592, 128, 28) == 1:
          apps_menu_open = 0
          run_vtn_demo_kernel()
          vtn_send(cast[ptr uint8]("input;raw"))
          vtn_send(cast[ptr uint8]("cursor;hide"))
          menu_handled = 1
        # Pong menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 624, 128, 28) == 1:
          apps_menu_open = 0
          run_vtn_pong_kernel()
          vtn_send(cast[ptr uint8]("input;raw"))
          vtn_send(cast[ptr uint8]("cursor;hide"))
          menu_handled = 1
        # Calculator menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 656, 128, 28) == 1:
          if win_count < 4:
            discard win_create(150, 150, 250, 300, cast[ptr uint8]("Calculator"), WIN_CLOSABLE)
          apps_menu_open = 0
          menu_handled = 1
        # Quit menu item
        if click_in_rect(mouse_click_x, mouse_click_y, 10, 688, 128, 28) == 1:
          apps_menu_open = 0
          desktop_running = 0
          menu_handled = 1
        # Click outside menu closes it
        if menu_handled == 0:
          apps_menu_open = 0

      # Apps button toggles menu
      if click_in_rect(mouse_click_x, mouse_click_y, 4, 724, 80, 40) == 1:
        if apps_menu_open == 0:
          apps_menu_open = 1
        else:
          apps_menu_open = 0
      if click_in_rect(mouse_click_x, mouse_click_y, 90, 724, 70, 40) == 1:
        # Term button - open terminal window
        if win_count < 4:
          discard win_create(120 + win_count * 30, 120 + win_count * 30, 400, 300, cast[ptr uint8]("Terminal"), WIN_CLOSABLE)
        apps_menu_open = 0
        needs_redraw = 1
      if click_in_rect(mouse_click_x, mouse_click_y, 165, 724, 70, 40) == 1:
        apps_menu_open = 0
        run_vtn_demo_kernel()
        vtn_send(cast[ptr uint8]("input;raw"))
        vtn_send(cast[ptr uint8]("cursor;hide"))
        needs_redraw = 1
      if click_in_rect(mouse_click_x, mouse_click_y, 240, 724, 70, 40) == 1:
        apps_menu_open = 0
        run_vtn_pong_kernel()
        vtn_send(cast[ptr uint8]("input;raw"))
        vtn_send(cast[ptr uint8]("cursor;hide"))
        needs_redraw = 1

  vtn_send(cast[ptr uint8]("cursor;show"))
  vtn_send(cast[ptr uint8]("input;cooked"))
  ser_println(cast[ptr uint8]("Desktop exited"))

# Kernel-mode VTNext demo (uses serial input directly)
proc run_vtn_demo_kernel() =
  ser_println(cast[ptr uint8]("Starting VTNext Demo... press Q to quit"))

  # Enable raw input and hide cursor
  vtn_send(cast[ptr uint8]("input;raw"))
  vtn_send(cast[ptr uint8]("cursor;hide"))

  # Draw demo scene ONCE
  vtn_clear(30, 40, 60)

  # Filled rectangles (red, green, blue)
  vtn_rect(50, 100, 120, 80, 255, 100, 100, 1)
  vtn_rect(190, 100, 120, 80, 100, 255, 100, 1)
  vtn_rect(330, 100, 120, 80, 100, 100, 255, 1)

  # Outlined rectangles
  vtn_rect(50, 200, 120, 80, 255, 200, 200, 0)
  vtn_rect(190, 200, 120, 80, 200, 255, 200, 0)
  vtn_rect(330, 200, 120, 80, 200, 200, 255, 0)

  # Circles (orange, lime, cyan)
  vtn_circle(550, 140, 40, 255, 150, 50)
  vtn_circle(650, 140, 40, 150, 255, 50)
  vtn_circle(750, 140, 40, 50, 150, 255)

  # Lines (triangle) - use raw escape sequences for now
  ser_print(cast[ptr uint8]("\x1b]vtn;line;50;320;450;320;1;2;255;255;255;255\x07"))
  ser_print(cast[ptr uint8]("\x1b]vtn;line;50;320;250;450;1;2;255;200;100;255\x07"))
  ser_print(cast[ptr uint8]("\x1b]vtn;line;450;320;250;450;1;2;100;200;255;255\x07"))

  # Yellow circle
  vtn_circle(500, 350, 25, 255, 255, 0)

  # Rounded rectangles - use raw escape sequences for now
  ser_print(cast[ptr uint8]("\x1b]vtn;rrect;550;400;1;180;100;15;100;150;200;220;1\x07"))
  ser_print(cast[ptr uint8]("\x1b]vtn;rrect;750;400;1;180;100;15;200;100;150;220;1\x07"))

  # Title
  vtn_text(50, 50, 255, 255, 255, cast[ptr uint8]("VTNext Demo - Press Q to quit"))

  # Present the frame
  vtn_send(cast[ptr uint8]("present"))

  # Wait for Q to quit (event-driven, no redraw)
  var running: int32 = 1
  while running != 0:
    var ch: int32 = serial_getchar()
    if ch == 113 or ch == 81:  # 'q' or 'Q'
      running = 0

  # Restore cursor and clear
  vtn_send(cast[ptr uint8]("cursor;show"))
  vtn_send(cast[ptr uint8]("input;cooked"))
  ser_println(cast[ptr uint8]("Demo exited"))

# Generic VTNext app runner
proc run_vtn_app(elf_ptr: int32, elf_size: int32, name: ptr uint8) =
  kprint(cast[ptr uint8]("Starting "))
  kprint(name)
  kprintln(cast[ptr uint8]("..."))

  # Validate ELF
  var valid: int32 = elf_validate(elf_ptr)
  if valid == 0:
    kprintln(cast[ptr uint8]("Error: invalid ELF binary"))
    return

  # Map the userland code/data space (0x08048000 - 0x08100000 = 736KB)
  # This covers code, data, BSS, and heap growth
  var vpage: int32 = 0x08048000
  var ppage: int32 = 0x00200000
  while vpage < 0x08100000:
    discard map_page(vpage, ppage, 7)  # Present+Writable+User
    vpage = vpage + 4096
    ppage = ppage + 4096

  # Map a dedicated userland stack (64KB at 0x0BFF0000-0x0C000000)
  # Stack grows downward, so ESP starts at 0x0C000000
  vpage = 0x0BFF0000
  ppage = 0x00300000  # Use physical memory at 3MB mark
  while vpage < 0x0C000000:
    discard map_page(vpage, ppage, 7)  # Present+Writable+User
    vpage = vpage + 4096
    ppage = ppage + 4096

  # Load ELF into memory
  var entry: int32 = elf_load(elf_ptr, 0)
  if entry == 0:
    kprintln(cast[ptr uint8]("Error: failed to load ELF"))
    return

  # Call entry point with dedicated userland stack
  # Stack pointer at top of stack area (grows downward)
  var user_stack: int32 = 0x0BFFFFF0  # Leave some room at top
  call_entry_with_stack(entry, user_stack)

  kprintln(cast[ptr uint8](" * App exited"))

# Flask-style webapp with routing (kernel mode)
proc run_webapp() =
  kprintln(cast[ptr uint8](" * Flask-style webapp starting..."))
  kprintln(cast[ptr uint8](" * Running on http://0.0.0.0:80/"))
  kprintln(cast[ptr uint8](" * Routes: /, /about, /api/status"))
  kprintln(cast[ptr uint8](" * Press any key to stop"))

  var conn: int32 = tcp_listen(80)
  if conn < 0:
    kprintln(cast[ptr uint8](" * Error: cannot bind to port 80"))
    return

  var path: array[64, uint8]
  var running: int32 = 1

  while running == 1:
    if keyboard_available() > 0:
      keyboard_read_char()
      running = 0
      break

    net_poll()

    if tcp_state[conn] == TCP_STATE_ESTABLISHED:
      # Wait for request
      var wait: int32 = 0
      while wait < 200:
        net_poll()
        if tcp_recv_ready[conn] == 1:
          break
        wait = wait + 1

      if tcp_recv_ready[conn] == 1:
        # Parse request path
        var req: ptr uint8 = addr(tcp_recv_buf[conn * TCP_BUF_SIZE])
        discard webapp_parse_path(req, addr(path[0]), 64)
        tcp_recv_ready[conn] = 0

        # Log request
        kprint(cast[ptr uint8](" * GET "))
        kprintln(addr(path[0]))

        # Route matching (Flask-style!) - using byte comparison
        var matched: int32 = 0

        # Route: / (just /)
        if cast[int32](path[0]) == 47 and cast[int32](path[1]) == 0:
          html(conn, cast[ptr uint8]("<html><head><title>Flask Demo</title></head><body><h1>Welcome to BrainhairOS!</h1><p>This is a Flask-style web framework.</p><ul><li><a href='/about'>About</a></li><li><a href='/api/status'>API Status</a></li></ul></body></html>"))
          matched = 1

        # Route: /about
        if matched == 0:
          if cast[int32](path[0]) == 47 and cast[int32](path[1]) == 97 and cast[int32](path[2]) == 98 and cast[int32](path[3]) == 111 and cast[int32](path[4]) == 117 and cast[int32](path[5]) == 116 and cast[int32](path[6]) == 0:
            html(conn, cast[ptr uint8]("<html><body><h1>About</h1><p>BrainhairOS is a hobby OS with a TCP/IP stack written from scratch.</p><p><a href='/'>Home</a></p></body></html>"))
            matched = 1

        # Route: /api/status
        if matched == 0:
          if cast[int32](path[0]) == 47 and cast[int32](path[1]) == 97 and cast[int32](path[2]) == 112 and cast[int32](path[3]) == 105 and cast[int32](path[4]) == 47:
            # /api/ prefix - check for status
            if cast[int32](path[5]) == 115 and cast[int32](path[6]) == 116 and cast[int32](path[7]) == 97 and cast[int32](path[8]) == 116 and cast[int32](path[9]) == 117 and cast[int32](path[10]) == 115 and cast[int32](path[11]) == 0:
              json_resp(conn, cast[ptr uint8]("{'status':'ok','os':'BrainhairOS','version':'0.1'}"))
              matched = 1

        # 404 Not Found
        if matched == 0:
          not_found(conn)

      tcp_close(conn)
      conn = tcp_listen(80)
      if conn < 0:
        running = 0

  if conn >= 0:
    tcp_close(conn)
  kprintln(cast[ptr uint8](" * Webapp stopped"))

# Sync time via NTP
proc ntp_sync(): int32 =
  # Use QEMU's default NTP server (10.0.2.2 usually works as gateway)
  var ntp_server: array[4, uint8]
  ntp_server[0] = cast[uint8](10)
  ntp_server[1] = cast[uint8](0)
  ntp_server[2] = cast[uint8](2)
  ntp_server[3] = cast[uint8](2)

  # Set up UDP receive
  udp_recv_port = 123
  udp_recv_ready = 0

  kprint(cast[ptr uint8]("[NTP] Syncing with "))
  print_ip_addr(addr(ntp_server[0]))
  kprintln(cast[ptr uint8]("..."))

  ntp_send_request(addr(ntp_server[0]))

  # Wait for response
  var start_tick: int32 = get_tick_count()
  while (get_tick_count() - start_tick) < 3000:
    net_poll()
    if udp_recv_ready == 1:
      ntp_handle_response(udp_recv_data, udp_recv_len)
      udp_recv_ready = 0
      udp_recv_port = 0
      kprintln(cast[ptr uint8]("[NTP] Time synchronized"))
      return 1

  udp_recv_port = 0
  kprintln(cast[ptr uint8]("[NTP] Timeout"))
  return 0

# Print current date/time (simplified - just shows Unix timestamp for now)
proc print_time() =
  if ntp_synced == 0:
    kprintln(cast[ptr uint8]("Time not synced"))
    return

  var ts: int32 = get_unix_time()
  kprint(cast[ptr uint8]("Unix time: "))
  kprint_dec(ts)
  kprintln(cast[ptr uint8](""))

  # Calculate date components
  # Days since 1970-01-01
  var days: int32 = ts / 86400
  var time_of_day: int32 = ts - (days * 86400)

  var hours: int32 = time_of_day / 3600
  var minutes: int32 = (time_of_day - (hours * 3600)) / 60
  var seconds: int32 = time_of_day - (hours * 3600) - (minutes * 60)

  kprint(cast[ptr uint8]("Time: "))
  if hours < 10:
    kprint(cast[ptr uint8]("0"))
  kprint_dec(hours)
  kprint(cast[ptr uint8](":"))
  if minutes < 10:
    kprint(cast[ptr uint8]("0"))
  kprint_dec(minutes)
  kprint(cast[ptr uint8](":"))
  if seconds < 10:
    kprint(cast[ptr uint8]("0"))
  kprint_dec(seconds)
  kprintln(cast[ptr uint8](" UTC"))

# ============================================================================
# TCP Protocol
# ============================================================================

# TCP flags
const TCP_FIN: int32 = 0x01
const TCP_SYN: int32 = 0x02
const TCP_RST: int32 = 0x04
const TCP_PSH: int32 = 0x08
const TCP_ACK: int32 = 0x10
const TCP_URG: int32 = 0x20

# Find a free connection slot
proc tcp_find_free(): int32 =
  var i: int32 = 0
  while i < TCP_MAX_CONNS:
    if tcp_state[i] == TCP_STATE_CLOSED:
      return i
    i = i + 1
  return -1

# Find connection by remote IP/port
proc tcp_find_conn(remote_ip: ptr uint8, remote_port: int32, local_port: int32): int32 =
  var i: int32 = 0
  while i < TCP_MAX_CONNS:
    var st: int32 = tcp_state[i]
    if st != TCP_STATE_CLOSED:
      if tcp_local_port[i] == local_port:
        if tcp_remote_port[i] == remote_port:
          var ip_match: int32 = 1
          var j: int32 = 0
          while j < 4:
            if tcp_remote_ip[i * 4 + j] != remote_ip[j]:
              ip_match = 0
            j = j + 1
          if ip_match == 1:
            return i
    i = i + 1
  return -1

# Calculate TCP checksum (pseudo-header + TCP)
proc tcp_checksum(src_ip: ptr uint8, dst_ip: ptr uint8, tcp_data: ptr uint8, tcp_len: int32): int32 =
  var sum: int32 = 0
  var i: int32 = 0

  # Pseudo-header
  sum = sum + (cast[int32](src_ip[0]) << 8) + cast[int32](src_ip[1])
  sum = sum + (cast[int32](src_ip[2]) << 8) + cast[int32](src_ip[3])
  sum = sum + (cast[int32](dst_ip[0]) << 8) + cast[int32](dst_ip[1])
  sum = sum + (cast[int32](dst_ip[2]) << 8) + cast[int32](dst_ip[3])
  sum = sum + 6  # Protocol TCP
  sum = sum + tcp_len

  # TCP header + data
  i = 0
  while i < tcp_len - 1:
    sum = sum + (cast[int32](tcp_data[i]) << 8) + cast[int32](tcp_data[i + 1])
    i = i + 2
  if (tcp_len & 1) == 1:
    sum = sum + (cast[int32](tcp_data[tcp_len - 1]) << 8)

  # Fold
  while (sum >> 16) != 0:
    sum = (sum & 0xFFFF) + (sum >> 16)

  return (sum ^ 0xFFFF) & 0xFFFF

# Send TCP packet
proc tcp_send_packet(conn: int32, flags: int32, data: ptr uint8, data_len: int32) =
  # Guard against recursion (net_poll during ARP wait could cause this)
  if tcp_send_in_progress == 1:
    return
  tcp_send_in_progress = 1

  if conn < 0:
    tcp_send_in_progress = 0
    return
  if conn >= TCP_MAX_CONNS:
    tcp_send_in_progress = 0
    return

  # Use static buffers to avoid stack overflow
  var i: int32 = 0

  # TCP header (20 bytes minimum)
  var tcp_header_len: int32 = 20

  # Read connection state from arrays
  var local_port: int32 = tcp_local_port[conn]
  var remote_port: int32 = tcp_remote_port[conn]
  var seq_num: int32 = tcp_seq[conn]
  var ack_num: int32 = tcp_ack[conn]

  # Source port
  tcp_send_pkt[0] = cast[uint8]((local_port >> 8) & 0xFF)
  tcp_send_pkt[1] = cast[uint8](local_port & 0xFF)

  # Dest port
  tcp_send_pkt[2] = cast[uint8]((remote_port >> 8) & 0xFF)
  tcp_send_pkt[3] = cast[uint8](remote_port & 0xFF)

  # Sequence number
  tcp_send_pkt[4] = cast[uint8]((seq_num >> 24) & 0xFF)
  tcp_send_pkt[5] = cast[uint8]((seq_num >> 16) & 0xFF)
  tcp_send_pkt[6] = cast[uint8]((seq_num >> 8) & 0xFF)
  tcp_send_pkt[7] = cast[uint8](seq_num & 0xFF)

  # Ack number
  tcp_send_pkt[8] = cast[uint8]((ack_num >> 24) & 0xFF)
  tcp_send_pkt[9] = cast[uint8]((ack_num >> 16) & 0xFF)
  tcp_send_pkt[10] = cast[uint8]((ack_num >> 8) & 0xFF)
  tcp_send_pkt[11] = cast[uint8](ack_num & 0xFF)

  # Data offset (5 = 20 bytes) + reserved
  tcp_send_pkt[12] = cast[uint8](0x50)

  # Flags
  tcp_send_pkt[13] = cast[uint8](flags)

  # Window size (8192)
  tcp_send_pkt[14] = cast[uint8](0x20)
  tcp_send_pkt[15] = cast[uint8](0x00)

  # Checksum (placeholder)
  tcp_send_pkt[16] = cast[uint8](0)
  tcp_send_pkt[17] = cast[uint8](0)

  # Urgent pointer
  tcp_send_pkt[18] = cast[uint8](0)
  tcp_send_pkt[19] = cast[uint8](0)

  # Copy data
  i = 0
  while i < data_len:
    tcp_send_pkt[20 + i] = data[i]
    i = i + 1

  # Calculate checksum
  var remote_ip_ptr: ptr uint8 = addr(tcp_remote_ip[conn * 4])
  var csum: int32 = tcp_checksum(addr(my_ip[0]), remote_ip_ptr, addr(tcp_send_pkt[0]), 20 + data_len)
  tcp_send_pkt[16] = cast[uint8]((csum >> 8) & 0xFF)
  tcp_send_pkt[17] = cast[uint8](csum & 0xFF)

  # Wrap in IP and send

  # IP header
  var total_len: int32 = 20 + 20 + data_len
  tcp_send_ip_pkt[0] = cast[uint8](0x45)
  tcp_send_ip_pkt[1] = cast[uint8](0)
  tcp_send_ip_pkt[2] = cast[uint8]((total_len >> 8) & 0xFF)
  tcp_send_ip_pkt[3] = cast[uint8](total_len & 0xFF)
  tcp_send_ip_pkt[4] = cast[uint8](0)
  tcp_send_ip_pkt[5] = cast[uint8](0)
  tcp_send_ip_pkt[6] = cast[uint8](0x40)
  tcp_send_ip_pkt[7] = cast[uint8](0)
  tcp_send_ip_pkt[8] = cast[uint8](64)
  tcp_send_ip_pkt[9] = cast[uint8](6)  # TCP
  tcp_send_ip_pkt[10] = cast[uint8](0)
  tcp_send_ip_pkt[11] = cast[uint8](0)

  # Source IP
  i = 0
  while i < 4:
    tcp_send_ip_pkt[12 + i] = my_ip[i]
    i = i + 1

  # Dest IP
  i = 0
  while i < 4:
    tcp_send_ip_pkt[16 + i] = tcp_remote_ip[conn * 4 + i]
    i = i + 1

  # IP checksum
  var ip_csum: int32 = ip_checksum(addr(tcp_send_ip_pkt[0]), 20)
  tcp_send_ip_pkt[10] = cast[uint8]((ip_csum >> 8) & 0xFF)
  tcp_send_ip_pkt[11] = cast[uint8](ip_csum & 0xFF)

  # Copy TCP data
  i = 0
  while i < 20 + data_len:
    tcp_send_ip_pkt[20 + i] = tcp_send_pkt[i]
    i = i + 1

  # Send via ARP lookup
  var dest_mac: array[6, uint8]
  var gateway_ip: array[4, uint8]
  gateway_ip[0] = cast[uint8](10)
  gateway_ip[1] = cast[uint8](0)
  gateway_ip[2] = cast[uint8](2)
  gateway_ip[3] = cast[uint8](2)

  var found: int32 = 0
  i = 0
  while i < arp_count:
    var matched: int32 = 1
    var j: int32 = 0
    while j < 4:
      if arp_ip[i * 4 + j] != gateway_ip[j]:
        matched = 0
      j = j + 1
    if matched == 1:
      j = 0
      while j < 6:
        dest_mac[j] = arp_mac[i * 6 + j]
        j = j + 1
      found = 1
    i = i + 1

  if found == 0:
    arp_send_request(addr(gateway_ip[0]))
    var start_tick: int32 = get_tick_count()
    while found == 0:
      if (get_tick_count() - start_tick) >= 500:
        tcp_send_in_progress = 0
        return
      net_poll()
      var k: int32 = 0
      while k < arp_count:
        var arp_matched: int32 = 1
        var m: int32 = 0
        while m < 4:
          if arp_ip[k * 4 + m] != gateway_ip[m]:
            arp_matched = 0
          m = m + 1
        if arp_matched == 1:
          m = 0
          while m < 6:
            dest_mac[m] = arp_mac[k * 6 + m]
            m = m + 1
          found = 1
        k = k + 1

  if found == 1:
    ser_println(cast[ptr uint8]("TX"))
    eth_send(addr(dest_mac[0]), ETH_TYPE_IP, addr(tcp_send_ip_pkt[0]), total_len)

  tcp_send_in_progress = 0

# Initiate TCP connection
proc tcp_connect(dest_ip: ptr uint8, dest_port: int32): int32 =
  var conn: int32 = tcp_find_free()
  if conn < 0:
    return -1

  # Set up connection
  tcp_state[conn] = TCP_STATE_SYN_SENT
  tcp_local_port[conn] = 49152 + (get_tick_count() & 0x3FFF)  # Random ephemeral port
  tcp_remote_port[conn] = dest_port
  var i: int32 = 0
  while i < 4:
    tcp_remote_ip[conn * 4 + i] = dest_ip[i]
    i = i + 1
  tcp_seq[conn] = get_tick_count()  # Initial seq number
  tcp_ack[conn] = 0
  tcp_recv_len[conn] = 0
  tcp_recv_ready[conn] = 0

  # Send SYN
  tcp_send_packet(conn, TCP_SYN, cast[ptr uint8](0), 0)

  # Wait for SYN-ACK
  var start_tick: int32 = get_tick_count()
  while (get_tick_count() - start_tick) < 5000:
    net_poll()
    if tcp_state[conn] == TCP_STATE_ESTABLISHED:
      return conn
    if tcp_state[conn] == TCP_STATE_CLOSED:
      return -1

  # Timeout
  tcp_state[conn] = TCP_STATE_CLOSED
  return -1

# Send data on established connection
proc tcp_write(conn: int32, data: ptr uint8, length: int32): int32 =
  ser_print(cast[ptr uint8]("[TCP] write conn="))
  ser_print_hex(conn)
  ser_print(cast[ptr uint8](" len="))
  ser_print_hex(length)
  ser_println(cast[ptr uint8](""))
  if conn < 0:
    return -1
  if conn >= TCP_MAX_CONNS:
    return -1
  if tcp_state[conn] != TCP_STATE_ESTABLISHED:
    ser_print(cast[ptr uint8]("[TCP] write: state="))
    ser_print_hex(tcp_state[conn])
    ser_println(cast[ptr uint8](" (not ESTABLISHED)"))
    return -1

  tcp_send_packet(conn, TCP_ACK | TCP_PSH, data, length)
  tcp_seq[conn] = tcp_seq[conn] + length
  return length

# Read data from connection
proc tcp_read(conn: int32, buf: ptr uint8, max_len: int32): int32 =
  if conn < 0:
    return -1
  if conn >= TCP_MAX_CONNS:
    return -1
  if tcp_recv_ready[conn] == 0:
    return 0

  ser_print(cast[ptr uint8]("[TCP] read conn="))
  ser_print_hex(conn)
  ser_print(cast[ptr uint8](" ready="))
  ser_print_hex(tcp_recv_ready[conn])
  ser_print(cast[ptr uint8](" len="))
  ser_print_hex(tcp_recv_len[conn])
  ser_println(cast[ptr uint8](""))

  var len: int32 = tcp_recv_len[conn]
  if len > max_len:
    len = max_len

  var i: int32 = 0
  while i < len:
    buf[i] = tcp_recv_buf[conn * TCP_BUF_SIZE + i]
    i = i + 1

  tcp_recv_ready[conn] = 0
  tcp_recv_len[conn] = 0
  return len

# Close TCP connection
proc tcp_close(conn: int32) =
  ser_print(cast[ptr uint8]("[TCP] close conn="))
  ser_print_hex(conn)
  ser_print(cast[ptr uint8](" state="))
  ser_print_hex(tcp_state[conn])
  ser_println(cast[ptr uint8](""))
  if conn < 0:
    return
  if conn >= TCP_MAX_CONNS:
    return
  # Send RST to force-close connection
  if tcp_state[conn] != TCP_STATE_CLOSED:
    ser_println(cast[ptr uint8]("[TCP] Sending RST"))
    tcp_send_packet(conn, TCP_RST | TCP_ACK, cast[ptr uint8](0), 0)
  tcp_state[conn] = TCP_STATE_CLOSED

# Listen on a TCP port (server)
proc tcp_listen(port: int32): int32 =
  ser_print(cast[ptr uint8]("[TCP] Listen on port "))
  ser_print_hex(port)
  ser_println(cast[ptr uint8](""))

  var conn: int32 = tcp_find_free()
  if conn < 0:
    ser_println(cast[ptr uint8]("[TCP] No free connection slot"))
    return -1

  tcp_state[conn] = TCP_STATE_LISTEN
  tcp_local_port[conn] = port
  ser_print(cast[ptr uint8]("[TCP] Created listener conn="))
  ser_print_hex(conn)
  ser_print(cast[ptr uint8](" state="))
  ser_print_hex(tcp_state[conn])
  ser_println(cast[ptr uint8](""))
  tcp_remote_port[conn] = 0
  tcp_seq[conn] = 0
  tcp_ack[conn] = 0
  tcp_recv_ready[conn] = 0
  tcp_recv_len[conn] = 0

  # Clear remote IP
  var i: int32 = 0
  while i < 4:
    tcp_remote_ip[conn * 4 + i] = cast[uint8](0)
    i = i + 1

  return conn

# Check if a listening socket has a pending connection
proc tcp_accept_ready(conn: int32): int32 =
  if conn < 0:
    return 0
  if conn >= TCP_MAX_CONNS:
    return 0
  # Connection is ready when it transitions to ESTABLISHED
  var state: int32 = tcp_state[conn]
  if state == TCP_STATE_ESTABLISHED:
    ser_print(cast[ptr uint8]("[TCP] accept_ready conn="))
    ser_print_hex(conn)
    ser_print(cast[ptr uint8](" state="))
    ser_print_hex(state)
    ser_println(cast[ptr uint8](" -> 1"))
    return 1
  return 0

# Check if a socket has data available to read
# Returns: 1 if data ready, 0 otherwise
proc tcp_has_data(conn: int32): int32 =
  if conn < 0:
    return 0
  if conn >= TCP_MAX_CONNS:
    return 0
  return tcp_recv_ready[conn]

# Find a listening socket for a given port
proc tcp_find_listener(port: int32): int32 =
  ser_print(cast[ptr uint8]("[TCP] Finding listener for port "))
  ser_print_hex(port)
  ser_println(cast[ptr uint8](""))
  var i: int32 = 0
  while i < TCP_MAX_CONNS:
    if tcp_state[i] == TCP_STATE_LISTEN:
      ser_print(cast[ptr uint8]("[TCP]   conn "))
      ser_print_hex(i)
      ser_print(cast[ptr uint8](" listening on port "))
      ser_print_hex(tcp_local_port[i])
      ser_println(cast[ptr uint8](""))
      if tcp_local_port[i] == port:
        return i
    i = i + 1
  ser_println(cast[ptr uint8]("[TCP]   No listener found"))
  return -1

# Handle incoming TCP packet
proc tcp_handle_packet(src_ip: ptr uint8, data: ptr uint8, length: int32) =
  if length < 20:
    return

  var src_port: int32 = (cast[int32](data[0]) << 8) | cast[int32](data[1])
  var dst_port: int32 = (cast[int32](data[2]) << 8) | cast[int32](data[3])
  var seq: int32 = (cast[int32](data[4]) << 24) | (cast[int32](data[5]) << 16) | (cast[int32](data[6]) << 8) | cast[int32](data[7])
  var ack_num: int32 = (cast[int32](data[8]) << 24) | (cast[int32](data[9]) << 16) | (cast[int32](data[10]) << 8) | cast[int32](data[11])
  var header_len: int32 = ((cast[int32](data[12]) >> 4) & 0x0F) * 4
  var flags: int32 = cast[int32](data[13])

  ser_print(cast[ptr uint8]("f="))
  ser_print_hex(flags)
  ser_println(cast[ptr uint8](""))

  var conn: int32 = tcp_find_conn(src_ip, src_port, dst_port)
  ser_print(cast[ptr uint8]("c="))
  ser_print_hex(conn)
  ser_println(cast[ptr uint8](""))

  # If no existing connection, check for listening socket (incoming SYN)
  if conn < 0:
    if (flags & TCP_SYN) != 0:
      if (flags & TCP_ACK) == 0:
        # Pure SYN - look for listener
        ser_println(cast[ptr uint8]("SYN"))
        conn = tcp_find_listener(dst_port)
        if conn >= 0:
          ser_print(cast[ptr uint8]("SYN-ACK conn="))
          ser_print_hex(conn)
          ser_print(cast[ptr uint8](" remote_port="))
          ser_print_hex(src_port)
          tcp_remote_port[conn] = src_port
          var j: int32 = 0
          while j < 4:
            tcp_remote_ip[conn * 4 + j] = src_ip[j]
            j = j + 1
          tcp_seq[conn] = get_tick_count()
          tcp_ack[conn] = seq + 1
          ser_print(cast[ptr uint8](" seq="))
          ser_print_hex(tcp_seq[conn])
          ser_print(cast[ptr uint8](" ack="))
          ser_print_hex(tcp_ack[conn])
          ser_println(cast[ptr uint8](""))
          tcp_state[conn] = TCP_STATE_SYN_RECEIVED
          tcp_send_packet(conn, TCP_SYN | TCP_ACK, cast[ptr uint8](0), 0)
          return
    return  # No matching connection

  # Handle SYN-ACK for connection in SYN_SENT state (client)
  if tcp_state[conn] == TCP_STATE_SYN_SENT:
    if (flags & TCP_SYN) != 0:
      if (flags & TCP_ACK) != 0:
        tcp_ack[conn] = seq + 1
        tcp_seq[conn] = tcp_seq[conn] + 1
        tcp_state[conn] = TCP_STATE_ESTABLISHED
        # Send ACK
        tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)
        return

  # Handle ACK for connection in SYN_RECEIVED state (server)
  if tcp_state[conn] == TCP_STATE_SYN_RECEIVED:
    if (flags & TCP_SYN) != 0:
      if (flags & TCP_ACK) == 0:
        # SYN retransmission - resend SYN-ACK
        ser_println(cast[ptr uint8]("[TCP] SYN retrans -> SYN-ACK"))
        tcp_send_packet(conn, TCP_SYN | TCP_ACK, cast[ptr uint8](0), 0)
        return
    if (flags & TCP_ACK) != 0:
      ser_println(cast[ptr uint8]("[TCP] ACK rcvd -> ESTABLISHED"))
      tcp_seq[conn] = tcp_seq[conn] + 1
      tcp_state[conn] = TCP_STATE_ESTABLISHED
      return

  if tcp_state[conn] == TCP_STATE_ESTABLISHED:
    # Handle incoming data (with or without PSH flag)
    var payload_offset: int32 = header_len
    var payload_len: int32 = length - header_len
    if payload_len > 0:
      ser_print(cast[ptr uint8]("[TCP] DATA received, len="))
      ser_print_hex(payload_len)
      ser_println(cast[ptr uint8](""))
      if payload_len > TCP_BUF_SIZE:
        payload_len = TCP_BUF_SIZE
      var i: int32 = 0
      while i < payload_len:
        tcp_recv_buf[conn * TCP_BUF_SIZE + i] = data[payload_offset + i]
        i = i + 1
      tcp_recv_len[conn] = payload_len
      tcp_recv_ready[conn] = 1
      tcp_ack[conn] = seq + payload_len
      tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)

    # Handle FIN
    if (flags & TCP_FIN) != 0:
      tcp_ack[conn] = seq + 1
      tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)
      tcp_state[conn] = TCP_STATE_CLOSE_WAIT

    # Handle RST
    if (flags & TCP_RST) != 0:
      tcp_state[conn] = TCP_STATE_CLOSED

  # Handle FIN_WAIT_1 state (we sent FIN, waiting for ACK and/or FIN)
  if tcp_state[conn] == TCP_STATE_FIN_WAIT_1:
    if (flags & TCP_ACK) != 0:
      if (flags & TCP_FIN) != 0:
        # Got FIN+ACK - send ACK and go to CLOSED (skip TIME_WAIT for simplicity)
        ser_println(cast[ptr uint8]("[TCP] FIN_WAIT_1: got FIN+ACK -> CLOSED"))
        tcp_ack[conn] = seq + 1
        tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)
        tcp_state[conn] = TCP_STATE_CLOSED
      else:
        # Got ACK only - go to FIN_WAIT_2
        ser_println(cast[ptr uint8]("[TCP] FIN_WAIT_1: got ACK -> FIN_WAIT_2"))
        tcp_state[conn] = TCP_STATE_FIN_WAIT_2
    elif (flags & TCP_FIN) != 0:
      # Got FIN only - simultaneous close
      ser_println(cast[ptr uint8]("[TCP] FIN_WAIT_1: got FIN -> CLOSING"))
      tcp_ack[conn] = seq + 1
      tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)
      tcp_state[conn] = TCP_STATE_CLOSING

  # Handle FIN_WAIT_2 state (waiting for FIN from peer)
  if tcp_state[conn] == TCP_STATE_FIN_WAIT_2:
    if (flags & TCP_FIN) != 0:
      ser_println(cast[ptr uint8]("[TCP] FIN_WAIT_2: got FIN -> CLOSED"))
      tcp_ack[conn] = seq + 1
      tcp_send_packet(conn, TCP_ACK, cast[ptr uint8](0), 0)
      tcp_state[conn] = TCP_STATE_CLOSED

  # Handle CLOSING state (simultaneous close, waiting for ACK)
  if tcp_state[conn] == TCP_STATE_CLOSING:
    if (flags & TCP_ACK) != 0:
      ser_println(cast[ptr uint8]("[TCP] CLOSING: got ACK -> CLOSED"))
      tcp_state[conn] = TCP_STATE_CLOSED

# ============================================================================
# DNS Client
# ============================================================================

proc dns_resolve(hostname: ptr uint8): int32 =
  # Build DNS query
  var query: array[256, uint8]
  var qlen: int32 = 0

  # Transaction ID
  var txid: int32 = get_tick_count() & 0xFFFF
  query[0] = cast[uint8]((txid >> 8) & 0xFF)
  query[1] = cast[uint8](txid & 0xFF)

  # Flags: standard query, recursion desired
  query[2] = cast[uint8](0x01)  # RD=1
  query[3] = cast[uint8](0x00)

  # Questions: 1
  query[4] = cast[uint8](0)
  query[5] = cast[uint8](1)

  # Answer RRs, Authority RRs, Additional RRs: 0
  query[6] = cast[uint8](0)
  query[7] = cast[uint8](0)
  query[8] = cast[uint8](0)
  query[9] = cast[uint8](0)
  query[10] = cast[uint8](0)
  query[11] = cast[uint8](0)

  qlen = 12

  # Encode hostname as labels (e.g., "www.google.com" -> "3www6google3com0")
  var i: int32 = 0
  var label_start: int32 = qlen
  qlen = qlen + 1  # Skip length byte
  while hostname[i] != cast[uint8](0):
    if hostname[i] == cast[uint8](46):  # '.'
      # Write label length
      query[label_start] = cast[uint8](qlen - label_start - 1)
      label_start = qlen
      qlen = qlen + 1
    else:
      query[qlen] = hostname[i]
      qlen = qlen + 1
    i = i + 1
  # Write last label length and null terminator
  query[label_start] = cast[uint8](qlen - label_start - 1)
  query[qlen] = cast[uint8](0)
  qlen = qlen + 1

  # Query type: A (1) and class: IN (1)
  query[qlen] = cast[uint8](0)
  query[qlen + 1] = cast[uint8](1)  # Type A
  query[qlen + 2] = cast[uint8](0)
  query[qlen + 3] = cast[uint8](1)  # Class IN
  qlen = qlen + 4

  # DNS server (QEMU: 10.0.2.3)
  var dns_server: array[4, uint8]
  dns_server[0] = cast[uint8](10)
  dns_server[1] = cast[uint8](0)
  dns_server[2] = cast[uint8](2)
  dns_server[3] = cast[uint8](3)

  # Set up to receive on port 53
  udp_recv_port = 12345  # Our source port
  udp_recv_ready = 0
  dns_result_ready = 0

  # Send DNS query
  udp_send(addr(dns_server[0]), 12345, 53, addr(query[0]), qlen)

  # Wait for response
  var start_tick: int32 = get_tick_count()
  while (get_tick_count() - start_tick) < 2000:
    net_poll()
    if udp_recv_ready == 1:
      # Parse DNS response
      var resp: ptr uint8 = udp_recv_data
      var resp_len: int32 = udp_recv_len

      if resp_len >= 12:
        # Check transaction ID
        var resp_txid: int32 = (cast[int32](resp[0]) << 8) | cast[int32](resp[1])
        if resp_txid == txid:
          # Get answer count
          var answer_count: int32 = (cast[int32](resp[6]) << 8) | cast[int32](resp[7])
          if answer_count > 0:
            # Skip question section
            var offset: int32 = 12
            # Skip QNAME
            while offset < resp_len:
              if resp[offset] == cast[uint8](0):
                offset = offset + 1
                break
              if (cast[int32](resp[offset]) & 0xC0) == 0xC0:
                offset = offset + 2
                break
              offset = offset + cast[int32](resp[offset]) + 1
            offset = offset + 4  # Skip QTYPE and QCLASS

            # Read answer
            if offset + 12 <= resp_len:
              # Skip name (might be pointer)
              if (cast[int32](resp[offset]) & 0xC0) == 0xC0:
                offset = offset + 2
              else:
                while offset < resp_len:
                  if resp[offset] == cast[uint8](0):
                    offset = offset + 1
                    break
                  offset = offset + cast[int32](resp[offset]) + 1

              # TYPE (2) + CLASS (2) + TTL (4) + RDLENGTH (2) = 10 bytes
              if offset + 10 <= resp_len:
                var ans_type: int32 = (cast[int32](resp[offset]) << 8) | cast[int32](resp[offset + 1])
                var rdlength: int32 = (cast[int32](resp[offset + 8]) << 8) | cast[int32](resp[offset + 9])
                offset = offset + 10

                if ans_type == 1:  # Type A
                  if rdlength == 4:
                    if offset + 4 <= resp_len:
                      dns_result_ip[0] = resp[offset]
                      dns_result_ip[1] = resp[offset + 1]
                      dns_result_ip[2] = resp[offset + 2]
                      dns_result_ip[3] = resp[offset + 3]
                      dns_result_ready = 1
                      udp_recv_port = 0
                      return 1

      udp_recv_ready = 0

  udp_recv_port = 0
  return 0

# ============================================================================
# Ethernet Frame Handling
# ============================================================================

proc net_handle_packet() =
  if packet_len < 14:
    return

  # Get EtherType
  var eth_type: int32 = (cast[int32](packet_buf[12]) << 8) | cast[int32](packet_buf[13])

  var payload: ptr uint8 = addr(packet_buf[14])
  var payload_len: int32 = packet_len - 14

  if eth_type == ETH_TYPE_ARP:
    arp_handle_packet(payload, payload_len)
  if eth_type == ETH_TYPE_IP:
    ip_handle_packet(payload, payload_len)

proc net_poll() =
  if e1000_found == 0:
    return

  var len: int32 = e1000_receive_packet()
  if len > 0:
    if net_debug == 1:
      kprint(cast[ptr uint8]("[RX:"))
      kprint_dec(len)
      kprint(cast[ptr uint8]("b] "))
    net_handle_packet()

# ============================================================================
# Network Shell Commands
# ============================================================================

proc print_mac() =
  var i: int32 = 0
  while i < 6:
    kprint_hex_byte(cast[int32](my_mac[i]))
    if i < 5:
      vga_putchar(58)
      serial_putchar(58)
    i = i + 1

proc print_ip_addr(ip: ptr uint8) =
  kprint_dec(cast[int32](ip[0]))
  vga_putchar(46)
  serial_putchar(46)
  kprint_dec(cast[int32](ip[1]))
  vga_putchar(46)
  serial_putchar(46)
  kprint_dec(cast[int32](ip[2]))
  vga_putchar(46)
  serial_putchar(46)
  kprint_dec(cast[int32](ip[3]))

proc print_ip() =
  print_ip_addr(addr(my_ip[0]))

# Main shell loop
proc shell_main() =
  cmd_len = 0
  shell_prompt()

  while true:
    # Check for keyboard input
    var avail: int32 = keyboard_available()
    if avail > 0:
      var c: int32 = keyboard_read_char()
      shell_process_char(c)

    # Check for serial input (non-blocking)
    var ser_avail: int32 = serial_available()
    if ser_avail != 0:
      var sc: int32 = serial_getchar()
      shell_process_char(sc)

    # Poll network for incoming packets
    net_poll()

# ============================================================================
# Syscall wrappers (int 0x42)
# ============================================================================

# Syscall numbers
const SYS_EXIT: int32 = 1
const SYS_GETPID: int32 = 5
const SYS_YIELD: int32 = 6
const SYS_SEND: int32 = 20
const SYS_RECV: int32 = 21
const SYS_CALL: int32 = 22
const SYS_REPLY: int32 = 23

# Low-level syscall (in assembly)
extern syscall2(num: int32, arg1: int32, arg2: int32): int32

# IPC syscall wrappers
proc sys_send(dest: int32, msg: ptr uint8): int32 =
  return syscall2(SYS_SEND, dest, cast[int32](msg))

proc sys_recv(from_pid: int32, buf: ptr uint8): int32 =
  return syscall2(SYS_RECV, from_pid, cast[int32](buf))

# File descriptor syscall numbers
const SYS_READ: int32 = 3
const SYS_WRITE: int32 = 4
const SYS_CLOSE: int32 = 7

# Process syscall numbers
const SYS_SPAWN: int32 = 40
const SYS_WAIT: int32 = 41
const SYS_GETPPID: int32 = 42
const SYS_WAITPID: int32 = 43
const SYS_FORK: int32 = 44
const SYS_PIPE: int32 = 45
const SYS_DUP: int32 = 46
const SYS_DUP2: int32 = 47

# Low-level syscall with 1 argument
extern syscall1(num: int32, arg1: int32): int32

# Process syscall wrappers
proc sys_spawn(entry: int32): int32 =
  return syscall1(SYS_SPAWN, entry)

proc sys_wait(): int32 =
  return syscall1(SYS_WAIT, 0)

proc sys_getppid(): int32 =
  return syscall1(SYS_GETPPID, 0)

proc sys_waitpid(pid: int32, status_ptr: ptr int32): int32 =
  return syscall2(SYS_WAITPID, pid, cast[int32](status_ptr))

proc sys_exit(code: int32) =
  syscall1(SYS_EXIT, code)

proc sys_fork(): int32 =
  return syscall1(SYS_FORK, 0)

# Networking syscall numbers
const SYS_NET_LISTEN: int32 = 50      # tcp_listen(port) -> conn
const SYS_NET_ACCEPT: int32 = 51      # tcp_accept_ready(conn) -> 0/1
const SYS_NET_CONNECT: int32 = 52     # tcp_connect(ip_ptr, port) -> conn
const SYS_NET_SEND: int32 = 53        # tcp_write(conn, data, len) -> sent
const SYS_NET_RECV: int32 = 54        # tcp_read(conn, buf, max) -> read
const SYS_NET_CLOSE: int32 = 55       # tcp_close(conn)
const SYS_NET_STATE: int32 = 56       # tcp_state[conn] -> state
const SYS_NET_POLL: int32 = 57        # net_poll() - process packets
const SYS_NET_HAS_DATA: int32 = 58    # tcp_recv_ready[conn] -> 0/1
