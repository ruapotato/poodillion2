# BrainhairOS Microkernel
# Main kernel entry point - called by boot.asm _start

# External assembly functions - Serial
extern proc serial_init()
extern proc serial_putchar(c: int32)
extern proc serial_print(s: int32)

# External assembly functions - IDT
extern proc init_idt()
extern proc remap_pic()
extern proc enable_interrupts()
extern proc disable_interrupts()

# External assembly functions - Paging
extern proc init_paging()
extern proc alloc_frame(): int32
extern proc free_frame(frame_addr: int32)
extern proc map_page(virtual_addr: int32, physical_addr: int32, flags: int32): int32
extern proc get_physical_address(virtual_addr: int32): int32
extern proc flush_tlb()
extern proc set_cr3(pdir: int32)
extern proc get_cr3(): int32

# External assembly functions - Process/Scheduler
extern proc init_scheduler()
extern proc create_process(entry: int32, parent: int32): int32
extern proc schedule(): int32
extern proc context_switch(new_pid: int32)
extern proc yield()
extern proc exit_process(code: int32)
extern proc get_current_pid(): int32
extern proc set_process_state(pid: int32, state: int32)
extern proc timer_tick()

# Get current tick count
extern proc get_tick_count(): int32

# Get process state (0=unused, 1=ready, 2=running, 3=blocked, 4=zombie)
extern proc get_process_state(pid: int32): int32

# External assembly functions - Keyboard
extern proc keyboard_init()
extern proc keyboard_read_char(): int32
extern proc keyboard_available(): int32

# Process states
const PROC_UNUSED: int32 = 0
const PROC_READY: int32 = 1
const PROC_RUNNING: int32 = 2
const PROC_BLOCKED: int32 = 3
const PROC_ZOMBIE: int32 = 4

# Paging flags
const PTE_PRESENT: int32 = 1
const PTE_WRITABLE: int32 = 2
const PTE_USER: int32 = 4
const PTE_KERNEL: int32 = 3      # PRESENT | WRITABLE
const PTE_USER_RW: int32 = 7     # PRESENT | WRITABLE | USER

# VGA text mode constants
const VGA_MEMORY: int32 = 0xB8000
const VGA_WIDTH: int32 = 80
const VGA_HEIGHT: int32 = 25

# VGA colors
const VGA_BLACK: int32 = 0
const VGA_BLUE: int32 = 1
const VGA_GREEN: int32 = 2
const VGA_CYAN: int32 = 3
const VGA_RED: int32 = 4
const VGA_MAGENTA: int32 = 5
const VGA_BROWN: int32 = 6
const VGA_LIGHT_GREY: int32 = 7
const VGA_DARK_GREY: int32 = 8
const VGA_LIGHT_BLUE: int32 = 9
const VGA_LIGHT_GREEN: int32 = 10
const VGA_LIGHT_CYAN: int32 = 11
const VGA_LIGHT_RED: int32 = 12
const VGA_LIGHT_MAGENTA: int32 = 13
const VGA_YELLOW: int32 = 14
const VGA_WHITE: int32 = 15

# Current cursor position
var vga_row: int32 = 0
var vga_col: int32 = 0
var vga_color: int32 = 0x0F  # White on black

# Make VGA attribute byte from fg/bg colors
proc vga_make_color(fg: int32, bg: int32): int32 =
  return (bg << 4) | fg

# Make VGA entry (char + attribute)
proc vga_make_entry(c: int32, color: int32): int32 =
  return (color << 8) | c

# Put a character at specific position
proc vga_putchar_at(c: int32, x: int32, y: int32, color: int32) =
  var index: int32 = y * VGA_WIDTH + x
  var entry: int32 = vga_make_entry(c, color)
  cast[ptr uint16](VGA_MEMORY)[index] = cast[uint16](entry)

# Clear the screen
proc vga_clear() =
  var y: int32 = 0
  while y < VGA_HEIGHT:
    var x: int32 = 0
    while x < VGA_WIDTH:
      vga_putchar_at(32, x, y, vga_color)  # Space character
      x = x + 1
    y = y + 1
  vga_row = 0
  vga_col = 0

# Scroll the screen up one line
proc vga_scroll() =
  var vga: ptr uint16 = cast[ptr uint16](VGA_MEMORY)

  # Move all lines up
  var y: int32 = 0
  while y < VGA_HEIGHT - 1:
    var x: int32 = 0
    while x < VGA_WIDTH:
      var src_idx: int32 = (y + 1) * VGA_WIDTH + x
      var dst_idx: int32 = y * VGA_WIDTH + x
      vga[dst_idx] = vga[src_idx]
      x = x + 1
    y = y + 1

  # Clear the last line
  var x: int32 = 0
  while x < VGA_WIDTH:
    vga_putchar_at(32, x, VGA_HEIGHT - 1, vga_color)
    x = x + 1

# Print a character with cursor advancement
proc vga_putchar(c: int32) =
  if c == 10:  # Newline
    vga_col = 0
    vga_row = vga_row + 1
  elif c == 13:  # Carriage return
    vga_col = 0
  elif c == 9:  # Tab
    vga_col = (vga_col + 8) & (0 - 8)  # Align to 8
  else:
    vga_putchar_at(c, vga_col, vga_row, vga_color)
    vga_col = vga_col + 1
    if vga_col >= VGA_WIDTH:
      vga_col = 0
      vga_row = vga_row + 1

  if vga_row >= VGA_HEIGHT:
    vga_scroll()
    vga_row = VGA_HEIGHT - 1

# Print a null-terminated string
proc vga_print(s: ptr uint8) =
  var i: int32 = 0
  while cast[int32](s[i]) != 0:
    vga_putchar(cast[int32](s[i]))
    i = i + 1

# Print a string with newline
proc vga_println(s: ptr uint8) =
  vga_print(s)
  vga_putchar(10)

# ============================================================================
# Serial Output (for debugging)
# ============================================================================

# Print string to serial (character by character)
proc ser_print(s: ptr uint8) =
  var i: int32 = 0
  var c: int32 = cast[int32](s[i])
  while c != 0:
    serial_putchar(c)
    i = i + 1
    c = cast[int32](s[i])

# Print string with newline to serial
proc ser_println(s: ptr uint8) =
  ser_print(s)
  serial_putchar(13)
  serial_putchar(10)

# Print to both VGA and serial
proc kprint(s: ptr uint8) =
  vga_print(s)
  ser_print(s)

proc kprintln(s: ptr uint8) =
  vga_println(s)
  ser_println(s)

# Set text color
proc vga_set_color(fg: int32, bg: int32) =
  vga_color = vga_make_color(fg, bg)

# Print a decimal number to VGA
proc vga_print_dec(num: int32) =
  if num == 0:
    vga_putchar(48)  # '0'
    return

  var buf: array[12, uint8]
  var i: int32 = 0
  var n: int32 = num

  # Handle negative
  if n < 0:
    vga_putchar(45)  # '-'
    n = 0 - n

  # Build digits in reverse
  while n > 0:
    buf[i] = cast[uint8](48 + (n - ((n / 10) * 10)))  # n % 10
    n = n / 10
    i = i + 1

  # Print in correct order
  while i > 0:
    i = i - 1
    vga_putchar(cast[int32](buf[i]))

# Print a hexadecimal number to VGA
proc vga_print_hex(num: int32) =
  var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var buf: array[11, uint8]
  buf[0] = cast[uint8](48)  # '0'
  buf[1] = cast[uint8](120) # 'x'

  var i: int32 = 9
  var n: int32 = num
  while i >= 2:
    buf[i] = hex_chars[n & 0xF]
    n = n >> 4
    i = i - 1
  buf[10] = cast[uint8](0)

  vga_print(addr(buf[0]))

# Print a hexadecimal number to serial
proc ser_print_hex(num: int32) =
  var hex_chars: ptr uint8 = cast[ptr uint8]("0123456789ABCDEF")
  var buf: array[11, uint8]
  buf[0] = cast[uint8](48)  # '0'
  buf[1] = cast[uint8](120) # 'x'

  var i: int32 = 9
  var n: int32 = num
  while i >= 2:
    buf[i] = hex_chars[n & 0xF]
    n = n >> 4
    i = i - 1
  buf[10] = cast[uint8](0)

  ser_print(addr(buf[0]))

# Halt the CPU
proc halt() =
  while true:
    # In a real kernel, this would be 'hlt' instruction
    # For now, just spin
    discard

# ============================================================================
# Kernel Entry Point
# ============================================================================

# Print status OK line
proc print_ok(msg: ptr uint8) =
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("  ["))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  vga_print(cast[ptr uint8]("OK"))
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("] "))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  vga_println(msg)
  # Also print to serial
  ser_print(cast[ptr uint8]("[OK] "))
  ser_println(msg)

# Print status pending line
proc print_pending(msg: ptr uint8) =
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("  ["))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_print(cast[ptr uint8](".."))
  vga_set_color(VGA_YELLOW, VGA_BLACK)
  vga_print(cast[ptr uint8]("] "))
  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
  vga_println(msg)
  # Also print to serial
  ser_print(cast[ptr uint8]("[..] "))
  ser_println(msg)

proc main() =
  # Initialize serial first for debug output
  serial_init()

  # Clear screen and show boot banner
  vga_clear()
  vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
  vga_println(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  vga_println(cast[ptr uint8](""))

  ser_println(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
  ser_println(cast[ptr uint8](""))

  # Initialize IDT (Interrupt Descriptor Table)
  print_pending(cast[ptr uint8]("Initializing IDT"))
  init_idt()
  remap_pic()
  print_ok(cast[ptr uint8]("IDT initialized"))

  # Initialize paging
  print_pending(cast[ptr uint8]("Initializing paging"))
  init_paging()
  print_ok(cast[ptr uint8]("Paging enabled (16MB identity mapped)"))

  # Initialize scheduler
  print_pending(cast[ptr uint8]("Initializing scheduler"))
  init_scheduler()
  print_ok(cast[ptr uint8]("Scheduler initialized"))

  # Enable interrupts
  print_pending(cast[ptr uint8]("Enabling interrupts"))
  enable_interrupts()
  print_ok(cast[ptr uint8]("Interrupts enabled"))

  # Boot complete
  vga_println(cast[ptr uint8](""))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  vga_println(cast[ptr uint8]("Kernel initialization complete!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  ser_println(cast[ptr uint8](""))
  ser_println(cast[ptr uint8]("Kernel initialization complete!"))

  # Test hex printing with known value
  ser_print(cast[ptr uint8]("Test hex (0xDEADBEEF): "))
  ser_print_hex(0xDEADBEEF)
  ser_println(cast[ptr uint8](""))

  # Display timer ticks to prove timer interrupt is working
  ser_print(cast[ptr uint8]("Timer ticks: "))

  # Wait for some timer ticks, then display the count
  var i: int32 = 0
  while i < 3:
    # Simple delay loop
    var j: int32 = 0
    while j < 5000000:
      j = j + 1

    # Show current tick count
    var ticks: int32 = get_tick_count()
    ser_print_hex(ticks)
    ser_print(cast[ptr uint8](" "))
    i = i + 1

  ser_println(cast[ptr uint8](""))
  ser_println(cast[ptr uint8]("Timer test complete!"))

  # Initialize keyboard
  print_pending(cast[ptr uint8]("Initializing keyboard"))
  keyboard_init()
  print_ok(cast[ptr uint8]("Keyboard initialized"))

  # Initialize filesystem
  print_pending(cast[ptr uint8]("Initializing ramdisk"))
  fs_init()
  print_ok(cast[ptr uint8]("Ramdisk initialized (8KB)"))

  vga_println(cast[ptr uint8](""))
  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
  vga_println(cast[ptr uint8]("Welcome to BrainhairOS!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  vga_println(cast[ptr uint8]("Type 'help' for available commands."))
  vga_println(cast[ptr uint8](""))

  ser_println(cast[ptr uint8](""))
  ser_println(cast[ptr uint8]("Starting kernel shell..."))

  # Run simple shell
  shell_main()

# ============================================================================
# Test Process (runs as a separate process)
# ============================================================================

proc test_process() =
  # This runs as a new process
  # For now, just print a message and loop
  vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
  vga_print(cast[ptr uint8]("[Process "))
  var pid: int32 = get_current_pid()
  vga_print_dec(pid)
  vga_println(cast[ptr uint8]("] Hello from child process!"))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  # Simple counter loop - shows process is running
  var count: int32 = 0
  while count < 5:
    var delay: int32 = 0
    while delay < 2000000:
      delay = delay + 1
    count = count + 1

  vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
  vga_print(cast[ptr uint8]("[Process "))
  vga_print_dec(pid)
  vga_println(cast[ptr uint8]("] Done, exiting."))
  vga_set_color(VGA_WHITE, VGA_BLACK)

  # Exit (for now just return, later use exit syscall)
  # The scheduler will reclaim this slot

# ============================================================================
# Shell Implementation
# ============================================================================

# Command buffer
var cmd_buffer: array[256, uint8]
var cmd_len: int32 = 0

# ============================================================================
# Simple Ramdisk Filesystem
# ============================================================================

# File entry: 32 bytes name + 4 bytes size + 4 bytes offset = 40 bytes
const MAX_FILES: int32 = 16
const MAX_FILENAME: int32 = 31
const FILE_ENTRY_SIZE: int32 = 40
const RAMDISK_SIZE: int32 = 8192  # 8KB data area

# File table: name (32) + size (4) + data_offset (4)
var file_table: array[640, uint8]  # 16 files * 40 bytes
var file_count: int32 = 0
var ramdisk_data: array[8192, uint8]  # 8KB data area
var ramdisk_used: int32 = 0

# Get file entry pointer
proc fs_get_entry(idx: int32): ptr uint8 =
  if idx < 0:
    return cast[ptr uint8](0)
  if idx >= MAX_FILES:
    return cast[ptr uint8](0)
  return addr(file_table[idx * FILE_ENTRY_SIZE])

# Get file size from entry
proc fs_get_size(entry: ptr uint8): int32 =
  var size_ptr: ptr int32 = cast[ptr int32](addr(entry[32]))
  return size_ptr[0]

# Set file size in entry
proc fs_set_size(entry: ptr uint8, size: int32) =
  var size_ptr: ptr int32 = cast[ptr int32](addr(entry[32]))
  size_ptr[0] = size

# Get file data offset from entry
proc fs_get_offset(entry: ptr uint8): int32 =
  var off_ptr: ptr int32 = cast[ptr int32](addr(entry[36]))
  return off_ptr[0]

# Set file data offset in entry
proc fs_set_offset(entry: ptr uint8, offset: int32) =
  var off_ptr: ptr int32 = cast[ptr int32](addr(entry[36]))
  off_ptr[0] = offset

# Find file by name, returns index or -1
proc fs_find(name: ptr uint8): int32 =
  var i: int32 = 0
  while i < file_count:
    var entry: ptr uint8 = fs_get_entry(i)
    if str_equals(entry, name) == 1:
      return i
    i = i + 1
  return -1

# Create a new file
proc fs_create(name: ptr uint8, content: ptr uint8, size: int32): int32 =
  # Check if file already exists
  if fs_find(name) >= 0:
    return -1  # Already exists

  # Check if we have space
  if file_count >= MAX_FILES:
    return -2  # No space for file entry
  if ramdisk_used + size > RAMDISK_SIZE:
    return -3  # No space for data

  # Get new entry
  var entry: ptr uint8 = fs_get_entry(file_count)

  # Copy filename (max 31 chars + null)
  var j: int32 = 0
  while j < MAX_FILENAME:
    var c: int32 = cast[int32](name[j])
    if c == 0:
      break
    entry[j] = name[j]
    j = j + 1
  entry[j] = cast[uint8](0)  # Null terminate

  # Set size and offset
  fs_set_size(entry, size)
  fs_set_offset(entry, ramdisk_used)

  # Copy data
  j = 0
  while j < size:
    ramdisk_data[ramdisk_used + j] = content[j]
    j = j + 1

  ramdisk_used = ramdisk_used + size
  file_count = file_count + 1

  return 0

# Delete a file (marks as deleted, doesn't reclaim space)
proc fs_delete(name: ptr uint8): int32 =
  var idx: int32 = fs_find(name)
  if idx < 0:
    return -1  # Not found

  # Move all entries after this one up
  var i: int32 = idx
  while i < file_count - 1:
    var src: ptr uint8 = fs_get_entry(i + 1)
    var dst: ptr uint8 = fs_get_entry(i)
    var j: int32 = 0
    while j < FILE_ENTRY_SIZE:
      dst[j] = src[j]
      j = j + 1
    i = i + 1

  file_count = file_count - 1
  return 0

# Initialize filesystem with some sample files
proc fs_init() =
  # Create a welcome file
  var welcome: ptr uint8 = cast[ptr uint8]("Welcome to BrainhairOS!\nThis is the ramdisk filesystem.\nUse 'ls' to list files.\n")
  var wlen: int32 = 0
  while cast[int32](welcome[wlen]) != 0:
    wlen = wlen + 1
  fs_create(cast[ptr uint8]("readme.txt"), welcome, wlen)

  # Create a test file
  var test: ptr uint8 = cast[ptr uint8]("Hello, World!\n")
  var tlen: int32 = 0
  while cast[int32](test[tlen]) != 0:
    tlen = tlen + 1
  fs_create(cast[ptr uint8]("hello.txt"), test, tlen)

  # Create a todo file
  var todo: ptr uint8 = cast[ptr uint8]("TODO:\n- Add more commands\n- Implement proper FS\n- Write more tests\n")
  var dlen: int32 = 0
  while cast[int32](todo[dlen]) != 0:
    dlen = dlen + 1
  fs_create(cast[ptr uint8]("todo.txt"), todo, dlen)

# Parse decimal string to integer
proc parse_int(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0
  var neg: int32 = 0

  # Skip leading spaces
  while cast[int32](s[i]) == 32:
    i = i + 1

  # Check for negative
  if cast[int32](s[i]) == 45:  # '-'
    neg = 1
    i = i + 1

  while true:
    var c: int32 = cast[int32](s[i])
    if c == 0:
      break
    if c == 32:  # space terminates
      break
    if c < 48:
      break
    if c > 57:
      break
    result = result * 10 + (c - 48)
    i = i + 1

  if neg == 1:
    return 0 - result
  return result

# Parse hex string to integer
proc parse_hex(s: ptr uint8): int32 =
  var result: int32 = 0
  var i: int32 = 0

  # Skip 0x prefix if present
  if s[0] == cast[uint8](48):  # '0'
    if s[1] == cast[uint8](120):  # 'x'
      i = 2
    elif s[1] == cast[uint8](88):  # 'X'
      i = 2

  while true:
    var c: int32 = cast[int32](s[i])
    if c == 0:
      return result
    if c == 32:  # space terminates
      return result

    result = result << 4

    if c >= 48:
      if c <= 57:  # 0-9
        result = result + (c - 48)
      elif c >= 65:
        if c <= 70:  # A-F
          result = result + (c - 55)
        elif c >= 97:
          if c <= 102:  # a-f
            result = result + (c - 87)
    i = i + 1
  return result

# Find next argument in command buffer
proc find_arg(buf: ptr uint8, argnum: int32): ptr uint8 =
  var i: int32 = 0
  var spaces: int32 = 0

  while cast[int32](buf[i]) != 0:
    if cast[int32](buf[i]) == 32:  # space
      spaces = spaces + 1
      # Skip consecutive spaces
      while cast[int32](buf[i + 1]) == 32:
        i = i + 1
      if spaces == argnum:
        return addr(buf[i + 1])
    i = i + 1

  return cast[ptr uint8](0)

# Check if s2 is a substring starting at position in s1
proc str_contains_at(s1: ptr uint8, pos: int32, s2: ptr uint8, s2_len: int32): int32 =
  var i: int32 = 0
  while i < s2_len:
    if cast[int32](s1[pos + i]) != cast[int32](s2[i]):
      return 0
    i = i + 1
  return 1

# String comparison
proc str_equals(s1: ptr uint8, s2: ptr uint8): int32 =
  var i: int32 = 0
  while true:
    var c1: int32 = cast[int32](s1[i])
    var c2: int32 = cast[int32](s2[i])
    if c1 != c2:
      return 0
    if c1 == 0:
      return 1
    i = i + 1
  return 0

# Print prompt
proc shell_prompt() =
  vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
  vga_print(cast[ptr uint8]("bhos"))
  vga_set_color(VGA_WHITE, VGA_BLACK)
  vga_print(cast[ptr uint8]("> "))

# Execute a command
proc shell_execute() =
  # Null-terminate the command
  cmd_buffer[cmd_len] = cast[uint8](0)

  # Skip empty commands
  if cmd_len == 0:
    return

  # Parse and execute command
  if str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("help")) == 1:
    vga_println(cast[ptr uint8]("Available commands:"))
    vga_println(cast[ptr uint8]("  help     - Show this help"))
    vga_println(cast[ptr uint8]("  clear    - Clear screen"))
    vga_println(cast[ptr uint8]("  ver      - Version info"))
    vga_println(cast[ptr uint8]("  uptime   - System uptime"))
    vga_println(cast[ptr uint8]("  ticks    - Timer tick count"))
    vga_println(cast[ptr uint8]("  mem      - Memory info"))
    vga_println(cast[ptr uint8]("  ps       - Show processes"))
    vga_println(cast[ptr uint8]("  echo X   - Echo text X"))
    vga_println(cast[ptr uint8]("  color    - Show colors"))
    vga_println(cast[ptr uint8]("  banner   - Show ASCII art"))
    vga_println(cast[ptr uint8]("  hello    - Hello World!"))
    vga_println(cast[ptr uint8]("  spin     - Spinner animation"))
    vga_println(cast[ptr uint8]("  guess    - Number guessing game"))
    vga_println(cast[ptr uint8]("  peek A   - Read memory at hex addr A"))
    vga_println(cast[ptr uint8]("  poke A V - Write V to hex addr A"))
    vga_println(cast[ptr uint8]("  dump A   - Hexdump 64 bytes at addr A"))
    vga_println(cast[ptr uint8]("  run      - Spawn a test process"))
    vga_println(cast[ptr uint8]("  calc     - Calculator (e.g. calc 5 + 3)"))
    vga_println(cast[ptr uint8]("  fill A V N - Fill N bytes at addr A with V"))
    vga_println(cast[ptr uint8]("  rand     - Generate random number"))
    vga_println(cast[ptr uint8]("  test     - Run kernel self-tests"))
    vga_println(cast[ptr uint8]("  countdown N - Count down from N"))
    vga_println(cast[ptr uint8]("  logo     - Show fancy logo"))
    vga_println(cast[ptr uint8]("  matrix   - Matrix rain effect"))
    vga_println(cast[ptr uint8]("  cls      - Clear screen (alias)"))
    vga_println(cast[ptr uint8]("  ls       - List files on ramdisk"))
    vga_println(cast[ptr uint8]("  cat F    - Show contents of file F"))
    vga_println(cast[ptr uint8]("  write F T - Write text T to file F"))
    vga_println(cast[ptr uint8]("  rm F     - Delete file F"))
    vga_println(cast[ptr uint8]("  cp S D   - Copy file S to D"))
    vga_println(cast[ptr uint8]("  df       - Show disk (ramdisk) usage"))
    vga_println(cast[ptr uint8]("  whoami   - Show current user"))
    vga_println(cast[ptr uint8]("  hostname - Show hostname"))
    vga_println(cast[ptr uint8]("  date     - Show date/time"))
    vga_println(cast[ptr uint8]("  wc F     - Count lines/words/chars in F"))
    vga_println(cast[ptr uint8]("  head F   - Show first 5 lines of F"))
    vga_println(cast[ptr uint8]("  grep P F - Search for pattern P in file F"))
    vga_println(cast[ptr uint8]("  mv S D   - Rename file S to D"))
    vga_println(cast[ptr uint8]("  touch F  - Create empty file F"))
    vga_println(cast[ptr uint8]("  xxd F    - Hexdump file F"))
    vga_println(cast[ptr uint8]("  size F   - Show size of file F"))
    vga_println(cast[ptr uint8]("  stat F   - File statistics"))
    vga_println(cast[ptr uint8]("  sysinfo  - System information"))
    vga_println(cast[ptr uint8]("  about    - About BrainhairOS"))
    vga_println(cast[ptr uint8]("  reboot   - Reboot system"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("clear")) == 1:
    vga_clear()
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ticks")) == 1:
    var ticks: int32 = get_tick_count()
    vga_print(cast[ptr uint8]("Timer ticks: "))
    vga_print_hex(ticks)
    vga_println(cast[ptr uint8](""))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ver")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8]("Written in Brainhair programming language"))
    vga_println(cast[ptr uint8]("Self-hosted on x86-32 architecture"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("uptime")) == 1:
    var ticks: int32 = get_tick_count()
    # PIT runs at ~18.2 Hz, so ticks/18 ~ seconds
    var seconds: int32 = ticks / 18
    var minutes: int32 = seconds / 60
    seconds = seconds - (minutes * 60)
    vga_print(cast[ptr uint8]("System uptime: "))
    vga_print_dec(minutes)
    vga_print(cast[ptr uint8]("m "))
    vga_print_dec(seconds)
    vga_println(cast[ptr uint8]("s"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ps")) == 1:
    vga_println(cast[ptr uint8]("PID  STATE"))
    vga_println(cast[ptr uint8]("---  --------"))
    var ps_pid: int32 = 0
    var ps_count: int32 = 0
    while ps_pid < 64:
      var state: int32 = get_process_state(ps_pid)
      if state > 0:  # Not unused
        vga_print_dec(ps_pid)
        if ps_pid < 10:
          vga_print(cast[ptr uint8]("    "))
        else:
          vga_print(cast[ptr uint8]("   "))
        if state == 1:
          vga_set_color(VGA_YELLOW, VGA_BLACK)
          vga_println(cast[ptr uint8]("READY"))
        elif state == 2:
          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
          vga_println(cast[ptr uint8]("RUNNING"))
        elif state == 3:
          vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
          vga_println(cast[ptr uint8]("BLOCKED"))
        elif state == 4:
          vga_set_color(VGA_DARK_GREY, VGA_BLACK)
          vga_println(cast[ptr uint8]("ZOMBIE"))
        else:
          vga_println(cast[ptr uint8]("UNKNOWN"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        ps_count = ps_count + 1
      ps_pid = ps_pid + 1
    vga_print(cast[ptr uint8]("Total: "))
    vga_print_dec(ps_count)
    vga_println(cast[ptr uint8](" process(es)"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("color")) == 1:
    vga_print(cast[ptr uint8]("Colors: "))
    var c: int32 = 0
    while c < 16:
      vga_set_color(c, VGA_BLACK)
      vga_putchar(42)  # '*'
      c = c + 1
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("banner")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_println(cast[ptr uint8]("  ____            _       _           _       ___  ____  "))
    vga_println(cast[ptr uint8](" | __ ) _ __ __ _(_)_ __ | |__   __ _(_)_ __ / _ \\/ ___| "))
    vga_println(cast[ptr uint8](" |  _ \\| '__/ _` | | '_ \\| '_ \\ / _` | | '__| | | \\___ \\ "))
    vga_println(cast[ptr uint8](" | |_) | | | (_| | | | | | | | | (_| | | |  | |_| |___) |"))
    vga_println(cast[ptr uint8](" |____/|_|  \\__,_|_|_| |_|_| |_|\\__,_|_|_|   \\___/|____/ "))
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("hello")) == 1:
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("Hello, World from BrainhairOS!"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("spin")) == 1:
    # Show a spinning animation
    var frames: array[4, uint8]
    frames[0] = cast[uint8](124)  # |
    frames[1] = cast[uint8](47)   # /
    frames[2] = cast[uint8](45)   # -
    frames[3] = cast[uint8](92)   # \
    vga_print(cast[ptr uint8]("Spinning: "))
    var spin_col: int32 = vga_col
    var spin_row: int32 = vga_row
    var frame: int32 = 0
    var count: int32 = 0
    while count < 40:
      vga_putchar_at(cast[int32](frames[frame]), spin_col, spin_row, vga_color)
      frame = (frame + 1) - ((frame + 1) / 4) * 4  # frame % 4
      # Delay
      var d: int32 = 0
      while d < 1000000:
        d = d + 1
      count = count + 1
    vga_col = spin_col + 1
    vga_println(cast[ptr uint8](" Done!"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("guess")) == 1:
    # Simple number guessing game
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("=== Number Guessing Game ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8]("I'm thinking of a number 1-100."))
    vga_println(cast[ptr uint8]("Type a number and press Enter."))
    vga_println(cast[ptr uint8](""))

    # Generate "random" number using tick count
    var secret: int32 = get_tick_count()
    secret = ((secret * 1103515245 + 12345) / 65536) - (((secret * 1103515245 + 12345) / 65536) / 100) * 100
    if secret < 1:
      secret = secret + 100
    if secret > 100:
      secret = secret - 100

    var guess_count: int32 = 0
    var game_buf: array[16, uint8]
    var game_len: int32 = 0
    var game_done: int32 = 0

    while game_done == 0:
      vga_print(cast[ptr uint8]("Guess: "))
      game_len = 0

      # Read guess
      var reading: int32 = 1
      while reading == 1:
        var avail: int32 = keyboard_available()
        if avail > 0:
          var c: int32 = keyboard_read_char()
          if c == 13:  # Enter
            vga_println(cast[ptr uint8](""))
            reading = 0
          elif c >= 48:
            if c <= 57:  # 0-9
              if game_len < 15:
                game_buf[game_len] = cast[uint8](c)
                game_len = game_len + 1
                vga_putchar(c)

      # Parse number
      game_buf[game_len] = cast[uint8](0)
      var guess: int32 = 0
      var gi: int32 = 0
      while gi < game_len:
        guess = guess * 10 + (cast[int32](game_buf[gi]) - 48)
        gi = gi + 1

      guess_count = guess_count + 1

      if guess == secret:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_print(cast[ptr uint8]("Correct! You got it in "))
        vga_print_dec(guess_count)
        vga_println(cast[ptr uint8](" guesses!"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        game_done = 1
      elif guess < secret:
        vga_println(cast[ptr uint8]("Too low!"))
      else:
        vga_println(cast[ptr uint8]("Too high!"))
  elif cmd_buffer[0] == cast[uint8](112):  # 'p'
    if cmd_buffer[1] == cast[uint8](101):  # 'e'
      if cmd_buffer[2] == cast[uint8](101):  # 'e'
        if cmd_buffer[3] == cast[uint8](107):  # 'k'
          # peek command
          var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](arg) != 0:
            var addr_val: int32 = parse_hex(arg)
            var mem: ptr uint8 = cast[ptr uint8](addr_val)
            var val: int32 = cast[int32](mem[0])
            vga_print(cast[ptr uint8]("["))
            vga_print_hex(addr_val)
            vga_print(cast[ptr uint8]("] = "))
            vga_print_hex(val)
            vga_println(cast[ptr uint8](""))
          else:
            vga_println(cast[ptr uint8]("Usage: peek <hex_addr>"))
      elif cmd_buffer[2] == cast[uint8](111):  # 'o'
        if cmd_buffer[3] == cast[uint8](107):  # 'k'
          if cmd_buffer[4] == cast[uint8](101):  # 'e'
            # poke command
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                var addr_val: int32 = parse_hex(arg1)
                var val: int32 = parse_hex(arg2)
                var mem: ptr uint8 = cast[ptr uint8](addr_val)
                mem[0] = cast[uint8](val)
                vga_print(cast[ptr uint8]("Wrote "))
                vga_print_hex(val)
                vga_print(cast[ptr uint8](" to "))
                vga_print_hex(addr_val)
                vga_println(cast[ptr uint8](""))
              else:
                vga_println(cast[ptr uint8]("Usage: poke <hex_addr> <hex_val>"))
            else:
              vga_println(cast[ptr uint8]("Usage: poke <hex_addr> <hex_val>"))
  elif cmd_buffer[0] == cast[uint8](100):  # 'd'
    if cmd_buffer[1] == cast[uint8](117):  # 'u'
      if cmd_buffer[2] == cast[uint8](109):  # 'm'
        if cmd_buffer[3] == cast[uint8](112):  # 'p'
          # dump command - show 64 bytes
          var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](arg) != 0:
            var addr_val: int32 = parse_hex(arg)
            var mem: ptr uint8 = cast[ptr uint8](addr_val)
            var row: int32 = 0
            while row < 4:
              vga_print_hex(addr_val + row * 16)
              vga_print(cast[ptr uint8](": "))
              var col: int32 = 0
              while col < 16:
                var byte_val: int32 = cast[int32](mem[row * 16 + col])
                # Print hex byte (2 digits)
                var hi: int32 = (byte_val >> 4) & 0xF
                var lo: int32 = byte_val & 0xF
                if hi < 10:
                  vga_putchar(48 + hi)
                else:
                  vga_putchar(55 + hi)
                if lo < 10:
                  vga_putchar(48 + lo)
                else:
                  vga_putchar(55 + lo)
                vga_putchar(32)  # space
                col = col + 1
              # Print ASCII
              vga_print(cast[ptr uint8](" |"))
              col = 0
              while col < 16:
                var byte_val: int32 = cast[int32](mem[row * 16 + col])
                if byte_val >= 32:
                  if byte_val < 127:
                    vga_putchar(byte_val)
                  else:
                    vga_putchar(46)  # '.'
                else:
                  vga_putchar(46)  # '.'
                col = col + 1
              vga_println(cast[ptr uint8]("|"))
              row = row + 1
          else:
            vga_println(cast[ptr uint8]("Usage: dump <hex_addr>"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("run")) == 1:
    vga_println(cast[ptr uint8]("Spawning test process..."))
    var pid: int32 = sys_spawn(cast[int32](addr(test_process)))
    if pid >= 0:
      vga_print(cast[ptr uint8]("Created process with PID "))
      vga_print_dec(pid)
      vga_println(cast[ptr uint8](""))
      vga_println(cast[ptr uint8]("(Process runs in background - use 'ps' to see)"))
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      vga_println(cast[ptr uint8]("Failed to spawn process!"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("rand")) == 1:
    # Generate pseudo-random number using tick count and LCG
    var seed: int32 = get_tick_count()
    seed = seed * 1103515245 + 12345
    seed = (seed / 65536) & 0x7FFF
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_print(cast[ptr uint8]("Random: "))
    vga_print_dec(seed)
    vga_print(cast[ptr uint8](" ("))
    vga_print_hex(seed)
    vga_println(cast[ptr uint8](")"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("test")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("=== Kernel Self-Tests ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    # Test 1: Memory write/read
    vga_print(cast[ptr uint8]("[1] Memory test...   "))
    var test_addr: ptr uint8 = cast[ptr uint8](0x90000)
    test_addr[0] = cast[uint8](0xAB)
    test_addr[1] = cast[uint8](0xCD)
    if cast[int32](test_addr[0]) == 0xAB:
      if cast[int32](test_addr[1]) == 0xCD:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_println(cast[ptr uint8]("PASS"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
      else:
        vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
        vga_println(cast[ptr uint8]("FAIL"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      vga_println(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 2: Timer running
    vga_print(cast[ptr uint8]("[2] Timer test...    "))
    var t1: int32 = get_tick_count()
    var delay: int32 = 0
    while delay < 500000:
      delay = delay + 1
    var t2: int32 = get_tick_count()
    if t2 > t1:
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      vga_print(cast[ptr uint8]("PASS ("))
      vga_print_dec(t2 - t1)
      vga_println(cast[ptr uint8](" ticks)"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      vga_println(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 3: Arithmetic
    vga_print(cast[ptr uint8]("[3] Arithmetic...    "))
    var arith_pass: int32 = 1
    if 5 + 3 != 8:
      arith_pass = 0
    if 10 - 7 != 3:
      arith_pass = 0
    if 6 * 7 != 42:
      arith_pass = 0
    if 100 / 5 != 20:
      arith_pass = 0
    if arith_pass == 1:
      vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
      vga_println(cast[ptr uint8]("PASS"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      vga_println(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    # Test 4: String comparison
    vga_print(cast[ptr uint8]("[4] String cmp...    "))
    if str_equals(cast[ptr uint8]("hello"), cast[ptr uint8]("hello")) == 1:
      if str_equals(cast[ptr uint8]("hello"), cast[ptr uint8]("world")) == 0:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_println(cast[ptr uint8]("PASS"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
      else:
        vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
        vga_println(cast[ptr uint8]("FAIL"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
    else:
      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
      vga_println(cast[ptr uint8]("FAIL"))
      vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("All tests complete!"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif cmd_buffer[0] == cast[uint8](102):  # 'f'
    if cmd_buffer[1] == cast[uint8](105):  # 'i'
      if cmd_buffer[2] == cast[uint8](108):  # 'l'
        if cmd_buffer[3] == cast[uint8](108):  # 'l'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # fill command: fill <addr> <value> <count>
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            var arg3: ptr uint8 = find_arg(addr(cmd_buffer[0]), 3)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                if cast[int32](arg3) != 0:
                  var addr_val: int32 = parse_hex(arg1)
                  var val: int32 = parse_hex(arg2)
                  var count: int32 = parse_int(arg3)
                  if count > 0:
                    if count > 4096:
                      count = 4096
                      vga_println(cast[ptr uint8]("(limited to 4096 bytes)"))
                    var mem: ptr uint8 = cast[ptr uint8](addr_val)
                    var i: int32 = 0
                    while i < count:
                      mem[i] = cast[uint8](val)
                      i = i + 1
                    vga_print(cast[ptr uint8]("Filled "))
                    vga_print_dec(count)
                    vga_print(cast[ptr uint8](" bytes at "))
                    vga_print_hex(addr_val)
                    vga_print(cast[ptr uint8](" with "))
                    vga_print_hex(val)
                    vga_println(cast[ptr uint8](""))
                  else:
                    vga_println(cast[ptr uint8]("Count must be > 0"))
                else:
                  vga_println(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
              else:
                vga_println(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
            else:
              vga_println(cast[ptr uint8]("Usage: fill <hex_addr> <hex_val> <count>"))
  elif cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](97):  # 'a'
      if cmd_buffer[2] == cast[uint8](108):  # 'l'
        if cmd_buffer[3] == cast[uint8](99):  # 'c'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # calc command: calc <num> <op> <num>
            var arg1: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var arg2: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            var arg3: ptr uint8 = find_arg(addr(cmd_buffer[0]), 3)
            if cast[int32](arg1) != 0:
              if cast[int32](arg2) != 0:
                if cast[int32](arg3) != 0:
                  var num1: int32 = parse_int(arg1)
                  var num2: int32 = parse_int(arg3)
                  var op: int32 = cast[int32](arg2[0])
                  var result: int32 = 0
                  var valid: int32 = 1
                  if op == 43:  # '+'
                    result = num1 + num2
                  elif op == 45:  # '-'
                    result = num1 - num2
                  elif op == 42:  # '*'
                    result = num1 * num2
                  elif op == 47:  # '/'
                    if num2 == 0:
                      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                      vga_println(cast[ptr uint8]("Error: Division by zero"))
                      vga_set_color(VGA_WHITE, VGA_BLACK)
                      valid = 0
                    else:
                      result = num1 / num2
                  elif op == 37:  # '%'
                    if num2 == 0:
                      vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                      vga_println(cast[ptr uint8]("Error: Division by zero"))
                      vga_set_color(VGA_WHITE, VGA_BLACK)
                      valid = 0
                    else:
                      result = num1 - (num1 / num2) * num2
                  elif op == 38:  # '&'
                    result = num1 & num2
                  elif op == 124:  # '|'
                    result = num1 | num2
                  elif op == 94:  # '^'
                    result = num1 ^ num2
                  else:
                    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                    vga_print(cast[ptr uint8]("Unknown operator: "))
                    vga_putchar(op)
                    vga_println(cast[ptr uint8](""))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                    valid = 0
                  if valid == 1:
                    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                    vga_print(cast[ptr uint8]("= "))
                    vga_print_dec(result)
                    vga_print(cast[ptr uint8](" ("))
                    vga_print_hex(result)
                    vga_println(cast[ptr uint8](")"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  vga_println(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
                  vga_println(cast[ptr uint8]("  Ops: + - * / % & | ^"))
              else:
                vga_println(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
            else:
              vga_println(cast[ptr uint8]("Usage: calc <num> <op> <num>"))
              vga_println(cast[ptr uint8]("  Ops: + - * / % & | ^"))
  elif cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](111):  # 'o'
      if cmd_buffer[2] == cast[uint8](117):  # 'u'
        if cmd_buffer[3] == cast[uint8](110):  # 'n'
          if cmd_buffer[4] == cast[uint8](116):  # 't'
            if cmd_buffer[5] == cast[uint8](100):  # 'd'
              if cmd_buffer[6] == cast[uint8](111):  # 'o'
                if cmd_buffer[7] == cast[uint8](119):  # 'w'
                  if cmd_buffer[8] == cast[uint8](110):  # 'n'
                    if cmd_buffer[9] == cast[uint8](32):  # ' '
                      # countdown N
                      var arg: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
                      if cast[int32](arg) != 0:
                        var n: int32 = parse_int(arg)
                        if n > 100:
                          n = 100
                        if n > 0:
                          vga_println(cast[ptr uint8](""))
                          while n >= 0:
                            vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                            vga_print(cast[ptr uint8]("\r"))
                            vga_print(cast[ptr uint8]("  "))
                            vga_print_dec(n)
                            vga_print(cast[ptr uint8]("   "))
                            vga_set_color(VGA_WHITE, VGA_BLACK)
                            # Delay ~1 second (18 ticks)
                            var start_tick: int32 = get_tick_count()
                            while get_tick_count() - start_tick < 18:
                              discard
                            n = n - 1
                          vga_println(cast[ptr uint8](""))
                          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                          vga_println(cast[ptr uint8]("*** BOOM! ***"))
                          vga_set_color(VGA_WHITE, VGA_BLACK)
                        else:
                          vga_println(cast[ptr uint8]("Number must be > 0"))
                      else:
                        vga_println(cast[ptr uint8]("Usage: countdown <number>"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("logo")) == 1:
    vga_println(cast[ptr uint8](""))
    # Draw a colorful logo
    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
    vga_println(cast[ptr uint8]("    ____  _   _ ___  ____"))
    vga_set_color(VGA_YELLOW, VGA_BLACK)
    vga_println(cast[ptr uint8]("   | __ )| | | / _ \\/ ___|"))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("   |  _ \\| |_| | | | \\___ \\"))
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("   | |_) |  _  | |_| |___) |"))
    vga_set_color(VGA_LIGHT_BLUE, VGA_BLACK)
    vga_println(cast[ptr uint8]("   |____/|_| |_|\\___/|____/"))
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_MAGENTA, VGA_BLACK)
    vga_println(cast[ptr uint8]("   B R A I N H A I R O S"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    vga_println(cast[ptr uint8]("   Self-hosted microkernel"))
    vga_println(cast[ptr uint8]("   Written in Brainhair"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("cls")) == 1:
    vga_clear()
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("ls")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("Ramdisk files:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    if file_count == 0:
      vga_println(cast[ptr uint8]("  (empty)"))
    else:
      var fi: int32 = 0
      while fi < file_count:
        var entry: ptr uint8 = fs_get_entry(fi)
        vga_print(cast[ptr uint8]("  "))
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_print(entry)  # filename
        vga_set_color(VGA_DARK_GREY, VGA_BLACK)
        vga_print(cast[ptr uint8]("  "))
        var fsize: int32 = fs_get_size(entry)
        vga_print_dec(fsize)
        vga_println(cast[ptr uint8](" bytes"))
        vga_set_color(VGA_WHITE, VGA_BLACK)
        fi = fi + 1
      vga_print(cast[ptr uint8]("Total: "))
      vga_print_dec(file_count)
      vga_print(cast[ptr uint8](" file(s), "))
      vga_print_dec(ramdisk_used)
      vga_println(cast[ptr uint8](" bytes used"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("df")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("Ramdisk Usage:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_print(cast[ptr uint8]("  Used:  "))
    vga_print_dec(ramdisk_used)
    vga_print(cast[ptr uint8](" / "))
    vga_print_dec(RAMDISK_SIZE)
    vga_println(cast[ptr uint8](" bytes"))
    vga_print(cast[ptr uint8]("  Free:  "))
    vga_print_dec(RAMDISK_SIZE - ramdisk_used)
    vga_println(cast[ptr uint8](" bytes"))
    vga_print(cast[ptr uint8]("  Files: "))
    vga_print_dec(file_count)
    vga_print(cast[ptr uint8](" / "))
    vga_print_dec(MAX_FILES)
    vga_println(cast[ptr uint8](""))
    # Show a usage bar
    vga_print(cast[ptr uint8]("  ["))
    var bar_used: int32 = (ramdisk_used * 40) / RAMDISK_SIZE
    var bi: int32 = 0
    while bi < 40:
      if bi < bar_used:
        vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
        vga_putchar(35)  # '#'
      else:
        vga_set_color(VGA_DARK_GREY, VGA_BLACK)
        vga_putchar(45)  # '-'
      bi = bi + 1
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8]("]"))
  elif cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](97):  # 'a'
      if cmd_buffer[2] == cast[uint8](116):  # 't'
        if cmd_buffer[3] == cast[uint8](32):  # ' '
          # cat filename
          var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](filename) != 0:
            var idx: int32 = fs_find(filename)
            if idx >= 0:
              var entry: ptr uint8 = fs_get_entry(idx)
              var fsize: int32 = fs_get_size(entry)
              var foffset: int32 = fs_get_offset(entry)
              # Print file contents
              var ci: int32 = 0
              while ci < fsize:
                var ch: int32 = cast[int32](ramdisk_data[foffset + ci])
                if ch == 10:
                  vga_putchar(10)
                elif ch >= 32:
                  if ch < 127:
                    vga_putchar(ch)
                ci = ci + 1
              vga_println(cast[ptr uint8](""))
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              vga_print(cast[ptr uint8]("File not found: "))
              vga_println(filename)
              vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_println(cast[ptr uint8]("Usage: cat <filename>"))
  elif cmd_buffer[0] == cast[uint8](119):  # 'w'
    if cmd_buffer[1] == cast[uint8](114):  # 'r'
      if cmd_buffer[2] == cast[uint8](105):  # 'i'
        if cmd_buffer[3] == cast[uint8](116):  # 't'
          if cmd_buffer[4] == cast[uint8](101):  # 'e'
            if cmd_buffer[5] == cast[uint8](32):  # ' '
              # write filename text
              var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              var text: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
              if cast[int32](filename) != 0:
                if cast[int32](text) != 0:
                  # Calculate text length
                  var tlen: int32 = 0
                  while cast[int32](text[tlen]) != 0:
                    tlen = tlen + 1
                  # Try to create file
                  var result: int32 = fs_create(filename, text, tlen)
                  if result == 0:
                    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                    vga_print(cast[ptr uint8]("Created: "))
                    vga_print(filename)
                    vga_print(cast[ptr uint8](" ("))
                    vga_print_dec(tlen)
                    vga_println(cast[ptr uint8](" bytes)"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                  elif result == -1:
                    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                    vga_println(cast[ptr uint8]("File already exists"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                  elif result == -2:
                    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                    vga_println(cast[ptr uint8]("Too many files"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                  else:
                    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                    vga_println(cast[ptr uint8]("Not enough space"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  vga_println(cast[ptr uint8]("Usage: write <filename> <text>"))
              else:
                vga_println(cast[ptr uint8]("Usage: write <filename> <text>"))
  elif cmd_buffer[0] == cast[uint8](114):  # 'r'
    if cmd_buffer[1] == cast[uint8](109):  # 'm'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # rm filename
        var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        if cast[int32](filename) != 0:
          var result: int32 = fs_delete(filename)
          if result == 0:
            vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
            vga_print(cast[ptr uint8]("Deleted: "))
            vga_println(filename)
            vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            vga_print(cast[ptr uint8]("File not found: "))
            vga_println(filename)
            vga_set_color(VGA_WHITE, VGA_BLACK)
        else:
          vga_println(cast[ptr uint8]("Usage: rm <filename>"))
  elif cmd_buffer[0] == cast[uint8](99):  # 'c'
    if cmd_buffer[1] == cast[uint8](112):  # 'p'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # cp source dest
        var src_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        var dst_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
        if cast[int32](src_name) != 0:
          if cast[int32](dst_name) != 0:
            var src_idx: int32 = fs_find(src_name)
            if src_idx >= 0:
              var src_entry: ptr uint8 = fs_get_entry(src_idx)
              var src_size: int32 = fs_get_size(src_entry)
              var src_offset: int32 = fs_get_offset(src_entry)
              # Create a new file with the same contents
              var result: int32 = fs_create(dst_name, addr(ramdisk_data[src_offset]), src_size)
              if result == 0:
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                vga_print(cast[ptr uint8]("Copied: "))
                vga_print(src_name)
                vga_print(cast[ptr uint8](" -> "))
                vga_println(dst_name)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              elif result == -1:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_println(cast[ptr uint8]("Destination already exists"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_println(cast[ptr uint8]("Not enough space"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              vga_print(cast[ptr uint8]("Source not found: "))
              vga_println(src_name)
              vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_println(cast[ptr uint8]("Usage: cp <source> <dest>"))
        else:
          vga_println(cast[ptr uint8]("Usage: cp <source> <dest>"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("whoami")) == 1:
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("root"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("hostname")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("brainhair"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif cmd_buffer[0] == cast[uint8](119):  # 'w'
    if cmd_buffer[1] == cast[uint8](99):  # 'c'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # wc filename
        var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        if cast[int32](filename) != 0:
          var idx: int32 = fs_find(filename)
          if idx >= 0:
            var entry: ptr uint8 = fs_get_entry(idx)
            var fsize: int32 = fs_get_size(entry)
            var foffset: int32 = fs_get_offset(entry)
            # Count lines, words, and chars
            var lines: int32 = 0
            var words: int32 = 0
            var chars: int32 = fsize
            var in_word: int32 = 0
            var wi: int32 = 0
            while wi < fsize:
              var ch: int32 = cast[int32](ramdisk_data[foffset + wi])
              if ch == 10:  # newline
                lines = lines + 1
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              elif ch == 32:  # space
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              elif ch == 9:  # tab
                if in_word == 1:
                  words = words + 1
                  in_word = 0
              else:
                in_word = 1
              wi = wi + 1
            if in_word == 1:
              words = words + 1
            # Print results
            vga_print(cast[ptr uint8]("  "))
            vga_print_dec(lines)
            vga_print(cast[ptr uint8]("  "))
            vga_print_dec(words)
            vga_print(cast[ptr uint8]("  "))
            vga_print_dec(chars)
            vga_print(cast[ptr uint8]("  "))
            vga_println(filename)
          else:
            vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
            vga_print(cast[ptr uint8]("File not found: "))
            vga_println(filename)
            vga_set_color(VGA_WHITE, VGA_BLACK)
        else:
          vga_println(cast[ptr uint8]("Usage: wc <filename>"))
  elif cmd_buffer[0] == cast[uint8](104):  # 'h'
    if cmd_buffer[1] == cast[uint8](101):  # 'e'
      if cmd_buffer[2] == cast[uint8](97):  # 'a'
        if cmd_buffer[3] == cast[uint8](100):  # 'd'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # head filename
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](filename) != 0:
              var idx: int32 = fs_find(filename)
              if idx >= 0:
                var entry: ptr uint8 = fs_get_entry(idx)
                var fsize: int32 = fs_get_size(entry)
                var foffset: int32 = fs_get_offset(entry)
                # Print first 5 lines
                var lines_shown: int32 = 0
                var hi: int32 = 0
                while hi < fsize:
                  if lines_shown >= 5:
                    break
                  var ch: int32 = cast[int32](ramdisk_data[foffset + hi])
                  if ch == 10:
                    vga_putchar(10)
                    lines_shown = lines_shown + 1
                  elif ch >= 32:
                    if ch < 127:
                      vga_putchar(ch)
                  hi = hi + 1
                if lines_shown < 5:
                  vga_println(cast[ptr uint8](""))
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_print(cast[ptr uint8]("File not found: "))
                vga_println(filename)
                vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_println(cast[ptr uint8]("Usage: head <filename>"))
  elif cmd_buffer[0] == cast[uint8](103):  # 'g'
    if cmd_buffer[1] == cast[uint8](114):  # 'r'
      if cmd_buffer[2] == cast[uint8](101):  # 'e'
        if cmd_buffer[3] == cast[uint8](112):  # 'p'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # grep pattern filename
            var pattern: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
            if cast[int32](pattern) != 0:
              if cast[int32](filename) != 0:
                var idx: int32 = fs_find(filename)
                if idx >= 0:
                  # Get pattern length
                  var plen: int32 = 0
                  while cast[int32](pattern[plen]) != 0:
                    if cast[int32](pattern[plen]) == 32:
                      break
                    plen = plen + 1
                  var entry: ptr uint8 = fs_get_entry(idx)
                  var fsize: int32 = fs_get_size(entry)
                  var foffset: int32 = fs_get_offset(entry)
                  # Search for pattern in each line
                  var line_start: int32 = 0
                  var gi: int32 = 0
                  var found: int32 = 0
                  while gi <= fsize:
                    var ch: int32 = 0
                    if gi < fsize:
                      ch = cast[int32](ramdisk_data[foffset + gi])
                    if ch == 10:
                      ch = 0
                    if gi == fsize:
                      ch = 0
                    if ch == 0:
                      # End of line - check if pattern found in this line
                      var li: int32 = line_start
                      while li + plen <= gi:
                        if str_contains_at(addr(ramdisk_data[foffset]), li, pattern, plen) == 1:
                          # Print this line
                          vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                          var pi: int32 = line_start
                          while pi < gi:
                            var pch: int32 = cast[int32](ramdisk_data[foffset + pi])
                            if pch >= 32:
                              if pch < 127:
                                vga_putchar(pch)
                            pi = pi + 1
                          vga_println(cast[ptr uint8](""))
                          vga_set_color(VGA_WHITE, VGA_BLACK)
                          found = found + 1
                          break
                        li = li + 1
                      line_start = gi + 1
                    gi = gi + 1
                  if found == 0:
                    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                    vga_println(cast[ptr uint8]("(no matches)"))
                    vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                  vga_print(cast[ptr uint8]("File not found: "))
                  vga_println(filename)
                  vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_println(cast[ptr uint8]("Usage: grep <pattern> <filename>"))
            else:
              vga_println(cast[ptr uint8]("Usage: grep <pattern> <filename>"))
  elif cmd_buffer[0] == cast[uint8](109):  # 'm'
    if cmd_buffer[1] == cast[uint8](118):  # 'v'
      if cmd_buffer[2] == cast[uint8](32):  # ' '
        # mv oldname newname
        var old_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
        var new_name: ptr uint8 = find_arg(addr(cmd_buffer[0]), 2)
        if cast[int32](old_name) != 0:
          if cast[int32](new_name) != 0:
            var idx: int32 = fs_find(old_name)
            if idx >= 0:
              # Check new name doesn't exist
              if fs_find(new_name) < 0:
                # Rename by copying name
                var entry: ptr uint8 = fs_get_entry(idx)
                var j: int32 = 0
                while j < MAX_FILENAME:
                  var c: int32 = cast[int32](new_name[j])
                  if c == 0:
                    break
                  if c == 32:
                    break
                  entry[j] = new_name[j]
                  j = j + 1
                entry[j] = cast[uint8](0)
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                vga_print(cast[ptr uint8]("Renamed: "))
                vga_print(old_name)
                vga_print(cast[ptr uint8](" -> "))
                vga_println(new_name)
                vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_println(cast[ptr uint8]("Destination already exists"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              vga_print(cast[ptr uint8]("Source not found: "))
              vga_println(old_name)
              vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_println(cast[ptr uint8]("Usage: mv <old_name> <new_name>"))
        else:
          vga_println(cast[ptr uint8]("Usage: mv <old_name> <new_name>"))
  elif cmd_buffer[0] == cast[uint8](116):  # 't'
    if cmd_buffer[1] == cast[uint8](111):  # 'o'
      if cmd_buffer[2] == cast[uint8](117):  # 'u'
        if cmd_buffer[3] == cast[uint8](99):  # 'c'
          if cmd_buffer[4] == cast[uint8](104):  # 'h'
            if cmd_buffer[5] == cast[uint8](32):  # ' '
              # touch filename
              var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
              if cast[int32](filename) != 0:
                # Create empty file
                var empty: ptr uint8 = cast[ptr uint8]("")
                var result: int32 = fs_create(filename, empty, 0)
                if result == 0:
                  vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                  vga_print(cast[ptr uint8]("Created: "))
                  vga_println(filename)
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                elif result == -1:
                  vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                  vga_println(cast[ptr uint8]("(file already exists)"))
                  vga_set_color(VGA_WHITE, VGA_BLACK)
                else:
                  vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                  vga_println(cast[ptr uint8]("Failed to create file"))
                  vga_set_color(VGA_WHITE, VGA_BLACK)
              else:
                vga_println(cast[ptr uint8]("Usage: touch <filename>"))
  elif cmd_buffer[0] == cast[uint8](120):  # 'x'
    if cmd_buffer[1] == cast[uint8](120):  # 'x'
      if cmd_buffer[2] == cast[uint8](100):  # 'd'
        if cmd_buffer[3] == cast[uint8](32):  # ' '
          # xxd filename - hexdump file
          var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
          if cast[int32](filename) != 0:
            var idx: int32 = fs_find(filename)
            if idx >= 0:
              var entry: ptr uint8 = fs_get_entry(idx)
              var fsize: int32 = fs_get_size(entry)
              var foffset: int32 = fs_get_offset(entry)
              # Limit to 128 bytes
              if fsize > 128:
                fsize = 128
                vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                vga_println(cast[ptr uint8]("(showing first 128 bytes)"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
              var row: int32 = 0
              while row * 16 < fsize:
                # Print offset
                vga_set_color(VGA_DARK_GREY, VGA_BLACK)
                var row_off: int32 = row * 16
                # Print as 4-digit hex
                var hi: int32 = (row_off >> 4) & 0xF
                var lo: int32 = row_off & 0xF
                if hi < 10:
                  vga_putchar(48 + hi)
                else:
                  vga_putchar(55 + hi)
                if lo < 10:
                  vga_putchar(48 + lo)
                else:
                  vga_putchar(55 + lo)
                vga_print(cast[ptr uint8](": "))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                # Print hex bytes
                var col: int32 = 0
                while col < 16:
                  if row * 16 + col < fsize:
                    var byte_val: int32 = cast[int32](ramdisk_data[foffset + row * 16 + col])
                    var bhi: int32 = (byte_val >> 4) & 0xF
                    var blo: int32 = byte_val & 0xF
                    if bhi < 10:
                      vga_putchar(48 + bhi)
                    else:
                      vga_putchar(55 + bhi)
                    if blo < 10:
                      vga_putchar(48 + blo)
                    else:
                      vga_putchar(55 + blo)
                  else:
                    vga_print(cast[ptr uint8]("  "))
                  vga_putchar(32)
                  col = col + 1
                # Print ASCII
                vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
                vga_print(cast[ptr uint8]("|"))
                col = 0
                while col < 16:
                  if row * 16 + col < fsize:
                    var ch: int32 = cast[int32](ramdisk_data[foffset + row * 16 + col])
                    if ch >= 32:
                      if ch < 127:
                        vga_putchar(ch)
                      else:
                        vga_putchar(46)
                    else:
                      vga_putchar(46)
                  col = col + 1
                vga_println(cast[ptr uint8]("|"))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                row = row + 1
            else:
              vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
              vga_print(cast[ptr uint8]("File not found: "))
              vga_println(filename)
              vga_set_color(VGA_WHITE, VGA_BLACK)
          else:
            vga_println(cast[ptr uint8]("Usage: xxd <filename>"))
  elif cmd_buffer[0] == cast[uint8](115):  # 's'
    if cmd_buffer[1] == cast[uint8](105):  # 'i'
      if cmd_buffer[2] == cast[uint8](122):  # 'z'
        if cmd_buffer[3] == cast[uint8](101):  # 'e'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # size filename
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](filename) != 0:
              var idx: int32 = fs_find(filename)
              if idx >= 0:
                var entry: ptr uint8 = fs_get_entry(idx)
                var fsize: int32 = fs_get_size(entry)
                vga_print_dec(fsize)
                vga_print(cast[ptr uint8](" "))
                vga_println(filename)
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_print(cast[ptr uint8]("File not found: "))
                vga_println(filename)
                vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_println(cast[ptr uint8]("Usage: size <filename>"))
    elif cmd_buffer[1] == cast[uint8](116):  # 't'
      if cmd_buffer[2] == cast[uint8](97):  # 'a'
        if cmd_buffer[3] == cast[uint8](116):  # 't'
          if cmd_buffer[4] == cast[uint8](32):  # ' '
            # stat filename
            var filename: ptr uint8 = find_arg(addr(cmd_buffer[0]), 1)
            if cast[int32](filename) != 0:
              var idx: int32 = fs_find(filename)
              if idx >= 0:
                var entry: ptr uint8 = fs_get_entry(idx)
                var fsize: int32 = fs_get_size(entry)
                var foffset: int32 = fs_get_offset(entry)
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                vga_print(cast[ptr uint8]("  File: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                vga_println(entry)
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                vga_print(cast[ptr uint8]("  Size: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                vga_print_dec(fsize)
                vga_println(cast[ptr uint8](" bytes"))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                vga_print(cast[ptr uint8]("  Offset: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                vga_print_hex(foffset)
                vga_println(cast[ptr uint8](""))
                vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
                vga_print(cast[ptr uint8]("  Index: "))
                vga_set_color(VGA_WHITE, VGA_BLACK)
                vga_print_dec(idx)
                vga_println(cast[ptr uint8](""))
              else:
                vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
                vga_print(cast[ptr uint8]("File not found: "))
                vga_println(filename)
                vga_set_color(VGA_WHITE, VGA_BLACK)
            else:
              vga_println(cast[ptr uint8]("Usage: stat <filename>"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("date")) == 1:
    # Show uptime-based fake time since we don't have RTC
    var ticks: int32 = get_tick_count()
    var total_secs: int32 = ticks / 18
    var hours: int32 = total_secs / 3600
    var mins: int32 = (total_secs - hours * 3600) / 60
    var secs: int32 = total_secs - hours * 3600 - mins * 60
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_print(cast[ptr uint8]("Uptime: "))
    if hours < 10:
      vga_putchar(48)  # '0'
    vga_print_dec(hours)
    vga_putchar(58)  # ':'
    if mins < 10:
      vga_putchar(48)
    vga_print_dec(mins)
    vga_putchar(58)  # ':'
    if secs < 10:
      vga_putchar(48)
    vga_print_dec(secs)
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    vga_println(cast[ptr uint8]("(No RTC - showing uptime as HH:MM:SS)"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("matrix")) == 1:
    # Matrix rain effect
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_clear()

    # Column drop positions (80 columns)
    var drops: array[80, int32]
    var speeds: array[80, int32]
    var chars: array[80, int32]

    # Initialize drops with random positions
    var col: int32 = 0
    while col < 80:
      var seed: int32 = get_tick_count() + col * 17
      seed = seed * 1103515245 + 12345
      drops[col] = (seed / 65536) & 0x1F  # 0-31
      seed = seed * 1103515245 + 12345
      speeds[col] = 1 + ((seed / 65536) & 0x03)  # 1-4
      seed = seed * 1103515245 + 12345
      chars[col] = 33 + ((seed / 65536) & 0x3F)  # Random ASCII
      col = col + 1

    # Run animation for ~200 frames
    var frame: int32 = 0
    while frame < 200:
      # Check for keypress to exit early
      if keyboard_available() > 0:
        var key: int32 = keyboard_read_char()
        if key > 0:
          frame = 200  # Exit loop

      col = 0
      while col < 80:
        # Update drop position
        var y: int32 = drops[col]

        # Draw the bright head
        if y >= 0:
          if y < 25:
            vga_set_color(VGA_WHITE, VGA_BLACK)
            vga_putchar_at(chars[col], col, y, vga_color)

        # Draw trail above
        if y > 0:
          if y - 1 < 25:
            vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
            var trail_char: int32 = chars[col] ^ 0x20
            vga_putchar_at(trail_char, col, y - 1, vga_color)

        # Fade old positions
        if y > 4:
          if y - 5 < 25:
            vga_set_color(VGA_GREEN, VGA_BLACK)
            vga_putchar_at(32, col, y - 5, vga_color)

        # Move drop down
        drops[col] = drops[col] + speeds[col]

        # Reset drop when it goes off screen
        if drops[col] > 30:
          var seed: int32 = get_tick_count() + col + frame
          seed = seed * 1103515245 + 12345
          drops[col] = 0 - ((seed / 65536) & 0x0F)  # Negative = delay
          seed = seed * 1103515245 + 12345
          chars[col] = 33 + ((seed / 65536) & 0x3F)
          seed = seed * 1103515245 + 12345
          speeds[col] = 1 + ((seed / 65536) & 0x03)

        # Change character occasionally
        if (frame + col) & 0x07 == 0:
          var seed: int32 = get_tick_count() + col
          seed = seed * 1103515245 + 12345
          chars[col] = 33 + ((seed / 65536) & 0x3F)

        col = col + 1

      # Small delay
      var delay: int32 = 0
      while delay < 50000:
        delay = delay + 1

      frame = frame + 1

    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_clear()
    vga_println(cast[ptr uint8]("Press any key to exit..."))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("sysinfo")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8]("=== System Information ==="))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_print(cast[ptr uint8]("OS:         "))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("BrainhairOS v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_print(cast[ptr uint8]("Arch:       "))
    vga_println(cast[ptr uint8]("x86-32 (i386)"))
    vga_print(cast[ptr uint8]("CPU Mode:   "))
    vga_println(cast[ptr uint8]("Protected mode"))
    vga_print(cast[ptr uint8]("Paging:     "))
    vga_println(cast[ptr uint8]("Enabled (16MB identity map)"))
    vga_print(cast[ptr uint8]("Kernel:     "))
    vga_print(cast[ptr uint8]("0x10000 - 0x"))
    # Show approximate kernel end
    vga_print(cast[ptr uint8]("14000"))
    vga_println(cast[ptr uint8](""))
    vga_print(cast[ptr uint8]("Stack:      "))
    vga_println(cast[ptr uint8]("0x90000"))
    var ticks: int32 = get_tick_count()
    var seconds: int32 = ticks / 18
    vga_print(cast[ptr uint8]("Uptime:     "))
    vga_print_dec(seconds)
    vga_println(cast[ptr uint8](" seconds"))
    vga_print(cast[ptr uint8]("Ticks:      "))
    vga_print_dec(ticks)
    vga_println(cast[ptr uint8](""))
    vga_print(cast[ptr uint8]("Max procs:  "))
    vga_println(cast[ptr uint8]("64"))
    vga_print(cast[ptr uint8]("Current PID:"))
    vga_print_dec(get_current_pid())
    vga_println(cast[ptr uint8](""))
    vga_println(cast[ptr uint8](""))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("about")) == 1:
    vga_set_color(VGA_LIGHT_CYAN, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_println(cast[ptr uint8]("BrainhairOS Microkernel v0.1"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
    vga_println(cast[ptr uint8]("A self-hosted operating system written in"))
    vga_println(cast[ptr uint8]("the Brainhair programming language."))
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("Kernel Features:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8]("  * x86-32 protected mode"))
    vga_println(cast[ptr uint8]("  * Paging with 16MB identity map"))
    vga_println(cast[ptr uint8]("  * Preemptive multitasking (64 processes)"))
    vga_println(cast[ptr uint8]("  * Synchronous IPC (send/recv/call/reply)"))
    vga_println(cast[ptr uint8]("  * PS/2 keyboard with IRQ"))
    vga_println(cast[ptr uint8]("  * VGA text mode (80x25, 16 colors)"))
    vga_println(cast[ptr uint8]("  * Ramdisk filesystem (8KB, 16 files)"))
    vga_println(cast[ptr uint8]("  * ELF32 program loader"))
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_LIGHT_GREEN, VGA_BLACK)
    vga_println(cast[ptr uint8]("Shell Features:"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8]("  * 45+ built-in commands"))
    vga_println(cast[ptr uint8]("  * File operations (ls, cat, cp, mv, rm...)"))
    vga_println(cast[ptr uint8]("  * Memory tools (peek, poke, dump, fill)"))
    vga_println(cast[ptr uint8]("  * Calculator with bitwise ops"))
    vga_println(cast[ptr uint8]("  * Process management (ps, run)"))
    vga_println(cast[ptr uint8]("  * Fun stuff (matrix, banner, guess)"))
    vga_println(cast[ptr uint8](""))
    vga_set_color(VGA_DARK_GREY, VGA_BLACK)
    vga_println(cast[ptr uint8]("Coded with love by Claude :)"))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(cast[ptr uint8](""))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("mem")) == 1:
    vga_println(cast[ptr uint8]("Memory Map:"))
    vga_println(cast[ptr uint8]("  Kernel: 0x10000 - 0x1FFFF (64KB)"))
    vga_println(cast[ptr uint8]("  Paging: 16MB identity mapped"))
    vga_println(cast[ptr uint8]("  Stack:  0x90000"))
  elif str_equals(addr(cmd_buffer[0]), cast[ptr uint8]("reboot")) == 1:
    vga_println(cast[ptr uint8]("Rebooting..."))
    # Triple fault to reboot
    disable_interrupts()
    # Write invalid value to IDTR
    # For now just halt
    halt()
  else:
    # Check for echo command
    if cmd_len >= 5:
      if cmd_buffer[0] == cast[uint8](101):  # 'e'
        if cmd_buffer[1] == cast[uint8](99):  # 'c'
          if cmd_buffer[2] == cast[uint8](104):  # 'h'
            if cmd_buffer[3] == cast[uint8](111):  # 'o'
              if cmd_buffer[4] == cast[uint8](32):  # ' '
                # Print everything after "echo "
                var i: int32 = 5
                while i < cmd_len:
                  vga_putchar(cast[int32](cmd_buffer[i]))
                  i = i + 1
                vga_println(cast[ptr uint8](""))
                return

    vga_set_color(VGA_LIGHT_RED, VGA_BLACK)
    vga_print(cast[ptr uint8]("Unknown command: "))
    vga_set_color(VGA_WHITE, VGA_BLACK)
    vga_println(addr(cmd_buffer[0]))

# Main shell loop
proc shell_main() =
  cmd_len = 0
  shell_prompt()

  while true:
    # Check for keyboard input
    var avail: int32 = keyboard_available()
    if avail > 0:
      var c: int32 = keyboard_read_char()

      if c == 13:  # Enter
        vga_println(cast[ptr uint8](""))
        shell_execute()
        cmd_len = 0
        shell_prompt()
      elif c == 8:  # Backspace
        if cmd_len > 0:
          cmd_len = cmd_len - 1
          # Move cursor back, print space, move back again
          vga_col = vga_col - 1
          vga_putchar(32)
          vga_col = vga_col - 1
      elif c >= 32:
        if cmd_len < 255:
          cmd_buffer[cmd_len] = cast[uint8](c)
          cmd_len = cmd_len + 1
          vga_putchar(c)

# ============================================================================
# Syscall wrappers (int 0x42)
# ============================================================================

# Syscall numbers
const SYS_EXIT: int32 = 1
const SYS_GETPID: int32 = 5
const SYS_YIELD: int32 = 6
const SYS_SEND: int32 = 20
const SYS_RECV: int32 = 21
const SYS_CALL: int32 = 22
const SYS_REPLY: int32 = 23

# Low-level syscall (in assembly)
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32

# IPC syscall wrappers
proc sys_send(dest: int32, msg: ptr uint8): int32 =
  return syscall2(SYS_SEND, dest, cast[int32](msg))

proc sys_recv(from_pid: int32, buf: ptr uint8): int32 =
  return syscall2(SYS_RECV, from_pid, cast[int32](buf))

# Process syscall numbers
const SYS_SPAWN: int32 = 40
const SYS_WAIT: int32 = 41

# Low-level syscall with 1 argument
extern proc syscall1(num: int32, arg1: int32): int32

# Process syscall wrappers
proc sys_spawn(entry: int32): int32 =
  return syscall1(SYS_SPAWN, entry)

proc sys_wait(): int32 =
  return syscall1(SYS_WAIT, 0)
