#!/usr/bin/env python3
"""
poocc - PooScript to C Compiler (Prototype)

Takes PooScript source and generates C code that can be compiled to native binary.

Example usage:
    python3 poocc_prototype.py /bin/ls > ls.c
    gcc ls.c -o ls -lpoo
    ./ls
"""

import sys
import os
from core.pooscript import PooScriptInterpreter

class PooScriptCompiler:
    """Compile PooScript to C"""

    def __init__(self):
        self.output = []
        self.includes = set()
        self.functions = []
        self.in_function = False

    def add_include(self, header):
        """Add C header include"""
        self.includes.add(header)

    def emit(self, code):
        """Emit C code"""
        self.output.append(code)

    def compile_command(self, cmd):
        """
        Compile a PooScript command to C

        PooScript: echo "Hello"
        C: poo_echo("Hello");
        """
        if not cmd.strip():
            return

        # Simple command translation
        parts = cmd.split()
        if not parts:
            return

        command = parts[0]

        # Built-in commands
        if command == 'echo':
            # echo "string" → poo_echo("string")
            args = ' '.join(parts[1:])
            if args.startswith('"') and args.endswith('"'):
                self.emit(f'    poo_echo({args});')
            else:
                self.emit(f'    poo_echo("{args}");')
            self.add_include('poo_runtime.h')

        elif command == 'cd':
            # cd /path → poo_cd("/path")
            path = parts[1] if len(parts) > 1 else '/'
            self.emit(f'    poo_cd("{path}");')
            self.add_include('poo_runtime.h')

        elif command == 'pwd':
            # pwd → poo_pwd()
            self.emit(f'    poo_pwd();')
            self.add_include('poo_runtime.h')

        elif command == 'exit':
            # exit 0 → poo_exit(0)
            code = parts[1] if len(parts) > 1 else '0'
            self.emit(f'    poo_exit({code});')
            self.add_include('poo_runtime.h')

        elif command.startswith('/') or command.startswith('./'):
            # Absolute or relative path - exec it
            args = ', '.join([f'"{arg}"' for arg in parts])
            self.emit(f'    char* args[] = {{{args}, NULL}};')
            self.emit(f'    poo_exec("{command}", args);')
            self.add_include('poo_runtime.h')

        else:
            # External command - look up in PATH
            args = ', '.join([f'"{arg}"' for arg in parts])
            self.emit(f'    char* args[] = {{{args}, NULL}};')
            self.emit(f'    poo_exec_path("{command}", args);')
            self.add_include('poo_runtime.h')

    def compile_script(self, script):
        """Compile entire PooScript to C"""
        # Header
        self.emit('/*')
        self.emit(' * Generated by poocc - PooScript Compiler')
        self.emit(' * DO NOT EDIT - Modify the .poo source instead')
        self.emit(' */')
        self.emit('')

        # Parse script line by line
        lines = script.strip().split('\n')

        # Skip shebang
        if lines and lines[0].startswith('#!'):
            lines = lines[1:]

        # Analyze script
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                self.compile_command(line)

        # Generate final C code
        c_code = []

        # Includes
        for inc in sorted(self.includes):
            c_code.append(f'#include "{inc}"')
        c_code.append('')

        # Main function
        c_code.append('int main(int argc, char** argv) {')
        c_code.extend(self.output)
        c_code.append('    return 0;')
        c_code.append('}')

        return '\n'.join(c_code)


def generate_runtime_header():
    """Generate the poo_runtime.h header file"""
    return '''/*
 * poo_runtime.h - PooScript Runtime Library
 *
 * This header defines the runtime functions that compiled PooScript
 * programs link against.
 */

#ifndef POO_RUNTIME_H
#define POO_RUNTIME_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

/* Built-in commands */
void poo_echo(const char* str);
void poo_cd(const char* path);
void poo_pwd(void);
void poo_exit(int code);

/* Process execution */
int poo_exec(const char* path, char** argv);
int poo_exec_path(const char* command, char** argv);

/* I/O operations */
int poo_cat(const char* filename);
int poo_ls(const char* path);

#endif /* POO_RUNTIME_H */
'''


def generate_runtime_impl():
    """Generate the poo_runtime.c implementation"""
    return '''/*
 * poo_runtime.c - PooScript Runtime Library Implementation
 */

#include "poo_runtime.h"

void poo_echo(const char* str) {
    printf("%s\\n", str);
}

void poo_cd(const char* path) {
    if (chdir(path) != 0) {
        perror("cd");
    }
}

void poo_pwd(void) {
    char cwd[4096];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("%s\\n", cwd);
    } else {
        perror("pwd");
    }
}

void poo_exit(int code) {
    exit(code);
}

int poo_exec(const char* path, char** argv) {
    pid_t pid = fork();
    if (pid == 0) {
        // Child process
        execv(path, argv);
        perror("exec");
        exit(1);
    } else if (pid > 0) {
        // Parent process
        int status;
        waitpid(pid, &status, 0);
        return WEXITSTATUS(status);
    } else {
        perror("fork");
        return -1;
    }
}

int poo_exec_path(const char* command, char** argv) {
    // Try common paths
    const char* paths[] = {
        "/bin/",
        "/usr/bin/",
        "/sbin/",
        "/usr/sbin/",
        NULL
    };

    for (int i = 0; paths[i]; i++) {
        char full_path[4096];
        snprintf(full_path, sizeof(full_path), "%s%s", paths[i], command);

        if (access(full_path, X_OK) == 0) {
            return poo_exec(full_path, argv);
        }
    }

    fprintf(stderr, "%s: command not found\\n", command);
    return 127;
}

int poo_cat(const char* filename) {
    FILE* f = fopen(filename, "r");
    if (!f) {
        perror(filename);
        return 1;
    }

    char buf[4096];
    while (fgets(buf, sizeof(buf), f)) {
        printf("%s", buf);
    }

    fclose(f);
    return 0;
}

int poo_ls(const char* path) {
    // Simple ls implementation
    // In real OS, this would call into VFS
    char cmd[4096];
    snprintf(cmd, sizeof(cmd), "/bin/ls %s", path);
    return system(cmd);
}
'''


def main():
    if len(sys.argv) < 2:
        print("Usage: poocc <script.poo>")
        print("")
        print("Compiles PooScript to C")
        print("")
        print("Example:")
        print("  poocc hello.poo > hello.c")
        print("  gcc hello.c poo_runtime.c -o hello")
        print("  ./hello")
        sys.exit(1)

    script_path = sys.argv[1]

    # Read script
    try:
        with open(script_path, 'r') as f:
            script = f.read()
    except FileNotFoundError:
        print(f"Error: {script_path} not found", file=sys.stderr)
        sys.exit(1)

    # Compile
    compiler = PooScriptCompiler()
    c_code = compiler.compile_script(script)

    # Output C code
    print(c_code)

    # Also generate runtime files if they don't exist
    if not os.path.exists('poo_runtime.h'):
        with open('poo_runtime.h', 'w') as f:
            f.write(generate_runtime_header())
        print("Generated poo_runtime.h", file=sys.stderr)

    if not os.path.exists('poo_runtime.c'):
        with open('poo_runtime.c', 'w') as f:
            f.write(generate_runtime_impl())
        print("Generated poo_runtime.c", file=sys.stderr)


if __name__ == '__main__':
    main()
