# Token Definitions for Brainhair Self-Hosted Compiler
#
# This module defines all token types used by the lexer and parser.
# Token values are simple integers for efficiency.

# ============================================================================
# Token Type Constants
# ============================================================================

# Literals
const TOK_EOF: int32 = 0
const TOK_IDENT: int32 = 1
const TOK_INT_LIT: int32 = 2
const TOK_STRING_LIT: int32 = 3
const TOK_CHAR_LIT: int32 = 4

# Keywords - Types
const TOK_INT8: int32 = 10
const TOK_INT16: int32 = 11
const TOK_INT32: int32 = 12
const TOK_UINT8: int32 = 13
const TOK_UINT16: int32 = 14
const TOK_UINT32: int32 = 15
const TOK_BOOL: int32 = 16
const TOK_CHAR: int32 = 17
const TOK_PTR: int32 = 18
const TOK_ARRAY: int32 = 19

# Keywords - Control
const TOK_IF: int32 = 20
const TOK_ELIF: int32 = 21
const TOK_ELSE: int32 = 22
const TOK_WHILE: int32 = 23
const TOK_FOR: int32 = 24
const TOK_BREAK: int32 = 25
const TOK_CONTINUE: int32 = 26
const TOK_RETURN: int32 = 27

# Keywords - Declarations
const TOK_PROC: int32 = 30
const TOK_VAR: int32 = 31
const TOK_CONST: int32 = 32
const TOK_TYPE: int32 = 33
const TOK_EXTERN: int32 = 34

# Keywords - Values
const TOK_TRUE: int32 = 40
const TOK_FALSE: int32 = 41
const TOK_NIL: int32 = 42

# Keywords - Operators
const TOK_AND: int32 = 50
const TOK_OR: int32 = 51
const TOK_NOT: int32 = 52
const TOK_DIV: int32 = 53
const TOK_MOD: int32 = 54

# Keywords - Special
const TOK_CAST: int32 = 60
const TOK_ADDR: int32 = 61
const TOK_DISCARD: int32 = 62
const TOK_OBJECT: int32 = 63

# Operators - Arithmetic
const TOK_PLUS: int32 = 70
const TOK_MINUS: int32 = 71
const TOK_STAR: int32 = 72
const TOK_SLASH: int32 = 73
const TOK_PERCENT: int32 = 74

# Operators - Comparison
const TOK_EQ: int32 = 80
const TOK_NE: int32 = 81
const TOK_LT: int32 = 82
const TOK_LE: int32 = 83
const TOK_GT: int32 = 84
const TOK_GE: int32 = 85

# Operators - Bitwise
const TOK_AMPERSAND: int32 = 90
const TOK_PIPE: int32 = 91
const TOK_CARET: int32 = 92
const TOK_TILDE: int32 = 93
const TOK_SHL: int32 = 94
const TOK_SHR: int32 = 95

# Operators - Assignment
const TOK_ASSIGN: int32 = 100

# Delimiters
const TOK_LPAREN: int32 = 110
const TOK_RPAREN: int32 = 111
const TOK_LBRACKET: int32 = 112
const TOK_RBRACKET: int32 = 113
const TOK_LBRACE: int32 = 114
const TOK_RBRACE: int32 = 115
const TOK_COMMA: int32 = 116
const TOK_COLON: int32 = 117
const TOK_DOT: int32 = 118
const TOK_NEWLINE: int32 = 119

# ============================================================================
# Token Structure
# Structure layout (20 bytes):
#   type: int32      - Token type constant (offset 0)
#   line: int32      - Line number (offset 4)
#   col: int32       - Column number (offset 8)
#   value: int32     - Integer value for INT_LIT (offset 12)
#   str_ptr: int32   - Pointer to string for IDENT/STRING_LIT (offset 16)
# ============================================================================

const TOKEN_TYPE_OFFSET: int32 = 0
const TOKEN_LINE_OFFSET: int32 = 4
const TOKEN_COL_OFFSET: int32 = 8
const TOKEN_VALUE_OFFSET: int32 = 12
const TOKEN_STR_OFFSET: int32 = 16
const TOKEN_SIZE: int32 = 20

# Get token type
proc token_type(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[0]

# Set token type
proc token_set_type(tok: ptr uint8, typ: int32) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[0] = typ

# Get token line
proc token_line(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[1]

# Set token line
proc token_set_line(tok: ptr uint8, line: int32) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[1] = line

# Get token column
proc token_col(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[2]

# Set token column
proc token_set_col(tok: ptr uint8, col: int32) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[2] = col

# Get token integer value
proc token_value(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[3]

# Set token integer value
proc token_set_value(tok: ptr uint8, value: int32) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[3] = value

# Get token string pointer
proc token_str(tok: ptr uint8): ptr uint8 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return cast[ptr uint8](t32[4])

# Set token string pointer
proc token_set_str(tok: ptr uint8, str: ptr uint8) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[4] = cast[int32](str)

# Initialize a token
proc token_init(tok: ptr uint8, typ: int32, line: int32, col: int32) =
    var t32: ptr int32 = cast[ptr int32](tok)
    t32[0] = typ
    t32[1] = line
    t32[2] = col
    t32[3] = 0
    t32[4] = 0

# ============================================================================
# Keyword Lookup
# ============================================================================

# Helper: compare two strings
proc str_eq(s1: ptr uint8, s2: ptr uint8): bool =
    var i: int32 = 0
    while true:
        if s1[i] != s2[i]:
            return false
        if s1[i] == 0:
            return true
        i = i + 1
    return false

# Lookup keyword by name, returns token type or TOK_IDENT if not a keyword
proc lookup_keyword(name: ptr uint8): int32 =
    # Type keywords
    if str_eq(name, cast[ptr uint8]("int8")):
        return TOK_INT8
    if str_eq(name, cast[ptr uint8]("int16")):
        return TOK_INT16
    if str_eq(name, cast[ptr uint8]("int32")):
        return TOK_INT32
    if str_eq(name, cast[ptr uint8]("uint8")):
        return TOK_UINT8
    if str_eq(name, cast[ptr uint8]("uint16")):
        return TOK_UINT16
    if str_eq(name, cast[ptr uint8]("uint32")):
        return TOK_UINT32
    if str_eq(name, cast[ptr uint8]("bool")):
        return TOK_BOOL
    if str_eq(name, cast[ptr uint8]("char")):
        return TOK_CHAR
    if str_eq(name, cast[ptr uint8]("ptr")):
        return TOK_PTR
    if str_eq(name, cast[ptr uint8]("array")):
        return TOK_ARRAY

    # Control keywords
    if str_eq(name, cast[ptr uint8]("if")):
        return TOK_IF
    if str_eq(name, cast[ptr uint8]("elif")):
        return TOK_ELIF
    if str_eq(name, cast[ptr uint8]("else")):
        return TOK_ELSE
    if str_eq(name, cast[ptr uint8]("while")):
        return TOK_WHILE
    if str_eq(name, cast[ptr uint8]("for")):
        return TOK_FOR
    if str_eq(name, cast[ptr uint8]("break")):
        return TOK_BREAK
    if str_eq(name, cast[ptr uint8]("continue")):
        return TOK_CONTINUE
    if str_eq(name, cast[ptr uint8]("return")):
        return TOK_RETURN

    # Declaration keywords
    if str_eq(name, cast[ptr uint8]("proc")):
        return TOK_PROC
    if str_eq(name, cast[ptr uint8]("var")):
        return TOK_VAR
    if str_eq(name, cast[ptr uint8]("const")):
        return TOK_CONST
    if str_eq(name, cast[ptr uint8]("type")):
        return TOK_TYPE
    if str_eq(name, cast[ptr uint8]("extern")):
        return TOK_EXTERN

    # Value keywords
    if str_eq(name, cast[ptr uint8]("true")):
        return TOK_TRUE
    if str_eq(name, cast[ptr uint8]("false")):
        return TOK_FALSE
    if str_eq(name, cast[ptr uint8]("nil")):
        return TOK_NIL

    # Operator keywords
    if str_eq(name, cast[ptr uint8]("and")):
        return TOK_AND
    if str_eq(name, cast[ptr uint8]("or")):
        return TOK_OR
    if str_eq(name, cast[ptr uint8]("not")):
        return TOK_NOT
    if str_eq(name, cast[ptr uint8]("div")):
        return TOK_DIV
    if str_eq(name, cast[ptr uint8]("mod")):
        return TOK_MOD

    # Special keywords
    if str_eq(name, cast[ptr uint8]("cast")):
        return TOK_CAST
    if str_eq(name, cast[ptr uint8]("addr")):
        return TOK_ADDR
    if str_eq(name, cast[ptr uint8]("discard")):
        return TOK_DISCARD
    if str_eq(name, cast[ptr uint8]("object")):
        return TOK_OBJECT

    # Not a keyword
    return TOK_IDENT

# Get token type name for debugging
proc token_type_name(typ: int32): ptr uint8 =
    if typ == TOK_EOF:
        return cast[ptr uint8]("EOF")
    if typ == TOK_IDENT:
        return cast[ptr uint8]("IDENT")
    if typ == TOK_INT_LIT:
        return cast[ptr uint8]("INT_LIT")
    if typ == TOK_STRING_LIT:
        return cast[ptr uint8]("STRING_LIT")
    if typ == TOK_CHAR_LIT:
        return cast[ptr uint8]("CHAR_LIT")
    if typ == TOK_INT32:
        return cast[ptr uint8]("int32")
    if typ == TOK_PROC:
        return cast[ptr uint8]("proc")
    if typ == TOK_VAR:
        return cast[ptr uint8]("var")
    if typ == TOK_RETURN:
        return cast[ptr uint8]("return")
    if typ == TOK_IF:
        return cast[ptr uint8]("if")
    if typ == TOK_WHILE:
        return cast[ptr uint8]("while")
    if typ == TOK_PLUS:
        return cast[ptr uint8]("+")
    if typ == TOK_MINUS:
        return cast[ptr uint8]("-")
    if typ == TOK_STAR:
        return cast[ptr uint8]("*")
    if typ == TOK_EQ:
        return cast[ptr uint8]("==")
    if typ == TOK_ASSIGN:
        return cast[ptr uint8]("=")
    if typ == TOK_LPAREN:
        return cast[ptr uint8]("(")
    if typ == TOK_RPAREN:
        return cast[ptr uint8](")")
    if typ == TOK_LBRACKET:
        return cast[ptr uint8]("[")
    if typ == TOK_RBRACKET:
        return cast[ptr uint8]("]")
    if typ == TOK_COLON:
        return cast[ptr uint8](":")
    if typ == TOK_COMMA:
        return cast[ptr uint8](",")
    if typ == TOK_NEWLINE:
        return cast[ptr uint8]("NEWLINE")
    return cast[ptr uint8]("UNKNOWN")
