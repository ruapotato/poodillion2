# Brainhair Self-Hosted Compiler - Main Entry Point
#
# This is the entry point for the self-hosted Brainhair compiler.
# It reads a source file, parses it, and generates x86 assembly.
#
# Usage:
#   bhc source.bh -o output.asm
#
# Once this compiler is functional, it can compile itself!

# System calls
const SYS_exit: int32 = 1
const SYS_read: int32 = 3
const SYS_write: int32 = 4
const SYS_open: int32 = 5
const SYS_close: int32 = 6
const SYS_lseek: int32 = 19

const STDIN: int32 = 0
const STDOUT: int32 = 1
const STDERR: int32 = 2

const O_RDONLY: int32 = 0
const O_WRONLY: int32 = 1
const O_CREAT: int32 = 64
const O_TRUNC: int32 = 512

const SEEK_SET: int32 = 0
const SEEK_END: int32 = 2

const FILE_MODE: int32 = 420  # 0644

extern proc syscall1(num: int32, arg1: int32): int32
extern proc syscall2(num: int32, arg1: int32, arg2: int32): int32
extern proc syscall3(num: int32, arg1: int32, arg2: int32, arg3: int32): int32

# Argument access
extern proc get_argc(): int32
extern proc get_argv(index: int32): ptr uint8

# External compiler functions
extern proc lexer_init(lex: ptr uint8, source: ptr uint8, length: int32)
extern proc lexer_next(lex: ptr uint8, tok: ptr uint8)
extern proc parser_init(p: ptr uint8, source: ptr uint8, length: int32)
extern proc parse_program(p: ptr uint8): ptr uint8
extern proc codegen_init(cg: ptr uint8)
extern proc codegen_generate(cg: ptr uint8, ast: ptr uint8)
extern proc codegen_get_output(cg: ptr uint8): ptr uint8
extern proc codegen_get_length(cg: ptr uint8): int32

# Memory allocation
const SYS_mmap: int32 = 90
const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_PRIVATE: int32 = 2
const MAP_ANONYMOUS: int32 = 32

proc mmap_alloc(size: int32): ptr uint8 =
    var mem: int32 = syscall3(SYS_mmap, 0, size) | (PROT_READ | PROT_WRITE) << 16 | (MAP_PRIVATE | MAP_ANONYMOUS) << 24
    # Simplified - full implementation would use syscall6
    return cast[ptr uint8](0)

# Structure sizes
const LEXER_SIZE: int32 = 24
const PARSER_SIZE: int32 = 28
const CODEGEN_SIZE: int32 = 32

# ============================================================================
# Helper Functions
# ============================================================================

proc print_str(s: ptr uint8) =
    var len: int32 = 0
    while s[len] != 0:
        len = len + 1
    discard syscall3(SYS_write, STDOUT, cast[int32](s), len)

proc print_line(s: ptr uint8) =
    print_str(s)
    var newline: uint8 = 10
    discard syscall3(SYS_write, STDOUT, cast[int32](addr(newline)), 1)

proc error_exit(msg: ptr uint8, code: int32) =
    discard syscall3(SYS_write, STDERR, cast[int32](msg), 0)
    # Calculate length
    var len: int32 = 0
    while msg[len] != 0:
        len = len + 1
    discard syscall3(SYS_write, STDERR, cast[int32](msg), len)
    var newline: uint8 = 10
    discard syscall3(SYS_write, STDERR, cast[int32](addr(newline)), 1)
    discard syscall1(SYS_exit, code)

proc str_eq(s1: ptr uint8, s2: ptr uint8): bool =
    var i: int32 = 0
    while true:
        if s1[i] != s2[i]:
            return false
        if s1[i] == 0:
            return true
        i = i + 1
    return false

# ============================================================================
# File I/O
# ============================================================================

proc read_file(path: ptr uint8, out_size: ptr int32): ptr uint8 =
    # Open file
    var fd: int32 = syscall3(SYS_open, cast[int32](path), O_RDONLY, 0)
    if fd < 0:
        return cast[ptr uint8](0)

    # Get file size
    var size: int32 = syscall3(SYS_lseek, fd, 0, SEEK_END)
    if size < 0:
        discard syscall1(SYS_close, fd)
        return cast[ptr uint8](0)

    # Seek back to start
    discard syscall3(SYS_lseek, fd, 0, SEEK_SET)

    # Allocate buffer (simplified - would need mmap)
    # For now, use a static buffer
    # In a real implementation, we'd use mmap here
    out_size[0] = 0
    discard syscall1(SYS_close, fd)
    return cast[ptr uint8](0)

proc write_file(path: ptr uint8, data: ptr uint8, size: int32): int32 =
    var fd: int32 = syscall3(SYS_open, cast[int32](path), O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE)
    if fd < 0:
        return fd

    var written: int32 = 0
    while written < size:
        var result: int32 = syscall3(SYS_write, fd, cast[int32](data) + written, size - written)
        if result <= 0:
            discard syscall1(SYS_close, fd)
            return result
        written = written + result

    discard syscall1(SYS_close, fd)
    return written

# ============================================================================
# Main Function
# ============================================================================

proc main(): int32 =
    var argc: int32 = get_argc()

    # Print banner
    print_line(cast[ptr uint8]("Brainhair Self-Hosted Compiler v0.1"))

    # Check arguments
    if argc < 2:
        print_line(cast[ptr uint8]("Usage: bhc <source.bh> [-o output.asm]"))
        print_line(cast[ptr uint8](""))
        print_line(cast[ptr uint8]("Options:"))
        print_line(cast[ptr uint8]("  -o <file>  Output file (default: source.asm)"))
        return 1

    # Get source file
    var source_file: ptr uint8 = get_argv(1)
    var output_file: ptr uint8 = cast[ptr uint8]("output.asm")

    # Parse arguments
    var i: int32 = 2
    while i < argc:
        var arg: ptr uint8 = get_argv(i)
        if str_eq(arg, cast[ptr uint8]("-o")):
            if i + 1 < argc:
                output_file = get_argv(i + 1)
                i = i + 2
            else:
                error_exit(cast[ptr uint8]("Error: -o requires an argument"), 1)
        else:
            i = i + 1

    print_str(cast[ptr uint8]("Compiling: "))
    print_line(source_file)

    # Read source file
    print_str(cast[ptr uint8]("  Reading source..."))

    # Note: File reading not fully implemented yet
    # This is a placeholder for the full implementation
    print_line(cast[ptr uint8](" (not yet implemented)"))

    print_line(cast[ptr uint8](""))
    print_line(cast[ptr uint8]("Note: This is a bootstrap compiler framework."))
    print_line(cast[ptr uint8]("Full file I/O requires the standard library."))
    print_line(cast[ptr uint8](""))
    print_line(cast[ptr uint8]("Compiler structure:"))
    print_line(cast[ptr uint8]("  - tokens.bh:  Token definitions"))
    print_line(cast[ptr uint8]("  - ast.bh:     AST node definitions"))
    print_line(cast[ptr uint8]("  - lexer.bh:   Lexical analysis"))
    print_line(cast[ptr uint8]("  - parser.bh:  Recursive descent parser"))
    print_line(cast[ptr uint8]("  - codegen.bh: x86 code generation"))
    print_line(cast[ptr uint8]("  - main.bh:    Compiler driver"))

    return 0
