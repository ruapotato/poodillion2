# Code Generator for Brainhair Self-Hosted Compiler
#
# Generates x86 assembly from AST nodes.
# Output is written to a string buffer.

# ============================================================================
# Code Generator State
# Layout (32 bytes):
#   output: ptr     - Output buffer (offset 0)
#   out_pos: int32  - Current position in output (offset 4)
#   out_cap: int32  - Output buffer capacity (offset 8)
#   label_count: i32- Counter for generating unique labels (offset 12)
#   data_section: p - Data section buffer (offset 16)
#   data_pos: int32 - Position in data section (offset 20)
#   data_cap: int32 - Data section capacity (offset 24)
#   string_count: i32 - Counter for string labels (offset 28)
# ============================================================================

const CODEGEN_OUTPUT_OFFSET: int32 = 0
const CODEGEN_OUT_POS_OFFSET: int32 = 4
const CODEGEN_OUT_CAP_OFFSET: int32 = 8
const CODEGEN_LABEL_COUNT_OFFSET: int32 = 12
const CODEGEN_DATA_OFFSET: int32 = 16
const CODEGEN_DATA_POS_OFFSET: int32 = 20
const CODEGEN_DATA_CAP_OFFSET: int32 = 24
const CODEGEN_STRING_COUNT_OFFSET: int32 = 28
const CODEGEN_SIZE: int32 = 32

const OUTPUT_BUFFER_SIZE: int32 = 65536   # 64KB
const DATA_BUFFER_SIZE: int32 = 16384     # 16KB

# AST Node types (from ast.bh)
const AST_PROGRAM: int32 = 1
const AST_PROC_DECL: int32 = 2
const AST_VAR_DECL: int32 = 3
const AST_CONST_DECL: int32 = 4
const AST_BLOCK: int32 = 10
const AST_IF_STMT: int32 = 11
const AST_WHILE_STMT: int32 = 12
const AST_RETURN_STMT: int32 = 13
const AST_ASSIGN_STMT: int32 = 14
const AST_EXPR_STMT: int32 = 15
const AST_DISCARD_STMT: int32 = 18
const AST_INT_LIT: int32 = 20
const AST_STRING_LIT: int32 = 21
const AST_BOOL_LIT: int32 = 23
const AST_IDENT: int32 = 24
const AST_BINARY_OP: int32 = 25
const AST_UNARY_OP: int32 = 26
const AST_CALL: int32 = 27
const AST_INDEX: int32 = 28
const AST_CAST: int32 = 30
const AST_ADDR: int32 = 31

# Binary operators
const OP_ADD: int32 = 1
const OP_SUB: int32 = 2
const OP_MUL: int32 = 3
const OP_DIV: int32 = 4
const OP_MOD: int32 = 5
const OP_EQ: int32 = 6
const OP_NE: int32 = 7
const OP_LT: int32 = 8
const OP_LE: int32 = 9
const OP_GT: int32 = 10
const OP_GE: int32 = 11
const OP_AND: int32 = 12
const OP_OR: int32 = 13
const OP_BIT_AND: int32 = 14
const OP_BIT_OR: int32 = 15
const OP_BIT_XOR: int32 = 16
const OP_SHL: int32 = 17
const OP_SHR: int32 = 18

# Unary operators
const UOP_NEG: int32 = 1
const UOP_NOT: int32 = 2

# Memory allocation
const SYS_mmap: int32 = 90
const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_PRIVATE: int32 = 2
const MAP_ANONYMOUS: int32 = 32

extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

proc codegen_mmap(size: int32): ptr uint8 =
    var mem: int32 = syscall6(SYS_mmap, 0, size,
                              PROT_READ | PROT_WRITE,
                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    if mem < 0:
        return cast[ptr uint8](0)
    return cast[ptr uint8](mem)

# ============================================================================
# Code Generator Helpers
# ============================================================================

proc codegen_output(cg: ptr uint8): ptr uint8 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return cast[ptr uint8](c32[0])

proc codegen_out_pos(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return c32[1]

proc codegen_set_out_pos(cg: ptr uint8, pos: int32) =
    var c32: ptr int32 = cast[ptr int32](cg)
    c32[1] = pos

proc codegen_label_count(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return c32[3]

proc codegen_inc_label(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    var count: int32 = c32[3]
    c32[3] = count + 1
    return count

proc codegen_data(cg: ptr uint8): ptr uint8 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return cast[ptr uint8](c32[4])

proc codegen_data_pos(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return c32[5]

proc codegen_set_data_pos(cg: ptr uint8, pos: int32) =
    var c32: ptr int32 = cast[ptr int32](cg)
    c32[5] = pos

proc codegen_string_count(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    return c32[7]

proc codegen_inc_string(cg: ptr uint8): int32 =
    var c32: ptr int32 = cast[ptr int32](cg)
    var count: int32 = c32[7]
    c32[7] = count + 1
    return count

# ============================================================================
# Output Writing
# ============================================================================

proc codegen_emit_char(cg: ptr uint8, c: uint8) =
    var output: ptr uint8 = codegen_output(cg)
    var pos: int32 = codegen_out_pos(cg)
    var c32: ptr int32 = cast[ptr int32](cg)
    var cap: int32 = c32[2]

    if pos < cap:
        output[pos] = c
        codegen_set_out_pos(cg, pos + 1)

proc codegen_emit_str(cg: ptr uint8, s: ptr uint8) =
    var i: int32 = 0
    while s[i] != 0:
        codegen_emit_char(cg, s[i])
        i = i + 1

proc codegen_emit_int(cg: ptr uint8, n: int32) =
    var num: int32 = n
    var negative: int32 = 0

    if num < 0:
        negative = 1
        num = 0 - num

    if num == 0:
        codegen_emit_char(cg, 48)  # '0'
        return

    # Reverse digits
    var reversed: int32 = 0
    var digits: int32 = 0
    while num > 0:
        reversed = reversed * 10 + (num % 10)
        num = num / 10
        digits = digits + 1

    if negative == 1:
        codegen_emit_char(cg, 45)  # '-'

    while digits > 0:
        codegen_emit_char(cg, cast[uint8](48 + (reversed % 10)))
        reversed = reversed / 10
        digits = digits - 1

proc codegen_emit_line(cg: ptr uint8, s: ptr uint8) =
    codegen_emit_str(cg, s)
    codegen_emit_char(cg, 10)

# ============================================================================
# Code Generator Initialization
# ============================================================================

proc codegen_init(cg: ptr uint8) =
    var c32: ptr int32 = cast[ptr int32](cg)

    # Allocate output buffer
    var output: ptr uint8 = codegen_mmap(OUTPUT_BUFFER_SIZE)
    var data: ptr uint8 = codegen_mmap(DATA_BUFFER_SIZE)

    c32[0] = cast[int32](output)
    c32[1] = 0                    # out_pos
    c32[2] = OUTPUT_BUFFER_SIZE   # out_cap
    c32[3] = 0                    # label_count
    c32[4] = cast[int32](data)
    c32[5] = 0                    # data_pos
    c32[6] = DATA_BUFFER_SIZE     # data_cap
    c32[7] = 0                    # string_count

# ============================================================================
# AST Node Access
# ============================================================================

proc ast_type(node: ptr uint8): int32 =
    var n32: ptr int32 = cast[ptr int32](node)
    return n32[0]

# ============================================================================
# Expression Code Generation
# ============================================================================

proc codegen_expr(cg: ptr uint8, node: ptr uint8) =
    if cast[int32](node) == 0:
        return

    var typ: int32 = ast_type(node)
    var n32: ptr int32 = cast[ptr int32](node)

    # Integer literal
    if typ == AST_INT_LIT:
        var value: int32 = n32[3]
        codegen_emit_str(cg, cast[ptr uint8]("    mov eax, "))
        codegen_emit_int(cg, value)
        codegen_emit_char(cg, 10)
        return

    # Boolean literal
    if typ == AST_BOOL_LIT:
        var value: int32 = n32[3]
        codegen_emit_str(cg, cast[ptr uint8]("    mov eax, "))
        codegen_emit_int(cg, value)
        codegen_emit_char(cg, 10)
        return

    # Identifier (variable reference)
    if typ == AST_IDENT:
        var name: ptr uint8 = cast[ptr uint8](n32[3])
        codegen_emit_str(cg, cast[ptr uint8]("    mov eax, ["))
        codegen_emit_str(cg, name)
        codegen_emit_line(cg, cast[ptr uint8]("]"))
        return

    # Binary operation
    if typ == AST_BINARY_OP:
        var op: int32 = n32[3]
        var left: ptr uint8 = cast[ptr uint8](n32[4])
        var right: ptr uint8 = cast[ptr uint8](n32[5])

        # Evaluate right first, push result
        codegen_expr(cg, right)
        codegen_emit_line(cg, cast[ptr uint8]("    push eax"))

        # Evaluate left
        codegen_expr(cg, left)

        # Pop right into ecx
        codegen_emit_line(cg, cast[ptr uint8]("    pop ecx"))

        # Apply operator
        if op == OP_ADD:
            codegen_emit_line(cg, cast[ptr uint8]("    add eax, ecx"))
        elif op == OP_SUB:
            codegen_emit_line(cg, cast[ptr uint8]("    sub eax, ecx"))
        elif op == OP_MUL:
            codegen_emit_line(cg, cast[ptr uint8]("    imul eax, ecx"))
        elif op == OP_DIV:
            codegen_emit_line(cg, cast[ptr uint8]("    cdq"))
            codegen_emit_line(cg, cast[ptr uint8]("    idiv ecx"))
        elif op == OP_MOD:
            codegen_emit_line(cg, cast[ptr uint8]("    cdq"))
            codegen_emit_line(cg, cast[ptr uint8]("    idiv ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    mov eax, edx"))
        elif op == OP_BIT_AND:
            codegen_emit_line(cg, cast[ptr uint8]("    and eax, ecx"))
        elif op == OP_BIT_OR:
            codegen_emit_line(cg, cast[ptr uint8]("    or eax, ecx"))
        elif op == OP_BIT_XOR:
            codegen_emit_line(cg, cast[ptr uint8]("    xor eax, ecx"))
        elif op == OP_SHL:
            codegen_emit_line(cg, cast[ptr uint8]("    shl eax, cl"))
        elif op == OP_SHR:
            codegen_emit_line(cg, cast[ptr uint8]("    shr eax, cl"))
        elif op == OP_EQ:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    sete al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        elif op == OP_NE:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    setne al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        elif op == OP_LT:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    setl al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        elif op == OP_LE:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    setle al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        elif op == OP_GT:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    setg al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        elif op == OP_GE:
            codegen_emit_line(cg, cast[ptr uint8]("    cmp eax, ecx"))
            codegen_emit_line(cg, cast[ptr uint8]("    setge al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        return

    # Unary operation
    if typ == AST_UNARY_OP:
        var op: int32 = n32[3]
        var operand: ptr uint8 = cast[ptr uint8](n32[4])

        codegen_expr(cg, operand)

        if op == UOP_NEG:
            codegen_emit_line(cg, cast[ptr uint8]("    neg eax"))
        elif op == UOP_NOT:
            codegen_emit_line(cg, cast[ptr uint8]("    test eax, eax"))
            codegen_emit_line(cg, cast[ptr uint8]("    sete al"))
            codegen_emit_line(cg, cast[ptr uint8]("    movzx eax, al"))
        return

    # Function call
    if typ == AST_CALL:
        var func_node: ptr uint8 = cast[ptr uint8](n32[3])
        var func_n32: ptr int32 = cast[ptr int32](func_node)
        var func_name: ptr uint8 = cast[ptr uint8](func_n32[3])

        codegen_emit_str(cg, cast[ptr uint8]("    call "))
        codegen_emit_line(cg, func_name)
        return

# ============================================================================
# Statement Code Generation
# ============================================================================

proc codegen_stmt(cg: ptr uint8, node: ptr uint8) =
    if cast[int32](node) == 0:
        return

    var typ: int32 = ast_type(node)
    var n32: ptr int32 = cast[ptr int32](node)

    # Return statement
    if typ == AST_RETURN_STMT:
        var value: ptr uint8 = cast[ptr uint8](n32[3])
        if cast[int32](value) != 0:
            codegen_expr(cg, value)
        codegen_emit_line(cg, cast[ptr uint8]("    jmp .return"))
        return

    # Expression statement
    if typ == AST_EXPR_STMT:
        var expr: ptr uint8 = cast[ptr uint8](n32[3])
        codegen_expr(cg, expr)
        return

    # Discard statement
    if typ == AST_DISCARD_STMT:
        var expr: ptr uint8 = cast[ptr uint8](n32[3])
        codegen_expr(cg, expr)
        return

    # Variable declaration
    if typ == AST_VAR_DECL:
        var name: ptr uint8 = cast[ptr uint8](n32[3])
        var init: ptr uint8 = cast[ptr uint8](n32[5])

        # Generate initialization if present
        if cast[int32](init) != 0:
            codegen_expr(cg, init)
            codegen_emit_str(cg, cast[ptr uint8]("    mov ["))
            codegen_emit_str(cg, name)
            codegen_emit_line(cg, cast[ptr uint8]("], eax"))
        return

    # Assignment
    if typ == AST_ASSIGN_STMT:
        var target: ptr uint8 = cast[ptr uint8](n32[3])
        var value: ptr uint8 = cast[ptr uint8](n32[4])

        codegen_expr(cg, value)

        # Get target name
        var t32: ptr int32 = cast[ptr int32](target)
        var target_name: ptr uint8 = cast[ptr uint8](t32[3])

        codegen_emit_str(cg, cast[ptr uint8]("    mov ["))
        codegen_emit_str(cg, target_name)
        codegen_emit_line(cg, cast[ptr uint8]("], eax"))
        return

    # If statement
    if typ == AST_IF_STMT:
        var cond: ptr uint8 = cast[ptr uint8](n32[3])
        var then_stmt: ptr uint8 = cast[ptr uint8](n32[4])
        var else_stmt: ptr uint8 = cast[ptr uint8](n32[5])

        var label_num: int32 = codegen_inc_label(cg)

        # Evaluate condition
        codegen_expr(cg, cond)
        codegen_emit_line(cg, cast[ptr uint8]("    test eax, eax"))
        codegen_emit_str(cg, cast[ptr uint8]("    jz .else_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_char(cg, 10)

        # Then block
        codegen_stmt(cg, then_stmt)
        codegen_emit_str(cg, cast[ptr uint8]("    jmp .endif_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_char(cg, 10)

        # Else label
        codegen_emit_str(cg, cast[ptr uint8](".else_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_line(cg, cast[ptr uint8](":"))

        if cast[int32](else_stmt) != 0:
            codegen_stmt(cg, else_stmt)

        # End label
        codegen_emit_str(cg, cast[ptr uint8](".endif_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_line(cg, cast[ptr uint8](":"))
        return

    # While statement
    if typ == AST_WHILE_STMT:
        var cond: ptr uint8 = cast[ptr uint8](n32[3])
        var body: ptr uint8 = cast[ptr uint8](n32[4])

        var label_num: int32 = codegen_inc_label(cg)

        # Loop start
        codegen_emit_str(cg, cast[ptr uint8](".while_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_line(cg, cast[ptr uint8](":"))

        # Condition
        codegen_expr(cg, cond)
        codegen_emit_line(cg, cast[ptr uint8]("    test eax, eax"))
        codegen_emit_str(cg, cast[ptr uint8]("    jz .endwhile_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_char(cg, 10)

        # Body
        codegen_stmt(cg, body)

        # Loop back
        codegen_emit_str(cg, cast[ptr uint8]("    jmp .while_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_char(cg, 10)

        # End label
        codegen_emit_str(cg, cast[ptr uint8](".endwhile_"))
        codegen_emit_int(cg, label_num)
        codegen_emit_line(cg, cast[ptr uint8](":"))
        return

# ============================================================================
# Declaration Code Generation
# ============================================================================

proc codegen_proc(cg: ptr uint8, node: ptr uint8) =
    var n32: ptr int32 = cast[ptr int32](node)
    var name: ptr uint8 = cast[ptr uint8](n32[3])
    var body: ptr uint8 = cast[ptr uint8](n32[7])
    var is_extern: int32 = n32[8]

    # Skip extern declarations (no code to generate)
    if is_extern == 1:
        return

    # Function label
    codegen_emit_line(cg, cast[ptr uint8](""))
    codegen_emit_str(cg, name)
    codegen_emit_line(cg, cast[ptr uint8](":"))

    # Prologue
    codegen_emit_line(cg, cast[ptr uint8]("    push ebp"))
    codegen_emit_line(cg, cast[ptr uint8]("    mov ebp, esp"))

    # Body
    codegen_stmt(cg, body)

    # Return label and epilogue
    codegen_emit_line(cg, cast[ptr uint8](".return:"))
    codegen_emit_line(cg, cast[ptr uint8]("    mov esp, ebp"))
    codegen_emit_line(cg, cast[ptr uint8]("    pop ebp"))
    codegen_emit_line(cg, cast[ptr uint8]("    ret"))

proc codegen_program(cg: ptr uint8, node: ptr uint8) =
    # Emit assembly header
    codegen_emit_line(cg, cast[ptr uint8]("; Generated by Brainhair Self-Hosted Compiler"))
    codegen_emit_line(cg, cast[ptr uint8]("bits 32"))
    codegen_emit_line(cg, cast[ptr uint8](""))
    codegen_emit_line(cg, cast[ptr uint8]("section .text"))
    codegen_emit_line(cg, cast[ptr uint8]("global _start"))
    codegen_emit_line(cg, cast[ptr uint8](""))

    # _start entry point
    codegen_emit_line(cg, cast[ptr uint8]("_start:"))
    codegen_emit_line(cg, cast[ptr uint8]("    call main"))
    codegen_emit_line(cg, cast[ptr uint8]("    mov ebx, eax"))
    codegen_emit_line(cg, cast[ptr uint8]("    mov eax, 1"))
    codegen_emit_line(cg, cast[ptr uint8]("    int 0x80"))

    # Generate code for each declaration
    # Note: In a full implementation, we'd iterate through the declaration list
    # For now, this is a placeholder

# ============================================================================
# Main Generate Function
# ============================================================================

proc codegen_generate(cg: ptr uint8, ast: ptr uint8) =
    codegen_program(cg, ast)

# Get output string
proc codegen_get_output(cg: ptr uint8): ptr uint8 =
    var output: ptr uint8 = codegen_output(cg)
    var pos: int32 = codegen_out_pos(cg)

    # Null terminate
    output[pos] = 0

    return output

# Get output length
proc codegen_get_length(cg: ptr uint8): int32 =
    return codegen_out_pos(cg)
