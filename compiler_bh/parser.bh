# Parser for Brainhair Self-Hosted Compiler
#
# Recursive descent parser that converts tokens into AST nodes.
# Uses the lexer module for token input.

# ============================================================================
# Parser State Structure
# Layout (28 bytes):
#   lexer: ptr      - Lexer state (offset 0)
#   current: ptr    - Current token buffer (offset 4)
#   peek: ptr       - Peek token buffer (offset 8)
#   arena: ptr      - Arena for AST allocation (offset 12)
#   arena_pos: i32  - Current position in arena (offset 16)
#   arena_size: i32 - Arena size (offset 20)
#   error: int32    - Error flag (offset 24)
# ============================================================================

const PARSER_LEXER_OFFSET: int32 = 0
const PARSER_CURRENT_OFFSET: int32 = 4
const PARSER_PEEK_OFFSET: int32 = 8
const PARSER_ARENA_OFFSET: int32 = 12
const PARSER_ARENA_POS_OFFSET: int32 = 16
const PARSER_ARENA_SIZE_OFFSET: int32 = 20
const PARSER_ERROR_OFFSET: int32 = 24
const PARSER_SIZE: int32 = 28

# Default arena size for AST nodes
const AST_ARENA_SIZE: int32 = 65536  # 64KB

# Memory allocation
const SYS_mmap: int32 = 90
const PROT_READ: int32 = 1
const PROT_WRITE: int32 = 2
const MAP_PRIVATE: int32 = 2
const MAP_ANONYMOUS: int32 = 32

extern proc syscall6(num: int32, arg1: int32, arg2: int32, arg3: int32, arg4: int32, arg5: int32, arg6: int32): int32

proc parser_mmap(size: int32): ptr uint8 =
    var mem: int32 = syscall6(SYS_mmap, 0, size,
                              PROT_READ | PROT_WRITE,
                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    if mem < 0:
        return cast[ptr uint8](0)
    return cast[ptr uint8](mem)

# ============================================================================
# Token Constants (from lexer.bh)
# ============================================================================

const TOK_EOF: int32 = 0
const TOK_IDENT: int32 = 1
const TOK_INT_LIT: int32 = 2
const TOK_STRING_LIT: int32 = 3
const TOK_CHAR_LIT: int32 = 4

const TOK_INT8: int32 = 10
const TOK_INT16: int32 = 11
const TOK_INT32: int32 = 12
const TOK_UINT8: int32 = 13
const TOK_UINT16: int32 = 14
const TOK_UINT32: int32 = 15
const TOK_BOOL: int32 = 16
const TOK_CHAR: int32 = 17
const TOK_PTR: int32 = 18
const TOK_ARRAY: int32 = 19

const TOK_IF: int32 = 20
const TOK_ELIF: int32 = 21
const TOK_ELSE: int32 = 22
const TOK_WHILE: int32 = 23
const TOK_FOR: int32 = 24
const TOK_BREAK: int32 = 25
const TOK_CONTINUE: int32 = 26
const TOK_RETURN: int32 = 27

const TOK_PROC: int32 = 30
const TOK_VAR: int32 = 31
const TOK_CONST: int32 = 32
const TOK_TYPE: int32 = 33
const TOK_EXTERN: int32 = 34

const TOK_TRUE: int32 = 40
const TOK_FALSE: int32 = 41
const TOK_NIL: int32 = 42

const TOK_AND: int32 = 50
const TOK_OR: int32 = 51
const TOK_NOT: int32 = 52
const TOK_DIV: int32 = 53
const TOK_MOD: int32 = 54

const TOK_CAST: int32 = 60
const TOK_ADDR: int32 = 61
const TOK_DISCARD: int32 = 62
const TOK_OBJECT: int32 = 63

const TOK_PLUS: int32 = 70
const TOK_MINUS: int32 = 71
const TOK_STAR: int32 = 72
const TOK_SLASH: int32 = 73
const TOK_PERCENT: int32 = 74

const TOK_EQ: int32 = 80
const TOK_NE: int32 = 81
const TOK_LT: int32 = 82
const TOK_LE: int32 = 83
const TOK_GT: int32 = 84
const TOK_GE: int32 = 85

const TOK_AMPERSAND: int32 = 90
const TOK_PIPE: int32 = 91
const TOK_CARET: int32 = 92
const TOK_TILDE: int32 = 93
const TOK_SHL: int32 = 94
const TOK_SHR: int32 = 95

const TOK_ASSIGN: int32 = 100

const TOK_LPAREN: int32 = 110
const TOK_RPAREN: int32 = 111
const TOK_LBRACKET: int32 = 112
const TOK_RBRACKET: int32 = 113
const TOK_LBRACE: int32 = 114
const TOK_RBRACE: int32 = 115
const TOK_COMMA: int32 = 116
const TOK_COLON: int32 = 117
const TOK_DOT: int32 = 118
const TOK_NEWLINE: int32 = 119

# Token structure
const TOKEN_SIZE: int32 = 20

# AST Node types
const AST_PROGRAM: int32 = 1
const AST_PROC_DECL: int32 = 2
const AST_VAR_DECL: int32 = 3
const AST_CONST_DECL: int32 = 4
const AST_PARAM: int32 = 5
const AST_BLOCK: int32 = 10
const AST_IF_STMT: int32 = 11
const AST_WHILE_STMT: int32 = 12
const AST_RETURN_STMT: int32 = 13
const AST_ASSIGN_STMT: int32 = 14
const AST_EXPR_STMT: int32 = 15
const AST_BREAK_STMT: int32 = 16
const AST_CONTINUE_STMT: int32 = 17
const AST_DISCARD_STMT: int32 = 18
const AST_INT_LIT: int32 = 20
const AST_STRING_LIT: int32 = 21
const AST_BOOL_LIT: int32 = 23
const AST_IDENT: int32 = 24
const AST_BINARY_OP: int32 = 25
const AST_UNARY_OP: int32 = 26
const AST_CALL: int32 = 27
const AST_INDEX: int32 = 28
const AST_CAST: int32 = 30
const AST_ADDR: int32 = 31
const AST_TYPE_NAME: int32 = 40
const AST_TYPE_PTR: int32 = 41
const AST_TYPE_ARRAY: int32 = 42

# Binary operators
const OP_ADD: int32 = 1
const OP_SUB: int32 = 2
const OP_MUL: int32 = 3
const OP_DIV: int32 = 4
const OP_MOD: int32 = 5
const OP_EQ: int32 = 6
const OP_NE: int32 = 7
const OP_LT: int32 = 8
const OP_LE: int32 = 9
const OP_GT: int32 = 10
const OP_GE: int32 = 11
const OP_AND: int32 = 12
const OP_OR: int32 = 13
const OP_BIT_AND: int32 = 14
const OP_BIT_OR: int32 = 15
const OP_BIT_XOR: int32 = 16
const OP_SHL: int32 = 17
const OP_SHR: int32 = 18

# Unary operators
const UOP_NEG: int32 = 1
const UOP_NOT: int32 = 2
const UOP_BIT_NOT: int32 = 3

# ============================================================================
# External lexer functions
# ============================================================================

extern proc lexer_init(lex: ptr uint8, source: ptr uint8, length: int32)
extern proc lexer_next(lex: ptr uint8, tok: ptr uint8)

# ============================================================================
# Parser Helpers
# ============================================================================

proc parser_lexer(p: ptr uint8): ptr uint8 =
    var p32: ptr int32 = cast[ptr int32](p)
    return cast[ptr uint8](p32[0])

proc parser_current(p: ptr uint8): ptr uint8 =
    var p32: ptr int32 = cast[ptr int32](p)
    return cast[ptr uint8](p32[1])

proc parser_peek(p: ptr uint8): ptr uint8 =
    var p32: ptr int32 = cast[ptr int32](p)
    return cast[ptr uint8](p32[2])

proc parser_arena(p: ptr uint8): ptr uint8 =
    var p32: ptr int32 = cast[ptr int32](p)
    return cast[ptr uint8](p32[3])

proc parser_arena_pos(p: ptr uint8): int32 =
    var p32: ptr int32 = cast[ptr int32](p)
    return p32[4]

proc parser_set_arena_pos(p: ptr uint8, pos: int32) =
    var p32: ptr int32 = cast[ptr int32](p)
    p32[4] = pos

proc parser_error(p: ptr uint8): int32 =
    var p32: ptr int32 = cast[ptr int32](p)
    return p32[6]

proc parser_set_error(p: ptr uint8, err: int32) =
    var p32: ptr int32 = cast[ptr int32](p)
    p32[6] = err

# Get current token type
proc token_type(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[0]

# Get token line
proc token_line(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[1]

# Get token column
proc token_col(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[2]

# Get token value
proc token_value(tok: ptr uint8): int32 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return t32[3]

# Get token string
proc token_str(tok: ptr uint8): ptr uint8 =
    var t32: ptr int32 = cast[ptr int32](tok)
    return cast[ptr uint8](t32[4])

# ============================================================================
# Arena Allocation for AST Nodes
# ============================================================================

proc parser_alloc(p: ptr uint8, size: int32): ptr uint8 =
    var arena: ptr uint8 = parser_arena(p)
    var pos: int32 = parser_arena_pos(p)
    var p32: ptr int32 = cast[ptr int32](p)
    var arena_size: int32 = p32[5]

    # Align to 4 bytes
    var aligned_size: int32 = (size + 3) & -4

    if pos + aligned_size > arena_size:
        return cast[ptr uint8](0)  # Out of memory

    var result: ptr uint8 = cast[ptr uint8](cast[int32](arena) + pos)
    parser_set_arena_pos(p, pos + aligned_size)

    # Zero memory
    var i: int32 = 0
    while i < aligned_size:
        result[i] = 0
        i = i + 1

    return result

# ============================================================================
# Token Management
# ============================================================================

# Advance to next token
proc parser_advance(p: ptr uint8) =
    var current: ptr uint8 = parser_current(p)
    var peek: ptr uint8 = parser_peek(p)
    var lex: ptr uint8 = parser_lexer(p)

    # Copy peek to current
    var i: int32 = 0
    while i < TOKEN_SIZE:
        current[i] = peek[i]
        i = i + 1

    # Get next token into peek
    lexer_next(lex, peek)

# Skip newlines
proc parser_skip_newlines(p: ptr uint8) =
    var current: ptr uint8 = parser_current(p)
    while token_type(current) == TOK_NEWLINE:
        parser_advance(p)
        current = parser_current(p)

# Check current token type
proc parser_check(p: ptr uint8, typ: int32): bool =
    var current: ptr uint8 = parser_current(p)
    return token_type(current) == typ

# Expect and consume token
proc parser_expect(p: ptr uint8, typ: int32): bool =
    if parser_check(p, typ):
        parser_advance(p)
        return true
    parser_set_error(p, 1)
    return false

# ============================================================================
# Parser Initialization
# ============================================================================

const LEXER_SIZE: int32 = 24

proc parser_init(p: ptr uint8, source: ptr uint8, length: int32) =
    var p32: ptr int32 = cast[ptr int32](p)

    # Allocate lexer state
    var lex: ptr uint8 = parser_mmap(LEXER_SIZE)
    lexer_init(lex, source, length)

    # Allocate token buffers
    var current: ptr uint8 = parser_mmap(TOKEN_SIZE)
    var peek: ptr uint8 = parser_mmap(TOKEN_SIZE)

    # Allocate AST arena
    var arena: ptr uint8 = parser_mmap(AST_ARENA_SIZE)

    p32[0] = cast[int32](lex)
    p32[1] = cast[int32](current)
    p32[2] = cast[int32](peek)
    p32[3] = cast[int32](arena)
    p32[4] = 0              # arena_pos
    p32[5] = AST_ARENA_SIZE # arena_size
    p32[6] = 0              # error

    # Prime the token buffers
    lexer_next(lex, current)
    lexer_next(lex, peek)

# ============================================================================
# Forward Declarations (for recursive descent)
# ============================================================================

# Note: In Brainhair, we don't have true forward declarations,
# so the parser functions must be ordered carefully to ensure
# functions are defined before they're called.

# ============================================================================
# Type Parsing
# ============================================================================

proc parse_type(p: ptr uint8): ptr uint8 =
    var current: ptr uint8 = parser_current(p)
    var typ: int32 = token_type(current)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)

    # ptr type
    if typ == TOK_PTR:
        parser_advance(p)
        parser_skip_newlines(p)

        # Expect [
        if not parser_expect(p, TOK_LBRACKET):
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Parse element type
        var elem: ptr uint8 = parse_type(p)
        if cast[int32](elem) == 0:
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Expect ]
        if not parser_expect(p, TOK_RBRACKET):
            return cast[ptr uint8](0)

        # Create pointer type node
        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_TYPE_PTR
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](elem)
        return node

    # array type
    if typ == TOK_ARRAY:
        parser_advance(p)
        parser_skip_newlines(p)

        # Expect [
        if not parser_expect(p, TOK_LBRACKET):
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Parse size
        current = parser_current(p)
        if token_type(current) != TOK_INT_LIT:
            parser_set_error(p, 1)
            return cast[ptr uint8](0)
        var size: int32 = token_value(current)
        parser_advance(p)

        parser_skip_newlines(p)

        # Expect ,
        if not parser_expect(p, TOK_COMMA):
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Parse element type
        var elem: ptr uint8 = parse_type(p)
        if cast[int32](elem) == 0:
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Expect ]
        if not parser_expect(p, TOK_RBRACKET):
            return cast[ptr uint8](0)

        # Create array type node
        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_TYPE_ARRAY
        n32[1] = line
        n32[2] = col
        n32[3] = size
        n32[4] = cast[int32](elem)
        return node

    # Named type (int32, bool, etc.)
    if typ == TOK_IDENT or typ == TOK_INT8 or typ == TOK_INT16 or typ == TOK_INT32 or
       typ == TOK_UINT8 or typ == TOK_UINT16 or typ == TOK_UINT32 or
       typ == TOK_BOOL or typ == TOK_CHAR:
        var name: ptr uint8 = token_str(current)
        parser_advance(p)

        # Create type name node
        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_TYPE_NAME
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](name)
        return node

    parser_set_error(p, 1)
    return cast[ptr uint8](0)

# ============================================================================
# Expression Parsing
# ============================================================================

# Forward declaration simulation - parse_expression will be defined later
# We need to use mutual recursion carefully

# Parse primary expression (literals, identifiers, parenthesized)
proc parse_primary(p: ptr uint8): ptr uint8 =
    var current: ptr uint8 = parser_current(p)
    var typ: int32 = token_type(current)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)

    # Integer literal
    if typ == TOK_INT_LIT:
        var value: int32 = token_value(current)
        parser_advance(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_INT_LIT
        n32[1] = line
        n32[2] = col
        n32[3] = value
        return node

    # String literal
    if typ == TOK_STRING_LIT:
        var str: ptr uint8 = token_str(current)
        parser_advance(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_STRING_LIT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](str)
        return node

    # Boolean literals
    if typ == TOK_TRUE or typ == TOK_FALSE:
        var value: int32 = 0
        if typ == TOK_TRUE:
            value = 1
        parser_advance(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_BOOL_LIT
        n32[1] = line
        n32[2] = col
        n32[3] = value
        return node

    # Identifier
    if typ == TOK_IDENT:
        var name: ptr uint8 = token_str(current)
        parser_advance(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_IDENT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](name)
        return node

    # cast[type](expr)
    if typ == TOK_CAST:
        parser_advance(p)

        # Expect [
        if not parser_expect(p, TOK_LBRACKET):
            return cast[ptr uint8](0)

        # Parse target type
        var target_type: ptr uint8 = parse_type(p)
        if cast[int32](target_type) == 0:
            return cast[ptr uint8](0)

        # Expect ]
        if not parser_expect(p, TOK_RBRACKET):
            return cast[ptr uint8](0)

        # Expect (
        if not parser_expect(p, TOK_LPAREN):
            return cast[ptr uint8](0)

        # Parse expression (simplified - would need forward decl)
        var expr: ptr uint8 = parse_primary(p)
        if cast[int32](expr) == 0:
            return cast[ptr uint8](0)

        # Expect )
        if not parser_expect(p, TOK_RPAREN):
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_CAST
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](target_type)
        n32[4] = cast[int32](expr)
        return node

    # addr(expr)
    if typ == TOK_ADDR:
        parser_advance(p)

        # Expect (
        if not parser_expect(p, TOK_LPAREN):
            return cast[ptr uint8](0)

        # Parse expression
        var expr: ptr uint8 = parse_primary(p)
        if cast[int32](expr) == 0:
            return cast[ptr uint8](0)

        # Expect )
        if not parser_expect(p, TOK_RPAREN):
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_ADDR
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](expr)
        return node

    # Parenthesized expression
    if typ == TOK_LPAREN:
        parser_advance(p)
        var expr: ptr uint8 = parse_primary(p)  # Simplified
        if not parser_expect(p, TOK_RPAREN):
            return cast[ptr uint8](0)
        return expr

    parser_set_error(p, 1)
    return cast[ptr uint8](0)

# Parse postfix expressions (calls, indexing)
proc parse_postfix(p: ptr uint8): ptr uint8 =
    var base: ptr uint8 = parse_primary(p)
    if cast[int32](base) == 0:
        return cast[ptr uint8](0)

    while true:
        var current: ptr uint8 = parser_current(p)
        var typ: int32 = token_type(current)
        var line: int32 = token_line(current)
        var col: int32 = token_col(current)

        # Function call
        if typ == TOK_LPAREN:
            parser_advance(p)

            # Parse arguments (simplified - no comma handling)
            var arg_count: int32 = 0

            if not parser_check(p, TOK_RPAREN):
                # At least one argument
                var first_arg: ptr uint8 = parse_primary(p)
                if cast[int32](first_arg) != 0:
                    arg_count = 1

            parser_expect(p, TOK_RPAREN)

            var node: ptr uint8 = parser_alloc(p, 24)
            var n32: ptr int32 = cast[ptr int32](node)
            n32[0] = AST_CALL
            n32[1] = line
            n32[2] = col
            n32[3] = cast[int32](base)
            n32[4] = 0  # args (simplified)
            n32[5] = arg_count
            base = node
            continue

        # Array indexing
        if typ == TOK_LBRACKET:
            parser_advance(p)

            var index: ptr uint8 = parse_primary(p)
            if cast[int32](index) == 0:
                return cast[ptr uint8](0)

            parser_expect(p, TOK_RBRACKET)

            var node: ptr uint8 = parser_alloc(p, 20)
            var n32: ptr int32 = cast[ptr int32](node)
            n32[0] = AST_INDEX
            n32[1] = line
            n32[2] = col
            n32[3] = cast[int32](base)
            n32[4] = cast[int32](index)
            base = node
            continue

        break

    return base

# Parse unary expressions
proc parse_unary(p: ptr uint8): ptr uint8 =
    var current: ptr uint8 = parser_current(p)
    var typ: int32 = token_type(current)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)

    # Unary minus
    if typ == TOK_MINUS:
        parser_advance(p)
        var operand: ptr uint8 = parse_unary(p)
        if cast[int32](operand) == 0:
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_UNARY_OP
        n32[1] = line
        n32[2] = col
        n32[3] = UOP_NEG
        n32[4] = cast[int32](operand)
        return node

    # Logical not
    if typ == TOK_NOT:
        parser_advance(p)
        var operand: ptr uint8 = parse_unary(p)
        if cast[int32](operand) == 0:
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_UNARY_OP
        n32[1] = line
        n32[2] = col
        n32[3] = UOP_NOT
        n32[4] = cast[int32](operand)
        return node

    return parse_postfix(p)

# Parse binary expression (simplified - single precedence level)
proc parse_binary(p: ptr uint8): ptr uint8 =
    var left: ptr uint8 = parse_unary(p)
    if cast[int32](left) == 0:
        return cast[ptr uint8](0)

    while true:
        var current: ptr uint8 = parser_current(p)
        var typ: int32 = token_type(current)
        var line: int32 = token_line(current)
        var col: int32 = token_col(current)

        var op: int32 = 0

        # Arithmetic
        if typ == TOK_PLUS:
            op = OP_ADD
        elif typ == TOK_MINUS:
            op = OP_SUB
        elif typ == TOK_STAR:
            op = OP_MUL
        elif typ == TOK_SLASH or typ == TOK_DIV:
            op = OP_DIV
        elif typ == TOK_PERCENT or typ == TOK_MOD:
            op = OP_MOD
        # Comparison
        elif typ == TOK_EQ:
            op = OP_EQ
        elif typ == TOK_NE:
            op = OP_NE
        elif typ == TOK_LT:
            op = OP_LT
        elif typ == TOK_LE:
            op = OP_LE
        elif typ == TOK_GT:
            op = OP_GT
        elif typ == TOK_GE:
            op = OP_GE
        # Logical
        elif typ == TOK_AND:
            op = OP_AND
        elif typ == TOK_OR:
            op = OP_OR
        # Bitwise
        elif typ == TOK_AMPERSAND:
            op = OP_BIT_AND
        elif typ == TOK_PIPE:
            op = OP_BIT_OR
        elif typ == TOK_CARET:
            op = OP_BIT_XOR
        elif typ == TOK_SHL:
            op = OP_SHL
        elif typ == TOK_SHR:
            op = OP_SHR
        else:
            break

        parser_advance(p)
        parser_skip_newlines(p)

        var right: ptr uint8 = parse_unary(p)
        if cast[int32](right) == 0:
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 24)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_BINARY_OP
        n32[1] = line
        n32[2] = col
        n32[3] = op
        n32[4] = cast[int32](left)
        n32[5] = cast[int32](right)
        left = node

    return left

# Main expression parser
proc parse_expression(p: ptr uint8): ptr uint8 =
    return parse_binary(p)

# ============================================================================
# Statement Parsing
# ============================================================================

proc parse_statement(p: ptr uint8): ptr uint8 =
    parser_skip_newlines(p)

    var current: ptr uint8 = parser_current(p)
    var typ: int32 = token_type(current)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)

    # Return statement
    if typ == TOK_RETURN:
        parser_advance(p)

        var value: ptr uint8 = cast[ptr uint8](0)
        if not parser_check(p, TOK_NEWLINE) and not parser_check(p, TOK_EOF):
            value = parse_expression(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_RETURN_STMT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](value)
        return node

    # Var declaration
    if typ == TOK_VAR:
        parser_advance(p)

        # Get name
        current = parser_current(p)
        if token_type(current) != TOK_IDENT:
            parser_set_error(p, 1)
            return cast[ptr uint8](0)
        var name: ptr uint8 = token_str(current)
        parser_advance(p)

        # Expect :
        if not parser_expect(p, TOK_COLON):
            return cast[ptr uint8](0)

        # Parse type
        var var_type: ptr uint8 = parse_type(p)
        if cast[int32](var_type) == 0:
            return cast[ptr uint8](0)

        # Optional initializer
        var init: ptr uint8 = cast[ptr uint8](0)
        if parser_check(p, TOK_ASSIGN):
            parser_advance(p)
            parser_skip_newlines(p)
            init = parse_expression(p)

        var node: ptr uint8 = parser_alloc(p, 24)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_VAR_DECL
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](name)
        n32[4] = cast[int32](var_type)
        n32[5] = cast[int32](init)
        return node

    # If statement
    if typ == TOK_IF:
        parser_advance(p)
        parser_skip_newlines(p)

        # Parse condition
        var cond: ptr uint8 = parse_expression(p)
        if cast[int32](cond) == 0:
            return cast[ptr uint8](0)

        # Expect :
        if not parser_expect(p, TOK_COLON):
            return cast[ptr uint8](0)

        # Parse then block (simplified - just one statement)
        parser_skip_newlines(p)
        var then_stmt: ptr uint8 = parse_statement(p)

        var node: ptr uint8 = parser_alloc(p, 28)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_IF_STMT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](cond)
        n32[4] = cast[int32](then_stmt)
        n32[5] = 0  # else
        n32[6] = 0  # elif
        return node

    # While statement
    if typ == TOK_WHILE:
        parser_advance(p)
        parser_skip_newlines(p)

        # Parse condition
        var cond: ptr uint8 = parse_expression(p)
        if cast[int32](cond) == 0:
            return cast[ptr uint8](0)

        # Expect :
        if not parser_expect(p, TOK_COLON):
            return cast[ptr uint8](0)

        # Parse body (simplified)
        parser_skip_newlines(p)
        var body: ptr uint8 = parse_statement(p)

        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_WHILE_STMT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](cond)
        n32[4] = cast[int32](body)
        return node

    # Discard statement
    if typ == TOK_DISCARD:
        parser_advance(p)
        var expr: ptr uint8 = parse_expression(p)

        var node: ptr uint8 = parser_alloc(p, 16)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_DISCARD_STMT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](expr)
        return node

    # Expression statement or assignment
    var expr: ptr uint8 = parse_expression(p)
    if cast[int32](expr) == 0:
        return cast[ptr uint8](0)

    # Check for assignment
    if parser_check(p, TOK_ASSIGN):
        parser_advance(p)
        parser_skip_newlines(p)

        var value: ptr uint8 = parse_expression(p)
        if cast[int32](value) == 0:
            return cast[ptr uint8](0)

        var node: ptr uint8 = parser_alloc(p, 20)
        var n32: ptr int32 = cast[ptr int32](node)
        n32[0] = AST_ASSIGN_STMT
        n32[1] = line
        n32[2] = col
        n32[3] = cast[int32](expr)
        n32[4] = cast[int32](value)
        return node

    # Just an expression statement
    var node: ptr uint8 = parser_alloc(p, 16)
    var n32: ptr int32 = cast[ptr int32](node)
    n32[0] = AST_EXPR_STMT
    n32[1] = line
    n32[2] = col
    n32[3] = cast[int32](expr)
    return node

# ============================================================================
# Declaration Parsing
# ============================================================================

proc parse_proc_decl(p: ptr uint8): ptr uint8 =
    var current: ptr uint8 = parser_current(p)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)
    var is_extern: int32 = 0

    # Check for extern
    if token_type(current) == TOK_EXTERN:
        is_extern = 1
        parser_advance(p)
        parser_skip_newlines(p)
        current = parser_current(p)

    # Expect proc
    if not parser_expect(p, TOK_PROC):
        return cast[ptr uint8](0)

    # Get name
    current = parser_current(p)
    if token_type(current) != TOK_IDENT:
        parser_set_error(p, 1)
        return cast[ptr uint8](0)
    var name: ptr uint8 = token_str(current)
    parser_advance(p)

    # Expect (
    if not parser_expect(p, TOK_LPAREN):
        return cast[ptr uint8](0)

    # Parse parameters (simplified - skip for now)
    var param_count: int32 = 0
    while not parser_check(p, TOK_RPAREN) and not parser_check(p, TOK_EOF):
        parser_advance(p)
    parser_expect(p, TOK_RPAREN)

    # Optional return type
    var ret_type: ptr uint8 = cast[ptr uint8](0)
    if parser_check(p, TOK_COLON):
        parser_advance(p)
        parser_skip_newlines(p)
        ret_type = parse_type(p)

    # Body (if not extern)
    var body: ptr uint8 = cast[ptr uint8](0)
    if is_extern == 0:
        # Expect =
        if not parser_expect(p, TOK_ASSIGN):
            return cast[ptr uint8](0)

        parser_skip_newlines(p)

        # Parse body statements until we hit a new declaration
        body = parse_statement(p)
    else:
        parser_skip_newlines(p)

    var node: ptr uint8 = parser_alloc(p, 36)
    var n32: ptr int32 = cast[ptr int32](node)
    n32[0] = AST_PROC_DECL
    n32[1] = line
    n32[2] = col
    n32[3] = cast[int32](name)
    n32[4] = 0  # params
    n32[5] = param_count
    n32[6] = cast[int32](ret_type)
    n32[7] = cast[int32](body)
    n32[8] = is_extern
    return node

proc parse_const_decl(p: ptr uint8): ptr uint8 =
    var current: ptr uint8 = parser_current(p)
    var line: int32 = token_line(current)
    var col: int32 = token_col(current)

    # Expect const
    parser_advance(p)

    # Get name
    current = parser_current(p)
    if token_type(current) != TOK_IDENT:
        parser_set_error(p, 1)
        return cast[ptr uint8](0)
    var name: ptr uint8 = token_str(current)
    parser_advance(p)

    # Expect :
    if not parser_expect(p, TOK_COLON):
        return cast[ptr uint8](0)

    # Parse type
    var const_type: ptr uint8 = parse_type(p)
    if cast[int32](const_type) == 0:
        return cast[ptr uint8](0)

    # Expect =
    if not parser_expect(p, TOK_ASSIGN):
        return cast[ptr uint8](0)

    parser_skip_newlines(p)

    # Parse value
    var value: ptr uint8 = parse_expression(p)
    if cast[int32](value) == 0:
        return cast[ptr uint8](0)

    var node: ptr uint8 = parser_alloc(p, 24)
    var n32: ptr int32 = cast[ptr int32](node)
    n32[0] = AST_CONST_DECL
    n32[1] = line
    n32[2] = col
    n32[3] = cast[int32](name)
    n32[4] = cast[int32](const_type)
    n32[5] = cast[int32](value)
    return node

# ============================================================================
# Main Parse Function
# ============================================================================

proc parse_program(p: ptr uint8): ptr uint8 =
    var line: int32 = 1
    var col: int32 = 1

    # Allocate program node
    var program: ptr uint8 = parser_alloc(p, 20)
    var p32: ptr int32 = cast[ptr int32](program)
    p32[0] = AST_PROGRAM
    p32[1] = line
    p32[2] = col
    p32[3] = 0  # decls (would be a list)
    p32[4] = 0  # count

    var decl_count: int32 = 0

    while not parser_check(p, TOK_EOF):
        parser_skip_newlines(p)
        if parser_check(p, TOK_EOF):
            break

        var current: ptr uint8 = parser_current(p)
        var typ: int32 = token_type(current)

        var decl: ptr uint8 = cast[ptr uint8](0)

        if typ == TOK_PROC or typ == TOK_EXTERN:
            decl = parse_proc_decl(p)
        elif typ == TOK_CONST:
            decl = parse_const_decl(p)
        else:
            # Skip unknown
            parser_advance(p)
            continue

        if cast[int32](decl) != 0:
            decl_count = decl_count + 1

        parser_skip_newlines(p)

    p32[4] = decl_count
    return program
